/* eslint-disable */
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * A `AbuseReportID` is a global ID. It is encoded as a string.
   *
   * An example `AbuseReportID` is: `"gid://gitlab/AbuseReport/1"`.
   */
  AbuseReportID: { input: any; output: any; }
  /**
   * A `AchievementsAchievementID` is a global ID. It is encoded as a string.
   *
   * An example `AchievementsAchievementID` is: `"gid://gitlab/Achievements::Achievement/1"`.
   */
  AchievementsAchievementID: { input: any; output: any; }
  /**
   * A `AchievementsUserAchievementID` is a global ID. It is encoded as a string.
   *
   * An example `AchievementsUserAchievementID` is: `"gid://gitlab/Achievements::UserAchievement/1"`.
   */
  AchievementsUserAchievementID: { input: any; output: any; }
  /**
   * A `AiAgentID` is a global ID. It is encoded as a string.
   *
   * An example `AiAgentID` is: `"gid://gitlab/Ai::Agent/1"`.
   */
  AiAgentID: { input: any; output: any; }
  /**
   * A `AiAgentVersionID` is a global ID. It is encoded as a string.
   *
   * An example `AiAgentVersionID` is: `"gid://gitlab/Ai::AgentVersion/1"`.
   */
  AiAgentVersionID: { input: any; output: any; }
  /**
   * A `AiCatalogBuiltInToolID` is a global ID. It is encoded as a string.
   *
   * An example `AiCatalogBuiltInToolID` is: `"gid://gitlab/Ai::Catalog::BuiltInTool/1"`.
   */
  AiCatalogBuiltInToolID: { input: any; output: any; }
  /**
   * A `AiCatalogItemConsumerID` is a global ID. It is encoded as a string.
   *
   * An example `AiCatalogItemConsumerID` is: `"gid://gitlab/Ai::Catalog::ItemConsumer/1"`.
   */
  AiCatalogItemConsumerID: { input: any; output: any; }
  /**
   * A `AiCatalogItemID` is a global ID. It is encoded as a string.
   *
   * An example `AiCatalogItemID` is: `"gid://gitlab/Ai::Catalog::Item/1"`.
   */
  AiCatalogItemID: { input: any; output: any; }
  /**
   * A `AiCatalogItemVersionID` is a global ID. It is encoded as a string.
   *
   * An example `AiCatalogItemVersionID` is: `"gid://gitlab/Ai::Catalog::ItemVersion/1"`.
   */
  AiCatalogItemVersionID: { input: any; output: any; }
  /**
   * A `AiConversationThreadID` is a global ID. It is encoded as a string.
   *
   * An example `AiConversationThreadID` is: `"gid://gitlab/Ai::Conversation::Thread/1"`.
   */
  AiConversationThreadID: { input: any; output: any; }
  /**
   * A `AiDuoWorkflowsWorkflowID` is a global ID. It is encoded as a string.
   *
   * An example `AiDuoWorkflowsWorkflowID` is: `"gid://gitlab/Ai::DuoWorkflows::Workflow/1"`.
   */
  AiDuoWorkflowsWorkflowID: { input: any; output: any; }
  /**
   * A `AiFlowTriggerID` is a global ID. It is encoded as a string.
   *
   * An example `AiFlowTriggerID` is: `"gid://gitlab/Ai::FlowTrigger/1"`.
   */
  AiFlowTriggerID: { input: any; output: any; }
  /**
   * A `AiFoundationalChatAgentID` is a global ID. It is encoded as a string.
   *
   * An example `AiFoundationalChatAgentID` is: `"gid://gitlab/Ai::FoundationalChatAgent/1"`.
   */
  AiFoundationalChatAgentID: { input: any; output: any; }
  /**
   * A `AiModelID` is a global ID. It is encoded as a string.
   *
   * An example `AiModelID` is: `"gid://gitlab/Ai::Model/1"`.
   */
  AiModelID: { input: any; output: any; }
  /**
   * A `AiSelfHostedModelID` is a global ID. It is encoded as a string.
   *
   * An example `AiSelfHostedModelID` is: `"gid://gitlab/Ai::SelfHostedModel/1"`.
   */
  AiSelfHostedModelID: { input: any; output: any; }
  /**
   * A `AlertManagementAlertID` is a global ID. It is encoded as a string.
   *
   * An example `AlertManagementAlertID` is: `"gid://gitlab/AlertManagement::Alert/1"`.
   */
  AlertManagementAlertID: { input: any; output: any; }
  /**
   * A `AlertManagementHttpIntegrationID` is a global ID. It is encoded as a string.
   *
   * An example `AlertManagementHttpIntegrationID` is: `"gid://gitlab/AlertManagement::HttpIntegration/1"`.
   */
  AlertManagementHttpIntegrationID: { input: any; output: any; }
  /**
   * A `AnalyticsCustomDashboardsDashboardID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsCustomDashboardsDashboardID` is: `"gid://gitlab/Analytics::CustomDashboards::Dashboard/1"`.
   */
  AnalyticsCustomDashboardsDashboardID: { input: any; output: any; }
  /**
   * A `AnalyticsCycleAnalyticsStageID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsCycleAnalyticsStageID` is: `"gid://gitlab/Analytics::CycleAnalytics::Stage/1"`.
   */
  AnalyticsCycleAnalyticsStageID: { input: any; output: any; }
  /**
   * A `AnalyticsCycleAnalyticsValueStreamID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsCycleAnalyticsValueStreamID` is: `"gid://gitlab/Analytics::CycleAnalytics::ValueStream/1"`.
   */
  AnalyticsCycleAnalyticsValueStreamID: { input: any; output: any; }
  /**
   * A `AnalyticsDevopsAdoptionEnabledNamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsDevopsAdoptionEnabledNamespaceID` is: `"gid://gitlab/Analytics::DevopsAdoption::EnabledNamespace/1"`.
   */
  AnalyticsDevopsAdoptionEnabledNamespaceID: { input: any; output: any; }
  /**
   * A `AppSecFuzzingCoverageCorpusID` is a global ID. It is encoded as a string.
   *
   * An example `AppSecFuzzingCoverageCorpusID` is: `"gid://gitlab/AppSec::Fuzzing::Coverage::Corpus/1"`.
   */
  AppSecFuzzingCoverageCorpusID: { input: any; output: any; }
  /**
   * A `ApprovalProjectRuleID` is a global ID. It is encoded as a string.
   *
   * An example `ApprovalProjectRuleID` is: `"gid://gitlab/ApprovalProjectRule/1"`.
   */
  ApprovalProjectRuleID: { input: any; output: any; }
  /**
   * A `AuditEventsAmazonS3ConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsAmazonS3ConfigurationID` is: `"gid://gitlab/AuditEvents::AmazonS3Configuration/1"`.
   */
  AuditEventsAmazonS3ConfigurationID: { input: any; output: any; }
  /**
   * A `AuditEventsExternalAuditEventDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::ExternalAuditEventDestination/1"`.
   */
  AuditEventsExternalAuditEventDestinationID: { input: any; output: any; }
  /**
   * A `AuditEventsGoogleCloudLoggingConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsGoogleCloudLoggingConfigurationID` is: `"gid://gitlab/AuditEvents::GoogleCloudLoggingConfiguration/1"`.
   */
  AuditEventsGoogleCloudLoggingConfigurationID: { input: any; output: any; }
  /**
   * A `AuditEventsGroupExternalStreamingDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsGroupExternalStreamingDestinationID` is: `"gid://gitlab/AuditEvents::Group::ExternalStreamingDestination/1"`.
   */
  AuditEventsGroupExternalStreamingDestinationID: { input: any; output: any; }
  /**
   * A `AuditEventsGroupNamespaceFilterID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsGroupNamespaceFilterID` is: `"gid://gitlab/AuditEvents::Group::NamespaceFilter/1"`.
   */
  AuditEventsGroupNamespaceFilterID: { input: any; output: any; }
  /**
   * A `AuditEventsInstanceAmazonS3ConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceAmazonS3ConfigurationID` is: `"gid://gitlab/AuditEvents::Instance::AmazonS3Configuration/1"`.
   */
  AuditEventsInstanceAmazonS3ConfigurationID: { input: any; output: any; }
  /**
   * A `AuditEventsInstanceExternalAuditEventDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::InstanceExternalAuditEventDestination/1"`.
   */
  AuditEventsInstanceExternalAuditEventDestinationID: { input: any; output: any; }
  /**
   * A `AuditEventsInstanceExternalStreamingDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceExternalStreamingDestinationID` is: `"gid://gitlab/AuditEvents::Instance::ExternalStreamingDestination/1"`.
   */
  AuditEventsInstanceExternalStreamingDestinationID: { input: any; output: any; }
  /**
   * A `AuditEventsInstanceGoogleCloudLoggingConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceGoogleCloudLoggingConfigurationID` is: `"gid://gitlab/AuditEvents::Instance::GoogleCloudLoggingConfiguration/1"`.
   */
  AuditEventsInstanceGoogleCloudLoggingConfigurationID: { input: any; output: any; }
  /**
   * A `AuditEventsInstanceNamespaceFilterID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceNamespaceFilterID` is: `"gid://gitlab/AuditEvents::Instance::NamespaceFilter/1"`.
   */
  AuditEventsInstanceNamespaceFilterID: { input: any; output: any; }
  /**
   * A `AuditEventsStreamingHTTPNamespaceFilterID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingHTTPNamespaceFilterID` is: `"gid://gitlab/AuditEvents::Streaming::HTTP::NamespaceFilter/1"`.
   */
  AuditEventsStreamingHTTPNamespaceFilterID: { input: any; output: any; }
  /**
   * A `AuditEventsStreamingHeaderID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::Header/1"`.
   */
  AuditEventsStreamingHeaderID: { input: any; output: any; }
  /**
   * A `AuditEventsStreamingInstanceHeaderID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingInstanceHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::InstanceHeader/1"`.
   */
  AuditEventsStreamingInstanceHeaderID: { input: any; output: any; }
  /**
   * A `AuthzLdapAdminRoleLinkID` is a global ID. It is encoded as a string.
   *
   * An example `AuthzLdapAdminRoleLinkID` is: `"gid://gitlab/Authz::LdapAdminRoleLink/1"`.
   */
  AuthzLdapAdminRoleLinkID: { input: any; output: any; }
  /**
   * A `AwardableID` is a global ID. It is encoded as a string.
   *
   * An example `AwardableID` is: `"gid://gitlab/Awardable/1"`.
   */
  AwardableID: { input: any; output: any; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: { input: any; output: any; }
  /**
   * A `BoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardID` is: `"gid://gitlab/Board/1"`.
   */
  BoardID: { input: any; output: any; }
  /**
   * A `BoardsEpicBoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicBoardID` is: `"gid://gitlab/Boards::EpicBoard/1"`.
   */
  BoardsEpicBoardID: { input: any; output: any; }
  /**
   * A `BoardsEpicListID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicListID` is: `"gid://gitlab/Boards::EpicList/1"`.
   */
  BoardsEpicListID: { input: any; output: any; }
  /**
   * A `CiBuildID` is a global ID. It is encoded as a string.
   *
   * An example `CiBuildID` is: `"gid://gitlab/Ci::Build/1"`.
   */
  CiBuildID: { input: any; output: any; }
  /**
   * A `CiCatalogResourceID` is a global ID. It is encoded as a string.
   *
   * An example `CiCatalogResourceID` is: `"gid://gitlab/Ci::Catalog::Resource/1"`.
   */
  CiCatalogResourceID: { input: any; output: any; }
  /**
   * A `CiCatalogResourcesComponentID` is a global ID. It is encoded as a string.
   *
   * An example `CiCatalogResourcesComponentID` is: `"gid://gitlab/Ci::Catalog::Resources::Component/1"`.
   */
  CiCatalogResourcesComponentID: { input: any; output: any; }
  /**
   * A `CiCatalogResourcesVersionID` is a global ID. It is encoded as a string.
   *
   * An example `CiCatalogResourcesVersionID` is: `"gid://gitlab/Ci::Catalog::Resources::Version/1"`.
   */
  CiCatalogResourcesVersionID: { input: any; output: any; }
  /** Value for a CI input. Can be a string, array, number, or boolean. */
  CiInputsValue: { input: any; output: any; }
  /**
   * A `CiJobArtifactID` is a global ID. It is encoded as a string.
   *
   * An example `CiJobArtifactID` is: `"gid://gitlab/Ci::JobArtifact/1"`.
   */
  CiJobArtifactID: { input: any; output: any; }
  /**
   * A `CiPipelineID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineID` is: `"gid://gitlab/Ci::Pipeline/1"`.
   */
  CiPipelineID: { input: any; output: any; }
  /**
   * A `CiPipelineScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineScheduleID` is: `"gid://gitlab/Ci::PipelineSchedule/1"`.
   */
  CiPipelineScheduleID: { input: any; output: any; }
  /**
   * A `CiPipelineScheduleVariableID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineScheduleVariableID` is: `"gid://gitlab/Ci::PipelineScheduleVariable/1"`.
   */
  CiPipelineScheduleVariableID: { input: any; output: any; }
  /**
   * A `CiProcessableID` is a global ID. It is encoded as a string.
   *
   * An example `CiProcessableID` is: `"gid://gitlab/Ci::Processable/1"`.
   */
  CiProcessableID: { input: any; output: any; }
  /**
   * A `CiRunnerID` is a global ID. It is encoded as a string.
   *
   * An example `CiRunnerID` is: `"gid://gitlab/Ci::Runner/1"`.
   */
  CiRunnerID: { input: any; output: any; }
  /**
   * A `CiRunnerManagerID` is a global ID. It is encoded as a string.
   *
   * An example `CiRunnerManagerID` is: `"gid://gitlab/Ci::RunnerManager/1"`.
   */
  CiRunnerManagerID: { input: any; output: any; }
  /**
   * A `CiStageID` is a global ID. It is encoded as a string.
   *
   * An example `CiStageID` is: `"gid://gitlab/Ci::Stage/1"`.
   */
  CiStageID: { input: any; output: any; }
  /**
   * A `CiSubscriptionsProjectID` is a global ID. It is encoded as a string.
   *
   * An example `CiSubscriptionsProjectID` is: `"gid://gitlab/Ci::Subscriptions::Project/1"`.
   */
  CiSubscriptionsProjectID: { input: any; output: any; }
  /**
   * A `CiTriggerID` is a global ID. It is encoded as a string.
   *
   * An example `CiTriggerID` is: `"gid://gitlab/Ci::Trigger/1"`.
   */
  CiTriggerID: { input: any; output: any; }
  /**
   * A `ClustersAgentID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentID` is: `"gid://gitlab/Clusters::Agent/1"`.
   */
  ClustersAgentID: { input: any; output: any; }
  /**
   * A `ClustersAgentTokenID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentTokenID` is: `"gid://gitlab/Clusters::AgentToken/1"`.
   */
  ClustersAgentTokenID: { input: any; output: any; }
  /**
   * A `ClustersAgentsUrlConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentsUrlConfigurationID` is: `"gid://gitlab/Clusters::Agents::UrlConfiguration/1"`.
   */
  ClustersAgentsUrlConfigurationID: { input: any; output: any; }
  /**
   * A `ClustersClusterID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersClusterID` is: `"gid://gitlab/Clusters::Cluster/1"`.
   */
  ClustersClusterID: { input: any; output: any; }
  /**
   * Color represented as a hex code or named color.
   *
   * For example: `#fefefe`.
   *
   */
  Color: { input: any; output: any; }
  /**
   * A `ComplianceManagementComplianceFrameworkComplianceRequirementID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementComplianceFrameworkComplianceRequirementID` is: `"gid://gitlab/ComplianceManagement::ComplianceFramework::ComplianceRequirement/1"`.
   */
  ComplianceManagementComplianceFrameworkComplianceRequirementID: { input: any; output: any; }
  /**
   * A `ComplianceManagementComplianceFrameworkComplianceRequirementsControlID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementComplianceFrameworkComplianceRequirementsControlID` is: `"gid://gitlab/ComplianceManagement::ComplianceFramework::ComplianceRequirementsControl/1"`.
   */
  ComplianceManagementComplianceFrameworkComplianceRequirementsControlID: { input: any; output: any; }
  /**
   * A `ComplianceManagementFrameworkID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementFrameworkID` is: `"gid://gitlab/ComplianceManagement::Framework/1"`.
   */
  ComplianceManagementFrameworkID: { input: any; output: any; }
  /**
   * A `ComplianceManagementProjectsComplianceViolationID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementProjectsComplianceViolationID` is: `"gid://gitlab/ComplianceManagement::Projects::ComplianceViolation/1"`.
   */
  ComplianceManagementProjectsComplianceViolationID: { input: any; output: any; }
  /**
   * A `ContainerRegistryProtectionRuleID` is a global ID. It is encoded as a string.
   *
   * An example `ContainerRegistryProtectionRuleID` is: `"gid://gitlab/ContainerRegistry::Protection::Rule/1"`.
   */
  ContainerRegistryProtectionRuleID: { input: any; output: any; }
  /**
   * A `ContainerRegistryProtectionTagRuleID` is a global ID. It is encoded as a string.
   *
   * An example `ContainerRegistryProtectionTagRuleID` is: `"gid://gitlab/ContainerRegistry::Protection::TagRule/1"`.
   */
  ContainerRegistryProtectionTagRuleID: { input: any; output: any; }
  /**
   * A `ContainerRepositoryID` is a global ID. It is encoded as a string.
   *
   * An example `ContainerRepositoryID` is: `"gid://gitlab/ContainerRepository/1"`.
   */
  ContainerRepositoryID: { input: any; output: any; }
  /**
   * A `CustomEmojiID` is a global ID. It is encoded as a string.
   *
   * An example `CustomEmojiID` is: `"gid://gitlab/CustomEmoji/1"`.
   */
  CustomEmojiID: { input: any; output: any; }
  /**
   * A `CustomerRelationsContactID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsContactID` is: `"gid://gitlab/CustomerRelations::Contact/1"`.
   */
  CustomerRelationsContactID: { input: any; output: any; }
  /**
   * A `CustomerRelationsOrganizationID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsOrganizationID` is: `"gid://gitlab/CustomerRelations::Organization/1"`.
   */
  CustomerRelationsOrganizationID: { input: any; output: any; }
  /**
   * A `DastProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileID` is: `"gid://gitlab/Dast::Profile/1"`.
   */
  DastProfileID: { input: any; output: any; }
  /**
   * A `DastProfileScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileScheduleID` is: `"gid://gitlab/Dast::ProfileSchedule/1"`.
   */
  DastProfileScheduleID: { input: any; output: any; }
  /**
   * A `DastScannerProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastScannerProfileID` is: `"gid://gitlab/DastScannerProfile/1"`.
   */
  DastScannerProfileID: { input: any; output: any; }
  /**
   * A `DastSiteProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteProfileID` is: `"gid://gitlab/DastSiteProfile/1"`.
   */
  DastSiteProfileID: { input: any; output: any; }
  /**
   * A `DastSiteTokenID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteTokenID` is: `"gid://gitlab/DastSiteToken/1"`.
   */
  DastSiteTokenID: { input: any; output: any; }
  /**
   * A `DastSiteValidationID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteValidationID` is: `"gid://gitlab/DastSiteValidation/1"`.
   */
  DastSiteValidationID: { input: any; output: any; }
  /** Date represented in ISO 8601 */
  Date: { input: any; output: any; }
  /**
   * A `DependencyProxyManifestID` is a global ID. It is encoded as a string.
   *
   * An example `DependencyProxyManifestID` is: `"gid://gitlab/DependencyProxy::Manifest/1"`.
   */
  DependencyProxyManifestID: { input: any; output: any; }
  /**
   * A `DeployKeyID` is a global ID. It is encoded as a string.
   *
   * An example `DeployKeyID` is: `"gid://gitlab/DeployKey/1"`.
   */
  DeployKeyID: { input: any; output: any; }
  /**
   * A `DeploymentID` is a global ID. It is encoded as a string.
   *
   * An example `DeploymentID` is: `"gid://gitlab/Deployment/1"`.
   */
  DeploymentID: { input: any; output: any; }
  /**
   * A `DescriptionVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DescriptionVersionID` is: `"gid://gitlab/DescriptionVersion/1"`.
   */
  DescriptionVersionID: { input: any; output: any; }
  /**
   * A `DesignManagementDesignAtVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignAtVersionID` is: `"gid://gitlab/DesignManagement::DesignAtVersion/1"`.
   */
  DesignManagementDesignAtVersionID: { input: any; output: any; }
  /**
   * A `DesignManagementDesignID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignID` is: `"gid://gitlab/DesignManagement::Design/1"`.
   */
  DesignManagementDesignID: { input: any; output: any; }
  /**
   * A `DesignManagementVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementVersionID` is: `"gid://gitlab/DesignManagement::Version/1"`.
   */
  DesignManagementVersionID: { input: any; output: any; }
  /**
   * A `DiffNoteID` is a global ID. It is encoded as a string.
   *
   * An example `DiffNoteID` is: `"gid://gitlab/DiffNote/1"`.
   */
  DiffNoteID: { input: any; output: any; }
  /**
   * A `DiscussionID` is a global ID. It is encoded as a string.
   *
   * An example `DiscussionID` is: `"gid://gitlab/Discussion/1"`.
   */
  DiscussionID: { input: any; output: any; }
  /**
   * Duration between two instants, represented as a fractional number of seconds.
   *
   * For example: 12.3334
   *
   */
  Duration: { input: any; output: any; }
  /**
   * A `EmailID` is a global ID. It is encoded as a string.
   *
   * An example `EmailID` is: `"gid://gitlab/Email/1"`.
   */
  EmailID: { input: any; output: any; }
  /**
   * A `EnvironmentID` is a global ID. It is encoded as a string.
   *
   * An example `EnvironmentID` is: `"gid://gitlab/Environment/1"`.
   */
  EnvironmentID: { input: any; output: any; }
  /**
   * A `EpicID` is a global ID. It is encoded as a string.
   *
   * An example `EpicID` is: `"gid://gitlab/Epic/1"`.
   */
  EpicID: { input: any; output: any; }
  /**
   * A `EpicTreeSortingID` is a global ID. It is encoded as a string.
   *
   * An example `EpicTreeSortingID` is: `"gid://gitlab/EpicTreeSorting/1"`.
   */
  EpicTreeSortingID: { input: any; output: any; }
  /**
   * A `GeoBaseRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoBaseRegistryID` is: `"gid://gitlab/Geo::BaseRegistry/1"`.
   */
  GeoBaseRegistryID: { input: any; output: any; }
  /**
   * A `GeoCiSecureFileRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoCiSecureFileRegistryID` is: `"gid://gitlab/Geo::CiSecureFileRegistry/1"`.
   */
  GeoCiSecureFileRegistryID: { input: any; output: any; }
  /**
   * A `GeoContainerRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoContainerRepositoryRegistryID` is: `"gid://gitlab/Geo::ContainerRepositoryRegistry/1"`.
   */
  GeoContainerRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoDependencyProxyBlobRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoDependencyProxyBlobRegistryID` is: `"gid://gitlab/Geo::DependencyProxyBlobRegistry/1"`.
   */
  GeoDependencyProxyBlobRegistryID: { input: any; output: any; }
  /**
   * A `GeoDependencyProxyManifestRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoDependencyProxyManifestRegistryID` is: `"gid://gitlab/Geo::DependencyProxyManifestRegistry/1"`.
   */
  GeoDependencyProxyManifestRegistryID: { input: any; output: any; }
  /**
   * A `GeoDesignManagementRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoDesignManagementRepositoryRegistryID` is: `"gid://gitlab/Geo::DesignManagementRepositoryRegistry/1"`.
   */
  GeoDesignManagementRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoGroupWikiRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoGroupWikiRepositoryRegistryID` is: `"gid://gitlab/Geo::GroupWikiRepositoryRegistry/1"`.
   */
  GeoGroupWikiRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoJobArtifactRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoJobArtifactRegistryID` is: `"gid://gitlab/Geo::JobArtifactRegistry/1"`.
   */
  GeoJobArtifactRegistryID: { input: any; output: any; }
  /**
   * A `GeoLfsObjectRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoLfsObjectRegistryID` is: `"gid://gitlab/Geo::LfsObjectRegistry/1"`.
   */
  GeoLfsObjectRegistryID: { input: any; output: any; }
  /**
   * A `GeoMergeRequestDiffRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoMergeRequestDiffRegistryID` is: `"gid://gitlab/Geo::MergeRequestDiffRegistry/1"`.
   */
  GeoMergeRequestDiffRegistryID: { input: any; output: any; }
  /**
   * A `GeoPackageFileRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoPackageFileRegistryID` is: `"gid://gitlab/Geo::PackageFileRegistry/1"`.
   */
  GeoPackageFileRegistryID: { input: any; output: any; }
  /**
   * A `GeoPackagesNugetSymbolRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoPackagesNugetSymbolRegistryID` is: `"gid://gitlab/Geo::PackagesNugetSymbolRegistry/1"`.
   */
  GeoPackagesNugetSymbolRegistryID: { input: any; output: any; }
  /**
   * A `GeoPagesDeploymentRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoPagesDeploymentRegistryID` is: `"gid://gitlab/Geo::PagesDeploymentRegistry/1"`.
   */
  GeoPagesDeploymentRegistryID: { input: any; output: any; }
  /**
   * A `GeoPipelineArtifactRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoPipelineArtifactRegistryID` is: `"gid://gitlab/Geo::PipelineArtifactRegistry/1"`.
   */
  GeoPipelineArtifactRegistryID: { input: any; output: any; }
  /**
   * A `GeoProjectRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoProjectRepositoryRegistryID` is: `"gid://gitlab/Geo::ProjectRepositoryRegistry/1"`.
   */
  GeoProjectRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoProjectWikiRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoProjectWikiRepositoryRegistryID` is: `"gid://gitlab/Geo::ProjectWikiRepositoryRegistry/1"`.
   */
  GeoProjectWikiRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoSnippetRepositoryRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoSnippetRepositoryRegistryID` is: `"gid://gitlab/Geo::SnippetRepositoryRegistry/1"`.
   */
  GeoSnippetRepositoryRegistryID: { input: any; output: any; }
  /**
   * A `GeoTerraformStateVersionRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoTerraformStateVersionRegistryID` is: `"gid://gitlab/Geo::TerraformStateVersionRegistry/1"`.
   */
  GeoTerraformStateVersionRegistryID: { input: any; output: any; }
  /**
   * A `GeoUploadRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoUploadRegistryID` is: `"gid://gitlab/Geo::UploadRegistry/1"`.
   */
  GeoUploadRegistryID: { input: any; output: any; }
  /**
   * A `GitlabErrorTrackingDetailedErrorID` is a global ID. It is encoded as a string.
   *
   * An example `GitlabErrorTrackingDetailedErrorID` is: `"gid://gitlab/Gitlab::ErrorTracking::DetailedError/1"`.
   */
  GitlabErrorTrackingDetailedErrorID: { input: any; output: any; }
  /**
   * A `GitlabSubscriptionsAddOnPurchaseID` is a global ID. It is encoded as a string.
   *
   * An example `GitlabSubscriptionsAddOnPurchaseID` is: `"gid://gitlab/GitlabSubscriptions::AddOnPurchase/1"`.
   */
  GitlabSubscriptionsAddOnPurchaseID: { input: any; output: any; }
  /**
   * A global identifier.
   *
   * A global identifier represents an object uniquely across the application.
   * An example of a global identifier is `"gid://gitlab/User/1"`.
   *
   * `gid://gitlab` stands for the root name.
   * `User` is the name of the ActiveRecord class of the record.
   * `1` is the record id as per the id in the db table.
   *
   * Global identifiers are encoded as strings.
   *
   */
  GlobalID: { input: any; output: any; }
  /** Represents a Google Cloud Image for GKE */
  GoogleCloudImage: { input: any; output: any; }
  /** Represents a Google Cloud Compute machine type */
  GoogleCloudMachineType: { input: any; output: any; }
  /** Represents a Google Cloud Compute project */
  GoogleCloudProject: { input: any; output: any; }
  /** Represents a Google Cloud Compute region */
  GoogleCloudRegion: { input: any; output: any; }
  /** Represents a Google Cloud Compute zone */
  GoogleCloudZone: { input: any; output: any; }
  /**
   * A `GroupHookID` is a global ID. It is encoded as a string.
   *
   * An example `GroupHookID` is: `"gid://gitlab/GroupHook/1"`.
   */
  GroupHookID: { input: any; output: any; }
  /**
   * A `GroupID` is a global ID. It is encoded as a string.
   *
   * An example `GroupID` is: `"gid://gitlab/Group/1"`.
   */
  GroupID: { input: any; output: any; }
  /**
   * A `GroupsSavedReplyID` is a global ID. It is encoded as a string.
   *
   * An example `GroupsSavedReplyID` is: `"gid://gitlab/Groups::SavedReply/1"`.
   */
  GroupsSavedReplyID: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: any; output: any; }
  /**
   * A `ImportSourceUserID` is a global ID. It is encoded as a string.
   *
   * An example `ImportSourceUserID` is: `"gid://gitlab/Import::SourceUser/1"`.
   */
  ImportSourceUserID: { input: any; output: any; }
  /**
   * A `IncidentManagementEscalationPolicyID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationPolicyID` is: `"gid://gitlab/IncidentManagement::EscalationPolicy/1"`.
   */
  IncidentManagementEscalationPolicyID: { input: any; output: any; }
  /**
   * A `IncidentManagementEscalationRuleID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationRuleID` is: `"gid://gitlab/IncidentManagement::EscalationRule/1"`.
   */
  IncidentManagementEscalationRuleID: { input: any; output: any; }
  /**
   * A `IncidentManagementIssuableResourceLinkID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementIssuableResourceLinkID` is: `"gid://gitlab/IncidentManagement::IssuableResourceLink/1"`.
   */
  IncidentManagementIssuableResourceLinkID: { input: any; output: any; }
  /**
   * A `IncidentManagementOncallParticipantID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallParticipantID` is: `"gid://gitlab/IncidentManagement::OncallParticipant/1"`.
   */
  IncidentManagementOncallParticipantID: { input: any; output: any; }
  /**
   * A `IncidentManagementOncallRotationID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallRotationID` is: `"gid://gitlab/IncidentManagement::OncallRotation/1"`.
   */
  IncidentManagementOncallRotationID: { input: any; output: any; }
  /**
   * A `IncidentManagementTimelineEventID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventID` is: `"gid://gitlab/IncidentManagement::TimelineEvent/1"`.
   */
  IncidentManagementTimelineEventID: { input: any; output: any; }
  /**
   * A `IncidentManagementTimelineEventTagID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventTagID` is: `"gid://gitlab/IncidentManagement::TimelineEventTag/1"`.
   */
  IncidentManagementTimelineEventTagID: { input: any; output: any; }
  /**
   * A `IntegrationsPrometheusID` is a global ID. It is encoded as a string.
   *
   * An example `IntegrationsPrometheusID` is: `"gid://gitlab/Integrations::Prometheus/1"`.
   * The older format `"gid://gitlab/PrometheusService/1"` was deprecated in 14.1.
   */
  IntegrationsPrometheusID: { input: any; output: any; }
  /**
   * A `IssuableID` is a global ID. It is encoded as a string.
   *
   * An example `IssuableID` is: `"gid://gitlab/Issuable/1"`.
   */
  IssuableID: { input: any; output: any; }
  /**
   * A `IssuablesCustomFieldID` is a global ID. It is encoded as a string.
   *
   * An example `IssuablesCustomFieldID` is: `"gid://gitlab/Issuables::CustomField/1"`.
   */
  IssuablesCustomFieldID: { input: any; output: any; }
  /**
   * A `IssuablesCustomFieldSelectOptionID` is a global ID. It is encoded as a string.
   *
   * An example `IssuablesCustomFieldSelectOptionID` is: `"gid://gitlab/Issuables::CustomFieldSelectOption/1"`.
   */
  IssuablesCustomFieldSelectOptionID: { input: any; output: any; }
  /**
   * A `IssueID` is a global ID. It is encoded as a string.
   *
   * An example `IssueID` is: `"gid://gitlab/Issue/1"`.
   */
  IssueID: { input: any; output: any; }
  /**
   * A `IterationID` is a global ID. It is encoded as a string.
   *
   * An example `IterationID` is: `"gid://gitlab/Iteration/1"`.
   * The older format `"gid://gitlab/EEIteration/1"` was deprecated in 13.3.
   */
  IterationID: { input: any; output: any; }
  /**
   * A `IterationsCadenceID` is a global ID. It is encoded as a string.
   *
   * An example `IterationsCadenceID` is: `"gid://gitlab/Iterations::Cadence/1"`.
   */
  IterationsCadenceID: { input: any; output: any; }
  /** Represents untyped JSON */
  JSON: { input: any; output: any; }
  /**
   * A `CommitStatusID` is a global ID. It is encoded as a string.
   *
   * An example `CommitStatusID` is: `"gid://gitlab/CommitStatus/1"`.
   */
  JobID: { input: any; output: any; }
  /** JSON object as raw string */
  JsonString: { input: any; output: any; }
  /**
   * A `LabelID` is a global ID. It is encoded as a string.
   *
   * An example `LabelID` is: `"gid://gitlab/Label/1"`.
   */
  LabelID: { input: any; output: any; }
  /**
   * A `ListID` is a global ID. It is encoded as a string.
   *
   * An example `ListID` is: `"gid://gitlab/List/1"`.
   */
  ListID: { input: any; output: any; }
  /**
   * A `MemberRoleID` is a global ID. It is encoded as a string.
   *
   * An example `MemberRoleID` is: `"gid://gitlab/MemberRole/1"`.
   */
  MemberRoleID: { input: any; output: any; }
  /**
   * A `MergeRequestID` is a global ID. It is encoded as a string.
   *
   * An example `MergeRequestID` is: `"gid://gitlab/MergeRequest/1"`.
   */
  MergeRequestID: { input: any; output: any; }
  /**
   * A `MergeRequestsClosingIssuesID` is a global ID. It is encoded as a string.
   *
   * An example `MergeRequestsClosingIssuesID` is: `"gid://gitlab/MergeRequestsClosingIssues/1"`.
   */
  MergeRequestsClosingIssuesID: { input: any; output: any; }
  /**
   * A `MergeRequestsExternalStatusCheckID` is a global ID. It is encoded as a string.
   *
   * An example `MergeRequestsExternalStatusCheckID` is: `"gid://gitlab/MergeRequests::ExternalStatusCheck/1"`.
   */
  MergeRequestsExternalStatusCheckID: { input: any; output: any; }
  /**
   * A `MergeTrainsCarID` is a global ID. It is encoded as a string.
   *
   * An example `MergeTrainsCarID` is: `"gid://gitlab/MergeTrains::Car/1"`.
   */
  MergeTrainsCarID: { input: any; output: any; }
  /**
   * A `MilestoneID` is a global ID. It is encoded as a string.
   *
   * An example `MilestoneID` is: `"gid://gitlab/Milestone/1"`.
   */
  MilestoneID: { input: any; output: any; }
  /**
   * A `MlCandidateID` is a global ID. It is encoded as a string.
   *
   * An example `MlCandidateID` is: `"gid://gitlab/Ml::Candidate/1"`.
   */
  MlCandidateID: { input: any; output: any; }
  /**
   * A `MlCandidateMetadataID` is a global ID. It is encoded as a string.
   *
   * An example `MlCandidateMetadataID` is: `"gid://gitlab/Ml::CandidateMetadata/1"`.
   */
  MlCandidateMetadataID: { input: any; output: any; }
  /**
   * A `MlCandidateMetricID` is a global ID. It is encoded as a string.
   *
   * An example `MlCandidateMetricID` is: `"gid://gitlab/Ml::CandidateMetric/1"`.
   */
  MlCandidateMetricID: { input: any; output: any; }
  /**
   * A `MlCandidateParamID` is a global ID. It is encoded as a string.
   *
   * An example `MlCandidateParamID` is: `"gid://gitlab/Ml::CandidateParam/1"`.
   */
  MlCandidateParamID: { input: any; output: any; }
  /**
   * A `MlExperimentID` is a global ID. It is encoded as a string.
   *
   * An example `MlExperimentID` is: `"gid://gitlab/Ml::Experiment/1"`.
   */
  MlExperimentID: { input: any; output: any; }
  /**
   * A `MlModelID` is a global ID. It is encoded as a string.
   *
   * An example `MlModelID` is: `"gid://gitlab/Ml::Model/1"`.
   */
  MlModelID: { input: any; output: any; }
  /**
   * A `MlModelVersionID` is a global ID. It is encoded as a string.
   *
   * An example `MlModelVersionID` is: `"gid://gitlab/Ml::ModelVersion/1"`.
   */
  MlModelVersionID: { input: any; output: any; }
  /**
   * A `NamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `NamespaceID` is: `"gid://gitlab/Namespace/1"`.
   */
  NamespaceID: { input: any; output: any; }
  /**
   * A `NamespacesNamespaceBanID` is a global ID. It is encoded as a string.
   *
   * An example `NamespacesNamespaceBanID` is: `"gid://gitlab/Namespaces::NamespaceBan/1"`.
   */
  NamespacesNamespaceBanID: { input: any; output: any; }
  /**
   * A `NoteID` is a global ID. It is encoded as a string.
   *
   * An example `NoteID` is: `"gid://gitlab/Note/1"`.
   */
  NoteID: { input: any; output: any; }
  /**
   * A `NoteableID` is a global ID. It is encoded as a string.
   *
   * An example `NoteableID` is: `"gid://gitlab/Noteable/1"`.
   */
  NoteableID: { input: any; output: any; }
  /**
   * A `OperationsFeatureFlagID` is a global ID. It is encoded as a string.
   *
   * An example `OperationsFeatureFlagID` is: `"gid://gitlab/Operations::FeatureFlag/1"`.
   */
  OperationsFeatureFlagID: { input: any; output: any; }
  /**
   * A `OrganizationsOrganizationID` is a global ID. It is encoded as a string.
   *
   * An example `OrganizationsOrganizationID` is: `"gid://gitlab/Organizations::Organization/1"`.
   */
  OrganizationsOrganizationID: { input: any; output: any; }
  /**
   * A `OrganizationsOrganizationUserID` is a global ID. It is encoded as a string.
   *
   * An example `OrganizationsOrganizationUserID` is: `"gid://gitlab/Organizations::OrganizationUser/1"`.
   */
  OrganizationsOrganizationUserID: { input: any; output: any; }
  /**
   * A `PackagesConanFileMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanFileMetadatumID` is: `"gid://gitlab/Packages::Conan::FileMetadatum/1"`.
   */
  PackagesConanFileMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesConanMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanMetadatumID` is: `"gid://gitlab/Packages::Conan::Metadatum/1"`.
   */
  PackagesConanMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesDependencyID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyID` is: `"gid://gitlab/Packages::Dependency/1"`.
   */
  PackagesDependencyID: { input: any; output: any; }
  /**
   * A `PackagesDependencyLinkID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyLinkID` is: `"gid://gitlab/Packages::DependencyLink/1"`.
   */
  PackagesDependencyLinkID: { input: any; output: any; }
  /**
   * A `PackagesMavenMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesMavenMetadatumID` is: `"gid://gitlab/Packages::Maven::Metadatum/1"`.
   */
  PackagesMavenMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesNugetDependencyLinkMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetDependencyLinkMetadatumID` is: `"gid://gitlab/Packages::Nuget::DependencyLinkMetadatum/1"`.
   */
  PackagesNugetDependencyLinkMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesNugetMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetMetadatumID` is: `"gid://gitlab/Packages::Nuget::Metadatum/1"`.
   */
  PackagesNugetMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesPackageFileID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageFileID` is: `"gid://gitlab/Packages::PackageFile/1"`.
   */
  PackagesPackageFileID: { input: any; output: any; }
  /**
   * A `PackagesPackageID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageID` is: `"gid://gitlab/Packages::Package/1"`.
   */
  PackagesPackageID: { input: any; output: any; }
  /**
   * A `PackagesProtectionRuleID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesProtectionRuleID` is: `"gid://gitlab/Packages::Protection::Rule/1"`.
   */
  PackagesProtectionRuleID: { input: any; output: any; }
  /**
   * A `PackagesPypiMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPypiMetadatumID` is: `"gid://gitlab/Packages::Pypi::Metadatum/1"`.
   */
  PackagesPypiMetadatumID: { input: any; output: any; }
  /**
   * A `PackagesTerraformModuleMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesTerraformModuleMetadatumID` is: `"gid://gitlab/Packages::TerraformModule::Metadatum/1"`.
   */
  PackagesTerraformModuleMetadatumID: { input: any; output: any; }
  /**
   * A `PagesDeploymentID` is a global ID. It is encoded as a string.
   *
   * An example `PagesDeploymentID` is: `"gid://gitlab/PagesDeployment/1"`.
   */
  PagesDeploymentID: { input: any; output: any; }
  /**
   * A `PathLockID` is a global ID. It is encoded as a string.
   *
   * An example `PathLockID` is: `"gid://gitlab/PathLock/1"`.
   */
  PathLockID: { input: any; output: any; }
  /** String or integer. */
  PayloadAlertFieldPathSegment: { input: any; output: any; }
  /**
   * A `PersonalAccessTokenID` is a global ID. It is encoded as a string.
   *
   * An example `PersonalAccessTokenID` is: `"gid://gitlab/PersonalAccessToken/1"`.
   */
  PersonalAccessTokenID: { input: any; output: any; }
  /**
   * A `ProjectHookID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectHookID` is: `"gid://gitlab/ProjectHook/1"`.
   */
  ProjectHookID: { input: any; output: any; }
  /**
   * A `ProjectID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectID` is: `"gid://gitlab/Project/1"`.
   */
  ProjectID: { input: any; output: any; }
  /**
   * A `ProjectImportStateID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectImportStateID` is: `"gid://gitlab/ProjectImportState/1"`.
   */
  ProjectImportStateID: { input: any; output: any; }
  /**
   * A `ProjectsBranchRuleID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectsBranchRuleID` is: `"gid://gitlab/Projects::BranchRule/1"`.
   */
  ProjectsBranchRuleID: { input: any; output: any; }
  /**
   * A `ProjectsSavedReplyID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectsSavedReplyID` is: `"gid://gitlab/Projects::SavedReply/1"`.
   */
  ProjectsSavedReplyID: { input: any; output: any; }
  /**
   * A `ProjectsTargetBranchRuleID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectsTargetBranchRuleID` is: `"gid://gitlab/Projects::TargetBranchRule/1"`.
   */
  ProjectsTargetBranchRuleID: { input: any; output: any; }
  /**
   * A `ReleaseID` is a global ID. It is encoded as a string.
   *
   * An example `ReleaseID` is: `"gid://gitlab/Release/1"`.
   */
  ReleaseID: { input: any; output: any; }
  /**
   * A `ReleasesLinkID` is a global ID. It is encoded as a string.
   *
   * An example `ReleasesLinkID` is: `"gid://gitlab/Releases::Link/1"`.
   */
  ReleasesLinkID: { input: any; output: any; }
  /**
   * A `RemoteDevelopmentNamespaceClusterAgentMappingID` is a global ID. It is encoded as a string.
   *
   * An example `RemoteDevelopmentNamespaceClusterAgentMappingID` is: `"gid://gitlab/RemoteDevelopment::NamespaceClusterAgentMapping/1"`.
   */
  RemoteDevelopmentNamespaceClusterAgentMappingID: { input: any; output: any; }
  /**
   * A `RemoteDevelopmentWorkspaceID` is a global ID. It is encoded as a string.
   *
   * An example `RemoteDevelopmentWorkspaceID` is: `"gid://gitlab/RemoteDevelopment::Workspace/1"`.
   */
  RemoteDevelopmentWorkspaceID: { input: any; output: any; }
  /**
   * A `RemoteDevelopmentWorkspaceVariableID` is a global ID. It is encoded as a string.
   *
   * An example `RemoteDevelopmentWorkspaceVariableID` is: `"gid://gitlab/RemoteDevelopment::WorkspaceVariable/1"`.
   */
  RemoteDevelopmentWorkspaceVariableID: { input: any; output: any; }
  /**
   * A `RemoteDevelopmentWorkspacesAgentConfigID` is a global ID. It is encoded as a string.
   *
   * An example `RemoteDevelopmentWorkspacesAgentConfigID` is: `"gid://gitlab/RemoteDevelopment::WorkspacesAgentConfig/1"`.
   */
  RemoteDevelopmentWorkspacesAgentConfigID: { input: any; output: any; }
  /**
   * A `SbomComponentID` is a global ID. It is encoded as a string.
   *
   * An example `SbomComponentID` is: `"gid://gitlab/Sbom::Component/1"`.
   */
  SbomComponentID: { input: any; output: any; }
  /**
   * A `SbomComponentVersionID` is a global ID. It is encoded as a string.
   *
   * An example `SbomComponentVersionID` is: `"gid://gitlab/Sbom::ComponentVersion/1"`.
   */
  SbomComponentVersionID: { input: any; output: any; }
  /**
   * A `SbomOccurrenceID` is a global ID. It is encoded as a string.
   *
   * An example `SbomOccurrenceID` is: `"gid://gitlab/Sbom::Occurrence/1"`.
   */
  SbomOccurrenceID: { input: any; output: any; }
  /**
   * A `SecurityAttributeID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityAttributeID` is: `"gid://gitlab/Security::Attribute/1"`.
   */
  SecurityAttributeID: { input: any; output: any; }
  /**
   * A `SecurityCategoryID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityCategoryID` is: `"gid://gitlab/Security::Category/1"`.
   */
  SecurityCategoryID: { input: any; output: any; }
  /**
   * A `SecurityOrchestrationPolicyConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityOrchestrationPolicyConfigurationID` is: `"gid://gitlab/Security::OrchestrationPolicyConfiguration/1"`.
   */
  SecurityOrchestrationPolicyConfigurationID: { input: any; output: any; }
  /**
   * A `SecurityProjectSecurityExclusionID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityProjectSecurityExclusionID` is: `"gid://gitlab/Security::ProjectSecurityExclusion/1"`.
   */
  SecurityProjectSecurityExclusionID: { input: any; output: any; }
  /**
   * A `SecurityScanProfileID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityScanProfileID` is: `"gid://gitlab/Security::ScanProfile/1"`.
   */
  SecurityScanProfileID: { input: any; output: any; }
  /**
   * A `SecurityTrainingProviderID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityTrainingProviderID` is: `"gid://gitlab/Security::TrainingProvider/1"`.
   */
  SecurityTrainingProviderID: { input: any; output: any; }
  /**
   * A `SnippetID` is a global ID. It is encoded as a string.
   *
   * An example `SnippetID` is: `"gid://gitlab/Snippet/1"`.
   */
  SnippetID: { input: any; output: any; }
  /**
   * A `SystemNoteMetadataID` is a global ID. It is encoded as a string.
   *
   * An example `SystemNoteMetadataID` is: `"gid://gitlab/SystemNoteMetadata/1"`.
   */
  SystemNoteMetadataID: { input: any; output: any; }
  /**
   * A `TerraformStateID` is a global ID. It is encoded as a string.
   *
   * An example `TerraformStateID` is: `"gid://gitlab/Terraform::State/1"`.
   */
  TerraformStateID: { input: any; output: any; }
  /**
   * Time represented in ISO 8601.
   *
   * For example: `2021-03-09T14:58:50+00:00`.
   *
   * See `https://www.iso.org/iso-8601-date-and-time-format.html`.
   *
   */
  Time: { input: any; output: any; }
  /**
   * A `TimelogID` is a global ID. It is encoded as a string.
   *
   * An example `TimelogID` is: `"gid://gitlab/Timelog/1"`.
   */
  TimelogID: { input: any; output: any; }
  /**
   * A `TodoID` is a global ID. It is encoded as a string.
   *
   * An example `TodoID` is: `"gid://gitlab/Todo/1"`.
   */
  TodoID: { input: any; output: any; }
  /**
   * A `TodoableID` is a global ID. It is encoded as a string.
   *
   * An example `TodoableID` is: `"gid://gitlab/Todoable/1"`.
   */
  TodoableID: { input: any; output: any; }
  /**
   * A `TypesNamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `TypesNamespaceID` is: `"gid://gitlab/Types::Namespace/1"`.
   */
  TypesNamespaceID: { input: any; output: any; }
  /** A regexp containing patterns sourced from user input */
  UntrustedRegexp: { input: any; output: any; }
  Upload: { input: any; output: any; }
  /**
   * A `UploadID` is a global ID. It is encoded as a string.
   *
   * An example `UploadID` is: `"gid://gitlab/Upload/1"`.
   */
  UploadID: { input: any; output: any; }
  /**
   * A `UserID` is a global ID. It is encoded as a string.
   *
   * An example `UserID` is: `"gid://gitlab/User/1"`.
   */
  UserID: { input: any; output: any; }
  /**
   * A `UsersSavedReplyID` is a global ID. It is encoded as a string.
   *
   * An example `UsersSavedReplyID` is: `"gid://gitlab/Users::SavedReply/1"`.
   */
  UsersSavedReplyID: { input: any; output: any; }
  /**
   * A `VirtualRegistriesContainerRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `VirtualRegistriesContainerRegistryID` is: `"gid://gitlab/VirtualRegistries::Container::Registry/1"`.
   */
  VirtualRegistriesContainerRegistryID: { input: any; output: any; }
  /**
   * A `VirtualRegistriesPackagesMavenRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `VirtualRegistriesPackagesMavenRegistryID` is: `"gid://gitlab/VirtualRegistries::Packages::Maven::Registry/1"`.
   */
  VirtualRegistriesPackagesMavenRegistryID: { input: any; output: any; }
  /**
   * A `VirtualRegistriesPackagesMavenUpstreamID` is a global ID. It is encoded as a string.
   *
   * An example `VirtualRegistriesPackagesMavenUpstreamID` is: `"gid://gitlab/VirtualRegistries::Packages::Maven::Upstream/1"`.
   */
  VirtualRegistriesPackagesMavenUpstreamID: { input: any; output: any; }
  /**
   * A `VulnerabilitiesExternalIssueLinkID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesExternalIssueLinkID` is: `"gid://gitlab/Vulnerabilities::ExternalIssueLink/1"`.
   */
  VulnerabilitiesExternalIssueLinkID: { input: any; output: any; }
  /**
   * A `VulnerabilitiesScannerID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesScannerID` is: `"gid://gitlab/Vulnerabilities::Scanner/1"`.
   */
  VulnerabilitiesScannerID: { input: any; output: any; }
  /**
   * A `VulnerabilitiesStateTransitionID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesStateTransitionID` is: `"gid://gitlab/Vulnerabilities::StateTransition/1"`.
   */
  VulnerabilitiesStateTransitionID: { input: any; output: any; }
  /**
   * A `VulnerabilityID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilityID` is: `"gid://gitlab/Vulnerability/1"`.
   */
  VulnerabilityID: { input: any; output: any; }
  /**
   * A `WebHookLogID` is a global ID. It is encoded as a string.
   *
   * An example `WebHookLogID` is: `"gid://gitlab/WebHookLog/1"`.
   */
  WebHookLogID: { input: any; output: any; }
  /**
   * A `WikiPageMetaID` is a global ID. It is encoded as a string.
   *
   * An example `WikiPageMetaID` is: `"gid://gitlab/WikiPage::Meta/1"`.
   */
  WikiPageMetaID: { input: any; output: any; }
  /**
   * A `WorkItemID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.
   *
   * While we transition from Issues into Work Items this type will temporarily support
   * `IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
   *
   */
  WorkItemID: { input: any; output: any; }
  /**
   * A `WorkItemsRelatedWorkItemLinkID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsRelatedWorkItemLinkID` is: `"gid://gitlab/WorkItems::RelatedWorkItemLink/1"`.
   */
  WorkItemsRelatedWorkItemLinkID: { input: any; output: any; }
  /**
   * A `WorkItemsSavedViewsSavedViewID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsSavedViewsSavedViewID` is: `"gid://gitlab/WorkItems::SavedViews::SavedView/1"`.
   */
  WorkItemsSavedViewsSavedViewID: { input: any; output: any; }
  /**
   * A `WorkItemsStatusesLifecycleID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsStatusesLifecycleID` is: `"gid://gitlab/WorkItems::Statuses::Lifecycle/1"`.
   */
  WorkItemsStatusesLifecycleID: { input: any; output: any; }
  /**
   * A `WorkItemsStatusesStatusID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsStatusesStatusID` is: `"gid://gitlab/WorkItems::Statuses::Status/1"`.
   */
  WorkItemsStatusesStatusID: { input: any; output: any; }
  /**
   * A `WorkItemsTypeID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsTypeID` is: `"gid://gitlab/WorkItems::Type/1"`.
   */
  WorkItemsTypeID: { input: any; output: any; }
};

/** An abuse report */
export type AbuseReport = {
  __typename?: 'AbuseReport';
  /** Global ID of the abuse report. */
  id: Scalars['AbuseReportID']['output'];
};

/** Represents the access level of a relationship between a User and object that it is related to */
export type AccessLevel = {
  __typename?: 'AccessLevel';
  /** Human-readable display name for the access level. */
  humanAccess?: Maybe<Scalars['String']['output']>;
  /** Integer number of the access level. */
  integerValue?: Maybe<Scalars['Int']['output']>;
  /** Enum string of the the access level. */
  stringValue?: Maybe<AccessLevelEnum>;
};

/** Representation of a GitLab deploy key. */
export type AccessLevelDeployKey = {
  __typename?: 'AccessLevelDeployKey';
  /** Expiration date of the deploy key. */
  expiresAt?: Maybe<Scalars['Date']['output']>;
  /** ID of the deploy key. */
  id: Scalars['ID']['output'];
  /** Title of the deploy key. */
  title: Scalars['String']['output'];
  /** User assigned to the deploy key. */
  user: AccessLevelUser;
};

/** The connection type for AccessLevelDeployKey. */
export type AccessLevelDeployKeyConnection = {
  __typename?: 'AccessLevelDeployKeyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessLevelDeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessLevelDeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AccessLevelDeployKeyEdge = {
  __typename?: 'AccessLevelDeployKeyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessLevelDeployKey>;
};

/** Access level to a resource */
export type AccessLevelEnum =
  /** Admin access. */
  | 'ADMIN'
  /** Developer access. */
  | 'DEVELOPER'
  /** Guest access. */
  | 'GUEST'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Minimal access. */
  | 'MINIMAL_ACCESS'
  /** No access. */
  | 'NO_ACCESS'
  /** Owner access. */
  | 'OWNER'
  /** Planner access. */
  | 'PLANNER'
  /** Reporter access. */
  | 'REPORTER';

/** Representation of a GitLab group. */
export type AccessLevelGroup = {
  __typename?: 'AccessLevelGroup';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the group. */
  id: Scalars['ID']['output'];
  /** Name of the group. */
  name: Scalars['String']['output'];
  /** Parent group. */
  parent?: Maybe<AccessLevelGroup>;
  /** Web URL of the group. */
  webUrl: Scalars['String']['output'];
};

export type AccessLevelInterface = {
  /**
   * Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  immutable: Scalars['Boolean']['output'];
  /**
   * Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can delete tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForDelete?: Maybe<ContainerProtectionTagRuleAccessLevel>;
  /**
   * Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can push tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForPush?: Maybe<ContainerProtectionTagRuleAccessLevel>;
};

/** Representation of a GitLab user. */
export type AccessLevelUser = {
  __typename?: 'AccessLevelUser';
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the user. */
  id: Scalars['ID']['output'];
  /**
   * Human-readable name of the user.
   * Returns `****` if the user is a project bot and the requester does not have permission to view the project.
   *
   */
  name: Scalars['String']['output'];
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Username of the user. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
};

/** Granular scope applied to an access token. */
export type AccessTokenGranularScope = {
  __typename?: 'AccessTokenGranularScope';
  /** Access configured on a granular scope. */
  access: AccessTokenGranularScopeAccess;
  /** Namespace of the granular scope. */
  namespace?: Maybe<Namespace>;
  /** List of permissions of a granular scope. */
  permissions?: Maybe<Array<AccessTokenPermission>>;
};

/** Access configured on a granular scope. */
export type AccessTokenGranularScopeAccess =
  /** Grants access to resources belonging to all groups and projects the user is a member of. */
  | 'ALL_MEMBERSHIPS'
  /** Grants access to standalone instance-level resources. */
  | 'INSTANCE'
  /** Grants access to resources belonging to all personal projects of a user. */
  | 'PERSONAL_PROJECTS'
  /** Grants access to resources belonging to selected groups and projects the user is a member of. */
  | 'SELECTED_MEMBERSHIPS'
  /** Grants access to standalone user-level resources. */
  | 'USER';

/** Legacy scope applied to an access token */
export type AccessTokenLegacyScope = {
  __typename?: 'AccessTokenLegacyScope';
  /** Value of the scope. */
  value: Scalars['String']['output'];
};

/** Permission that belongs to a granular scope. */
export type AccessTokenPermission = {
  __typename?: 'AccessTokenPermission';
  /** Action of the permission. */
  action: Scalars['String']['output'];
  /** List of resource types that the permission can be applied to. */
  boundaries?: Maybe<Array<PermissionBoundary>>;
  /** Permission category. */
  category: Scalars['String']['output'];
  /** Description of the permission. */
  description: Scalars['String']['output'];
  /** Name of the permission. */
  name: Scalars['String']['output'];
  /** Resource of the permission. */
  resource: Scalars['String']['output'];
  /** Description of the resource. */
  resourceDescription?: Maybe<Scalars['String']['output']>;
  /** Display name of the resource. */
  resourceName?: Maybe<Scalars['String']['output']>;
};

/** Values for sorting access tokens. */
export type AccessTokenSort =
  /** Sort by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Sort by created_at in descending order. */
  | 'CREATED_DESC'
  /** Sort by expires_at in ascending order. */
  | 'EXPIRES_ASC'
  /** Sort by expires_at in descending order. */
  | 'EXPIRES_DESC'
  /** Sort by ID in ascending order. */
  | 'ID_ASC'
  /** Sort by ID in descending order. */
  | 'ID_DESC'
  /** Sort by last_used_at in ascending order. */
  | 'LAST_USED_ASC'
  /** Sort by last_used_at in descending order. */
  | 'LAST_USED_DESC'
  /** Sort by name in ascending order. */
  | 'NAME_ASC'
  /** Sort by name in descending order. */
  | 'NAME_DESC'
  /** Sort by updated_at in ascending order. */
  | 'UPDATED_ASC'
  /** Sort by updated_at in descending order. */
  | 'UPDATED_DESC';

/** State of an access token. */
export type AccessTokenState =
  /** Token is active. */
  | 'ACTIVE'
  /** Token is inactive. */
  | 'INACTIVE';

export type Achievement = {
  __typename?: 'Achievement';
  /** URL to avatar of the achievement. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp the achievement was created. */
  createdAt: Scalars['Time']['output'];
  /** Description or notes for the achievement. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the achievement. */
  id: Scalars['AchievementsAchievementID']['output'];
  /** Name of the achievement. */
  name: Scalars['String']['output'];
  /** Namespace of the achievement. */
  namespace?: Maybe<Namespace>;
  /**
   * Unique users who have received the achievement. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  uniqueUsers: UserCoreConnection;
  /** Timestamp the achievement was last updated. */
  updatedAt: Scalars['Time']['output'];
  /**
   * Recipients for the achievement. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
};


export type AchievementUniqueUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type AchievementUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Achievement. */
export type AchievementConnection = {
  __typename?: 'AchievementConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AchievementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Achievement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Achievement. */
export type AchievementConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type AchievementEdge = {
  __typename?: 'AchievementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Achievement>;
};

/** Autogenerated input type of AchievementsAward */
export type AchievementsAwardInput = {
  /** Global ID of the achievement being awarded. */
  achievementId: Scalars['AchievementsAchievementID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the user being awarded the achievement. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of AchievementsAward. */
export type AchievementsAwardPayload = {
  __typename?: 'AchievementsAwardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Achievement award. */
  userAchievement?: Maybe<UserAchievement>;
};

/** Autogenerated input type of AchievementsCreate */
export type AchievementsCreateInput = {
  /** Avatar for the achievement. */
  avatar?: InputMaybe<Scalars['Upload']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of or notes for the achievement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the achievement. */
  name: Scalars['String']['input'];
  /** Namespace for the achievement. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of AchievementsCreate. */
export type AchievementsCreatePayload = {
  __typename?: 'AchievementsCreatePayload';
  /** Achievement created. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AchievementsDelete */
export type AchievementsDeleteInput = {
  /** Global ID of the achievement being deleted. */
  achievementId: Scalars['AchievementsAchievementID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AchievementsDelete. */
export type AchievementsDeletePayload = {
  __typename?: 'AchievementsDeletePayload';
  /** Achievement. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AchievementsRevoke */
export type AchievementsRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the user achievement being revoked. */
  userAchievementId: Scalars['AchievementsUserAchievementID']['input'];
};

/** Autogenerated return type of AchievementsRevoke. */
export type AchievementsRevokePayload = {
  __typename?: 'AchievementsRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Achievement award. */
  userAchievement?: Maybe<UserAchievement>;
};

/** Autogenerated input type of AchievementsUpdate */
export type AchievementsUpdateInput = {
  /** Global ID of the achievement being updated. */
  achievementId: Scalars['AchievementsAchievementID']['input'];
  /** Avatar for the achievement. */
  avatar?: InputMaybe<Scalars['Upload']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of or notes for the achievement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the achievement. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AchievementsUpdate. */
export type AchievementsUpdatePayload = {
  __typename?: 'AchievementsUpdatePayload';
  /** Achievement. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents AddOn purchase for Namespace */
export type AddOnPurchase = {
  __typename?: 'AddOnPurchase';
  /** Number of seats assigned. */
  assignedQuantity: Scalars['Int']['output'];
  /** ID of AddOnPurchase. */
  id: Scalars['GitlabSubscriptionsAddOnPurchaseID']['output'];
  /** Name of AddOn. */
  name: Scalars['String']['output'];
  /** Number of seats purchased. */
  purchasedQuantity: Scalars['Int']['output'];
};

/** A user with add-on data */
export type AddOnUser = Todoable & User & {
  __typename?: 'AddOnUser';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Add-on purchase assignments for the user. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  addOnAssignments?: Maybe<UserAddOnAssignmentConnection>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** Date of the last Duo activity of the user. Refreshed on any GitLab Duo activity. */
  lastDuoActivityOn?: Maybe<Scalars['Date']['output']>;
  /** Timestamp of the last sign in. */
  lastLoginAt?: Maybe<Scalars['Time']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user with add-on data */
export type AddOnUserAddOnAssignmentsArgs = {
  addOnPurchaseIds: Array<Scalars['GitlabSubscriptionsAddOnPurchaseID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user with add-on data */
export type AddOnUserAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user with add-on data */
export type AddOnUserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user with add-on data */
export type AddOnUserEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** A user with add-on data */
export type AddOnUserNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user with add-on data */
export type AddOnUserPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** A user with add-on data */
export type AddOnUserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user with add-on data */
export type AddOnUserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** A user with add-on data */
export type AddOnUserSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user with add-on data */
export type AddOnUserStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user with add-on data */
export type AddOnUserTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** A user with add-on data */
export type AddOnUserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user with add-on data */
export type AddOnUserUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user with add-on data */
export type AddOnUserWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** The connection type for AddOnUser. */
export type AddOnUserConnection = {
  __typename?: 'AddOnUserConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddOnUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AddOnUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for AddOnUser. */
export type AddOnUserConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type AddOnUserEdge = {
  __typename?: 'AddOnUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AddOnUser>;
};

/** Autogenerated input type of AddProjectToSecurityDashboard */
export type AddProjectToSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project to be added to Instance Security Dashboard. */
  id: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of AddProjectToSecurityDashboard. */
export type AddProjectToSecurityDashboardPayload = {
  __typename?: 'AddProjectToSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project that was added to the Instance Security Dashboard. */
  project?: Maybe<Project>;
};

/** Represents an admin member role */
export type AdminMemberRole = CustomRoleInterface & RoleInterface & {
  __typename?: 'AdminMemberRole';
  /** Timestamp of when the member role was created. */
  createdAt: Scalars['Time']['output'];
  /** Role description. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * URL path to the role details webpage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  detailsPath?: Maybe<Scalars['String']['output']>;
  /**
   * Web UI path to edit the custom role. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  editPath: Scalars['String']['output'];
  /**
   * Array of all permissions enabled for the custom role. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  enabledPermissions: CustomizableAdminPermissionConnection;
  /** Role ID. */
  id: Scalars['ID']['output'];
  /**
   * LDAP admin role sync configurations that will assign the admin member role. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  ldapAdminRoleLinks?: Maybe<LdapAdminRoleLinkConnection>;
  /** Role name. */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Number of users who have been directly assigned the admin member role. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  usersCount?: Maybe<Scalars['Int']['output']>;
};


/** Represents an admin member role */
export type AdminMemberRoleEnabledPermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an admin member role */
export type AdminMemberRoleLdapAdminRoleLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for AdminMemberRole. */
export type AdminMemberRoleConnection = {
  __typename?: 'AdminMemberRoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AdminMemberRoleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AdminMemberRole>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AdminMemberRoleEdge = {
  __typename?: 'AdminMemberRoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AdminMemberRole>;
};

/** Autogenerated input type of AdminRolesLdapSync */
export type AdminRolesLdapSyncInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AdminRolesLdapSync. */
export type AdminRolesLdapSyncPayload = {
  __typename?: 'AdminRolesLdapSyncPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during operation. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Whether the sync was successfully enqueued. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AdminSidekiqQueuesDeleteJobs */
export type AdminSidekiqQueuesDeleteJobsInput = {
  /** Delete jobs matching ai_resource in the context metadata. */
  aiResource?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching artifact_size in the context metadata. */
  artifactSize?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching artifact_used_cdn in the context metadata. */
  artifactUsedCdn?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching artifacts_dependencies_count in the context metadata. */
  artifactsDependenciesCount?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching artifacts_dependencies_size in the context metadata. */
  artifactsDependenciesSize?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching bulk_import_entity_id in the context metadata. */
  bulkImportEntityId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching caller_id in the context metadata. */
  callerId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching client_id in the context metadata. */
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching feature_category in the context metadata. */
  featureCategory?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching gl_user_id in the context metadata. */
  glUserId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching job_id in the context metadata. */
  jobId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching kubernetes_agent_id in the context metadata. */
  kubernetesAgentId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching merge_action_status in the context metadata. */
  mergeActionStatus?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching organization_id in the context metadata. */
  organizationId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching pipeline_id in the context metadata. */
  pipelineId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching policy_sync_config_id in the context metadata. */
  policySyncConfigId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching project in the context metadata. */
  project?: InputMaybe<Scalars['String']['input']>;
  /** Name of the queue to delete jobs from. */
  queueName: Scalars['String']['input'];
  /** Delete jobs matching related_class in the context metadata. */
  relatedClass?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching remote_ip in the context metadata. */
  remoteIp?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching root_caller_id in the context metadata. */
  rootCallerId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching root_namespace in the context metadata. */
  rootNamespace?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching scoped_user in the context metadata. */
  scopedUser?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching scoped_user_id in the context metadata. */
  scopedUserId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching sidekiq_destination_shard_redis in the context metadata. */
  sidekiqDestinationShardRedis?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching subscription_plan in the context metadata. */
  subscriptionPlan?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching user in the context metadata. */
  user?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs matching user_id in the context metadata. */
  userId?: InputMaybe<Scalars['String']['input']>;
  /** Delete jobs with the given worker class. */
  workerClass?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AdminSidekiqQueuesDeleteJobs. */
export type AdminSidekiqQueuesDeleteJobsPayload = {
  __typename?: 'AdminSidekiqQueuesDeleteJobsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Information about the status of the deletion request. */
  result?: Maybe<DeleteJobsResponse>;
};

/** Configuration details for an Agent */
export type AgentConfiguration = {
  __typename?: 'AgentConfiguration';
  /** Name of the agent. */
  agentName?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AgentConfiguration. */
export type AgentConfigurationConnection = {
  __typename?: 'AgentConfigurationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AgentConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AgentConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AgentConfigurationEdge = {
  __typename?: 'AgentConfigurationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AgentConfiguration>;
};

/** Information about a connected Agent */
export type AgentMetadata = {
  __typename?: 'AgentMetadata';
  /** Agent version commit. */
  commit?: Maybe<Scalars['String']['output']>;
  /** Name of the pod running the Agent. */
  podName?: Maybe<Scalars['String']['output']>;
  /** Namespace of the pod running the Agent. */
  podNamespace?: Maybe<Scalars['String']['output']>;
  /** Agent version tag. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Agent platform aggregated metrics by flow type */
export type AgentPlatformFlowMetric = {
  __typename?: 'AgentPlatformFlowMetric';
  /** Completion rate as a percentage. */
  completionRate?: Maybe<Scalars['Float']['output']>;
  /** Type of the flow. */
  flowType: Scalars['String']['output'];
  /** Median flow execution time in seconds. */
  medianExecutionTime?: Maybe<Scalars['Float']['output']>;
  /** Total number of sessions. */
  sessionsCount: Scalars['Int']['output'];
  /** Number of unique users. */
  usersCount: Scalars['Int']['output'];
};

export type AgentPlatformMetricsNotInput = {
  /** List of flow types to exclude. */
  flowTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Agent token statuses */
export type AgentTokenStatus =
  /** Active agent token. */
  | 'ACTIVE'
  /** Revoked agent token. */
  | 'REVOKED';

/** Version-related warning for a connected Agent */
export type AgentVersionWarning = {
  __typename?: 'AgentVersionWarning';
  /** Warning message related to the version. */
  message?: Maybe<Scalars['String']['output']>;
  /** Warning type related to the version. */
  type?: Maybe<Scalars['String']['output']>;
};

/** Warning object for a connected Agent */
export type AgentWarning = {
  __typename?: 'AgentWarning';
  /** Agent warning related to the version. */
  version?: Maybe<AgentVersionWarning>;
};

export type AggregationStatus = {
  __typename?: 'AggregationStatus';
  /** Whether background aggregation is enabled or disabled. For downgraded, non-licensed groups and projects the field is `false`. */
  enabled: Scalars['Boolean']['output'];
  /** Estimated time when the next incremental update will happen. */
  estimatedNextUpdateAt?: Maybe<Scalars['Time']['output']>;
  /** Last incremental update time. */
  lastUpdateAt?: Maybe<Scalars['Time']['output']>;
};

/** LLMs supported by the self-hosted model features. */
export type AiAcceptedSelfHostedModels =
  /** Claude 3 model family, suitable for code generation and duo chat. */
  | 'CLAUDE_3'
  /** CodeGemma Code: Suitable for code suggestions. */
  | 'CODEGEMMA'
  /** Code-Llama Instruct: Suitable for code suggestions. */
  | 'CODELLAMA'
  /** Codestral: Suitable for code suggestions. */
  | 'CODESTRAL'
  /** Deepseek Coder base or instruct. */
  | 'DEEPSEEKCODER'
  /** General: Any model suitable for code suggestions and duo chat. */
  | 'GENERAL'
  /** GPT: Suitable for code suggestions. */
  | 'GPT'
  /** LLaMA 3: Suitable for code suggestions and duo chat. */
  | 'LLAMA3'
  /** Mistral: Suitable for code suggestions and duo chat. */
  | 'MISTRAL'
  /** Mixtral: Suitable for code suggestions and duo chat. */
  | 'MIXTRAL';

/** Action to subscribe to. */
export type AiAction =
  /** Chat action. */
  | 'CHAT';

/** Autogenerated input type of AiAction */
export type AiActionInput = {
  /** Input for agentic_chat AI action. */
  agenticChat?: InputMaybe<AiAgenticChatInput>;
  /** Input for chat AI action. */
  chat?: InputMaybe<AiChatInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Client generated ID that can be subscribed to, to receive a response for the mutation. */
  clientSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** Conversation type of the thread. */
  conversationType?: InputMaybe<AiConversationsThreadsConversationType>;
  /** Input for description_composer AI action. */
  descriptionComposer?: InputMaybe<AiDescriptionComposerInput>;
  /** Input for explain_vulnerability AI action. */
  explainVulnerability?: InputMaybe<AiExplainVulnerabilityInput>;
  /** Input for generate_commit_message AI action. */
  generateCommitMessage?: InputMaybe<AiGenerateCommitMessageInput>;
  /** Input for generate_description AI action. */
  generateDescription?: InputMaybe<AiGenerateDescriptionInput>;
  /** Input for measure_comment_temperature AI action. */
  measureCommentTemperature?: InputMaybe<AiMeasureCommentTemperatureInput>;
  /** Specifies the origin platform of the request. */
  platformOrigin?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the project the user is acting on. */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  /** Input for resolve_vulnerability AI action. */
  resolveVulnerability?: InputMaybe<AiResolveVulnerabilityInput>;
  /** Global ID of the top-level namespace the user is acting on. */
  rootNamespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Input for summarize_new_merge_request AI action. */
  summarizeNewMergeRequest?: InputMaybe<AiSummarizeNewMergeRequestInput>;
  /** Input for summarize_review AI action. */
  summarizeReview?: InputMaybe<AiSummarizeReviewInput>;
  /** Global Id of the existing thread to continue the conversation. If it is not specified, a new thread will be created for the specified conversation_type. */
  threadId?: InputMaybe<Scalars['AiConversationThreadID']['input']>;
};

/** Autogenerated return type of AiAction. */
export type AiActionPayload = {
  __typename?: 'AiActionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** ID of the request. */
  requestId?: Maybe<Scalars['String']['output']>;
  /** Global Id of the thread. */
  threadId?: Maybe<Scalars['AiConversationThreadID']['output']>;
};

/** Additional context for AI message. */
export type AiAdditionalContext = {
  __typename?: 'AiAdditionalContext';
  /** Category of the additional context. */
  category: AiAdditionalContextCategory;
  /** Content of the additional context. */
  content: Scalars['String']['output'];
  /** ID of the additional context. */
  id: Scalars['ID']['output'];
  /** Metadata of the additional context. */
  metadata?: Maybe<Scalars['JSON']['output']>;
};

/** The category of the additional context */
export type AiAdditionalContextCategory =
  /** Agent_user_environment content category. */
  | 'AGENT_USER_ENVIRONMENT'
  /** Dependency content category. */
  | 'DEPENDENCY'
  /** Directory content category. */
  | 'DIRECTORY'
  /** File content category. */
  | 'FILE'
  /** Issue content category. */
  | 'ISSUE'
  /** Local_git content category. */
  | 'LOCAL_GIT'
  /** Merge_request content category. */
  | 'MERGE_REQUEST'
  /** Repository content category. */
  | 'REPOSITORY'
  /** Snippet content category. */
  | 'SNIPPET'
  /** Terminal content category. */
  | 'TERMINAL'
  /** User_rule content category. */
  | 'USER_RULE';

export type AiAdditionalContextInput = {
  /** Category of the additional context. */
  category: AiAdditionalContextCategory;
  /** Content of the additional context. */
  content: Scalars['String']['input'];
  /** ID of the additional context. */
  id: Scalars['String']['input'];
  /** Metadata of the additional context. */
  metadata?: InputMaybe<Scalars['JSON']['input']>;
};

/** An AI agent */
export type AiAgent = {
  __typename?: 'AiAgent';
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the agent. */
  id: Scalars['ID']['output'];
  /** Latest version of the agent. */
  latestVersion?: Maybe<AiAgentVersion>;
  /** Name of the agent. */
  name: Scalars['String']['output'];
  /** Route ID of the agent. */
  routeId: Scalars['Int']['output'];
  /** Versions of the agent. */
  versions?: Maybe<Array<AiAgentVersion>>;
};

/** The connection type for AiAgent. */
export type AiAgentConnection = {
  __typename?: 'AiAgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of AiAgentCreate */
export type AiAgentCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the agent. */
  name: Scalars['String']['input'];
  /** Project to which the agent belongs. */
  projectPath: Scalars['ID']['input'];
  /** Prompt for the agent. */
  prompt: Scalars['String']['input'];
};

/** Autogenerated return type of AiAgentCreate. */
export type AiAgentCreatePayload = {
  __typename?: 'AiAgentCreatePayload';
  /** Agent after mutation. */
  agent?: Maybe<AiAgent>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AiAgentDestroy */
export type AiAgentDestroyInput = {
  /** Global ID of the AI Agent to be deleted. */
  agentId: Scalars['AiAgentID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project to which the agent belongs. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of AiAgentDestroy. */
export type AiAgentDestroyPayload = {
  __typename?: 'AiAgentDestroyPayload';
  /** Agent after mutation. */
  agent?: Maybe<AiAgent>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** AI Agent deletion result message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type AiAgentEdge = {
  __typename?: 'AiAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiAgent>;
};

/** Autogenerated input type of AiAgentUpdate */
export type AiAgentUpdateInput = {
  /** ID of the agent. */
  agentId: Scalars['AiAgentID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the agent. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Project to which the agent belongs. */
  projectPath: Scalars['ID']['input'];
  /** Prompt for the agent. */
  prompt?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AiAgentUpdate. */
export type AiAgentUpdatePayload = {
  __typename?: 'AiAgentUpdatePayload';
  /** Agent after mutation. */
  agent?: Maybe<AiAgent>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Version of an AI Agent */
export type AiAgentVersion = {
  __typename?: 'AiAgentVersion';
  /** Timestamp when the agent version was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the agent version. */
  id: Scalars['ID']['output'];
  /** Model of the agent. */
  model: Scalars['String']['output'];
  /** Prompt of the agent. */
  prompt: Scalars['String']['output'];
};

export type AiAgenticChatInput = {
  /** Additional context to be passed for the chat. */
  additionalContext?: InputMaybe<Array<AiAdditionalContextInput>>;
  /** Content of the message. */
  content: Scalars['String']['input'];
  /** Information about currently selected text which can be passed for additional context. */
  currentFile?: InputMaybe<AiCurrentFileInput>;
  /** Global ID of the namespace the user is acting on. */
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

/** An AI catalog agent */
export type AiCatalogAgent = AiCatalogItem & {
  __typename?: 'AiCatalogAgent';
  /**
   * Item configuration for the given group. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  configurationForGroup?: Maybe<AiCatalogItemConsumer>;
  /**
   * Item configuration for the given project. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  configurationForProject?: Maybe<AiCatalogItemConsumer>;
  /** Timestamp of when the item was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the item. */
  description: Scalars['String']['output'];
  /** Whether the item is a foundational agent (only on GitLab SaaS). */
  foundational: Scalars['Boolean']['output'];
  /** Foundational flow reference. */
  foundationalFlowReference?: Maybe<Scalars['String']['output']>;
  /** ID of the item. */
  id: Scalars['ID']['output'];
  /** Type of the item. */
  itemType: AiCatalogItemType;
  /** Latest version of the item. */
  latestVersion?: Maybe<AiCatalogItemVersion>;
  /** Name of the item. */
  name: Scalars['String']['output'];
  /** Project for the item. */
  project?: Maybe<Project>;
  /** Whether the item is publicly visible in the catalog. */
  public: Scalars['Boolean']['output'];
  /** Indicates if the item has been soft deleted. */
  softDeleted?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the item was soft deleted. */
  softDeletedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: AiCatalogItemPermissions;
  /** Versions of the item. */
  versions?: Maybe<AiCatalogItemVersionConnection>;
};


/** An AI catalog agent */
export type AiCatalogAgentConfigurationForGroupArgs = {
  groupId: Scalars['GroupID']['input'];
};


/** An AI catalog agent */
export type AiCatalogAgentConfigurationForProjectArgs = {
  projectId: Scalars['ProjectID']['input'];
};


/** An AI catalog agent */
export type AiCatalogAgentLatestVersionArgs = {
  released?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AI catalog agent */
export type AiCatalogAgentVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of AiCatalogAgentCreate */
export type AiCatalogAgentCreateInput = {
  /** Whether to add to the project upon creation. */
  addToProjectWhenCreated?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description for the agent. */
  description: Scalars['String']['input'];
  /** Name for the agent. */
  name: Scalars['String']['input'];
  /** Project for the agent. */
  projectId: Scalars['ProjectID']['input'];
  /** Whether the agent is publicly visible in the catalog. */
  public: Scalars['Boolean']['input'];
  /** Whether to release the latest version of the agent. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
  /** System prompt for the agent. */
  systemPrompt: Scalars['String']['input'];
  /** List of GitLab tools enabled for the agent. */
  tools?: InputMaybe<Array<Scalars['AiCatalogBuiltInToolID']['input']>>;
  /** User prompt for the agent. */
  userPrompt?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AiCatalogAgentCreate. */
export type AiCatalogAgentCreatePayload = {
  __typename?: 'AiCatalogAgentCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Item created. */
  item?: Maybe<AiCatalogAgent>;
};

/** Autogenerated input type of AiCatalogAgentDelete */
export type AiCatalogAgentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When true, the flow will always be hard deleted and never soft deleted. Can only be used by instance admins */
  forceHardDelete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the catalog Agent to delete. */
  id: Scalars['AiCatalogItemID']['input'];
};

/** Autogenerated return type of AiCatalogAgentDelete. */
export type AiCatalogAgentDeletePayload = {
  __typename?: 'AiCatalogAgentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if catalog Agent was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of AiCatalogAgentUpdate */
export type AiCatalogAgentUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description for the agent. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog Agent to update. */
  id: Scalars['AiCatalogItemID']['input'];
  /** Name for the agent. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Whether the agent is publicly visible in the catalog. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to release the latest version of the agent. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
  /** System prompt for the agent. */
  systemPrompt?: InputMaybe<Scalars['String']['input']>;
  /** List of GitLab tools enabled for the agent. */
  tools?: InputMaybe<Array<Scalars['AiCatalogBuiltInToolID']['input']>>;
  /** User prompt for the agent. */
  userPrompt?: InputMaybe<Scalars['String']['input']>;
  /** Bump version, calculated from the last released version name. */
  versionBump?: InputMaybe<AiCatalogVersionBump>;
};

/** Autogenerated return type of AiCatalogAgentUpdate. */
export type AiCatalogAgentUpdatePayload = {
  __typename?: 'AiCatalogAgentUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Agent that was updated. */
  item?: Maybe<AiCatalogAgent>;
};

/** An AI catalog agent version */
export type AiCatalogAgentVersion = AiCatalogItemVersion & {
  __typename?: 'AiCatalogAgentVersion';
  /** Timestamp of when the item version was created. */
  createdAt: Scalars['Time']['output'];
  /** Human-friendly name of the item version. In the form v1.0.0-draft. */
  humanVersionName?: Maybe<Scalars['String']['output']>;
  /** ID of the item version. */
  id: Scalars['ID']['output'];
  /** Indicates the item version is released. */
  released: Scalars['Boolean']['output'];
  /** Timestamp of when the item version was released. */
  releasedAt?: Maybe<Scalars['Time']['output']>;
  /** System prompt for the agent. */
  systemPrompt?: Maybe<Scalars['String']['output']>;
  /** List of GitLab tools enabled for the agent. */
  tools: AiCatalogBuiltInToolConnection;
  /** Timestamp of when the item version was updated. */
  updatedAt: Scalars['Time']['output'];
  /** User prompt for the agent. */
  userPrompt?: Maybe<Scalars['String']['output']>;
  /** Version name of the item version. */
  versionName?: Maybe<Scalars['String']['output']>;
};


/** An AI catalog agent version */
export type AiCatalogAgentVersionToolsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An AI catalog built-in tool */
export type AiCatalogBuiltInTool = {
  __typename?: 'AiCatalogBuiltInTool';
  /** Description of the built-in tool. */
  description: Scalars['String']['output'];
  /** Global ID of the built-in tool. */
  id: Scalars['AiCatalogBuiltInToolID']['output'];
  /** Name of the built-in tool. */
  name: Scalars['String']['output'];
  /** Title of the built-in tool. */
  title: Scalars['String']['output'];
};

/** The connection type for AiCatalogBuiltInTool. */
export type AiCatalogBuiltInToolConnection = {
  __typename?: 'AiCatalogBuiltInToolConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCatalogBuiltInToolEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCatalogBuiltInTool>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiCatalogBuiltInToolEdge = {
  __typename?: 'AiCatalogBuiltInToolEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCatalogBuiltInTool>;
};

/** An AI catalog flow */
export type AiCatalogFlow = AiCatalogItem & {
  __typename?: 'AiCatalogFlow';
  /**
   * Item configuration for the given group. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  configurationForGroup?: Maybe<AiCatalogItemConsumer>;
  /**
   * Item configuration for the given project. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  configurationForProject?: Maybe<AiCatalogItemConsumer>;
  /** Timestamp of when the item was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the item. */
  description: Scalars['String']['output'];
  /** Whether the item is a foundational flow (only on GitLab SaaS). */
  foundational: Scalars['Boolean']['output'];
  /** Foundational flow reference. */
  foundationalFlowReference?: Maybe<Scalars['String']['output']>;
  /** ID of the item. */
  id: Scalars['ID']['output'];
  /** Type of the item. */
  itemType: AiCatalogItemType;
  /** Latest version of the item. */
  latestVersion?: Maybe<AiCatalogItemVersion>;
  /** Name of the item. */
  name: Scalars['String']['output'];
  /** Project for the item. */
  project?: Maybe<Project>;
  /** Whether the item is publicly visible in the catalog. */
  public: Scalars['Boolean']['output'];
  /** Indicates if the item has been soft deleted. */
  softDeleted?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the item was soft deleted. */
  softDeletedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: AiCatalogItemPermissions;
  /** Versions of the item. */
  versions?: Maybe<AiCatalogItemVersionConnection>;
};


/** An AI catalog flow */
export type AiCatalogFlowConfigurationForGroupArgs = {
  groupId: Scalars['GroupID']['input'];
};


/** An AI catalog flow */
export type AiCatalogFlowConfigurationForProjectArgs = {
  projectId: Scalars['ProjectID']['input'];
};


/** An AI catalog flow */
export type AiCatalogFlowLatestVersionArgs = {
  released?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AI catalog flow */
export type AiCatalogFlowVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Possible flow configuration types for AI Catalog agents. */
export type AiCatalogFlowConfigType =
  /** Chat flow configuration. */
  | 'CHAT';

/** Autogenerated input type of AiCatalogFlowCreate */
export type AiCatalogFlowCreateInput = {
  /** Whether to add to the project upon creation. */
  addToProjectWhenCreated?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** YAML definition for the flow. */
  definition?: InputMaybe<Scalars['String']['input']>;
  /** Description for the flow. */
  description: Scalars['String']['input'];
  /** Name for the flow. */
  name: Scalars['String']['input'];
  /** Project for the flow. */
  projectId: Scalars['ProjectID']['input'];
  /** Whether the flow is publicly visible in the catalog. */
  public: Scalars['Boolean']['input'];
  /** Whether to release the latest version of the flow. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
  /** Steps for the flow. */
  steps?: InputMaybe<Array<AiCatalogFlowStepsInput>>;
};

/** Autogenerated return type of AiCatalogFlowCreate. */
export type AiCatalogFlowCreatePayload = {
  __typename?: 'AiCatalogFlowCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Item created. */
  item?: Maybe<AiCatalogFlow>;
};

/** Autogenerated input type of AiCatalogFlowDelete */
export type AiCatalogFlowDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When true, the flow will always be hard deleted and never soft deleted. Can only be used by instance admins */
  forceHardDelete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the catalog flow to delete. */
  id: Scalars['AiCatalogItemID']['input'];
};

/** Autogenerated return type of AiCatalogFlowDelete. */
export type AiCatalogFlowDeletePayload = {
  __typename?: 'AiCatalogFlowDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if catalog flow was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

export type AiCatalogFlowSteps = {
  __typename?: 'AiCatalogFlowSteps';
  /** Agent used. */
  agent?: Maybe<AiCatalogAgent>;
  /** Major version, minor version, or patch the agent is pinned to. */
  pinnedVersionPrefix?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AiCatalogFlowSteps. */
export type AiCatalogFlowStepsConnection = {
  __typename?: 'AiCatalogFlowStepsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCatalogFlowStepsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCatalogFlowSteps>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiCatalogFlowStepsEdge = {
  __typename?: 'AiCatalogFlowStepsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCatalogFlowSteps>;
};

export type AiCatalogFlowStepsInput = {
  /** Agent to use. */
  agentId: Scalars['AiCatalogItemID']['input'];
  /** Major version, minor version, or patch to pin the agent to. */
  pinnedVersionPrefix?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of AiCatalogFlowUpdate */
export type AiCatalogFlowUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** YAML definition for the Flow. */
  definition?: InputMaybe<Scalars['String']['input']>;
  /** Description for the flow. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog flow to update. */
  id: Scalars['AiCatalogItemID']['input'];
  /** Name for the flow. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Whether the flow is publicly visible in the catalog. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to release the latest version of the flow. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
  /** Steps for the flow. */
  steps?: InputMaybe<Array<AiCatalogFlowStepsInput>>;
  /** Bump version, calculated from the last released version name. */
  versionBump?: InputMaybe<AiCatalogVersionBump>;
};

/** Autogenerated return type of AiCatalogFlowUpdate. */
export type AiCatalogFlowUpdatePayload = {
  __typename?: 'AiCatalogFlowUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Flow that was updated. */
  item?: Maybe<AiCatalogFlow>;
};

/** An AI catalog flow version */
export type AiCatalogFlowVersion = AiCatalogItemVersion & {
  __typename?: 'AiCatalogFlowVersion';
  /** Timestamp of when the item version was created. */
  createdAt: Scalars['Time']['output'];
  /** YAML definition of the flow. */
  definition?: Maybe<Scalars['String']['output']>;
  /** Human-friendly name of the item version. In the form v1.0.0-draft. */
  humanVersionName?: Maybe<Scalars['String']['output']>;
  /** ID of the item version. */
  id: Scalars['ID']['output'];
  /** Indicates the item version is released. */
  released: Scalars['Boolean']['output'];
  /** Timestamp of when the item version was released. */
  releasedAt?: Maybe<Scalars['Time']['output']>;
  /** Steps of the flow. */
  steps?: Maybe<AiCatalogFlowStepsConnection>;
  /** Timestamp of when the item version was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Version name of the item version. */
  versionName?: Maybe<Scalars['String']['output']>;
};


/** An AI catalog flow version */
export type AiCatalogFlowVersionStepsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An AI catalog item */
export type AiCatalogItem = {
  /**
   * Item configuration for the given group. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  configurationForGroup?: Maybe<AiCatalogItemConsumer>;
  /**
   * Item configuration for the given project. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  configurationForProject?: Maybe<AiCatalogItemConsumer>;
  /** Timestamp of when the item was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the item. */
  description: Scalars['String']['output'];
  /** Foundational flow reference. */
  foundationalFlowReference?: Maybe<Scalars['String']['output']>;
  /** ID of the item. */
  id: Scalars['ID']['output'];
  /** Type of the item. */
  itemType: AiCatalogItemType;
  /** Latest version of the item. */
  latestVersion?: Maybe<AiCatalogItemVersion>;
  /** Name of the item. */
  name: Scalars['String']['output'];
  /** Project for the item. */
  project?: Maybe<Project>;
  /** Whether the item is publicly visible in the catalog. */
  public: Scalars['Boolean']['output'];
  /** Indicates if the item has been soft deleted. */
  softDeleted?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the item was soft deleted. */
  softDeletedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: AiCatalogItemPermissions;
  /** Versions of the item. */
  versions?: Maybe<AiCatalogItemVersionConnection>;
};


/** An AI catalog item */
export type AiCatalogItemConfigurationForGroupArgs = {
  groupId: Scalars['GroupID']['input'];
};


/** An AI catalog item */
export type AiCatalogItemConfigurationForProjectArgs = {
  projectId: Scalars['ProjectID']['input'];
};


/** An AI catalog item */
export type AiCatalogItemLatestVersionArgs = {
  released?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AI catalog item */
export type AiCatalogItemVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for AiCatalogItem. */
export type AiCatalogItemConnection = {
  __typename?: 'AiCatalogItemConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCatalogItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCatalogItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for AiCatalogItem. */
export type AiCatalogItemConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An AI catalog item configuration */
export type AiCatalogItemConsumer = {
  __typename?: 'AiCatalogItemConsumer';
  /** Indicates if the configuration item is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Trigger associated with the configured catalog item. */
  flowTrigger?: Maybe<AiFlowTriggerType>;
  /** Group in which the catalog item is configured. */
  group?: Maybe<Group>;
  /** ID of the configuration item. */
  id: Scalars['ID']['output'];
  /** Configuration catalog item. */
  item?: Maybe<AiCatalogItem>;
  /** Organization in which the catalog item is configured. */
  organization?: Maybe<Organization>;
  /** Parent item consumer associated with the configured catalog item. */
  parentItemConsumer?: Maybe<AiCatalogItemConsumer>;
  /** Resolved item version according to the `pinnedVersionPrefix`.This field can only be resolved for 20 AiCatalogItemConsumers in any single request. */
  pinnedItemVersion?: Maybe<AiCatalogItemVersion>;
  /** Major version, minor version, or patch item is pinned to. */
  pinnedVersionPrefix?: Maybe<Scalars['String']['output']>;
  /** Project in which the catalog item is configured. */
  project?: Maybe<Project>;
  /** Service account associated with the item consumer. */
  serviceAccount?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: AiCatalogItemConsumerPermissions;
};

/** The connection type for AiCatalogItemConsumer. */
export type AiCatalogItemConsumerConnection = {
  __typename?: 'AiCatalogItemConsumerConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCatalogItemConsumerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCatalogItemConsumer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for AiCatalogItemConsumer. */
export type AiCatalogItemConsumerConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of AiCatalogItemConsumerCreate */
export type AiCatalogItemConsumerCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Item to configure. */
  itemId: Scalars['AiCatalogItemID']['input'];
  /** Parent item consumer belonging to the top-level group. */
  parentItemConsumerId?: InputMaybe<Scalars['AiCatalogItemConsumerID']['input']>;
  /** Target project or top-level group in which the catalog item is configured. */
  target: ItemConsumerTargetInput;
  /** List of event types to create flow triggers for (values can be mention, assign or assign_reviewer). */
  triggerTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of AiCatalogItemConsumerCreate. */
export type AiCatalogItemConsumerCreatePayload = {
  __typename?: 'AiCatalogItemConsumerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Item configuration created. */
  itemConsumer?: Maybe<AiCatalogItemConsumer>;
};

/** Autogenerated input type of AiCatalogItemConsumerDelete */
export type AiCatalogItemConsumerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog item consumer to delete. */
  id: Scalars['AiCatalogItemConsumerID']['input'];
};

/** Autogenerated return type of AiCatalogItemConsumerDelete. */
export type AiCatalogItemConsumerDeletePayload = {
  __typename?: 'AiCatalogItemConsumerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if catalog item consumer was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

/** An edge in a connection. */
export type AiCatalogItemConsumerEdge = {
  __typename?: 'AiCatalogItemConsumerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCatalogItemConsumer>;
};

/** Check permissions for the current user on an AI catalog item consumer. */
export type AiCatalogItemConsumerPermissions = {
  __typename?: 'AiCatalogItemConsumerPermissions';
  /** If `true`, the user can perform `admin_ai_catalog_item_consumer` on this resource */
  adminAiCatalogItemConsumer: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_ai_catalog_item_consumer` on this resource */
  readAiCatalogItemConsumer: Scalars['Boolean']['output'];
};

/** Autogenerated input type of AiCatalogItemConsumerUpdate */
export type AiCatalogItemConsumerUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog item consumer to update. */
  id: Scalars['AiCatalogItemConsumerID']['input'];
  /** Version to pin the item to. */
  pinnedVersionPrefix: Scalars['String']['input'];
  /** Service account to associate with the item consumer. */
  serviceAccountId?: InputMaybe<Scalars['UserID']['input']>;
  /** List of event types to create flow triggers for (values can be mention, assign or assign_reviewer). */
  triggerTypes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of AiCatalogItemConsumerUpdate. */
export type AiCatalogItemConsumerUpdatePayload = {
  __typename?: 'AiCatalogItemConsumerUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Item consumer that was updated. */
  itemConsumer?: Maybe<AiCatalogItemConsumer>;
};

/** An edge in a connection. */
export type AiCatalogItemEdge = {
  __typename?: 'AiCatalogItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCatalogItem>;
};

/** Check permissions for the current user on an AI catalog item. */
export type AiCatalogItemPermissions = {
  __typename?: 'AiCatalogItemPermissions';
  /** If `true`, the user can perform `admin_ai_catalog_item` on this resource */
  adminAiCatalogItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `force_hard_delete_ai_catalog_item` on this resource */
  forceHardDeleteAiCatalogItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_ai_catalog_item` on this resource */
  readAiCatalogItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `report_ai_catalog_item` on this resource */
  reportAiCatalogItem: Scalars['Boolean']['output'];
};

/** Autogenerated input type of AiCatalogItemReport */
export type AiCatalogItemReportInput = {
  /** Additional details about the report. Limited to 1000 characters. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog item to report. */
  id: Scalars['AiCatalogItemID']['input'];
  /** Reason for reporting the catalog item. */
  reason: AiCatalogItemReportReason;
};

/** Autogenerated return type of AiCatalogItemReport. */
export type AiCatalogItemReportPayload = {
  __typename?: 'AiCatalogItemReportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Possible reasons for reporting an AI catalog item. */
export type AiCatalogItemReportReason =
  /** Wasting compute or causing performance issues. */
  | 'EXCESSIVE_RESOURCE_USAGE'
  /** Contains dangerous code, exploits, or harmful actions. */
  | 'IMMEDIATE_SECURITY_THREAT'
  /** Please describe below. */
  | 'OTHER'
  /** Hypothetical or low risk security flaws that could be exploited. */
  | 'POTENTIAL_SECURITY_THREAT'
  /** Frequently failing or nuisance activity. */
  | 'SPAM_OR_LOW_QUALITY';

/** Possible item types for AI items. */
export type AiCatalogItemType =
  /** Agent. */
  | 'AGENT'
  /** Flow. */
  | 'FLOW'
  /** Third party flow. */
  | 'THIRD_PARTY_FLOW';

/** An AI catalog item version */
export type AiCatalogItemVersion = {
  /** Timestamp of when the item version was created. */
  createdAt: Scalars['Time']['output'];
  /** Human-friendly name of the item version. In the form v1.0.0-draft. */
  humanVersionName?: Maybe<Scalars['String']['output']>;
  /** ID of the item version. */
  id: Scalars['ID']['output'];
  /** Indicates the item version is released. */
  released: Scalars['Boolean']['output'];
  /** Timestamp of when the item version was released. */
  releasedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item version was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Version name of the item version. */
  versionName?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AiCatalogItemVersion. */
export type AiCatalogItemVersionConnection = {
  __typename?: 'AiCatalogItemVersionConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCatalogItemVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCatalogItemVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for AiCatalogItemVersion. */
export type AiCatalogItemVersionConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type AiCatalogItemVersionEdge = {
  __typename?: 'AiCatalogItemVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCatalogItemVersion>;
};

/** An AI catalog third party flow */
export type AiCatalogThirdPartyFlow = AiCatalogItem & {
  __typename?: 'AiCatalogThirdPartyFlow';
  /**
   * Item configuration for the given group. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  configurationForGroup?: Maybe<AiCatalogItemConsumer>;
  /**
   * Item configuration for the given project. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  configurationForProject?: Maybe<AiCatalogItemConsumer>;
  /** Timestamp of when the item was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the item. */
  description: Scalars['String']['output'];
  /** Foundational flow reference. */
  foundationalFlowReference?: Maybe<Scalars['String']['output']>;
  /** ID of the item. */
  id: Scalars['ID']['output'];
  /** Type of the item. */
  itemType: AiCatalogItemType;
  /** Latest version of the item. */
  latestVersion?: Maybe<AiCatalogItemVersion>;
  /** Name of the item. */
  name: Scalars['String']['output'];
  /** Project for the item. */
  project?: Maybe<Project>;
  /** Whether the item is publicly visible in the catalog. */
  public: Scalars['Boolean']['output'];
  /** Indicates if the item has been soft deleted. */
  softDeleted?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the item was soft deleted. */
  softDeletedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: AiCatalogItemPermissions;
  /** Versions of the item. */
  versions?: Maybe<AiCatalogItemVersionConnection>;
};


/** An AI catalog third party flow */
export type AiCatalogThirdPartyFlowConfigurationForGroupArgs = {
  groupId: Scalars['GroupID']['input'];
};


/** An AI catalog third party flow */
export type AiCatalogThirdPartyFlowConfigurationForProjectArgs = {
  projectId: Scalars['ProjectID']['input'];
};


/** An AI catalog third party flow */
export type AiCatalogThirdPartyFlowLatestVersionArgs = {
  released?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An AI catalog third party flow */
export type AiCatalogThirdPartyFlowVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of AiCatalogThirdPartyFlowCreate */
export type AiCatalogThirdPartyFlowCreateInput = {
  /** Whether to add to the project upon creation. */
  addToProjectWhenCreated?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** YAML definition for the Flow. */
  definition: Scalars['String']['input'];
  /** Description for the Flow. */
  description: Scalars['String']['input'];
  /** Name for the Flow. */
  name: Scalars['String']['input'];
  /** Project for the Flow. */
  projectId: Scalars['ProjectID']['input'];
  /** Whether the Flow is publicly visible in the catalog. */
  public: Scalars['Boolean']['input'];
  /** Whether to release the latest version of the Flow. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of AiCatalogThirdPartyFlowCreate. */
export type AiCatalogThirdPartyFlowCreatePayload = {
  __typename?: 'AiCatalogThirdPartyFlowCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Item created. */
  item?: Maybe<AiCatalogThirdPartyFlow>;
};

/** Autogenerated input type of AiCatalogThirdPartyFlowDelete */
export type AiCatalogThirdPartyFlowDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When true, the Third Party Flow will always be hard deleted and never soft deleted. Can only be used by instance admins */
  forceHardDelete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the catalog Third Party Flow to delete. */
  id: Scalars['AiCatalogItemID']['input'];
};

/** Autogenerated return type of AiCatalogThirdPartyFlowDelete. */
export type AiCatalogThirdPartyFlowDeletePayload = {
  __typename?: 'AiCatalogThirdPartyFlowDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if catalog Third Party Flow was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of AiCatalogThirdPartyFlowUpdate */
export type AiCatalogThirdPartyFlowUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** YAML definition for the Flow. */
  definition?: InputMaybe<Scalars['String']['input']>;
  /** Description for the Flow. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the catalog Flow to update. */
  id: Scalars['AiCatalogItemID']['input'];
  /** Name for the Flow. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Whether the Flow is publicly visible in the catalog. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to release the latest version of the Flow. */
  release?: InputMaybe<Scalars['Boolean']['input']>;
  /** Bump version, calculated from the last released version name. */
  versionBump?: InputMaybe<AiCatalogVersionBump>;
};

/** Autogenerated return type of AiCatalogThirdPartyFlowUpdate. */
export type AiCatalogThirdPartyFlowUpdatePayload = {
  __typename?: 'AiCatalogThirdPartyFlowUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Flow that was updated. */
  item?: Maybe<AiCatalogThirdPartyFlow>;
};

/** An AI catalog third party flow version */
export type AiCatalogThirdPartyFlowVersion = AiCatalogItemVersion & {
  __typename?: 'AiCatalogThirdPartyFlowVersion';
  /** Timestamp of when the item version was created. */
  createdAt: Scalars['Time']['output'];
  /** YAML definition of the third party flow. */
  definition: Scalars['String']['output'];
  /** Human-friendly name of the item version. In the form v1.0.0-draft. */
  humanVersionName?: Maybe<Scalars['String']['output']>;
  /** ID of the item version. */
  id: Scalars['ID']['output'];
  /** Indicates the item version is released. */
  released: Scalars['Boolean']['output'];
  /** Timestamp of when the item version was released. */
  releasedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the item version was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Version name of the item version. */
  versionName?: Maybe<Scalars['String']['output']>;
};

/** Possible version bumps for AI catalog items. */
export type AiCatalogVersionBump =
  /** Major version bump. */
  | 'MAJOR'
  /** Minor version bump. */
  | 'MINOR'
  /** Patch version bump. */
  | 'PATCH';

export type AiChatInput = {
  /** Additional context to be passed for the chat. */
  additionalContext?: InputMaybe<Array<AiAdditionalContextInput>>;
  /** Global ID of the agent version to answer the chat. */
  agentVersionId?: InputMaybe<Scalars['AiAgentVersionID']['input']>;
  /** Content of the message. */
  content: Scalars['String']['input'];
  /** Information about currently selected text which can be passed for additional context. */
  currentFile?: InputMaybe<AiCurrentFileInput>;
  /** Global ID of the namespace the user is acting on. */
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Global ID of the resource to mutate. */
  resourceId?: InputMaybe<Scalars['AiModelID']['input']>;
};

/** Conversation thread of the AI feature */
export type AiConversationsThread = {
  __typename?: 'AiConversationsThread';
  /** Conversation type of the thread. */
  conversationType: AiConversationsThreadsConversationType;
  /** Created date of the thread. */
  createdAt: Scalars['Time']['output'];
  /** ID of the thread. */
  id: Scalars['ID']['output'];
  /** Last updated date of the thread. */
  lastUpdatedAt: Scalars['Time']['output'];
  /** Title of the thread. */
  title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AiConversationsThread. */
export type AiConversationsThreadConnection = {
  __typename?: 'AiConversationsThreadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiConversationsThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiConversationsThread>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiConversationsThreadEdge = {
  __typename?: 'AiConversationsThreadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiConversationsThread>;
};

/** Conversation type of the thread. */
export type AiConversationsThreadsConversationType =
  /** duo_chat thread. */
  | 'DUO_CHAT'
  /** duo_chat_legacy thread. */
  | 'DUO_CHAT_LEGACY'
  /** duo_code_review thread. */
  | 'DUO_CODE_REVIEW'
  /** duo_quick_chat thread. */
  | 'DUO_QUICK_CHAT';

export type AiCurrentFileInput = {
  /** Content above cursor. */
  contentAboveCursor?: InputMaybe<Scalars['String']['input']>;
  /** Content below cursor. */
  contentBelowCursor?: InputMaybe<Scalars['String']['input']>;
  /** File name. */
  fileName: Scalars['String']['input'];
  /** Selected text. */
  selectedText: Scalars['String']['input'];
};

export type AiDescriptionComposerInput = {
  /** Current description. */
  description: Scalars['String']['input'];
  /**
   * Previously AI-generated description content used for context in iterative refinements or follow-up prompts.
   *
   */
  previousResponse?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
  /** Source branch of the changes. */
  sourceBranch?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project where the changes are from. */
  sourceProjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Target branch of where the changes will be merged into. */
  targetBranch?: InputMaybe<Scalars['String']['input']>;
  /** Current merge request title. */
  title: Scalars['String']['input'];
  /** Prompt from user. */
  userPrompt: Scalars['String']['input'];
};

/** Autogenerated input type of AiDuoWorkflowCreate */
export type AiDuoWorkflowCreateInput = {
  /** Actions the agent is allowed to perform. */
  agentPrivileges?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID of the catalog item the workflow is triggered from. */
  aiCatalogItemVersionId?: InputMaybe<Scalars['AiCatalogItemVersionID']['input']>;
  /** When enabled, Duo Agent Platform may stop to ask the user questions before proceeding. */
  allowAgentToRequestUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Environment for the workflow. */
  environment?: InputMaybe<WorkflowEnvironment>;
  /** Goal of the workflow. */
  goal?: InputMaybe<Scalars['String']['input']>;
  /** IID of the noteable (Issue) that the workflow is associated with. */
  issueId?: InputMaybe<Scalars['BigInt']['input']>;
  /** IID of the noteable (MergeRequest) that the workflow is associated with. */
  mergeRequestId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Global ID of the namespace the user is acting on. */
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Actions the agent can perform without asking for approval. */
  preApprovedAgentPrivileges?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Global ID of the project the user is acting on. */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  /** Workflow type based on its capability. */
  workflowDefinition?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AiDuoWorkflowCreate. */
export type AiDuoWorkflowCreatePayload = {
  __typename?: 'AiDuoWorkflowCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the creation process. */
  errors: Array<Scalars['String']['output']>;
  /** Created workflow. */
  workflow?: Maybe<DuoWorkflow>;
};

export type AiExplainVulnerabilityInput = {
  /** Include vulnerablility source code in the AI prompt. */
  includeSourceCode?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

/** Providers for AI features that can be configured. */
export type AiFeatureProviders =
  /** Disabled option */
  | 'DISABLED'
  /** Self hosted option */
  | 'SELF_HOSTED'
  /** Unassigned option */
  | 'UNASSIGNED'
  /** Vendored option */
  | 'VENDORED';

/** Duo Chat feature setting */
export type AiFeatureSetting = {
  __typename?: 'AiFeatureSetting';
  /** LLMs Compatible with the feature. */
  compatibleLlms?: Maybe<Array<Scalars['String']['output']>>;
  /** GitLab model selected for use with the AI feature. */
  defaultGitlabModel?: Maybe<AiModelSelectionOfferedModel>;
  /** Identifier for the AI feature. */
  feature: Scalars['String']['output'];
  /** GitLab model selected for use with the AI feature. */
  gitlabModel?: Maybe<AiModelSelectionOfferedModel>;
  /** Displayed name of the main feature. */
  mainFeature?: Maybe<Scalars['String']['output']>;
  /** Humanized name for the AI feature, e.g "Code Completion". */
  provider: Scalars['String']['output'];
  /** Current release state of the feature. */
  releaseState?: Maybe<Scalars['String']['output']>;
  /** Self-hosted model selected for use with the AI feature. */
  selfHostedModel?: Maybe<AiSelfHostedModel>;
  /** Displayed AI feature name. */
  title?: Maybe<Scalars['String']['output']>;
  /** Valid GitLab managed models for the feature. */
  validGitlabModels: AiModelSelectionOfferedModelConnection;
  /** Compatible self-hosted models for the feature. */
  validModels: AiSelfHostedModelConnection;
};


/** Duo Chat feature setting */
export type AiFeatureSettingValidGitlabModelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Duo Chat feature setting */
export type AiFeatureSettingValidModelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for AiFeatureSetting. */
export type AiFeatureSettingConnection = {
  __typename?: 'AiFeatureSettingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiFeatureSettingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiFeatureSetting>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiFeatureSettingEdge = {
  __typename?: 'AiFeatureSettingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiFeatureSetting>;
};

/** Autogenerated input type of AiFeatureSettingUpdate */
export type AiFeatureSettingUpdateInput = {
  /** Global ID of the self-hosted model providing the AI setting. */
  aiSelfHostedModelId?: InputMaybe<Scalars['AiSelfHostedModelID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Array of AI features being configured (for single or batch update). */
  features: Array<AiFeatures>;
  /** Identifier of the selected model for the feature. */
  offeredModelRef?: InputMaybe<Scalars['String']['input']>;
  /** Provider for AI setting. */
  provider: AiFeatureProviders;
};

/** Autogenerated return type of AiFeatureSettingUpdate. */
export type AiFeatureSettingUpdatePayload = {
  __typename?: 'AiFeatureSettingUpdatePayload';
  /** List of AI feature settings after mutation. */
  aiFeatureSettings: Array<AiFeatureSetting>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** AI features that can be configured through the Duo self-hosted feature settings. */
export type AiFeatures =
  /** Code completion feature setting */
  | 'CODE_COMPLETIONS'
  /** Code generation feature setting */
  | 'CODE_GENERATIONS'
  /** Duo agent platform feature setting */
  | 'DUO_AGENT_PLATFORM'
  /** Duo agent platform agentic chat feature setting */
  | 'DUO_AGENT_PLATFORM_AGENTIC_CHAT'
  /** Duo Chat feature setting */
  | 'DUO_CHAT'
  /** Duo chat explain code feature setting */
  | 'DUO_CHAT_EXPLAIN_CODE'
  /** Duo chat explain vulnerability feature setting */
  | 'DUO_CHAT_EXPLAIN_VULNERABILITY'
  /** Duo chat fix code feature setting */
  | 'DUO_CHAT_FIX_CODE'
  /** Duo chat refactor code feature setting */
  | 'DUO_CHAT_REFACTOR_CODE'
  /** Duo chat summarize comment feature setting */
  | 'DUO_CHAT_SUMMARIZE_COMMENTS'
  /** Duo chat troubleshoot job feature setting */
  | 'DUO_CHAT_TROUBLESHOOT_JOB'
  /** Duo chat write test feature setting */
  | 'DUO_CHAT_WRITE_TESTS'
  /** Generate commit message feature setting */
  | 'GENERATE_COMMIT_MESSAGE'
  /** Glab ask git command feature setting */
  | 'GLAB_ASK_GIT_COMMAND'
  /** Resolve vulnerability feature setting */
  | 'RESOLVE_VULNERABILITY'
  /** Review merge request feature setting */
  | 'REVIEW_MERGE_REQUEST'
  /** Summarize new merge request feature setting */
  | 'SUMMARIZE_NEW_MERGE_REQUEST'
  /** Summarize review feature setting */
  | 'SUMMARIZE_REVIEW';

/** Autogenerated input type of AiFlowTriggerCreate */
export type AiFlowTriggerCreateInput = {
  /** AI catalog item consumer to use instead of config_path. */
  aiCatalogItemConsumerId?: InputMaybe<Scalars['AiCatalogItemConsumerID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Path to the configuration file for the AI flow trigger. */
  configPath?: InputMaybe<Scalars['String']['input']>;
  /** Description of the AI flow trigger. */
  description: Scalars['String']['input'];
  /** Event types that triggers the AI flow. */
  eventTypes?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Full path of the project the AI flow trigger is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Owner of the AI flow trigger. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of AiFlowTriggerCreate. */
export type AiFlowTriggerCreatePayload = {
  __typename?: 'AiFlowTriggerCreatePayload';
  /** Created AI flow trigger. */
  aiFlowTrigger?: Maybe<AiFlowTriggerType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AiFlowTriggerDelete */
export type AiFlowTriggerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the flow trigger to delete. */
  id: Scalars['AiFlowTriggerID']['input'];
};

/** Autogenerated return type of AiFlowTriggerDelete. */
export type AiFlowTriggerDeletePayload = {
  __typename?: 'AiFlowTriggerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents an AI flow trigger */
export type AiFlowTriggerType = {
  __typename?: 'AiFlowTriggerType';
  /** AI catalog item consumer associated with the trigger. */
  aiCatalogItemConsumer?: Maybe<AiCatalogItemConsumer>;
  /** Path to the configuration file for the trigger. */
  configPath?: Maybe<Scalars['String']['output']>;
  /** Web URL to the configuration file for the trigger. */
  configUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the flow trigger was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the flow trigger. */
  description: Scalars['String']['output'];
  /** List of events that triggers the flow. */
  eventTypes: Array<Scalars['Int']['output']>;
  /** ID of the flow trigger. */
  id: Scalars['ID']['output'];
  /** Project of the flow trigger. */
  project: Project;
  /** Timestamp of when the flow trigger was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** User who created the flow trigger. */
  user?: Maybe<UserCore>;
};

/** The connection type for AiFlowTriggerType. */
export type AiFlowTriggerTypeConnection = {
  __typename?: 'AiFlowTriggerTypeConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiFlowTriggerTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiFlowTriggerType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for AiFlowTriggerType. */
export type AiFlowTriggerTypeConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type AiFlowTriggerTypeEdge = {
  __typename?: 'AiFlowTriggerTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiFlowTriggerType>;
};

/** Autogenerated input type of AiFlowTriggerUpdate */
export type AiFlowTriggerUpdateInput = {
  /** AI catalog item consumer to use instead of config_path. */
  aiCatalogItemConsumerId?: InputMaybe<Scalars['AiCatalogItemConsumerID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Path to the configuration file for the AI flow trigger. */
  configPath?: InputMaybe<Scalars['String']['input']>;
  /** Description of the AI flow trigger. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Event types that triggers the AI flow. */
  eventTypes?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID of the flow trigger to update. */
  id: Scalars['AiFlowTriggerID']['input'];
  /** Owner of the AI flow trigger. */
  userId?: InputMaybe<Scalars['UserID']['input']>;
};

/** Autogenerated return type of AiFlowTriggerUpdate. */
export type AiFlowTriggerUpdatePayload = {
  __typename?: 'AiFlowTriggerUpdatePayload';
  /** Updated AI flow trigger. */
  aiFlowTrigger?: Maybe<AiFlowTriggerType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Core Agent available for GitLab features. */
export type AiFoundationalChatAgent = {
  __typename?: 'AiFoundationalChatAgent';
  /** Description of the agent. */
  description: Scalars['String']['output'];
  /** Global ID of the foundational chat agent. */
  id: Scalars['AiFoundationalChatAgentID']['output'];
  /** Name of the agent. */
  name: Scalars['String']['output'];
  /** Reference ID of the agent. */
  reference: Scalars['String']['output'];
  /** Versioned reference of the agent. */
  referenceWithVersion?: Maybe<Scalars['String']['output']>;
  /** Version of the agent. */
  version?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AiFoundationalChatAgent. */
export type AiFoundationalChatAgentConnection = {
  __typename?: 'AiFoundationalChatAgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiFoundationalChatAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiFoundationalChatAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiFoundationalChatAgentEdge = {
  __typename?: 'AiFoundationalChatAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiFoundationalChatAgent>;
};

export type AiGenerateCommitMessageInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

export type AiGenerateDescriptionInput = {
  /** Content of the message. */
  content: Scalars['String']['input'];
  /** Name of the description template to use to generate message off of. */
  descriptionTemplateName?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

/** Instance wide usage data for events stored in either PostgreSQL (default) or ClickHouse (when configured). Data retention: three months in PostgreSQL, indefinite in ClickHouse. Premium and Ultimate only. */
export type AiInstanceUsageData = {
  __typename?: 'AiInstanceUsageData';
  /** All Duo usage events. */
  all?: Maybe<AiInstanceUsageEventConnection>;
};


/** Instance wide usage data for events stored in either PostgreSQL (default) or ClickHouse (when configured). Data retention: three months in PostgreSQL, indefinite in ClickHouse. Premium and Ultimate only. */
export type AiInstanceUsageDataAllArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  events?: InputMaybe<Array<AiUsageEventType>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  userIds?: InputMaybe<Array<Scalars['UserID']['input']>>;
};

export type AiInstanceUsageEvent = {
  __typename?: 'AiInstanceUsageEvent';
  /** Type of the event. */
  event: AiUsageEventType;
  /** Associated event context data. */
  extras?: Maybe<Scalars['JSON']['output']>;
  /** Namespace hierarchy for Namespace or ProjectNamespace associated with the event. */
  namespacePath?: Maybe<Scalars['String']['output']>;
  /** When the event happened. */
  timestamp: Scalars['Time']['output'];
  /** User associated with the event. */
  user: UserCore;
};

/** The connection type for AiInstanceUsageEvent. */
export type AiInstanceUsageEventConnection = {
  __typename?: 'AiInstanceUsageEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiInstanceUsageEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiInstanceUsageEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiInstanceUsageEventEdge = {
  __typename?: 'AiInstanceUsageEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiInstanceUsageEvent>;
};

export type AiMeasureCommentTemperatureInput = {
  /** Content of the message. */
  content: Scalars['String']['input'];
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

/** AI features communication message */
export type AiMessage = {
  __typename?: 'AiMessage';
  /** Global ID of the agent version to answer the message. */
  agentVersionId?: Maybe<Scalars['AiAgentVersionID']['output']>;
  /** Incremental ID for a chunk from a streamed message. Null when it is not a streamed message. */
  chunkId?: Maybe<Scalars['Int']['output']>;
  /** Raw response content. */
  content?: Maybe<Scalars['String']['output']>;
  /** Response content as HTML. */
  contentHtml?: Maybe<Scalars['String']['output']>;
  /** Message errors. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Extra message metadata. */
  extras?: Maybe<AiMessageExtras>;
  /** UUID of the message. */
  id?: Maybe<Scalars['ID']['output']>;
  /** UUID of the original request. Shared between chat prompt and response. */
  requestId?: Maybe<Scalars['String']['output']>;
  /** Message owner role. */
  role: AiMessageRole;
  /** Global ID of the existing thread for the Chat conversation. */
  threadId?: Maybe<Scalars['AiConversationThreadID']['output']>;
  /** Message creation timestamp. */
  timestamp: Scalars['Time']['output'];
  /** Message type. */
  type?: Maybe<AiMessageType>;
};

/** The connection type for AiMessage. */
export type AiMessageConnection = {
  __typename?: 'AiMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiMessageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiMessage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiMessageEdge = {
  __typename?: 'AiMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiMessage>;
};

/** Extra metadata for AI message. */
export type AiMessageExtras = {
  __typename?: 'AiMessageExtras';
  /** Additional context for the message. */
  additionalContext?: Maybe<Array<AiAdditionalContext>>;
  /** Whether the user has provided feedback for the mesage. */
  hasFeedback?: Maybe<Scalars['Boolean']['output']>;
  /** Sources used to form the message. */
  sources?: Maybe<Array<Scalars['JSON']['output']>>;
};

/** Possible message roles for AI features. */
export type AiMessageRole =
  /** assistant message. */
  | 'ASSISTANT'
  /** system message. */
  | 'SYSTEM'
  /** user message. */
  | 'USER';

/** Types of messages returned from AI features. */
export type AiMessageType =
  /** Tool selection message. */
  | 'TOOL';

/** Requires ClickHouse. Premium and Ultimate only. */
export type AiMetrics = {
  __typename?: 'AiMetrics';
  /** Duo Agent Platform metrics. */
  agentPlatform?: Maybe<AgentPlatformMetrics>;
  /** Number of code contributors. */
  codeContributorsCount?: Maybe<Scalars['Int']['output']>;
  /** Code review metrics. */
  codeReview?: Maybe<CodeReviewMetrics>;
  /** Code suggestions metrics. */
  codeSuggestions?: Maybe<CodeSuggestionMetrics>;
  /**
   * Total count of code suggestions accepted by code contributors. Deprecated in GitLab 18.0: moved to codeSuggestions field.
   * @deprecated moved to codeSuggestions field. Deprecated in GitLab 18.0.
   */
  codeSuggestionsAcceptedCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Number of code contributors who used GitLab Duo Code Suggestions features. Deprecated in GitLab 18.0: moved to codeSuggestions field.
   * @deprecated moved to codeSuggestions field. Deprecated in GitLab 18.0.
   */
  codeSuggestionsContributorsCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Total count of code suggestions shown to code contributors. Deprecated in GitLab 18.0: moved to codeSuggestions field.
   * @deprecated moved to codeSuggestions field. Deprecated in GitLab 18.0.
   */
  codeSuggestionsShownCount?: Maybe<Scalars['Int']['output']>;
  /** Total assigned Duo Pro and Enterprise seats. Ignores time period filter. Returns current data. */
  duoAssignedUsersCount?: Maybe<Scalars['Int']['output']>;
  /** Number of contributors who used GitLab Duo Chat features. */
  duoChatContributorsCount?: Maybe<Scalars['Int']['output']>;
  /** Number of contributors who used any GitLab Duo feature. */
  duoUsedCount?: Maybe<Scalars['Int']['output']>;
  /** Number of users using troubleshoot within a failed pipeline. */
  rootCauseAnalysisUsersCount?: Maybe<Scalars['Int']['output']>;
};


/** Requires ClickHouse. Premium and Ultimate only. */
export type AiMetricsAgentPlatformArgs = {
  flowTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AgentPlatformMetricsNotInput>;
};


/** Requires ClickHouse. Premium and Ultimate only. */
export type AiMetricsCodeSuggestionsArgs = {
  ideNames?: InputMaybe<Array<Scalars['String']['input']>>;
  languages?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * AI-related metrics with three months of data retention.
 * Premium and Ultimate only.
 *
 */
export type AiMetricsBasic = {
  __typename?: 'AiMetricsBasic';
  /** Code Suggestions metrics. */
  codeSuggestions?: Maybe<CodeSuggestionMetricsBasic>;
};

/** AI features that can be configured through the Model Selection feature settings. */
export type AiModelSelectionFeatures =
  /** Code completion feature setting */
  | 'CODE_COMPLETIONS'
  /** Code generation feature setting */
  | 'CODE_GENERATIONS'
  /** Duo agent platform feature setting */
  | 'DUO_AGENT_PLATFORM'
  /** Duo agent platform agentic chat feature setting */
  | 'DUO_AGENT_PLATFORM_AGENTIC_CHAT'
  /** Duo Chat feature setting */
  | 'DUO_CHAT'
  /** Duo chat explain code feature setting */
  | 'DUO_CHAT_EXPLAIN_CODE'
  /** Duo chat explain vulnerability feature setting */
  | 'DUO_CHAT_EXPLAIN_VULNERABILITY'
  /** Duo chat fix code feature setting */
  | 'DUO_CHAT_FIX_CODE'
  /** Duo chat refactor code feature setting */
  | 'DUO_CHAT_REFACTOR_CODE'
  /** Duo chat summarize comment feature setting */
  | 'DUO_CHAT_SUMMARIZE_COMMENTS'
  /** Duo chat troubleshoot job feature setting */
  | 'DUO_CHAT_TROUBLESHOOT_JOB'
  /** Duo chat write test feature setting */
  | 'DUO_CHAT_WRITE_TESTS'
  /** Generate commit message feature setting */
  | 'GENERATE_COMMIT_MESSAGE'
  /** Resolve vulnerability feature setting */
  | 'RESOLVE_VULNERABILITY'
  /** Review merge request feature setting */
  | 'REVIEW_MERGE_REQUEST'
  /** Summarize new merge request feature setting */
  | 'SUMMARIZE_NEW_MERGE_REQUEST'
  /** Summarize review feature setting */
  | 'SUMMARIZE_REVIEW';

/** Model Selection feature setting for namespaces. */
export type AiModelSelectionNamespaceFeatureSetting = {
  __typename?: 'AiModelSelectionNamespaceFeatureSetting';
  /** LLMs Compatible with the feature. */
  defaultModel?: Maybe<AiModelSelectionOfferedModel>;
  /** Identifier for the AI feature. */
  feature: Scalars['String']['output'];
  /** Displayed name of the main feature. */
  mainFeature?: Maybe<Scalars['String']['output']>;
  /** Namespace that the feature setting is set for. */
  namespace: Group;
  /** LLMs Compatible with the feature. */
  selectableModels: Array<AiModelSelectionOfferedModel>;
  /** Identifier of the current model selected. */
  selectedModel?: Maybe<AiModelSelectionOfferedModel>;
  /** Displayed AI feature name. */
  title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AiModelSelectionNamespaceFeatureSetting. */
export type AiModelSelectionNamespaceFeatureSettingConnection = {
  __typename?: 'AiModelSelectionNamespaceFeatureSettingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiModelSelectionNamespaceFeatureSettingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiModelSelectionNamespaceFeatureSetting>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiModelSelectionNamespaceFeatureSettingEdge = {
  __typename?: 'AiModelSelectionNamespaceFeatureSettingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiModelSelectionNamespaceFeatureSetting>;
};

/** Autogenerated input type of AiModelSelectionNamespaceUpdate */
export type AiModelSelectionNamespaceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Array of AI features being configured (for single or batch update). */
  features: Array<AiModelSelectionFeatures>;
  /** Group for the model selection. */
  groupId: Scalars['GroupID']['input'];
  /** Identifier of the selected model for the feature. */
  offeredModelRef: Scalars['String']['input'];
};

/** Autogenerated return type of AiModelSelectionNamespaceUpdate. */
export type AiModelSelectionNamespaceUpdatePayload = {
  __typename?: 'AiModelSelectionNamespaceUpdatePayload';
  /**
   * List of AI feature settings after mutation. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  aiFeatureSettings: Array<AiModelSelectionNamespaceFeatureSetting>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Model offered for Model Selection */
export type AiModelSelectionOfferedModel = {
  __typename?: 'AiModelSelectionOfferedModel';
  /**
   * Presentational cost indicator for model usage, e.g "$", "$$", "$$$". Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  costIndicator?: Maybe<Scalars['String']['output']>;
  /**
   * Brief description of the model, e.g "Fast, cost-effective responses". Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  modelDescription?: Maybe<Scalars['String']['output']>;
  /**
   * Provider for the model, e.g "OpenAI". Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  modelProvider?: Maybe<Scalars['String']['output']>;
  /** Humanized name for the offered model, e.g "Chat GPT 4o". */
  name: Scalars['String']['output'];
  /** Identifier for the offered model. */
  ref: Scalars['String']['output'];
};

/** The connection type for AiModelSelectionOfferedModel. */
export type AiModelSelectionOfferedModelConnection = {
  __typename?: 'AiModelSelectionOfferedModelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiModelSelectionOfferedModelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiModelSelectionOfferedModel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiModelSelectionOfferedModelEdge = {
  __typename?: 'AiModelSelectionOfferedModelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiModelSelectionOfferedModel>;
};

export type AiNamespaceSettings = {
  __typename?: 'AiNamespaceSettings';
  /** Indicates whether the namespace has MCP enabled. */
  duoWorkflowMcpEnabled: Scalars['Boolean']['output'];
  /** Level of prompt injection protection for the namespace. */
  promptInjectionProtectionLevel: PromptInjectionProtectionLevel;
};

export type AiResolveVulnerabilityInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
  /** Global ID of the merge request which the merge request containing the vulnerability resolution will target. */
  vulnerableMergeRequestId?: InputMaybe<Scalars['MergeRequestID']['input']>;
};

/** Self-hosted LLM servers */
export type AiSelfHostedModel = {
  __typename?: 'AiSelfHostedModel';
  /** Optional API key for the self-hosted model server. */
  apiToken?: Maybe<Scalars['String']['output']>;
  /** Timestamp of creation. */
  createdAt: Scalars['Time']['output'];
  /** Endpoint of the self-hosted model server. */
  endpoint: Scalars['String']['output'];
  /** AI feature settings using the self-hosted model. */
  featureSettings?: Maybe<AiFeatureSettingConnection>;
  /** Indicates if an API key is set for the self-hosted model server. */
  hasApiToken: Scalars['Boolean']['output'];
  /** ID of the self-hosted model server. */
  id: Scalars['AiSelfHostedModelID']['output'];
  /** Identifier for 3rd party model provider. */
  identifier?: Maybe<Scalars['String']['output']>;
  /** AI model deployed. */
  model: Scalars['String']['output'];
  /** Display name of the AI model deployed. */
  modelDisplayName: Scalars['String']['output'];
  /** Deployment name of the self-hosted model. */
  name: Scalars['String']['output'];
  /** GitLab release status of the model. */
  releaseState: AiSelfHostedModelReleaseState;
  /** Timestamp of last update. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};


/** Self-hosted LLM servers */
export type AiSelfHostedModelFeatureSettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for AiSelfHostedModel. */
export type AiSelfHostedModelConnection = {
  __typename?: 'AiSelfHostedModelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiSelfHostedModelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiSelfHostedModel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of AiSelfHostedModelConnectionCheck */
export type AiSelfHostedModelConnectionCheckInput = {
  /** API token to access the self-hosted model, if any. */
  apiToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Endpoint of the self-hosted model. */
  endpoint: Scalars['String']['input'];
  /** Identifier for 3rd party model provider. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** AI model deployed. */
  model: AiAcceptedSelfHostedModels;
  /** Deployment name of the self-hosted model. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AiSelfHostedModelConnectionCheck. */
export type AiSelfHostedModelConnectionCheckPayload = {
  __typename?: 'AiSelfHostedModelConnectionCheckPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Self-hosted hosted connection check result. */
  result?: Maybe<CloudConnectorProbeResult>;
};

/** Autogenerated input type of AiSelfHostedModelCreate */
export type AiSelfHostedModelCreateInput = {
  /** API token to access the self-hosted model, if any. */
  apiToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Endpoint of the self-hosted model. */
  endpoint: Scalars['String']['input'];
  /** Identifier for 3rd party model provider. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** AI model deployed. */
  model: AiAcceptedSelfHostedModels;
  /** Deployment name of the self-hosted model. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AiSelfHostedModelCreate. */
export type AiSelfHostedModelCreatePayload = {
  __typename?: 'AiSelfHostedModelCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Self-hosted model after mutation. */
  selfHostedModel?: Maybe<AiSelfHostedModel>;
};

/** Autogenerated input type of AiSelfHostedModelDelete */
export type AiSelfHostedModelDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the self-hosted model to delete. */
  id: Scalars['AiSelfHostedModelID']['input'];
};

/** Autogenerated return type of AiSelfHostedModelDelete. */
export type AiSelfHostedModelDeletePayload = {
  __typename?: 'AiSelfHostedModelDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type AiSelfHostedModelEdge = {
  __typename?: 'AiSelfHostedModelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiSelfHostedModel>;
};

/** GitLab release state of the model */
export type AiSelfHostedModelReleaseState =
  /** Beta status. */
  | 'BETA'
  /** Experimental status. */
  | 'EXPERIMENTAL'
  /** GA status. */
  | 'GA';

/** Autogenerated input type of AiSelfHostedModelUpdate */
export type AiSelfHostedModelUpdateInput = {
  /** API token to access the self-hosted model, if any. */
  apiToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Endpoint of the self-hosted model. */
  endpoint: Scalars['String']['input'];
  /** Global ID of the self-hosted model to update. */
  id: Scalars['AiSelfHostedModelID']['input'];
  /** Identifier for 3rd party model provider. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** AI model deployed. */
  model: AiAcceptedSelfHostedModels;
  /** Deployment name of the self-hosted model. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AiSelfHostedModelUpdate. */
export type AiSelfHostedModelUpdatePayload = {
  __typename?: 'AiSelfHostedModelUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Self-hosted model after mutation. */
  selfHostedModel?: Maybe<AiSelfHostedModel>;
};

/** Summarize a new merge request based on two branches. Returns `null` if the `add_ai_summary_for_new_mr` feature flag is disabled. */
export type AiSummarizeNewMergeRequestInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
  /** Source branch of the changes. */
  sourceBranch: Scalars['String']['input'];
  /** ID of the project where the changes are from. */
  sourceProjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Target branch of where the changes will be merged into. */
  targetBranch: Scalars['String']['input'];
};

export type AiSummarizeReviewInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID']['input'];
};

/** Usage data for events stored in either PostgreSQL (default) or ClickHouse (when configured). Data retention: three months in PostgreSQL, indefinite in ClickHouse. Requires a personal access token. Works only on top-level groups. Premium and Ultimate only. */
export type AiUsageData = {
  __typename?: 'AiUsageData';
  /** All Duo usage events. */
  all?: Maybe<AiUsageEventConnection>;
  /** Events related to code suggestions. */
  codeSuggestionEvents?: Maybe<CodeSuggestionEventConnection>;
};


/** Usage data for events stored in either PostgreSQL (default) or ClickHouse (when configured). Data retention: three months in PostgreSQL, indefinite in ClickHouse. Requires a personal access token. Works only on top-level groups. Premium and Ultimate only. */
export type AiUsageDataAllArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  events?: InputMaybe<Array<AiUsageEventType>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  userIds?: InputMaybe<Array<Scalars['UserID']['input']>>;
};


/** Usage data for events stored in either PostgreSQL (default) or ClickHouse (when configured). Data retention: three months in PostgreSQL, indefinite in ClickHouse. Requires a personal access token. Works only on top-level groups. Premium and Ultimate only. */
export type AiUsageDataCodeSuggestionEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  events?: InputMaybe<Array<AiUsageEventType>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  userIds?: InputMaybe<Array<Scalars['UserID']['input']>>;
};

export type AiUsageEvent = {
  __typename?: 'AiUsageEvent';
  /** Type of the event. */
  event: AiUsageEventType;
  /** When the event happened. */
  timestamp: Scalars['Time']['output'];
  /** User associated with the event. */
  user: UserCore;
};

/** The connection type for AiUsageEvent. */
export type AiUsageEventConnection = {
  __typename?: 'AiUsageEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiUsageEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiUsageEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiUsageEventEdge = {
  __typename?: 'AiUsageEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiUsageEvent>;
};

/** Type of AI usage event */
export type AiUsageEventType =
  /** Agent platform session was created. */
  | 'AGENT_PLATFORM_SESSION_CREATED'
  /** Agent platform session was dropped. */
  | 'AGENT_PLATFORM_SESSION_DROPPED'
  /** Agent platform session was finished. */
  | 'AGENT_PLATFORM_SESSION_FINISHED'
  /** Agent platform session was resumed. */
  | 'AGENT_PLATFORM_SESSION_RESUMED'
  /** Agent platform session was started. */
  | 'AGENT_PLATFORM_SESSION_STARTED'
  /** Agent platform session was stopped. */
  | 'AGENT_PLATFORM_SESSION_STOPPED'
  /** Code Suggestion was requested. Old data only. */
  | 'CODE_SUGGESTIONS_REQUESTED'
  /** Code Suggestion was accepted in IDE. */
  | 'CODE_SUGGESTION_ACCEPTED_IN_IDE'
  /** Code Suggestion token was refreshed. Old data only. */
  | 'CODE_SUGGESTION_DIRECT_ACCESS_TOKEN_REFRESH'
  /** Code Suggestion was rejected in IDE. */
  | 'CODE_SUGGESTION_REJECTED_IN_IDE'
  /** Code Suggestion was shown in IDE. */
  | 'CODE_SUGGESTION_SHOWN_IN_IDE'
  /** Duo Code Review encountered an error. */
  | 'ENCOUNTER_DUO_CODE_REVIEW_ERROR_DURING_REVIEW'
  /** Files were excluded from Duo Code Review. */
  | 'EXCLUDED_FILES_FROM_DUO_CODE_REVIEW'
  /** Duo Code Review found nothing to review on MR. */
  | 'FIND_NOTHING_TO_REVIEW_DUO_CODE_REVIEW_ON_MR'
  /** Duo Code Review found no issues after review. */
  | 'FIND_NO_ISSUES_DUO_CODE_REVIEW_AFTER_REVIEW'
  /** MCP tool call was finished. */
  | 'FINISH_MCP_TOOL_CALL'
  /** Duo Code Review posted a diff comment. */
  | 'POST_COMMENT_DUO_CODE_REVIEW_ON_DIFF'
  /** User gave thumbs-down reaction to Duo Code Review comment. */
  | 'REACT_THUMBS_DOWN_ON_DUO_CODE_REVIEW_COMMENT'
  /** User gave thumbs-up reaction to Duo Code Review comment. */
  | 'REACT_THUMBS_UP_ON_DUO_CODE_REVIEW_COMMENT'
  /** Duo Chat response was requested. */
  | 'REQUEST_DUO_CHAT_RESPONSE'
  /** MR author requested Duo Code Review. */
  | 'REQUEST_REVIEW_DUO_CODE_REVIEW_ON_MR_BY_AUTHOR'
  /** Non-author requested Duo Code Review on MR. */
  | 'REQUEST_REVIEW_DUO_CODE_REVIEW_ON_MR_BY_NON_AUTHOR'
  /** MCP tool call was started. */
  | 'START_MCP_TOOL_CALL'
  /** Troubleshoot job feature was used. */
  | 'TROUBLESHOOT_JOB';

/** Pre-aggregated per-user metrics for GitLab Code Suggestions and GitLab Duo Chat. Requires ClickHouse to be enabled. Premium or Ultimate only. */
export type AiUserMetrics = {
  __typename?: 'AiUserMetrics';
  /** Agent Platform metrics for the user. */
  agentPlatform?: Maybe<AgentPlatformUserMetrics>;
  /** Chat metrics for the user. */
  chat?: Maybe<ChatUserMetrics>;
  /** Code Review metrics for the user. */
  codeReview?: Maybe<CodeReviewUserMetrics>;
  /** Code Suggestions metrics for the user. */
  codeSuggestions?: Maybe<CodeSuggestionsUserMetrics>;
  /**
   * Total count of code suggestions accepted by the user. Deprecated in GitLab 18.7: Use `codeSuggestions.codeSuggestionAcceptedInIdeEventCount` instead.
   * @deprecated Use `codeSuggestions.codeSuggestionAcceptedInIdeEventCount` instead. Deprecated in GitLab 18.7.
   */
  codeSuggestionsAcceptedCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Number of user interactions with GitLab Duo Chat. Deprecated in GitLab 18.7: Use `chat.requestDuoChatResponseEventCount` instead.
   * @deprecated Use `chat.requestDuoChatResponseEventCount` instead. Deprecated in GitLab 18.7.
   */
  duoChatInteractionsCount?: Maybe<Scalars['Int']['output']>;
  /** Mcp metrics for the user. */
  mcp?: Maybe<McpUserMetrics>;
  /** Total count of all tracked events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
  /** Troubleshoot Job metrics for the user. */
  troubleshootJob?: Maybe<TroubleshootJobUserMetrics>;
  /** User associated with metrics. */
  user: AddOnUser;
};

/** The connection type for AiUserMetrics. */
export type AiUserMetricsConnection = {
  __typename?: 'AiUserMetricsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiUserMetricsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiUserMetrics>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiUserMetricsEdge = {
  __typename?: 'AiUserMetricsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiUserMetrics>;
};

/** Values for sorting AI user metrics. */
export type AiUserMetricsSort =
  /** Agent Platform total event count in ascending order. */
  | 'AGENT_PLATFORM_TOTAL_COUNT_ASC'
  /** Agent Platform total event count in descending order. */
  | 'AGENT_PLATFORM_TOTAL_COUNT_DESC'
  /** Chat total event count in ascending order. */
  | 'CHAT_TOTAL_COUNT_ASC'
  /** Chat total event count in descending order. */
  | 'CHAT_TOTAL_COUNT_DESC'
  /** Code Review total event count in ascending order. */
  | 'CODE_REVIEW_TOTAL_COUNT_ASC'
  /** Code Review total event count in descending order. */
  | 'CODE_REVIEW_TOTAL_COUNT_DESC'
  /** Code Suggestions total event count in ascending order. */
  | 'CODE_SUGGESTIONS_TOTAL_COUNT_ASC'
  /** Code Suggestions total event count in descending order. */
  | 'CODE_SUGGESTIONS_TOTAL_COUNT_DESC'
  /** Mcp total event count in ascending order. */
  | 'MCP_TOTAL_COUNT_ASC'
  /** Mcp total event count in descending order. */
  | 'MCP_TOTAL_COUNT_DESC'
  /** Troubleshoot Job total event count in ascending order. */
  | 'TROUBLESHOOT_JOB_TOTAL_COUNT_ASC'
  /** Troubleshoot Job total event count in descending order. */
  | 'TROUBLESHOOT_JOB_TOTAL_COUNT_DESC';

export type AiXrayReport = {
  __typename?: 'AiXrayReport';
  /** Language of the x-ray report. */
  language: Scalars['String']['output'];
};

/** The connection type for AiXrayReport. */
export type AiXrayReportConnection = {
  __typename?: 'AiXrayReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiXrayReportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiXrayReport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiXrayReportEdge = {
  __typename?: 'AiXrayReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AiXrayReport>;
};

/** Describes an alert from the project's Alert Management */
export type AlertManagementAlert = NoteableInterface & Todoable & {
  __typename?: 'AlertManagementAlert';
  /** Assignees of the alert. */
  assignees?: Maybe<UserCoreConnection>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Timestamp the alert was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Description of the alert. */
  description?: Maybe<Scalars['String']['output']>;
  /** Alert details. */
  details?: Maybe<Scalars['JSON']['output']>;
  /** URL of the alert detail page. */
  detailsUrl: Scalars['String']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Timestamp the alert ended. */
  endedAt?: Maybe<Scalars['Time']['output']>;
  /** Environment for the alert. */
  environment?: Maybe<Environment>;
  /** Number of events of the alert. */
  eventCount?: Maybe<Scalars['Int']['output']>;
  /** List of hosts the alert came from. */
  hosts?: Maybe<Array<Scalars['String']['output']>>;
  /** ID of the alert. */
  id: Scalars['ID']['output'];
  /** Internal ID of the alert. */
  iid: Scalars['String']['output'];
  /** Issue attached to the alert. */
  issue?: Maybe<Issue>;
  /**
   * Internal ID of the GitLab issue attached to the alert. Deprecated in GitLab 13.10: Use issue field.
   * @deprecated Use issue field. Deprecated in GitLab 13.10.
   */
  issueIid?: Maybe<Scalars['String']['output']>;
  /**
   * URL for metrics embed for the alert. Deprecated in GitLab 16.0: Returns no data. Underlying feature was removed in 16.0.
   * @deprecated Returns no data. Underlying feature was removed in 16.0. Deprecated in GitLab 16.0.
   */
  metricsDashboardUrl?: Maybe<Scalars['String']['output']>;
  /** Monitoring tool the alert came from. */
  monitoringTool?: Maybe<Scalars['String']['output']>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /**
   * Alert condition for Prometheus. Deprecated in GitLab 17.3: Returns no data. Underlying feature was removed in 16.0.
   * @deprecated Returns no data. Underlying feature was removed in 16.0. Deprecated in GitLab 17.3.
   */
  prometheusAlert?: Maybe<PrometheusAlert>;
  /** Runbook for the alert as defined in alert details. */
  runbook?: Maybe<Scalars['String']['output']>;
  /** Service the alert came from. */
  service?: Maybe<Scalars['String']['output']>;
  /** Severity of the alert. */
  severity?: Maybe<AlertManagementSeverity>;
  /** Timestamp the alert was raised. */
  startedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the alert. */
  status?: Maybe<AlertManagementStatus>;
  /** Title of the alert. */
  title?: Maybe<Scalars['String']['output']>;
  /** To-do items of the current user for the alert. */
  todos?: Maybe<TodoConnection>;
  /** Timestamp the alert was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** URL of the alert. */
  webUrl: Scalars['String']['output'];
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};

/** The connection type for AlertManagementAlert. */
export type AlertManagementAlertConnection = {
  __typename?: 'AlertManagementAlertConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementAlertEdge = {
  __typename?: 'AlertManagementAlertEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementAlert>;
};

/** Values for sorting alerts */
export type AlertManagementAlertSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Created time by ascending order. */
  | 'CREATED_TIME_ASC'
  /** Created time by descending order. */
  | 'CREATED_TIME_DESC'
  /** End time by ascending order. */
  | 'ENDED_AT_ASC'
  /** End time by descending order. */
  | 'ENDED_AT_DESC'
  /** Events count by ascending order. */
  | 'EVENT_COUNT_ASC'
  /** Events count by descending order. */
  | 'EVENT_COUNT_DESC'
  /** Severity from less critical to more critical. */
  | 'SEVERITY_ASC'
  /** Severity from more critical to less critical. */
  | 'SEVERITY_DESC'
  /** Start time by ascending order. */
  | 'STARTED_AT_ASC'
  /** Start time by descending order. */
  | 'STARTED_AT_DESC'
  /** Status by order: `Ignored > Resolved > Acknowledged > Triggered`. */
  | 'STATUS_ASC'
  /** Status by order: `Triggered > Acknowledged > Resolved > Ignored`. */
  | 'STATUS_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created time by ascending order. */
  | 'UPDATED_TIME_ASC'
  /** Created time by descending order. */
  | 'UPDATED_TIME_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Represents total number of alerts for the represented categories */
export type AlertManagementAlertStatusCountsType = {
  __typename?: 'AlertManagementAlertStatusCountsType';
  /** Number of alerts with status ACKNOWLEDGED for the project */
  acknowledged?: Maybe<Scalars['Int']['output']>;
  /** Total number of alerts for the project. */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of alerts with status IGNORED for the project */
  ignored?: Maybe<Scalars['Int']['output']>;
  /** Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project. */
  open?: Maybe<Scalars['Int']['output']>;
  /** Number of alerts with status RESOLVED for the project */
  resolved?: Maybe<Scalars['Int']['output']>;
  /** Number of alerts with status TRIGGERED for the project */
  triggered?: Maybe<Scalars['Int']['output']>;
};

/** Filters the alerts based on given domain */
export type AlertManagementDomainFilter =
  /** Alerts for operations domain. */
  | 'operations'
  /** Alerts for threat monitoring domain. Deprecated in GitLab 15.0: Network policies are deprecated and will be removed in GitLab 16.0. */
  | 'threat_monitoring';

/** An endpoint and credentials used to accept alerts for a project */
export type AlertManagementHttpIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementHttpIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /**
   * URL at which Prometheus metrics can be queried to populate the metrics dashboard. Deprecated in GitLab 18.2: Feature removed in 16.0.
   * @deprecated Feature removed in 16.0. Deprecated in GitLab 18.2.
   */
  apiUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the integration. */
  id: Scalars['ID']['output'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']['output']>;
  /** Extract alert fields from payload example for custom mapping. */
  payloadAlertFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /** The custom mapping of GitLab alert attributes to fields from the payload_example. */
  payloadAttributeMappings?: Maybe<Array<AlertManagementPayloadAlertMappingField>>;
  /** Example of an alert payload. */
  payloadExample?: Maybe<Scalars['JsonString']['output']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']['output']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AlertManagementHttpIntegration. */
export type AlertManagementHttpIntegrationConnection = {
  __typename?: 'AlertManagementHttpIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementHttpIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementHttpIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementHttpIntegrationEdge = {
  __typename?: 'AlertManagementHttpIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementHttpIntegration>;
};

export type AlertManagementIntegration = {
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /**
   * URL at which Prometheus metrics can be queried to populate the metrics dashboard. Deprecated in GitLab 18.2: Feature removed in 16.0.
   * @deprecated Feature removed in 16.0. Deprecated in GitLab 18.2.
   */
  apiUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the integration. */
  id: Scalars['ID']['output'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']['output']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']['output']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AlertManagementIntegration. */
export type AlertManagementIntegrationConnection = {
  __typename?: 'AlertManagementIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementIntegrationEdge = {
  __typename?: 'AlertManagementIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementIntegration>;
};

/** Values of types of integrations */
export type AlertManagementIntegrationType =
  /** Integration with any monitoring tool. */
  | 'HTTP'
  /** Prometheus integration. */
  | 'PROMETHEUS';

/** Parsed field from an alert used for custom mappings */
export type AlertManagementPayloadAlertField = {
  __typename?: 'AlertManagementPayloadAlertField';
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']['output']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']['output']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** Field that are available while modifying the custom mapping attributes for an HTTP integration */
export type AlertManagementPayloadAlertFieldInput = {
  /** GitLab alert field name. */
  fieldName: AlertManagementPayloadAlertFieldName;
  /** Human-readable label of the payload path. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Path to value inside payload JSON. */
  path: Array<Scalars['PayloadAlertFieldPathSegment']['input']>;
  /** Type of the parsed value. */
  type: AlertManagementPayloadAlertFieldType;
};

/** Values for alert field names used in the custom mapping */
export type AlertManagementPayloadAlertFieldName =
  /** A high-level summary of the problem. */
  | 'DESCRIPTION'
  /** The resolved time of the incident. */
  | 'END_TIME'
  /** The unique identifier of the alert. This can be used to group occurrences of the same alert. */
  | 'FINGERPRINT'
  /** The name of the associated GitLab environment. */
  | 'GITLAB_ENVIRONMENT_NAME'
  /** One or more hosts, as to where this incident occurred. */
  | 'HOSTS'
  /** The name of the associated monitoring tool. */
  | 'MONITORING_TOOL'
  /** The affected service. */
  | 'SERVICE'
  /** The severity of the alert. */
  | 'SEVERITY'
  /** The time of the incident. */
  | 'START_TIME'
  /** The title of the incident. */
  | 'TITLE';

/** Values for alert field types used in the custom mapping */
export type AlertManagementPayloadAlertFieldType =
  /** Array field type. */
  | 'ARRAY'
  /** DateTime field type. */
  | 'DATETIME'
  /** Number field type. */
  | 'NUMBER'
  /** String field type. */
  | 'STRING';

/** Parsed field (with its name) from an alert used for custom mappings */
export type AlertManagementPayloadAlertMappingField = {
  __typename?: 'AlertManagementPayloadAlertMappingField';
  /** GitLab alert field name. */
  fieldName?: Maybe<AlertManagementPayloadAlertFieldName>;
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']['output']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']['output']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** **DEPRECATED - Use AlertManagementHttpIntegration directly** An endpoint and credentials used to accept Prometheus alerts for a project */
export type AlertManagementPrometheusIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementPrometheusIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /**
   * URL at which Prometheus metrics can be queried to populate the metrics dashboard. Deprecated in GitLab 18.2: Feature removed in 16.0.
   * @deprecated Feature removed in 16.0. Deprecated in GitLab 18.2.
   */
  apiUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the integration. */
  id: Scalars['ID']['output'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']['output']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']['output']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Alert severity values */
export type AlertManagementSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** Alert status values */
export type AlertManagementStatus =
  /** Someone is actively investigating the problem. */
  | 'ACKNOWLEDGED'
  /** No action will be taken. */
  | 'IGNORED'
  /** The problem has been addressed. */
  | 'RESOLVED'
  /** Investigation has not started. */
  | 'TRIGGERED';

/** Autogenerated input type of AlertSetAssignees */
export type AlertSetAssigneesInput = {
  /** Usernames to assign to the alert. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String']['input'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of AlertSetAssignees. */
export type AlertSetAssigneesPayload = {
  __typename?: 'AlertSetAssigneesPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of AlertTodoCreate */
export type AlertTodoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String']['input'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of AlertTodoCreate. */
export type AlertTodoCreatePayload = {
  __typename?: 'AlertTodoCreatePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

export type AmazonS3ConfigurationInterface = {
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid: Scalars['String']['output'];
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** AWS region where the bucket is created. */
  awsRegion: Scalars['String']['output'];
  /** Name of the bucket where the audit events would be logged. */
  bucketName: Scalars['String']['output'];
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** Stores Amazon S3 configurations for audit event streaming. */
export type AmazonS3ConfigurationType = AmazonS3ConfigurationInterface & {
  __typename?: 'AmazonS3ConfigurationType';
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid: Scalars['String']['output'];
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** AWS region where the bucket is created. */
  awsRegion: Scalars['String']['output'];
  /** Name of the bucket where the audit events would be logged. */
  bucketName: Scalars['String']['output'];
  /** Group the configuration belongs to. */
  group: Group;
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** The connection type for AmazonS3ConfigurationType. */
export type AmazonS3ConfigurationTypeConnection = {
  __typename?: 'AmazonS3ConfigurationTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AmazonS3ConfigurationTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AmazonS3ConfigurationType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AmazonS3ConfigurationTypeEdge = {
  __typename?: 'AmazonS3ConfigurationTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AmazonS3ConfigurationType>;
};

export type AnalyticsAggregationPeriod =
  /** Daily aggregation. */
  | 'DAY'
  /** Monthly aggregation. */
  | 'MONTH'
  /** Weekly aggregation. */
  | 'WEEK';

/** Input type for filtering projects by analyzer type and status */
export type AnalyzerFilterInput = {
  /** Type of analyzer to filter by. */
  analyzerType: AnalyzerTypeEnum;
  /** Status of the analyzer to filter by. */
  status: AnalyzerStatusEnum;
};

/** Counts for each analyzer status in the group and subgroups. */
export type AnalyzerGroupStatusType = {
  __typename?: 'AnalyzerGroupStatusType';
  /** Analyzer type. */
  analyzerType: AnalyzerTypeEnum;
  /** Number of projects where `analyzer_type` failed to execute. */
  failure: Scalars['Int']['output'];
  /** Namespace ID. */
  namespaceId: Scalars['Int']['output'];
  /** Number of projects where `analyzer_type` is not configured. */
  notConfigured: Scalars['Int']['output'];
  /** Number of projects where `analyzer_type` completed successfully. */
  success: Scalars['Int']['output'];
  /** Total number of projects descending from the group. */
  totalProjectsCount: Scalars['Int']['output'];
  /** Timestamp of when the status was last updated. */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Analyzer status (success/fail) for projects */
export type AnalyzerProjectStatusType = {
  __typename?: 'AnalyzerProjectStatusType';
  /** Analyzer type. */
  analyzerType: AnalyzerTypeEnum;
  /** Build ID. */
  buildId?: Maybe<Scalars['JobID']['output']>;
  /** Last time analyzer was called. */
  lastCall: Scalars['Time']['output'];
  /** Project ID. */
  projectId: Scalars['Int']['output'];
  /** Analyzer status. */
  status: AnalyzerStatusEnum;
  /** Timestamp of when the status was last updated. */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Enum for types of analyzers  */
export type AnalyzerStatusEnum =
  /** Last analyzer execution failed. */
  | 'FAILED'
  /** Analyzer is not configured. */
  | 'NOT_CONFIGURED'
  /** Last analyzer execution finished successfully. */
  | 'SUCCESS';

/** Enum for types of analyzers  */
export type AnalyzerTypeEnum =
  /** Api fuzzing analyzer. */
  | 'API_FUZZING'
  /** Cluster image scanning analyzer. */
  | 'CLUSTER_IMAGE_SCANNING'
  /** Any kind of container scanning. */
  | 'CONTAINER_SCANNING'
  /** Container scanning for registry. Managed via project security settings. */
  | 'CONTAINER_SCANNING_FOR_REGISTRY'
  /** Container scanning analyzer. */
  | 'CONTAINER_SCANNING_PIPELINE_BASED'
  /** Coverage fuzzing analyzer. */
  | 'COVERAGE_FUZZING'
  /** Dast analyzer. */
  | 'DAST'
  /** Dependency scanning analyzer. */
  | 'DEPENDENCY_SCANNING'
  /** Sast analyzer. */
  | 'SAST'
  /** Sast advanced analyzer. */
  | 'SAST_ADVANCED'
  /** Sast iac analyzer. */
  | 'SAST_IAC'
  /** Any kind of secret detection. */
  | 'SECRET_DETECTION'
  /** Secret detection analyzer. */
  | 'SECRET_DETECTION_PIPELINE_BASED'
  /** Secret push protection. Managed via project security settings. */
  | 'SECRET_DETECTION_SECRET_PUSH_PROTECTION';

export type AncestorType = {
  __typename?: 'AncestorType';
  /** Name of the ancestor. */
  name?: Maybe<Scalars['String']['output']>;
  /** Version of the ancestor. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Data associated with configuring API fuzzing scans in GitLab CI */
export type ApiFuzzingCiConfiguration = {
  __typename?: 'ApiFuzzingCiConfiguration';
  /** All available scan modes. */
  scanModes?: Maybe<Array<ApiFuzzingScanMode>>;
  /** All default scan profiles. */
  scanProfiles?: Maybe<Array<ApiFuzzingScanProfile>>;
};

/** All possible ways to specify the API surface for an API fuzzing scan. */
export type ApiFuzzingScanMode =
  /** The API surface is specified by a HAR file. */
  | 'HAR'
  /** The API surface is specified by a OPENAPI file. */
  | 'OPENAPI'
  /** The API surface is specified by a POSTMAN file. */
  | 'POSTMAN';

/** An API Fuzzing scan profile. */
export type ApiFuzzingScanProfile = {
  __typename?: 'ApiFuzzingScanProfile';
  /** Short description of the profile. */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique name of the profile. */
  name?: Maybe<Scalars['String']['output']>;
  /** Syntax highlighted HTML representation of the YAML. */
  yaml?: Maybe<Scalars['String']['output']>;
};

/** Represents the approval policy */
export type ApprovalPolicy = OrchestrationPolicy & {
  __typename?: 'ApprovalPolicy';
  /** Multiple approvers action. */
  actionApprovers?: Maybe<Array<PolicyApproversType>>;
  /** All potential approvers of the group type, including groups inaccessible to the user. */
  allGroupApprovers?: Maybe<Array<PolicyApprovalGroup>>;
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Approvers of the custom role type. Users belonging to these role(s) alone will be approvers. */
  customRoles?: Maybe<Array<MemberRole>>;
  /**
   * All deprecated properties in the policy. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  deprecatedProperties?: Maybe<Array<Scalars['String']['output']>>;
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Enforcement type of the policy. Can be "enforce" or "warn". */
  enforcementType?: Maybe<PolicyEnforcementType>;
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Approvers of the role type. Users belonging to these role(s) alone will be approvers. */
  roleApprovers?: Maybe<Array<MemberAccessLevelName>>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Approvers of the user type. */
  userApprovers?: Maybe<Array<UserCore>>;
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** Represents policy fields related to the approval policy. */
export type ApprovalPolicyAttributesType = {
  __typename?: 'ApprovalPolicyAttributesType';
  /** Multiple approvers action. */
  actionApprovers?: Maybe<Array<PolicyApproversType>>;
  /** All potential approvers of the group type, including groups inaccessible to the user. */
  allGroupApprovers?: Maybe<Array<PolicyApprovalGroup>>;
  /** Approvers of the custom role type. Users belonging to these role(s) alone will be approvers. */
  customRoles?: Maybe<Array<MemberRole>>;
  /**
   * All deprecated properties in the policy. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  deprecatedProperties?: Maybe<Array<Scalars['String']['output']>>;
  /** Enforcement type of the policy. Can be "enforce" or "warn". */
  enforcementType?: Maybe<PolicyEnforcementType>;
  /** Approvers of the role type. Users belonging to these role(s) alone will be approvers. */
  roleApprovers?: Maybe<Array<MemberAccessLevelName>>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Approvers of the user type. */
  userApprovers?: Maybe<Array<UserCore>>;
};

/** The connection type for ApprovalPolicy. */
export type ApprovalPolicyConnection = {
  __typename?: 'ApprovalPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApprovalPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ApprovalPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ApprovalPolicyEdge = {
  __typename?: 'ApprovalPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ApprovalPolicy>;
};

/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRule = {
  __typename?: 'ApprovalProjectRule';
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']['output']>;
  /** List of users eligible to approve merge requests for the approval rule. */
  eligibleApprovers?: Maybe<UserCoreConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID']['output'];
  /** Name of the rule. */
  name?: Maybe<Scalars['String']['output']>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
};


/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRuleEligibleApproversArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ApprovalProjectRule. */
export type ApprovalProjectRuleConnection = {
  __typename?: 'ApprovalProjectRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApprovalProjectRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ApprovalProjectRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ApprovalProjectRuleEdge = {
  __typename?: 'ApprovalProjectRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ApprovalProjectRule>;
};

export type ApprovalReportType =
  /** Represents report_type for any_merge_request related approval rules. */
  | 'ANY_MERGE_REQUEST'
  /** Represents report_type for license scanning related approval rules. */
  | 'LICENSE_SCANNING'
  /** Represents report_type for vulnerability check related approval rules. */
  | 'SCAN_FINDING';

/** Describes a rule for who can approve merge requests. */
export type ApprovalRule = {
  __typename?: 'ApprovalRule';
  /** Indicates if the rule can be ignored if it is invalid. */
  allowMergeWhenInvalid?: Maybe<Scalars['Boolean']['output']>;
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']['output']>;
  /** Indicates if the rule is satisfied. */
  approved?: Maybe<Scalars['Boolean']['output']>;
  /** List of users defined in the rule that approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** List of users, defined in the rule, who commented on the merge request. */
  commentedBy?: Maybe<UserCoreConnection>;
  /** Indicates if the rule contains approvers from a hidden group. */
  containsHiddenGroups?: Maybe<Scalars['Boolean']['output']>;
  /** List of all users eligible to approve the merge request (defined explicitly and from associated groups). */
  eligibleApprovers?: Maybe<Array<UserCore>>;
  /** List of groups added as approvers for the rule. */
  groups?: Maybe<GroupConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID']['output'];
  /** Indicates if the rule is invalid and cannot be approved. */
  invalid?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the rule. */
  name?: Maybe<Scalars['String']['output']>;
  /** Indicates if the rule was overridden for the merge request. */
  overridden?: Maybe<Scalars['Boolean']['output']>;
  /** List of scan result policies associated with the rule. */
  scanResultPolicies?: Maybe<Array<ApprovalScanResultPolicy>>;
  /** Named section of the Code Owners file that the rule applies to. */
  section?: Maybe<Scalars['String']['output']>;
  /** Source rule used to create the rule. */
  sourceRule?: Maybe<ApprovalRule>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
  /** List of users added as approvers for the rule. */
  users?: Maybe<UserCoreConnection>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleApprovedByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleCommentedByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The kind of an approval rule. */
export type ApprovalRuleType =
  /** A `any_approver` approval rule. */
  | 'ANY_APPROVER'
  /** A `code_owner` approval rule. */
  | 'CODE_OWNER'
  /** A `regular` approval rule. */
  | 'REGULAR'
  /** A `report_approver` approval rule. */
  | 'REPORT_APPROVER';

/** Represents the scan result policy */
export type ApprovalScanResultPolicy = {
  __typename?: 'ApprovalScanResultPolicy';
  /** Represents the required approvals defined in the policy. */
  approvalsRequired: Scalars['Int']['output'];
  /** Represents the name of the policy. */
  name: Scalars['String']['output'];
  /** Represents the report_type of the approval rule. */
  reportType: ApprovalReportType;
};

/** Autogenerated input type of ApproveDeployment */
export type ApproveDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment to go with the approval. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** ID of the deployment. */
  id: Scalars['DeploymentID']['input'];
  /** Name of the User/Group/Role to use for the approval, when the user belongs to multiple approval rules. */
  representedAs?: InputMaybe<Scalars['String']['input']>;
  /** Status of the approval (either `APPROVED` or `REJECTED`). */
  status: DeploymentsApprovalStatus;
};

/** Autogenerated return type of ApproveDeployment. */
export type ApproveDeploymentPayload = {
  __typename?: 'ApproveDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** DeploymentApproval after mutation. */
  deploymentApproval?: Maybe<DeploymentApproval>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of ArtifactDestroy */
export type ArtifactDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the artifact to delete. */
  id: Scalars['CiJobArtifactID']['input'];
};

/** Autogenerated return type of ArtifactDestroy. */
export type ArtifactDestroyPayload = {
  __typename?: 'ArtifactDestroyPayload';
  /** Deleted artifact. */
  artifact?: Maybe<CiJobArtifact>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents a vulnerability asset type. */
export type AssetType = {
  __typename?: 'AssetType';
  /** Name of the asset. */
  name: Scalars['String']['output'];
  /** Type of the asset. */
  type: Scalars['String']['output'];
  /** URL of the asset. */
  url: Scalars['String']['output'];
};

/** Assignee ID wildcard values */
export type AssigneeWildcardId =
  /** An assignee is assigned. */
  | 'ANY'
  /** No assignee is assigned. */
  | 'NONE';

/** Input type for filtering projects by security attributes */
export type AttributeFilterInput = {
  /** Global IDs of the security attributes to filter by. Up to 20 values. */
  attributes: Array<Scalars['SecurityAttributeID']['input']>;
  /** Operator to apply for the attribute filter. */
  operator: AttributeFilterOperator;
};

/** Operators for filtering by security attributes */
export type AttributeFilterOperator =
  /** Project does not have any of the specified attributes. */
  | 'IS_NOT_ONE_OF'
  /** Project has one or more of the specified attributes. */
  | 'IS_ONE_OF';

/** Audit event. */
export type AuditEvent = {
  __typename?: 'AuditEvent';
  /** User who triggered the event. */
  author?: Maybe<UserCore>;
  /** Timestamp when the audit event was created. */
  createdAt: Scalars['Time']['output'];
  /** Additional details of the audit event. */
  details?: Maybe<Scalars['String']['output']>;
  /** ID of the entity. */
  entityId?: Maybe<Scalars['ID']['output']>;
  /** Path of the entity. */
  entityPath?: Maybe<Scalars['String']['output']>;
  /** Type of the entity. */
  entityType?: Maybe<Scalars['String']['output']>;
  /** Name of the event. */
  eventName?: Maybe<Scalars['String']['output']>;
  /** Group associated with the audit event. */
  group?: Maybe<Group>;
  /** Audit Event ID. */
  id: Scalars['ID']['output'];
  /** IP address of the user. */
  ipAddress?: Maybe<Scalars['String']['output']>;
  /** Project associated with the audit event. */
  project?: Maybe<Project>;
  /** Additional details of the target. */
  targetDetails?: Maybe<Scalars['String']['output']>;
  /** ID of the target of the audit event. */
  targetId?: Maybe<Scalars['ID']['output']>;
  /** Type of the target of the audit event. */
  targetType?: Maybe<Scalars['String']['output']>;
  /** User associated with the audit event. */
  user?: Maybe<UserCore>;
};

/** Represents the YAML definitions for audit events defined in `ee/config/audit_events/types/<event-type-name>.yml` and `config/audit_events/types/<event-type-name>.yml`. */
export type AuditEventDefinition = {
  __typename?: 'AuditEventDefinition';
  /** Description of what action the audit event tracks. */
  description: Scalars['String']['output'];
  /** Feature category associated with the event. */
  featureCategory: Scalars['String']['output'];
  /** Link to the issue introducing the event. For olderaudit events, it can be a commit URL rather than amerge request URL. */
  introducedByIssue?: Maybe<Scalars['String']['output']>;
  /** Link to the merge request introducing the event. Forolder audit events, it can be a commit URL rather thana merge request URL. */
  introducedByMr?: Maybe<Scalars['String']['output']>;
  /** Milestone the event was introduced in. */
  milestone: Scalars['String']['output'];
  /** Key name of the audit event. */
  name: Scalars['String']['output'];
  /** Indicates if the event is saved to PostgreSQL database. */
  savedToDatabase: Scalars['Boolean']['output'];
  /** Indicates if the event is streamed to an external destination. */
  streamed: Scalars['Boolean']['output'];
};

/** The connection type for AuditEventDefinition. */
export type AuditEventDefinitionConnection = {
  __typename?: 'AuditEventDefinitionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventDefinitionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventDefinition>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventDefinitionEdge = {
  __typename?: 'AuditEventDefinitionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventDefinition>;
};

export type AuditEventStreamingDestinationInterface = {
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Category of the external destination to send audit events to. */
  category: Scalars['String']['output'];
  /** Config of the external destination. */
  config: Scalars['JSON']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** Secret token for the destination, will be non-empty value only for http category. */
  secretToken: Scalars['String']['output'];
};

/** Represents a subgroup or project filter that belongs to an external audit event streaming destination. */
export type AuditEventStreamingHttpNamespaceFilter = {
  __typename?: 'AuditEventStreamingHTTPNamespaceFilter';
  /** Destination to which the filter belongs. */
  externalAuditEventDestination: ExternalAuditEventDestination;
  /** ID of the filter. */
  id: Scalars['ID']['output'];
  /** Group or project namespace the filter belongs to. */
  namespace: Namespace;
};

/** Represents a HTTP header key/value that belongs to an audit streaming destination. */
export type AuditEventStreamingHeader = BaseHeaderInterface & {
  __typename?: 'AuditEventStreamingHeader';
  /** Header is active or not. */
  active: Scalars['Boolean']['output'];
  /** ID of the header. */
  id: Scalars['ID']['output'];
  /** Key of the header. */
  key: Scalars['String']['output'];
  /** Value of the header. */
  value: Scalars['String']['output'];
};

/** The connection type for AuditEventStreamingHeader. */
export type AuditEventStreamingHeaderConnection = {
  __typename?: 'AuditEventStreamingHeaderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventStreamingHeaderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventStreamingHeader>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventStreamingHeaderEdge = {
  __typename?: 'AuditEventStreamingHeaderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventStreamingHeader>;
};

/** Autogenerated input type of AuditEventsAmazonS3ConfigurationCreate */
export type AuditEventsAmazonS3ConfigurationCreateInput = {
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid: Scalars['String']['input'];
  /** AWS region where the bucket is created. */
  awsRegion: Scalars['String']['input'];
  /** Name of the bucket where the audit events would be logged. */
  bucketName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group path. */
  groupPath: Scalars['ID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret access key of the Amazon S3 account. */
  secretAccessKey: Scalars['String']['input'];
};

/** Autogenerated return type of AuditEventsAmazonS3ConfigurationCreate. */
export type AuditEventsAmazonS3ConfigurationCreatePayload = {
  __typename?: 'AuditEventsAmazonS3ConfigurationCreatePayload';
  /** configuration created. */
  amazonS3Configuration?: Maybe<AmazonS3ConfigurationType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsAmazonS3ConfigurationDelete */
export type AuditEventsAmazonS3ConfigurationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Amazon S3 configuration to destroy. */
  id: Scalars['AuditEventsAmazonS3ConfigurationID']['input'];
};

/** Autogenerated return type of AuditEventsAmazonS3ConfigurationDelete. */
export type AuditEventsAmazonS3ConfigurationDeletePayload = {
  __typename?: 'AuditEventsAmazonS3ConfigurationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsAmazonS3ConfigurationUpdate */
export type AuditEventsAmazonS3ConfigurationUpdateInput = {
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid?: InputMaybe<Scalars['String']['input']>;
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** AWS region where the bucket is created. */
  awsRegion?: InputMaybe<Scalars['String']['input']>;
  /** Name of the bucket where the audit events would be logged. */
  bucketName?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Amazon S3 configuration to update. */
  id: Scalars['AuditEventsAmazonS3ConfigurationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret access key of the Amazon S3 account. */
  secretAccessKey?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsAmazonS3ConfigurationUpdate. */
export type AuditEventsAmazonS3ConfigurationUpdatePayload = {
  __typename?: 'AuditEventsAmazonS3ConfigurationUpdatePayload';
  /** Updated Amazon S3 configuration. */
  amazonS3Configuration?: Maybe<AmazonS3ConfigurationType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsGroupDestinationEventsAdd */
export type AuditEventsGroupDestinationEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsGroupExternalStreamingDestinationID']['input'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsGroupDestinationEventsAdd. */
export type AuditEventsGroupDestinationEventsAddPayload = {
  __typename?: 'AuditEventsGroupDestinationEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** List of event type filters for the audit event external destination. */
  eventTypeFilters?: Maybe<Array<Scalars['String']['output']>>;
};

/** Autogenerated input type of AuditEventsGroupDestinationEventsDelete */
export type AuditEventsGroupDestinationEventsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsGroupExternalStreamingDestinationID']['input'];
  /** List of event type filters to remove from streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsGroupDestinationEventsDelete. */
export type AuditEventsGroupDestinationEventsDeletePayload = {
  __typename?: 'AuditEventsGroupDestinationEventsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsGroupDestinationNamespaceFilterCreate */
export type AuditEventsGroupDestinationNamespaceFilterCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination ID. */
  destinationId: Scalars['AuditEventsGroupExternalStreamingDestinationID']['input'];
  /** Full path of the namespace(only project or group). */
  namespacePath?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsGroupDestinationNamespaceFilterCreate. */
export type AuditEventsGroupDestinationNamespaceFilterCreatePayload = {
  __typename?: 'AuditEventsGroupDestinationNamespaceFilterCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace filter created. */
  namespaceFilter?: Maybe<GroupAuditEventNamespaceFilter>;
};

/** Autogenerated input type of AuditEventsGroupDestinationNamespaceFilterDelete */
export type AuditEventsGroupDestinationNamespaceFilterDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Namespace filter ID. */
  namespaceFilterId: Scalars['AuditEventsGroupNamespaceFilterID']['input'];
};

/** Autogenerated return type of AuditEventsGroupDestinationNamespaceFilterDelete. */
export type AuditEventsGroupDestinationNamespaceFilterDeletePayload = {
  __typename?: 'AuditEventsGroupDestinationNamespaceFilterDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationCreate */
export type AuditEventsInstanceAmazonS3ConfigurationCreateInput = {
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid: Scalars['String']['input'];
  /** AWS region where the bucket is created. */
  awsRegion: Scalars['String']['input'];
  /** Name of the bucket where the audit events would be logged. */
  bucketName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret access key of the Amazon S3 account. */
  secretAccessKey: Scalars['String']['input'];
};

/** Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationCreate. */
export type AuditEventsInstanceAmazonS3ConfigurationCreatePayload = {
  __typename?: 'AuditEventsInstanceAmazonS3ConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created instance Amazon S3 configuration. */
  instanceAmazonS3Configuration?: Maybe<InstanceAmazonS3ConfigurationType>;
};

/** Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationDelete */
export type AuditEventsInstanceAmazonS3ConfigurationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the instance-level Amazon S3 configuration to delete. */
  id: Scalars['AuditEventsInstanceAmazonS3ConfigurationID']['input'];
};

/** Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationDelete. */
export type AuditEventsInstanceAmazonS3ConfigurationDeletePayload = {
  __typename?: 'AuditEventsInstanceAmazonS3ConfigurationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationUpdate */
export type AuditEventsInstanceAmazonS3ConfigurationUpdateInput = {
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid?: InputMaybe<Scalars['String']['input']>;
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** AWS region where the bucket is created. */
  awsRegion?: InputMaybe<Scalars['String']['input']>;
  /** Name of the bucket where the audit events would be logged. */
  bucketName?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the instance-level Amazon S3 configuration to update. */
  id: Scalars['AuditEventsInstanceAmazonS3ConfigurationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret access key of the Amazon S3 account. */
  secretAccessKey?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationUpdate. */
export type AuditEventsInstanceAmazonS3ConfigurationUpdatePayload = {
  __typename?: 'AuditEventsInstanceAmazonS3ConfigurationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated instance-level Amazon S3 configuration. */
  instanceAmazonS3Configuration?: Maybe<InstanceAmazonS3ConfigurationType>;
};

/** Autogenerated input type of AuditEventsInstanceDestinationEventsAdd */
export type AuditEventsInstanceDestinationEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsInstanceExternalStreamingDestinationID']['input'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsInstanceDestinationEventsAdd. */
export type AuditEventsInstanceDestinationEventsAddPayload = {
  __typename?: 'AuditEventsInstanceDestinationEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** List of event type filters for the audit event external destination. */
  eventTypeFilters?: Maybe<Array<Scalars['String']['output']>>;
};

/** Autogenerated input type of AuditEventsInstanceDestinationEventsDelete */
export type AuditEventsInstanceDestinationEventsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsInstanceExternalStreamingDestinationID']['input'];
  /** List of event type filters to remove from streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsInstanceDestinationEventsDelete. */
export type AuditEventsInstanceDestinationEventsDeletePayload = {
  __typename?: 'AuditEventsInstanceDestinationEventsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsInstanceDestinationNamespaceFilterCreate */
export type AuditEventsInstanceDestinationNamespaceFilterCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination ID. */
  destinationId: Scalars['AuditEventsInstanceExternalStreamingDestinationID']['input'];
  /** Full path of the namespace. Project or group namespaces only. */
  namespacePath?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsInstanceDestinationNamespaceFilterCreate. */
export type AuditEventsInstanceDestinationNamespaceFilterCreatePayload = {
  __typename?: 'AuditEventsInstanceDestinationNamespaceFilterCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace filter to be created. */
  namespaceFilter?: Maybe<InstanceAuditEventNamespaceFilter>;
};

/** Autogenerated input type of AuditEventsInstanceDestinationNamespaceFilterDelete */
export type AuditEventsInstanceDestinationNamespaceFilterDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Namespace filter ID. */
  namespaceFilterId: Scalars['AuditEventsInstanceNamespaceFilterID']['input'];
};

/** Autogenerated return type of AuditEventsInstanceDestinationNamespaceFilterDelete. */
export type AuditEventsInstanceDestinationNamespaceFilterDeletePayload = {
  __typename?: 'AuditEventsInstanceDestinationNamespaceFilterDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationEventsAdd */
export type AuditEventsStreamingDestinationEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationEventsAdd. */
export type AuditEventsStreamingDestinationEventsAddPayload = {
  __typename?: 'AuditEventsStreamingDestinationEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** List of event type filters for the audit event external destination. */
  eventTypeFilters?: Maybe<Array<Scalars['String']['output']>>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationEventsRemove */
export type AuditEventsStreamingDestinationEventsRemoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
  /** List of event type filters to remove from streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationEventsRemove. */
export type AuditEventsStreamingDestinationEventsRemovePayload = {
  __typename?: 'AuditEventsStreamingDestinationEventsRemovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationInstanceEventsAdd */
export type AuditEventsStreamingDestinationInstanceEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsInstanceExternalAuditEventDestinationID']['input'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationInstanceEventsAdd. */
export type AuditEventsStreamingDestinationInstanceEventsAddPayload = {
  __typename?: 'AuditEventsStreamingDestinationInstanceEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** List of event type filters for the audit event external destination. */
  eventTypeFilters?: Maybe<Array<Scalars['String']['output']>>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationInstanceEventsRemove */
export type AuditEventsStreamingDestinationInstanceEventsRemoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsInstanceExternalAuditEventDestinationID']['input'];
  /** List of event type filters to remove from streaming. */
  eventTypeFilters: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationInstanceEventsRemove. */
export type AuditEventsStreamingDestinationInstanceEventsRemovePayload = {
  __typename?: 'AuditEventsStreamingDestinationInstanceEventsRemovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingHTTPNamespaceFiltersAdd */
export type AuditEventsStreamingHttpNamespaceFiltersAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination ID. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
  /** Full path of the group. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Full path of the project. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingHTTPNamespaceFiltersAdd. */
export type AuditEventsStreamingHttpNamespaceFiltersAddPayload = {
  __typename?: 'AuditEventsStreamingHTTPNamespaceFiltersAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace filter created. */
  namespaceFilter?: Maybe<AuditEventStreamingHttpNamespaceFilter>;
};

/** Autogenerated input type of AuditEventsStreamingHTTPNamespaceFiltersDelete */
export type AuditEventsStreamingHttpNamespaceFiltersDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Namespace filter ID. */
  namespaceFilterId: Scalars['AuditEventsStreamingHTTPNamespaceFilterID']['input'];
};

/** Autogenerated return type of AuditEventsStreamingHTTPNamespaceFiltersDelete. */
export type AuditEventsStreamingHttpNamespaceFiltersDeletePayload = {
  __typename?: 'AuditEventsStreamingHTTPNamespaceFiltersDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersCreate */
export type AuditEventsStreamingHeadersCreateInput = {
  /** Boolean option determining whether header is active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination to associate header with. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
  /** Header key. */
  key: Scalars['String']['input'];
  /** Header value. */
  value: Scalars['String']['input'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersCreate. */
export type AuditEventsStreamingHeadersCreatePayload = {
  __typename?: 'AuditEventsStreamingHeadersCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersDestroy */
export type AuditEventsStreamingHeadersDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Header to delete. */
  headerId: Scalars['AuditEventsStreamingHeaderID']['input'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersDestroy. */
export type AuditEventsStreamingHeadersDestroyPayload = {
  __typename?: 'AuditEventsStreamingHeadersDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersUpdate */
export type AuditEventsStreamingHeadersUpdateInput = {
  /** Boolean option determining whether header is active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Header to update. */
  headerId: Scalars['AuditEventsStreamingHeaderID']['input'];
  /** Header key. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Header value. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingHeadersUpdate. */
export type AuditEventsStreamingHeadersUpdatePayload = {
  __typename?: 'AuditEventsStreamingHeadersUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updates header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Represents a HTTP header key/value that belongs to an instance level audit streaming destination. */
export type AuditEventsStreamingInstanceHeader = BaseHeaderInterface & {
  __typename?: 'AuditEventsStreamingInstanceHeader';
  /** Header is active or not. */
  active: Scalars['Boolean']['output'];
  /** ID of the header. */
  id: Scalars['ID']['output'];
  /** Key of the header. */
  key: Scalars['String']['output'];
  /** Value of the header. */
  value: Scalars['String']['output'];
};

/** The connection type for AuditEventsStreamingInstanceHeader. */
export type AuditEventsStreamingInstanceHeaderConnection = {
  __typename?: 'AuditEventsStreamingInstanceHeaderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventsStreamingInstanceHeaderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventsStreamingInstanceHeader>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventsStreamingInstanceHeaderEdge = {
  __typename?: 'AuditEventsStreamingInstanceHeaderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersCreate */
export type AuditEventsStreamingInstanceHeadersCreateInput = {
  /** Boolean option determining whether header is active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Instance level external destination to associate header with. */
  destinationId: Scalars['AuditEventsInstanceExternalAuditEventDestinationID']['input'];
  /** Header key. */
  key: Scalars['String']['input'];
  /** Header value. */
  value: Scalars['String']['input'];
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersCreate. */
export type AuditEventsStreamingInstanceHeadersCreatePayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created header. */
  header?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersDestroy */
export type AuditEventsStreamingInstanceHeadersDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Header to delete. */
  headerId: Scalars['AuditEventsStreamingInstanceHeaderID']['input'];
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersDestroy. */
export type AuditEventsStreamingInstanceHeadersDestroyPayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersUpdate */
export type AuditEventsStreamingInstanceHeadersUpdateInput = {
  /** Boolean option determining whether header is active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Header to update. */
  headerId: Scalars['AuditEventsStreamingInstanceHeaderID']['input'];
  /** Header key. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Header value. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersUpdate. */
export type AuditEventsStreamingInstanceHeadersUpdatePayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updates header. */
  header?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** Auto stop setting. */
export type AutoStopSetting =
  /** Always */
  | 'ALWAYS'
  /** With Action */
  | 'WITH_ACTION';

/** Core representation of a GitLab user. */
export type AutocompletedUser = Todoable & User & {
  __typename?: 'AutocompletedUser';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user has composite identity enforcement enabled. */
  compositeIdentityEnforced: Scalars['Boolean']['output'];
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Merge request state related to the user. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};


/** Core representation of a GitLab user. */
export type AutocompletedUserNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** Core representation of a GitLab user. */
export type AutocompletedUserSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type AutocompletedUserWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** User availability status */
export type AvailabilityEnum =
  /** Busy */
  | 'BUSY'
  /** Not Set */
  | 'NOT_SET';

/** Available fields to be exported as CSV */
export type AvailableExportFields =
  /** Assignee(s) name of the work item. */
  | 'ASSIGNEE'
  /** Assignee(s) username of the work item. */
  | 'ASSIGNEE_USERNAME'
  /** Author name of the work item. */
  | 'AUTHOR'
  /** Author username of the work item. */
  | 'AUTHOR_USERNAME'
  /** Closed at (UTC) date of the work item. */
  | 'CLOSED_AT'
  /** Confidentiality flag of the work item. */
  | 'CONFIDENTIAL'
  /** Crated at (UTC) date of the work item. */
  | 'CREATED_AT'
  /** Description of the work item. */
  | 'DESCRIPTION'
  /** Due date (UTC) of the work item. */
  | 'DUE_DATE'
  /** Unique identifier of the work item. */
  | 'ID'
  /** IID identifier of the work item. */
  | 'IID'
  /** Locked discussions flag of the work item. */
  | 'LOCKED'
  /** Milestone of the work item. */
  | 'MILESTONE'
  /** Parent ID of the work item. */
  | 'PARENT_ID'
  /** Parent IID of the work item. */
  | 'PARENT_IID'
  /** Parent title of the work item. */
  | 'PARENT_TITLE'
  /** Start date (UTC) of the work item. */
  | 'START_DATE'
  /** State of the work item. */
  | 'STATE'
  /** Time estimate of the work item. */
  | 'TIME_ESTIMATE'
  /** Time spent of the work item. */
  | 'TIME_SPENT'
  /** Title of the work item. */
  | 'TITLE'
  /** Type of the work item. */
  | 'TYPE'
  /** Updated at (UTC) date of the work item. */
  | 'UPDATED_AT'
  /** Web URL to the work item. */
  | 'URL'
  /** Weight of the work item. */
  | 'WEIGHT';

/** Available models for Duo Agentic Chat */
export type AvailableModels = {
  __typename?: 'AvailableModels';
  /** Default LLM for Duo Agentic Chat. */
  defaultModel?: Maybe<AiModelSelectionOfferedModel>;
  /** Pinned model for Duo Agentic Chat if set via feature settings. */
  pinnedModel?: Maybe<AiModelSelectionOfferedModel>;
  /** LLMs compatible with Duo Agentic Chat. */
  selectableModels?: Maybe<Array<AiModelSelectionOfferedModel>>;
};

/** An emoji awarded by a user */
export type AwardEmoji = {
  __typename?: 'AwardEmoji';
  /** Emoji description. */
  description: Scalars['String']['output'];
  /** Emoji as an icon. */
  emoji: Scalars['String']['output'];
  /** Emoji name. */
  name: Scalars['String']['output'];
  /** Emoji in Unicode. */
  unicode: Scalars['String']['output'];
  /** Unicode version for the emoji. */
  unicodeVersion: Scalars['String']['output'];
  /** User who awarded the emoji. */
  user: UserCore;
};

/** Autogenerated input type of AwardEmojiAdd */
export type AwardEmojiAddInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Emoji name. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AwardEmojiAdd. */
export type AwardEmojiAddPayload = {
  __typename?: 'AwardEmojiAddPayload';
  /** Emoji reactions after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** The connection type for AwardEmoji. */
export type AwardEmojiConnection = {
  __typename?: 'AwardEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AwardEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AwardEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AwardEmojiEdge = {
  __typename?: 'AwardEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AwardEmoji>;
};

/** Autogenerated input type of AwardEmojiRemove */
export type AwardEmojiRemoveInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Emoji name. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AwardEmojiRemove. */
export type AwardEmojiRemovePayload = {
  __typename?: 'AwardEmojiRemovePayload';
  /** Emoji reactions after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of AwardEmojiToggle */
export type AwardEmojiToggleInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Emoji name. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of AwardEmojiToggle. */
export type AwardEmojiTogglePayload = {
  __typename?: 'AwardEmojiTogglePayload';
  /** Emoji reactions after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Indicates the status of the emoji. True if the toggle awarded the emoji, and false if the toggle removed the emoji. */
  toggledOn: Scalars['Boolean']['output'];
};

export type BaseDiscussionInterface = {
  /** Timestamp of the discussion's creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the discussion. */
  id: Scalars['DiscussionID']['output'];
  /** ID used to reply to the discussion. */
  replyId: Scalars['DiscussionID']['output'];
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean']['output'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean']['output'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};

export type BaseHeaderInterface = {
  /** Header is active or not. */
  active: Scalars['Boolean']['output'];
  /** ID of the header. */
  id: Scalars['ID']['output'];
  /** Key of the header. */
  key: Scalars['String']['output'];
  /** Value of the header. */
  value: Scalars['String']['output'];
};

export type BaseNoteInterface = {
  /** User who wrote the note. */
  author?: Maybe<UserCore>;
  /** List of emoji reactions associated with the note. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Content of the note. */
  body: Scalars['String']['output'];
  /** First line of the note content. */
  bodyFirstLineHtml: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of the content of the note. */
  bodyHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the note creation. */
  createdAt: Scalars['Time']['output'];
  /** Timestamp when note was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']['output']>;
  /** User who last edited the note. */
  lastEditedBy?: Maybe<UserCore>;
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean']['output'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean']['output'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
  /** Timestamp of the note's last activity. */
  updatedAt: Scalars['Time']['output'];
  /** URL to view the note in the Web UI. */
  url?: Maybe<Scalars['String']['output']>;
};


export type BaseNoteInterfaceAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BaseService = Service & {
  __typename?: 'BaseService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']['output']>;
};

export type Blame = {
  __typename?: 'Blame';
  /** First line of Git Blame for given range. */
  firstLine?: Maybe<Scalars['String']['output']>;
  /** Git Blame grouped by contiguous lines for commit. */
  groups?: Maybe<Array<Groups>>;
};

export type Blob = Entry & {
  __typename?: 'Blob';
  /** Flat path of the entry. */
  flatPath: Scalars['String']['output'];
  /** ID of the entry. */
  id: Scalars['ID']['output'];
  /** LFS ID of the blob. */
  lfsOid?: Maybe<Scalars['String']['output']>;
  /** Blob mode in numeric format. */
  mode?: Maybe<Scalars['String']['output']>;
  /** Name of the entry. */
  name: Scalars['String']['output'];
  /** Path of the entry. */
  path: Scalars['String']['output'];
  /** SHA of the entry. */
  sha: Scalars['String']['output'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']['output']>;
  /** Web URL of the blob. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Blob. */
export type BlobConnection = {
  __typename?: 'BlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Blob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BlobEdge = {
  __typename?: 'BlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Blob>;
};

/** Full JSON structure of multi-match results in a single file */
export type BlobSearch = {
  __typename?: 'BlobSearch';
  /**
   * Duration of the request in seconds. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  durationS?: Maybe<Scalars['Float']['output']>;
  /**
   * Total number of files with matches. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  fileCount?: Maybe<Scalars['Int']['output']>;
  /**
   * List of files with matches. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  files?: Maybe<Array<SearchBlobFileType>>;
  /**
   * Total number of matches. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  matchCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Total number of files per page. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  perPage?: Maybe<Scalars['Int']['output']>;
  /**
   * Level of search performed. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  searchLevel?: Maybe<SearchLevel>;
  /**
   * Type of search performed. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  searchType?: Maybe<SearchType>;
};

/** Represents how the blob content should be displayed */
export type BlobViewer = {
  __typename?: 'BlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean']['output'];
  /** Content file type. */
  fileType: Scalars['String']['output'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean']['output'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String']['output'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']['output']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean']['output'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** Types of blob viewers */
export type BlobViewersType =
  /** Auxiliary blob viewers type. */
  | 'auxiliary'
  /** Rich blob viewers type. */
  | 'rich'
  /** Simple blob viewers type. */
  | 'simple';

/** Information about the rules that must be satisfied to merge this merge request. */
export type BlockingMergeRequests = {
  __typename?: 'BlockingMergeRequests';
  /** Blocking merge requests not visible to the user. */
  hiddenCount: Scalars['Int']['output'];
  /** Total number of blocking merge requests. */
  totalCount: Scalars['Int']['output'];
  /** Blocking merge requests visible to the user. */
  visibleMergeRequests?: Maybe<Array<MergeRequest>>;
};

/** Represents a project or group issue board */
export type Board = {
  __typename?: 'Board';
  /** Board assignee. */
  assignee?: Maybe<UserCore>;
  /** Timestamp of when the board was created. */
  createdAt: Scalars['Time']['output'];
  /** Epics associated with board issues. */
  epics?: Maybe<BoardEpicConnection>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']['output']>;
  /** ID (global ID) of the board. */
  id: Scalars['ID']['output'];
  /** Board iteration. */
  iteration?: Maybe<Iteration>;
  /** Board iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Lists of the board. */
  lists?: Maybe<BoardListConnection>;
  /** Board milestone. */
  milestone?: Maybe<Milestone>;
  /** Name of the board. */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the board was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Web path of the board. */
  webPath: Scalars['String']['output'];
  /** Web URL of the board. */
  webUrl: Scalars['String']['output'];
  /** Weight of the board. */
  weight?: Maybe<Scalars['Int']['output']>;
};


/** Represents a project or group issue board */
export type BoardEpicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  issueFilters?: InputMaybe<BoardIssueInput>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a project or group issue board */
export type BoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a project or group issue board */
export type BoardListsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ListID']['input']>;
  issueFilters?: InputMaybe<BoardIssueInput>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Board. */
export type BoardConnection = {
  __typename?: 'BoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Board>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BoardEdge = {
  __typename?: 'BoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Board>;
};

/** Represents an epic on an issue board */
export type BoardEpic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'BoardEpic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of emoji reactions associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']['output']>;
  /** Count of epics blocking the epic. */
  blockedByCount?: Maybe<Scalars['Int']['output']>;
  /** Epics blocking the epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that the epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']['output']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** Color of the epic. */
  color?: Maybe<Scalars['String']['output']>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int']['output'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']['output']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']['output']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']['output']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean']['output'];
  /** Indicates if the epic has children in the specified timeframe. */
  hasChildrenWithinTimeframe: Scalars['Boolean']['output'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean']['output'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean']['output'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID']['output'];
  /** Internal ID of the epic. */
  iid: Scalars['String']['output'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** Work items linked to the epic. */
  linkedWorkItems?: Maybe<LinkedWorkItemTypeConnection>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']['output']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']['output']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']['output']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']['output']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']['output']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean']['output'];
  /** Text color generated for the epic. */
  textColor?: Maybe<Scalars['String']['output']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int']['output'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int']['output'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** User preferences for the epic on the issue board. */
  userPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Web path of the epic. */
  webPath: Scalars['String']['output'];
  /** Web URL of the epic. */
  webUrl: Scalars['String']['output'];
  /** ID of the corresponding work item for a legacy epic. */
  workItemId: Scalars['WorkItemID']['output'];
};


/** Represents an epic on an issue board */
export type BoardEpicAncestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic on an issue board */
export type BoardEpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicLinkedWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WorkItemRelatedLinkType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic on an issue board */
export type BoardEpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The connection type for BoardEpic. */
export type BoardEpicConnection = {
  __typename?: 'BoardEpicConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardEpic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for BoardEpic. */
export type BoardEpicConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of BoardEpicCreate */
export type BoardEpicCreateInput = {
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group the epic to create is in. */
  groupPath: Scalars['ID']['input'];
  /** Global ID of the epic board list in which epic will be created. */
  listId: Scalars['BoardsEpicListID']['input'];
  /** Title of the epic. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of BoardEpicCreate. */
export type BoardEpicCreatePayload = {
  __typename?: 'BoardEpicCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after creation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type BoardEpicEdge = {
  __typename?: 'BoardEpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardEpic>;
};

/** Represents user preferences for a board epic */
export type BoardEpicUserPreferences = {
  __typename?: 'BoardEpicUserPreferences';
  /** Indicates epic should be displayed as collapsed. */
  collapsed: Scalars['Boolean']['output'];
};

export type BoardIssueInput = {
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by epic ID wildcard. Incompatible with epicId. */
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  /** Health status of the issue, "none" and "any" values are supported. */
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Whether to include subepics when filtering issues by epicId. */
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by a list of iteration cadence IDs. */
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']['input']>>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** List of negated arguments. */
  not?: InputMaybe<NegatedBoardIssueInput>;
  /** List of arguments with inclusive OR. */
  or?: InputMaybe<UnionedIssueFilterInput>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  /** Search query for issue title or description. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']['input']>;
  /** Filter by weight ID wildcard. Incompatible with weight. */
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};

/** Represents a list for an issue board */
export type BoardList = {
  __typename?: 'BoardList';
  /** Assignee in the list. */
  assignee?: Maybe<UserCore>;
  /** Indicates if the list is collapsed for the user. */
  collapsed?: Maybe<Scalars['Boolean']['output']>;
  /** ID (global ID) of the list. */
  id: Scalars['ID']['output'];
  /** Board issues. */
  issues?: Maybe<IssueConnection>;
  /** Count of issues in the list. */
  issuesCount?: Maybe<Scalars['Int']['output']>;
  /** Iteration of the list. */
  iteration?: Maybe<Iteration>;
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Current limit metric for the list. */
  limitMetric?: Maybe<ListLimitMetric>;
  /** Type of the list. */
  listType: Scalars['String']['output'];
  /** Maximum number of issues in the list. */
  maxIssueCount?: Maybe<Scalars['Int']['output']>;
  /** Maximum weight of issues in the list. */
  maxIssueWeight?: Maybe<Scalars['Int']['output']>;
  /** Milestone of the list. */
  milestone?: Maybe<Milestone>;
  /** Position of list within the board. */
  position?: Maybe<Scalars['Int']['output']>;
  /**
   * Status of the list. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  status?: Maybe<WorkItemStatus>;
  /** Title of the list. */
  title: Scalars['String']['output'];
  /** Total weight of all issues in the list, encoded as a string. */
  totalIssueWeight?: Maybe<Scalars['BigInt']['output']>;
};


/** Represents a list for an issue board */
export type BoardListIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<BoardIssueInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for BoardList. */
export type BoardListConnection = {
  __typename?: 'BoardListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BoardListCreate */
export type BoardListCreateInput = {
  /** Global ID of an existing user. */
  assigneeId?: InputMaybe<Scalars['UserID']['input']>;
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of an existing iteration. */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']['input']>;
  /** Global ID of an existing milestone. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
  /** Position of the list. */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of BoardListCreate. */
export type BoardListCreatePayload = {
  __typename?: 'BoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue list in the issue board. */
  list?: Maybe<BoardList>;
};

/** An edge in a connection. */
export type BoardListEdge = {
  __typename?: 'BoardListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardList>;
};

/** Autogenerated input type of BoardListUpdateLimitMetrics */
export type BoardListUpdateLimitMetricsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New limit metric type for the list. */
  limitMetric?: InputMaybe<ListLimitMetric>;
  /** Global ID of the list. */
  listId: Scalars['ListID']['input'];
  /** New maximum issue count limit. */
  maxIssueCount?: InputMaybe<Scalars['Int']['input']>;
  /** New maximum issue weight limit. */
  maxIssueWeight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of BoardListUpdateLimitMetrics. */
export type BoardListUpdateLimitMetricsPayload = {
  __typename?: 'BoardListUpdateLimitMetricsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated list. */
  list?: Maybe<BoardList>;
};

/** an expression with a boolean value. */
export type BooleanExpression = ExpressionInterface & {
  __typename?: 'BooleanExpression';
  /** Field the expression applies to. */
  field: Scalars['String']['output'];
  /** Operator of the expression. */
  operator: Scalars['String']['output'];
  /** Boolean value of the expression. */
  value: Scalars['Boolean']['output'];
};

export type Branch = {
  __typename?: 'Branch';
  /** Commit for the branch. */
  commit?: Maybe<Commit>;
  /** Name of the branch. */
  name: Scalars['String']['output'];
};

/** Autogenerated input type of BranchDelete */
export type BranchDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the branch. */
  name: Scalars['String']['input'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of BranchDelete. */
export type BranchDeletePayload = {
  __typename?: 'BranchDeletePayload';
  /** Branch after mutation. */
  branch?: Maybe<Branch>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Branch protection details for a branch rule. */
export type BranchProtection = {
  __typename?: 'BranchProtection';
  /** Toggle force push to the branch for users with write access. */
  allowForcePush: Scalars['Boolean']['output'];
  /** Enforce code owner approvals before allowing a merge. */
  codeOwnerApprovalRequired: Scalars['Boolean']['output'];
  /**
   * Indicates whether the branch protection rule was created at the group level. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  isGroupLevel: Scalars['Boolean']['output'];
  /** Details about who can merge when the branch is the source branch. */
  mergeAccessLevels?: Maybe<MergeAccessLevelConnection>;
  /** Indicates if a security policy prevents modification. */
  modificationBlockedByPolicy: Scalars['Boolean']['output'];
  /** Indicates if a security policy prevents push or force push. */
  protectedFromPushBySecurityPolicy: Scalars['Boolean']['output'];
  /** Details about who can push when the branch is the source branch. */
  pushAccessLevels?: Maybe<PushAccessLevelConnection>;
  /** Details about who can unprotect the branch. */
  unprotectAccessLevels?: Maybe<UnprotectAccessLevelConnection>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionMergeAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionPushAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionUnprotectAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BranchProtectionInput = {
  /** Allows users with write access to the branch rule target to force push changes. */
  allowForcePush?: InputMaybe<Scalars['Boolean']['input']>;
  /** Enforce code owner approvals before allowing a merge. */
  codeOwnerApprovalRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** Details about who can merge into the branch rule target. */
  mergeAccessLevels?: InputMaybe<Array<MergeAccessLevelInput>>;
  /** Details about who can push to the branch rule target. */
  pushAccessLevels?: InputMaybe<Array<PushAccessLevelInput>>;
};

/** Branch rules configured for a rule target. */
export type BranchRule = {
  __typename?: 'BranchRule';
  /** Merge request approval rules configured for the branch rule. */
  approvalRules?: Maybe<ApprovalProjectRuleConnection>;
  /** Branch protections configured for the branch rule. */
  branchProtection?: Maybe<BranchProtection>;
  /** Timestamp of when the branch rule was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** External status checks configured for the branch rule. */
  externalStatusChecks?: Maybe<ExternalStatusCheckConnection>;
  /** ID of the branch rule. */
  id?: Maybe<Scalars['ProjectsBranchRuleID']['output']>;
  /** Check if the branch rule protects the project's default branch. */
  isDefault: Scalars['Boolean']['output'];
  /** Check if the branch rule protects access for the branch. */
  isProtected: Scalars['Boolean']['output'];
  /** Number of existing branches that match the branch rule. */
  matchingBranchesCount: Scalars['Int']['output'];
  /** Name of the branch rule target. Includes wildcards. */
  name: Scalars['String']['output'];
  /**
   * Default behavior for squashing in merge requests. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  squashOption?: Maybe<SquashOption>;
  /** Timestamp of when the branch rule was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};


/** Branch rules configured for a rule target. */
export type BranchRuleApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Branch rules configured for a rule target. */
export type BranchRuleExternalStatusChecksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for BranchRule. */
export type BranchRuleConnection = {
  __typename?: 'BranchRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BranchRuleCreate */
export type BranchRuleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Branch name, with wildcards, for the branch rules. */
  name: Scalars['String']['input'];
  /** Full path to the project that the branch is associated with. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of BranchRuleCreate. */
export type BranchRuleCreatePayload = {
  __typename?: 'BranchRuleCreatePayload';
  /** Branch rule after mutation. */
  branchRule?: Maybe<BranchRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BranchRuleDelete */
export type BranchRuleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the branch rule to destroy. */
  id: Scalars['ProjectsBranchRuleID']['input'];
};

/** Autogenerated return type of BranchRuleDelete. */
export type BranchRuleDeletePayload = {
  __typename?: 'BranchRuleDeletePayload';
  /** Branch rule after mutation. */
  branchRule?: Maybe<BranchRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type BranchRuleEdge = {
  __typename?: 'BranchRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BranchRule>;
};

/** Autogenerated input type of BranchRuleExternalStatusCheckCreate */
export type BranchRuleExternalStatusCheckCreateInput = {
  /** Global ID of the branch rule to update. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** URL of external status check resource. */
  externalUrl: Scalars['String']['input'];
  /** Name of the external status check. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of BranchRuleExternalStatusCheckCreate. */
export type BranchRuleExternalStatusCheckCreatePayload = {
  __typename?: 'BranchRuleExternalStatusCheckCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** New status check after mutation. */
  externalStatusCheck?: Maybe<ExternalStatusCheck>;
};

/** Autogenerated input type of BranchRuleExternalStatusCheckDestroy */
export type BranchRuleExternalStatusCheckDestroyInput = {
  /** Global ID of the branch rule. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the external status check to destroy. */
  id: Scalars['MergeRequestsExternalStatusCheckID']['input'];
};

/** Autogenerated return type of BranchRuleExternalStatusCheckDestroy. */
export type BranchRuleExternalStatusCheckDestroyPayload = {
  __typename?: 'BranchRuleExternalStatusCheckDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BranchRuleExternalStatusCheckUpdate */
export type BranchRuleExternalStatusCheckUpdateInput = {
  /** Global ID of the branch rule. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** External URL of the external status check. */
  externalUrl: Scalars['String']['input'];
  /** Global ID of the external status check to update. */
  id: Scalars['MergeRequestsExternalStatusCheckID']['input'];
  /** Name of the external status check. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of BranchRuleExternalStatusCheckUpdate. */
export type BranchRuleExternalStatusCheckUpdatePayload = {
  __typename?: 'BranchRuleExternalStatusCheckUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated external status check after mutation. */
  externalStatusCheck?: Maybe<ExternalStatusCheck>;
};

/** Autogenerated input type of BranchRuleSquashOptionDelete */
export type BranchRuleSquashOptionDeleteInput = {
  /** Global ID of the branch rule. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of BranchRuleSquashOptionDelete. */
export type BranchRuleSquashOptionDeletePayload = {
  __typename?: 'BranchRuleSquashOptionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BranchRuleSquashOptionUpdate */
export type BranchRuleSquashOptionUpdateInput = {
  /** Global ID of the branch rule. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Squash option after mutation. */
  squashOption: SquashOptionSetting;
};

/** Autogenerated return type of BranchRuleSquashOptionUpdate. */
export type BranchRuleSquashOptionUpdatePayload = {
  __typename?: 'BranchRuleSquashOptionUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated squash option after mutation. */
  squashOption?: Maybe<SquashOption>;
};

/** Autogenerated input type of BranchRuleUpdate */
export type BranchRuleUpdateInput = {
  /** Branch protections configured for the branch rule. */
  branchProtection?: InputMaybe<BranchProtectionInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the branch rule to update. */
  id: Scalars['ProjectsBranchRuleID']['input'];
  /** Branch name, with wildcards, for the branch rules. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of BranchRuleUpdate. */
export type BranchRuleUpdatePayload = {
  __typename?: 'BranchRuleUpdatePayload';
  /** Branch rule after mutation. */
  branchRule?: Maybe<BranchRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkDestroyJobArtifacts */
export type BulkDestroyJobArtifactsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the job artifacts to destroy. */
  ids: Array<Scalars['CiJobArtifactID']['input']>;
  /** Global Project ID of the job artifacts to destroy. Incompatible with projectPath. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of BulkDestroyJobArtifacts. */
export type BulkDestroyJobArtifactsPayload = {
  __typename?: 'BulkDestroyJobArtifactsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Number of job artifacts deleted. */
  destroyedCount?: Maybe<Scalars['Int']['output']>;
  /** IDs of job artifacts that were deleted. */
  destroyedIds?: Maybe<Array<Scalars['CiJobArtifactID']['output']>>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkEnableDevopsAdoptionNamespaces */
export type BulkEnableDevopsAdoptionNamespacesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** List of Namespace IDs. */
  namespaceIds: Array<Scalars['NamespaceID']['input']>;
};

/** Autogenerated return type of BulkEnableDevopsAdoptionNamespaces. */
export type BulkEnableDevopsAdoptionNamespacesPayload = {
  __typename?: 'BulkEnableDevopsAdoptionNamespacesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Enabled namespaces after mutation. */
  enabledNamespaces?: Maybe<Array<DevopsAdoptionEnabledNamespace>>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkRunnerDelete */
export type BulkRunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the runners to delete. */
  ids?: InputMaybe<Array<Scalars['CiRunnerID']['input']>>;
};

/** Autogenerated return type of BulkRunnerDelete. */
export type BulkRunnerDeletePayload = {
  __typename?: 'BulkRunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Number of records effectively deleted. Only present if operation was performed synchronously. */
  deletedCount?: Maybe<Scalars['Int']['output']>;
  /** IDs of records effectively deleted. Only present if operation was performed synchronously. */
  deletedIds?: Maybe<Array<Scalars['CiRunnerID']['output']>>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkUpdateSecurityAttributes */
export type BulkUpdateSecurityAttributesInput = {
  /** Global IDs of security attributes to apply. */
  attributes: Array<Scalars['SecurityAttributeID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of groups and projects to update. */
  items: Array<Scalars['ID']['input']>;
  /** Update mode: add, remove, or replace attributes. */
  mode: SecurityAttributeBulkUpdateMode;
};

/** Autogenerated return type of BulkUpdateSecurityAttributes. */
export type BulkUpdateSecurityAttributesPayload = {
  __typename?: 'BulkUpdateSecurityAttributesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered while initiating the bulk update operation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents the total number of issues and their weights for a particular day */
export type BurnupChartDailyTotals = {
  __typename?: 'BurnupChartDailyTotals';
  /** Number of closed issues as of the day. */
  completedCount: Scalars['Int']['output'];
  /** Total weight of closed issues as of the day. */
  completedWeight: Scalars['Int']['output'];
  /** Date for burnup totals. */
  date: Scalars['ISO8601Date']['output'];
  /** Number of issues as of the day. */
  scopeCount: Scalars['Int']['output'];
  /** Total weight of issues as of the day. */
  scopeWeight: Scalars['Int']['output'];
};

/** Check user's permission for the car. */
export type CarPermissions = {
  __typename?: 'CarPermissions';
  /** If `true`, the user can perform `delete_merge_train_car` on this resource */
  deleteMergeTrainCar: Scalars['Boolean']['output'];
};

/** Status of a merge train's car */
export type CarStatus =
  /** Car's status: fresh */
  | 'FRESH'
  /** Car's status: idle */
  | 'IDLE'
  /** Car's status: merged */
  | 'MERGED'
  /** Car's status: merging */
  | 'MERGING'
  /** Car's status: skip_merged */
  | 'SKIP_MERGED'
  /** Car's status: stale */
  | 'STALE';

/** Autogenerated input type of CatalogResourcesCreate */
export type CatalogResourcesCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project path belonging to the catalog resource. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CatalogResourcesCreate. */
export type CatalogResourcesCreatePayload = {
  __typename?: 'CatalogResourcesCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CatalogResourcesDestroy */
export type CatalogResourcesDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project path belonging to the catalog resource. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CatalogResourcesDestroy. */
export type CatalogResourcesDestroyPayload = {
  __typename?: 'CatalogResourcesDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CiApplicationSettings = {
  __typename?: 'CiApplicationSettings';
  /** Whether to keep the latest jobs artifacts. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']['output']>;
};

export type CiBuildNeed = {
  __typename?: 'CiBuildNeed';
  /** ID of the BuildNeed. */
  id: Scalars['ID']['output'];
  /** Name of the job we need to complete. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiBuildNeed. */
export type CiBuildNeedConnection = {
  __typename?: 'CiBuildNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiBuildNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiBuildNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiBuildNeedEdge = {
  __typename?: 'CiBuildNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiBuildNeed>;
};

export type CiCatalogResource = {
  __typename?: 'CiCatalogResource';
  /** Indicates the archived status of the project. */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the catalog resource. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Full project path of the catalog resource. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  fullPath?: Maybe<Scalars['ID']['output']>;
  /** Icon for the catalog resource. */
  icon?: Maybe<Scalars['String']['output']>;
  /** ID of the catalog resource. */
  id: Scalars['ID']['output'];
  /**
   * Number of projects that used a component fromthis catalog resource in a pipeline, by using `include:component` in the last 30 days. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  last30DayUsageCount: Scalars['Int']['output'];
  /**
   * Release date of the catalog resource's latest version. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  latestReleasedAt?: Maybe<Scalars['Time']['output']>;
  /** Name of the catalog resource. */
  name?: Maybe<Scalars['String']['output']>;
  /** Number of times the catalog resource has been starred. */
  starCount: Scalars['Int']['output'];
  /** Relative path to the starrers page for the catalog resource project. */
  starrersPath?: Maybe<Scalars['String']['output']>;
  /** Topics for the catalog resource. */
  topics?: Maybe<Array<Scalars['String']['output']>>;
  /** Verification level of the catalog resource. */
  verificationLevel?: Maybe<CiCatalogResourceVerificationLevel>;
  /** Versions of the catalog resource. This field can only be resolved for one catalog resource in any single request. */
  versions?: Maybe<CiCatalogResourceVersionConnection>;
  /** Visibility level of the catalog resource. */
  visibilityLevel?: Maybe<VisibilityLevelsEnum>;
  /**
   * Web path of the catalog resource. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  webPath?: Maybe<Scalars['String']['output']>;
};


export type CiCatalogResourceVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CiCatalogResourceComponent = {
  __typename?: 'CiCatalogResourceComponent';
  /** ID of the component. */
  id: Scalars['CiCatalogResourcesComponentID']['output'];
  /** Path used to include the component. */
  includePath?: Maybe<Scalars['String']['output']>;
  /** Inputs for the component. */
  inputs?: Maybe<Array<CiInputsSpec>>;
  /** Number of times the component has been used in the last 30 days in a pipeline using `include`. */
  last30DayUsageCount?: Maybe<Scalars['Int']['output']>;
  /** Name of the component. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiCatalogResourceComponent. */
export type CiCatalogResourceComponentConnection = {
  __typename?: 'CiCatalogResourceComponentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiCatalogResourceComponentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiCatalogResourceComponent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiCatalogResourceComponentEdge = {
  __typename?: 'CiCatalogResourceComponentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiCatalogResourceComponent>;
};

/** Represents a component usage in a project */
export type CiCatalogResourceComponentUsage = {
  __typename?: 'CiCatalogResourceComponentUsage';
  /** When the component was last used. */
  lastUsedDate?: Maybe<Scalars['ISO8601Date']['output']>;
  /** Name of the component. */
  name?: Maybe<Scalars['String']['output']>;
  /** Version of the component. */
  version?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiCatalogResourceComponentUsage. */
export type CiCatalogResourceComponentUsageConnection = {
  __typename?: 'CiCatalogResourceComponentUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiCatalogResourceComponentUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiCatalogResourceComponentUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiCatalogResourceComponentUsageEdge = {
  __typename?: 'CiCatalogResourceComponentUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiCatalogResourceComponentUsage>;
};

/** The connection type for CiCatalogResource. */
export type CiCatalogResourceConnection = {
  __typename?: 'CiCatalogResourceConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiCatalogResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiCatalogResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiCatalogResource. */
export type CiCatalogResourceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiCatalogResourceEdge = {
  __typename?: 'CiCatalogResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiCatalogResource>;
};

/** Values for scoping catalog resources */
export type CiCatalogResourceScope =
  /** All catalog resources visible to the current user. */
  | 'ALL'
  /** Catalog resources belonging to authorized namespaces of the user. */
  | 'NAMESPACES';

/** Values for sorting catalog resources */
export type CiCatalogResourceSort =
  /** Created date by ascending order. */
  | 'CREATED_ASC'
  /** Created date by descending order. */
  | 'CREATED_DESC'
  /** Latest release date by ascending order. */
  | 'LATEST_RELEASED_AT_ASC'
  /** Latest release date by descending order. */
  | 'LATEST_RELEASED_AT_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Star count by ascending order. */
  | 'STAR_COUNT_ASC'
  /** Star count by descending order. */
  | 'STAR_COUNT_DESC'
  /** Last 30-day usage count by ascending order. */
  | 'USAGE_COUNT_ASC'
  /** Last 30-day usage count by descending order. */
  | 'USAGE_COUNT_DESC';

export type CiCatalogResourceVerificationLevel =
  /** The resource is Gitlab Maintained */
  | 'GITLAB_MAINTAINED'
  /** The resource is Gitlab Partner Maintained */
  | 'GITLAB_PARTNER_MAINTAINED'
  /** The resource is Unverified */
  | 'UNVERIFIED'
  /** The resource is Verified Creator Maintained */
  | 'VERIFIED_CREATOR_MAINTAINED'
  /** The resource is Verified Creator Self Managed */
  | 'VERIFIED_CREATOR_SELF_MANAGED';

export type CiCatalogResourceVersion = {
  __typename?: 'CiCatalogResourceVersion';
  /** User that created the version. */
  author?: Maybe<UserCore>;
  /** Commit associated with the version. */
  commit?: Maybe<Commit>;
  /** Components belonging to the catalog resource. */
  components?: Maybe<CiCatalogResourceComponentConnection>;
  /** Timestamp of when the version was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Global ID of the version. */
  id: Scalars['CiCatalogResourcesVersionID']['output'];
  /** Name that uniquely identifies the version within the catalog resource. */
  name?: Maybe<Scalars['String']['output']>;
  /** Relative web path to the version. */
  path?: Maybe<Scalars['String']['output']>;
  /** Readme data. */
  readme?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `readme` */
  readmeHtml?: Maybe<Scalars['String']['output']>;
  /**
   * Timestamp of when the version was released. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  releasedAt?: Maybe<Scalars['Time']['output']>;
};


export type CiCatalogResourceVersionComponentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiCatalogResourceVersion. */
export type CiCatalogResourceVersionConnection = {
  __typename?: 'CiCatalogResourceVersionConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiCatalogResourceVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiCatalogResourceVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiCatalogResourceVersion. */
export type CiCatalogResourceVersionConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiCatalogResourceVersionEdge = {
  __typename?: 'CiCatalogResourceVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiCatalogResourceVersion>;
};

export type CiCdSettings = {
  __typename?: 'CiCdSettings';
  /** Indicates the default minimum role required to override pipeline variables in the namespace. */
  pipelineVariablesDefaultRole?: Maybe<Scalars['String']['output']>;
};

export type CiConfig = {
  __typename?: 'CiConfig';
  /** Linting errors. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** List of included files. */
  includes?: Maybe<Array<CiConfigInclude>>;
  /** Merged CI configuration YAML. */
  mergedYaml?: Maybe<Scalars['String']['output']>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiConfigStageConnection>;
  /** Status of linting, can be either valid or invalid. */
  status?: Maybe<CiConfigStatus>;
  /** Linting warnings. */
  warnings?: Maybe<Array<Scalars['String']['output']>>;
};


export type CiConfigStagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type CiConfigGroup = {
  __typename?: 'CiConfigGroup';
  /** Jobs in group. */
  jobs?: Maybe<CiConfigJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']['output']>;
  /** Size of the job group. */
  size?: Maybe<Scalars['Int']['output']>;
};


export type CiConfigGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiConfigGroup. */
export type CiConfigGroupConnection = {
  __typename?: 'CiConfigGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigGroupEdge = {
  __typename?: 'CiConfigGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigGroup>;
};

export type CiConfigGroupV2 = {
  __typename?: 'CiConfigGroupV2';
  /** Jobs in group. */
  jobs?: Maybe<Array<CiConfigJobV2>>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']['output']>;
  /** Size of the job group. */
  size?: Maybe<Scalars['Int']['output']>;
};

export type CiConfigInclude = {
  __typename?: 'CiConfigInclude';
  /** File blob location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`. */
  blob?: Maybe<Scalars['String']['output']>;
  /** Current project scope, e.g., "gitlab-org/gitlab". */
  contextProject?: Maybe<Scalars['String']['output']>;
  /** Current sha scope. */
  contextSha?: Maybe<Scalars['String']['output']>;
  /** Extra information for the `include`, which can contain `job_name`, `project`, and `ref`. Values can be masked if they contain masked variables. */
  extra?: Maybe<Scalars['JSON']['output']>;
  /** File location. It can be masked if it contains masked variables. For example, `".gitlab/ci/build-images.gitlab-ci.yml"`. */
  location?: Maybe<Scalars['String']['output']>;
  /** File raw location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`. */
  raw?: Maybe<Scalars['String']['output']>;
  /** Include type. */
  type?: Maybe<CiConfigIncludeType>;
};

/** Include type. */
export type CiConfigIncludeType =
  /** Component include. */
  | 'component'
  /** Project file include. */
  | 'file'
  /** Local include. */
  | 'local'
  /** Remote include. */
  | 'remote'
  /** Template include. */
  | 'template';

export type CiConfigJob = {
  __typename?: 'CiConfigJob';
  /** Override a set of commands that are executed after the job. */
  afterScript?: Maybe<Array<Scalars['String']['output']>>;
  /** Allow job to fail. */
  allowFailure?: Maybe<Scalars['Boolean']['output']>;
  /** Override a set of commands that are executed before the job. */
  beforeScript?: Maybe<Array<Scalars['String']['output']>>;
  /** Name of an environment to which the job deploys. */
  environment?: Maybe<Scalars['String']['output']>;
  /** Limit when jobs are not created. */
  except?: Maybe<CiConfigJobRestriction>;
  /** Name of the job group. */
  groupName?: Maybe<Scalars['String']['output']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']['output']>;
  /** Builds that must complete before the jobs run. */
  needs?: Maybe<CiConfigNeedConnection>;
  /** Jobs are created when these conditions do not apply. */
  only?: Maybe<CiConfigJobRestriction>;
  /** Shell script that is executed by a runner. */
  script?: Maybe<Array<Scalars['String']['output']>>;
  /** Name of the job stage. */
  stage?: Maybe<Scalars['String']['output']>;
  /** List of tags that are used to select a runner. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** When to run the job. */
  when?: Maybe<Scalars['String']['output']>;
};


export type CiConfigJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiConfigJob. */
export type CiConfigJobConnection = {
  __typename?: 'CiConfigJobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigJobEdge = {
  __typename?: 'CiConfigJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigJob>;
};

export type CiConfigJobRestriction = {
  __typename?: 'CiConfigJobRestriction';
  /** Git refs the job restriction applies to. */
  refs?: Maybe<Array<Scalars['String']['output']>>;
};

export type CiConfigJobV2 = {
  __typename?: 'CiConfigJobV2';
  /** Override a set of commands that are executed after the job. */
  afterScript?: Maybe<Array<Scalars['String']['output']>>;
  /** Allow job to fail. */
  allowFailure?: Maybe<Scalars['Boolean']['output']>;
  /** Override a set of commands that are executed before the job. */
  beforeScript?: Maybe<Array<Scalars['String']['output']>>;
  /** Name of an environment to which the job deploys. */
  environment?: Maybe<Scalars['String']['output']>;
  /** Limit when jobs are not created. */
  except?: Maybe<CiConfigJobRestriction>;
  /** Name of the job group. */
  groupName?: Maybe<Scalars['String']['output']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']['output']>;
  /** Builds that must complete before the jobs run. */
  needs?: Maybe<Array<CiConfigNeed>>;
  /** Jobs are created when these conditions do not apply. */
  only?: Maybe<CiConfigJobRestriction>;
  /** Shell script that is executed by a runner. */
  script?: Maybe<Array<Scalars['String']['output']>>;
  /** Name of the job stage. */
  stage?: Maybe<Scalars['String']['output']>;
  /** List of tags that are used to select a runner. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** When to run the job. */
  when?: Maybe<Scalars['String']['output']>;
};

export type CiConfigNeed = {
  __typename?: 'CiConfigNeed';
  /** Name of the need. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiConfigNeed. */
export type CiConfigNeedConnection = {
  __typename?: 'CiConfigNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigNeedEdge = {
  __typename?: 'CiConfigNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigNeed>;
};

export type CiConfigStage = {
  __typename?: 'CiConfigStage';
  /** Groups of jobs for the stage. */
  groups?: Maybe<CiConfigGroupConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']['output']>;
};


export type CiConfigStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiConfigStage. */
export type CiConfigStageConnection = {
  __typename?: 'CiConfigStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigStageEdge = {
  __typename?: 'CiConfigStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigStage>;
};

export type CiConfigStageV2 = {
  __typename?: 'CiConfigStageV2';
  /** Groups of jobs for the stage. */
  groups?: Maybe<Array<CiConfigGroupV2>>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Values for YAML processor result */
export type CiConfigStatus =
  /** Configuration file is not valid. */
  | 'INVALID'
  /** Configuration file is valid. */
  | 'VALID';

export type CiConfigV2 = {
  __typename?: 'CiConfigV2';
  /** Linting errors. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** List of included files. */
  includes?: Maybe<Array<CiConfigInclude>>;
  /** Merged CI configuration YAML. */
  mergedYaml?: Maybe<Scalars['String']['output']>;
  /** Stages of the pipeline. */
  stages?: Maybe<Array<CiConfigStageV2>>;
  /** Status of linting, can be either valid or invalid. */
  status?: Maybe<CiConfigStatus>;
  /** Linting warnings. */
  warnings?: Maybe<Array<Scalars['String']['output']>>;
};

/** CI/CD config variables. */
export type CiConfigVariable = {
  __typename?: 'CiConfigVariable';
  /** Description for the CI/CD config variable. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Value options for the variable. */
  valueOptions?: Maybe<Array<Scalars['String']['output']>>;
};

/** Filter options available for GitLab Dedicated runner usage data. */
export type CiDedicatedHostedRunnerFilters = {
  __typename?: 'CiDedicatedHostedRunnerFilters';
  /** List of runner IDs from usage data without associated runner records. */
  deletedRunners?: Maybe<CiDeletedRunnerConnection>;
  /** List of unique runners with usage data. */
  runners?: Maybe<CiRunnerConnection>;
  /** List of years with available usage data. */
  years?: Maybe<Array<Scalars['Int']['output']>>;
};


/** Filter options available for GitLab Dedicated runner usage data. */
export type CiDedicatedHostedRunnerFiltersDeletedRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Filter options available for GitLab Dedicated runner usage data. */
export type CiDedicatedHostedRunnerFiltersRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Compute usage data for hosted runners on GitLab Dedicated. */
export type CiDedicatedHostedRunnerUsage = {
  __typename?: 'CiDedicatedHostedRunnerUsage';
  /** Month of the usage data. */
  billingMonth: Scalars['String']['output'];
  /** Timestamp of the billing month in ISO 8601 format. */
  billingMonthIso8601: Scalars['ISO8601Date']['output'];
  /** Total compute minutes used across all namespaces. Values are rounded down to the nearest integer. */
  computeMinutes: Scalars['Int']['output'];
  /** Total compute minutes used across all namespaces. */
  computeMinutesUsage: Scalars['Float']['output'];
  /** Total duration in minutes of runner usage. */
  durationMinutes: Scalars['Float']['output'];
  /** Total duration in seconds of runner usage. Values are rounded down to the nearest integer. */
  durationSeconds: Scalars['Int']['output'];
  /** Namespace associated with the usage data. Null for instance aggregate data. */
  rootNamespace?: Maybe<NamespaceUnion>;
};

/** The connection type for CiDedicatedHostedRunnerUsage. */
export type CiDedicatedHostedRunnerUsageConnection = {
  __typename?: 'CiDedicatedHostedRunnerUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiDedicatedHostedRunnerUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiDedicatedHostedRunnerUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiDedicatedHostedRunnerUsageEdge = {
  __typename?: 'CiDedicatedHostedRunnerUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiDedicatedHostedRunnerUsage>;
};

/** Reference to a namespace that no longer exists */
export type CiDeletedNamespace = {
  __typename?: 'CiDeletedNamespace';
  /** ID of the deleted namespace. */
  id?: Maybe<Scalars['NamespaceID']['output']>;
};

/** Reference to a deleted runner */
export type CiDeletedRunner = {
  __typename?: 'CiDeletedRunner';
  /** Global ID of the deleted runner. */
  id: Scalars['CiRunnerID']['output'];
};

/** The connection type for CiDeletedRunner. */
export type CiDeletedRunnerConnection = {
  __typename?: 'CiDeletedRunnerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiDeletedRunnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiDeletedRunner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiDeletedRunnerEdge = {
  __typename?: 'CiDeletedRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiDeletedRunner>;
};

/** Histogram of durations for a group of CI/CD jobs or pipelines. */
export type CiDurationStatistics = {
  __typename?: 'CiDurationStatistics';
  /**
   * Mean (average) duration. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  mean?: Maybe<Scalars['Duration']['output']>;
  /**
   * 50th percentile. 50% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  p50?: Maybe<Scalars['Duration']['output']>;
  /**
   * 75th percentile. 75% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  p75?: Maybe<Scalars['Duration']['output']>;
  /**
   * 90th percentile. 90% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  p90?: Maybe<Scalars['Duration']['output']>;
  /**
   * 95th percentile. 95% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  p95?: Maybe<Scalars['Duration']['output']>;
  /**
   * 99th percentile. 99% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  p99?: Maybe<Scalars['Duration']['output']>;
};

/** Represents a deployment freeze window of a project */
export type CiFreezePeriod = {
  __typename?: 'CiFreezePeriod';
  /** Time zone for the cron fields, defaults to UTC if not provided. */
  cronTimezone?: Maybe<Scalars['String']['output']>;
  /** End of the freeze period in cron format. */
  endCron: Scalars['String']['output'];
  /** Timestamp (UTC) of when the current/next active period ends. */
  endTime?: Maybe<Scalars['Time']['output']>;
  /** Start of the freeze period in cron format. */
  startCron: Scalars['String']['output'];
  /** Timestamp (UTC) of when the current/next active period starts. */
  startTime?: Maybe<Scalars['Time']['output']>;
  /** Freeze period status. */
  status: CiFreezePeriodStatus;
};

/** Deploy freeze period status */
export type CiFreezePeriodStatus =
  /** Freeze period is active. */
  | 'ACTIVE'
  /** Freeze period is inactive. */
  | 'INACTIVE';

export type CiGroup = {
  __typename?: 'CiGroup';
  /** Detailed status of the group. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** ID for a group. */
  id: Scalars['String']['output'];
  /** Jobs in group. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']['output']>;
  /** Size of the group. */
  size?: Maybe<Scalars['Int']['output']>;
};


export type CiGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiGroup. */
export type CiGroupConnection = {
  __typename?: 'CiGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupEdge = {
  __typename?: 'CiGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroup>;
};

/** CI/CD environment scope for a group. */
export type CiGroupEnvironmentScope = {
  __typename?: 'CiGroupEnvironmentScope';
  /** Scope name defininig the enviromnments that can use the variable. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiGroupEnvironmentScope. */
export type CiGroupEnvironmentScopeConnection = {
  __typename?: 'CiGroupEnvironmentScopeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupEnvironmentScopeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroupEnvironmentScope>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupEnvironmentScopeEdge = {
  __typename?: 'CiGroupEnvironmentScopeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroupEnvironmentScope>;
};

/** CI/CD variables for a group. */
export type CiGroupVariable = CiVariable & {
  __typename?: 'CiGroupVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']['output']>;
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is hidden. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiGroupVariable. */
export type CiGroupVariableConnection = {
  __typename?: 'CiGroupVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupVariableEdge>>>;
  /** Maximum amount of group CI/CD variables. */
  limit: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroupVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupVariableEdge = {
  __typename?: 'CiGroupVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroupVariable>;
};

/** Values for sorting inherited variables */
export type CiGroupVariablesSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Key by ascending order. */
  | 'KEY_ASC'
  /** Key by descending order. */
  | 'KEY_DESC';

/** Condition node in rule expression tree. */
export type CiInputsCondition = {
  __typename?: 'CiInputsCondition';
  /** Child conditions for AND/OR nodes. */
  children?: Maybe<Array<CiInputsCondition>>;
  /** Input field name for comparison nodes. */
  field?: Maybe<Scalars['String']['output']>;
  /** Operator type: equals, not_equals, AND, OR. */
  operator: Scalars['String']['output'];
  /** Expected value for comparison nodes. */
  value?: Maybe<Scalars['String']['output']>;
};

/** CI input saved for a pipeline schedule */
export type CiInputsField = {
  __typename?: 'CiInputsField';
  /** Name of the input. */
  name: Scalars['String']['output'];
  /** Value of the input. */
  value?: Maybe<Scalars['CiInputsValue']['output']>;
};

/** The connection type for CiInputsField. */
export type CiInputsFieldConnection = {
  __typename?: 'CiInputsFieldConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiInputsFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiInputsField>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiInputsFieldEdge = {
  __typename?: 'CiInputsFieldEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiInputsField>;
};

/** Attributes for defining an input. */
export type CiInputsInput = {
  /** Set to `true` to delete the input. */
  destroy?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the input. */
  name: Scalars['String']['input'];
  /** Value of the input. */
  value: Scalars['CiInputsValue']['input'];
};

/** Conditional rule for dynamic input options */
export type CiInputsRule = {
  __typename?: 'CiInputsRule';
  /** Parsed condition tree for frontend eval. */
  conditionTree?: Maybe<CiInputsCondition>;
  /** Default value when rule matches. */
  default?: Maybe<Scalars['String']['output']>;
  /** Condition expression. */
  if?: Maybe<Scalars['String']['output']>;
  /** Available options when rule matches. */
  options?: Maybe<Array<Scalars['String']['output']>>;
};

/** Input for pipeline creation */
export type CiInputsSpec = {
  __typename?: 'CiInputsSpec';
  /** Default value for the input, if provided. */
  default?: Maybe<Scalars['CiInputsValue']['output']>;
  /** Description of the input. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the input. */
  name: Scalars['String']['output'];
  /** Possible values that the input can take, if provided. */
  options?: Maybe<Scalars['CiInputsValue']['output']>;
  /** Regular expression pattern that the input value must match if provided. */
  regex?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the input is required. */
  required: Scalars['Boolean']['output'];
  /** Conditional rules for dynamic input options. */
  rules?: Maybe<Array<CiInputsRule>>;
  /** Input data type. */
  type: CiInputsType;
};

/** Available input types */
export type CiInputsType =
  /** Array input */
  | 'ARRAY'
  /** Boolean input */
  | 'BOOLEAN'
  /** Number input */
  | 'NUMBER'
  /** String input */
  | 'STRING';

/** CI/CD variables for a GitLab instance. */
export type CiInstanceVariable = CiVariable & {
  __typename?: 'CiInstanceVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Scope defining the environments that can use the variable. Deprecated in GitLab 15.3: No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in GitLab 15.3.
   */
  environmentScope?: Maybe<Scalars['String']['output']>;
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiInstanceVariable. */
export type CiInstanceVariableConnection = {
  __typename?: 'CiInstanceVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiInstanceVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiInstanceVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiInstanceVariableEdge = {
  __typename?: 'CiInstanceVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiInstanceVariable>;
};

export type CiJob = CiJobInterface & {
  __typename?: 'CiJob';
  /** Indicates the job is active. */
  active: Scalars['Boolean']['output'];
  /** Whether the job is allowed to fail. */
  allowFailure: Scalars['Boolean']['output'];
  /** Artifacts generated by the job. */
  artifacts?: Maybe<CiJobArtifactConnection>;
  /** URL for browsing the artifact's archive. */
  browseArtifactsPath?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the current user can play the job. */
  canPlayJob: Scalars['Boolean']['output'];
  /** Indicates the job can be canceled. */
  cancelable: Scalars['Boolean']['output'];
  /** Path to the commit that triggered the job. */
  commitPath?: Maybe<Scalars['String']['output']>;
  /** Coverage level of the job. */
  coverage?: Maybe<Scalars['Float']['output']>;
  /** When the job was created. */
  createdAt: Scalars['Time']['output'];
  /** Whether the job was created by a tag. */
  createdByTag: Scalars['Boolean']['output'];
  /** Detailed status of the job. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Downstream pipeline for a bridge. */
  downstreamPipeline?: Maybe<Pipeline>;
  /** Duration of the job in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** When the job was erased. */
  erasedAt?: Maybe<Scalars['Time']['output']>;
  /** Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code. */
  exitCode?: Maybe<Scalars['Int']['output']>;
  /** Message on why the job failed. */
  failureMessage?: Maybe<Scalars['String']['output']>;
  /** When a job has finished running. */
  finishedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the job. */
  id?: Maybe<Scalars['JobID']['output']>;
  /** Indicates the type of job. */
  kind: CiJobKind;
  /** Whether the job has a manual action. */
  manualJob?: Maybe<Scalars['Boolean']['output']>;
  /** Variables added to a manual job when the job is triggered. */
  manualVariables?: Maybe<CiManualVariableConnection>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']['output']>;
  /** References to builds that must complete before the jobs run. */
  needs?: Maybe<CiBuildNeedConnection>;
  /** Pipeline the job belongs to. */
  pipeline?: Maybe<PipelineInterface>;
  /** Play path of the job. */
  playPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be played. */
  playable: Scalars['Boolean']['output'];
  /** Jobs from the previous stage. */
  previousStageJobs?: Maybe<CiJobConnection>;
  /**
   * Jobs that must complete before the job runs. Returns `BuildNeed`, which is the needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise. Deprecated in GitLab 16.4: Replaced by previousStageJobs and needs fields.
   * @deprecated Replaced by previousStageJobs and needs fields. Deprecated in GitLab 16.4.
   */
  previousStageJobsOrNeeds?: Maybe<JobNeedUnionConnection>;
  /** Project that the job belongs to. */
  project?: Maybe<Project>;
  /** When the job was enqueued and marked as pending. */
  queuedAt?: Maybe<Scalars['Time']['output']>;
  /** How long the job was enqueued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']['output']>;
  /** Ref name of the job. */
  refName?: Maybe<Scalars['String']['output']>;
  /** Path to the ref. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Indicates that the job has been retried. */
  retried?: Maybe<Scalars['Boolean']['output']>;
  /** Retry path of the job. */
  retryPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be retried. */
  retryable: Scalars['Boolean']['output'];
  /** Runner assigned to execute the job. */
  runner?: Maybe<CiRunner>;
  /** Runner manager assigned to the job. */
  runnerManager?: Maybe<CiRunnerManager>;
  /** Indicates the job is scheduled. */
  scheduled: Scalars['Boolean']['output'];
  /** Schedule for the build. */
  scheduledAt?: Maybe<Scalars['Time']['output']>;
  /** Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise. */
  schedulingType?: Maybe<Scalars['String']['output']>;
  /** Short SHA1 ID of the commit. */
  shortSha: Scalars['String']['output'];
  /** Policy or action that initiated the job. If not set, the value is inherited from the pipeline. */
  source?: Maybe<Scalars['String']['output']>;
  /** Stage of the job. */
  stage?: Maybe<CiStage>;
  /** When the job was started. */
  startedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the job. */
  status?: Maybe<CiJobStatus>;
  /** Indicates the job is stuck. */
  stuck: Scalars['Boolean']['output'];
  /** Tags for the current job. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Trace generated by the job. */
  trace?: Maybe<CiJobTrace>;
  /** Whether the job was triggered. */
  triggered?: Maybe<Scalars['Boolean']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: JobPermissions;
  /** Web path of the job. */
  webPath?: Maybe<Scalars['String']['output']>;
};


export type CiJobArtifactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobManualVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobPreviousStageJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobPreviousStageJobsOrNeedsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** CI/CD job analytics data */
export type CiJobAnalytics = {
  __typename?: 'CiJobAnalytics';
  /** Job name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Stage information. */
  stage?: Maybe<CiStage>;
  /** Statistics for the jobs. */
  statistics?: Maybe<CiJobAnalyticsStatistics>;
};

/** The connection type for CiJobAnalytics. */
export type CiJobAnalyticsConnection = {
  __typename?: 'CiJobAnalyticsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobAnalyticsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobAnalytics>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobAnalyticsEdge = {
  __typename?: 'CiJobAnalyticsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobAnalytics>;
};

/** Values for sorting CI/CD job analytics */
export type CiJobAnalyticsSort =
  /** Sort by canceled rate in ascending order. */
  | 'CANCELED_RATE_ASC'
  /** Sort by canceled rate in descending order. */
  | 'CANCELED_RATE_DESC'
  /** Sort by failed rate in ascending order. */
  | 'FAILED_RATE_ASC'
  /** Sort by failed rate in descending order. */
  | 'FAILED_RATE_DESC'
  /** Sort by mean duration in ascending order. */
  | 'MEAN_DURATION_ASC'
  /** Sort by mean duration in descending order. */
  | 'MEAN_DURATION_DESC'
  /** Sort by name in ascending order. */
  | 'NAME_ASC'
  /** Sort by name in descending order. */
  | 'NAME_DESC'
  /** Sort by 50th percentile duration in ascending order. */
  | 'P50_DURATION_ASC'
  /** Sort by 50th percentile duration in descending order. */
  | 'P50_DURATION_DESC'
  /** Sort by 75th percentile duration in ascending order. */
  | 'P75_DURATION_ASC'
  /** Sort by 75th percentile duration in descending order. */
  | 'P75_DURATION_DESC'
  /** Sort by 90th percentile duration in ascending order. */
  | 'P90_DURATION_ASC'
  /** Sort by 90th percentile duration in descending order. */
  | 'P90_DURATION_DESC'
  /** Sort by 95th percentile duration in ascending order. */
  | 'P95_DURATION_ASC'
  /** Sort by 95th percentile duration in descending order. */
  | 'P95_DURATION_DESC'
  /** Sort by 99th percentile duration in ascending order. */
  | 'P99_DURATION_ASC'
  /** Sort by 99th percentile duration in descending order. */
  | 'P99_DURATION_DESC'
  /** Sort by success rate in ascending order. */
  | 'SUCCESS_RATE_ASC'
  /** Sort by success rate in descending order. */
  | 'SUCCESS_RATE_DESC';

/** Statistics for CI/CD job analytics */
export type CiJobAnalyticsStatistics = {
  __typename?: 'CiJobAnalyticsStatistics';
  /** Count of jobs, optionally filtered by status. */
  count?: Maybe<Scalars['BigInt']['output']>;
  /** Duration statistics for the jobs. */
  durationStatistics?: Maybe<CiDurationStatistics>;
  /** Percentage of jobs, optionally filtered by status. */
  rate?: Maybe<Scalars['Float']['output']>;
};


/** Statistics for CI/CD job analytics */
export type CiJobAnalyticsStatisticsCountArgs = {
  status?: InputMaybe<PipelineAnalyticsJobStatus>;
};


/** Statistics for CI/CD job analytics */
export type CiJobAnalyticsStatisticsRateArgs = {
  status?: InputMaybe<PipelineAnalyticsJobStatus>;
};

export type CiJobArtifact = {
  __typename?: 'CiJobArtifact';
  /** URL for downloading the artifact's file. */
  downloadPath?: Maybe<Scalars['String']['output']>;
  /** Expiry date of the artifact. */
  expireAt?: Maybe<Scalars['Time']['output']>;
  /** Expired state of the artifact. */
  expired: Scalars['Boolean']['output'];
  /** File type of the artifact. */
  fileType?: Maybe<JobArtifactFileType>;
  /** ID of the artifact. */
  id: Scalars['CiJobArtifactID']['output'];
  /** File name of the artifact. */
  name?: Maybe<Scalars['String']['output']>;
  /** Size of the artifact in bytes. */
  size: Scalars['BigInt']['output'];
};

/** The connection type for CiJobArtifact. */
export type CiJobArtifactConnection = {
  __typename?: 'CiJobArtifactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobArtifactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobArtifact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobArtifactEdge = {
  __typename?: 'CiJobArtifactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobArtifact>;
};

/** The connection type for CiJob. */
export type CiJobConnection = {
  __typename?: 'CiJobConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJob. */
export type CiJobConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiJobEdge = {
  __typename?: 'CiJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJob>;
};

export type CiJobFailureReason =
  /** A job that failed due to api failure. */
  | 'API_FAILURE'
  /** A job that failed due to archived failure. */
  | 'ARCHIVED_FAILURE'
  /** A job that failed due to bridge pipeline is child pipeline. */
  | 'BRIDGE_PIPELINE_IS_CHILD_PIPELINE'
  /** A job that failed due to builds disabled. */
  | 'BUILDS_DISABLED'
  /** A job that failed due to ci quota exceeded. */
  | 'CI_QUOTA_EXCEEDED'
  /** A job that failed due to data integrity failure. */
  | 'DATA_INTEGRITY_FAILURE'
  /** A job that failed due to deployment rejected. */
  | 'DEPLOYMENT_REJECTED'
  /** A job that failed due to downstream bridge project not found. */
  | 'DOWNSTREAM_BRIDGE_PROJECT_NOT_FOUND'
  /** A job that failed due to downstream pipeline creation failed. */
  | 'DOWNSTREAM_PIPELINE_CREATION_FAILED'
  /** A job that failed due to duo workflow not allowed. */
  | 'DUO_WORKFLOW_NOT_ALLOWED'
  /** A job that failed due to environment creation failure. */
  | 'ENVIRONMENT_CREATION_FAILURE'
  /** A job that failed due to failed outdated deployment job. */
  | 'FAILED_OUTDATED_DEPLOYMENT_JOB'
  /** A job that failed due to forward deployment failure. */
  | 'FORWARD_DEPLOYMENT_FAILURE'
  /** A job that failed due to insufficient bridge permissions. */
  | 'INSUFFICIENT_BRIDGE_PERMISSIONS'
  /** A job that failed due to insufficient upstream permissions. */
  | 'INSUFFICIENT_UPSTREAM_PERMISSIONS'
  /** A job that failed due to invalid bridge trigger. */
  | 'INVALID_BRIDGE_TRIGGER'
  /** A job that failed due to ip restriction failure. */
  | 'IP_RESTRICTION_FAILURE'
  /** A job that failed due to job execution timeout. */
  | 'JOB_EXECUTION_TIMEOUT'
  /** A job that failed due to missing dependency failure. */
  | 'MISSING_DEPENDENCY_FAILURE'
  /** A job that failed due to no matching runner. */
  | 'NO_MATCHING_RUNNER'
  /** A job that failed due to pipeline loop detected. */
  | 'PIPELINE_LOOP_DETECTED'
  /** A job that failed due to project deleted. */
  | 'PROJECT_DELETED'
  /** A job that failed due to protected environment failure. */
  | 'PROTECTED_ENVIRONMENT_FAILURE'
  /** A job that failed due to reached downstream pipeline trigger rate limit. */
  | 'REACHED_DOWNSTREAM_PIPELINE_TRIGGER_RATE_LIMIT'
  /** A job that failed due to reached max descendant pipelines depth. */
  | 'REACHED_MAX_DESCENDANT_PIPELINES_DEPTH'
  /** A job that failed due to reached max pipeline hierarchy size. */
  | 'REACHED_MAX_PIPELINE_HIERARCHY_SIZE'
  /** A job that failed due to runner system failure. */
  | 'RUNNER_SYSTEM_FAILURE'
  /** A job that failed due to runner unsupported. */
  | 'RUNNER_UNSUPPORTED'
  /** A job that failed due to scheduler failure. */
  | 'SCHEDULER_FAILURE'
  /** A job that failed due to script failure. */
  | 'SCRIPT_FAILURE'
  /** A job that failed due to secrets provider not found. */
  | 'SECRETS_PROVIDER_NOT_FOUND'
  /** A job that failed due to stale schedule. */
  | 'STALE_SCHEDULE'
  /** A job that failed due to stuck or timeout failure. */
  | 'STUCK_OR_TIMEOUT_FAILURE'
  /** A job that failed due to trace size exceeded. */
  | 'TRACE_SIZE_EXCEEDED'
  /** A job that failed due to unknown failure. */
  | 'UNKNOWN_FAILURE'
  /** A job that failed due to unmet prerequisites. */
  | 'UNMET_PREREQUISITES'
  /** A job that failed due to upstream bridge project not found. */
  | 'UPSTREAM_BRIDGE_PROJECT_NOT_FOUND'
  /** A job that failed due to user blocked. */
  | 'USER_BLOCKED';

export type CiJobInterface = {
  /** Indicates the job is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the job is allowed to fail. */
  allowFailure?: Maybe<Scalars['Boolean']['output']>;
  /** Artifacts generated by the job. */
  artifacts?: Maybe<CiJobArtifactConnection>;
  /** URL for browsing the artifact's archive. */
  browseArtifactsPath?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the current user can play the job. */
  canPlayJob?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates the job can be canceled. */
  cancelable?: Maybe<Scalars['Boolean']['output']>;
  /** Path to the commit that triggered the job. */
  commitPath?: Maybe<Scalars['String']['output']>;
  /** Coverage level of the job. */
  coverage?: Maybe<Scalars['Float']['output']>;
  /** When the job was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Whether the job was created by a tag. */
  createdByTag?: Maybe<Scalars['Boolean']['output']>;
  /** Detailed status of the job. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Duration of the job in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** When the job was erased. */
  erasedAt?: Maybe<Scalars['Time']['output']>;
  /** Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code. */
  exitCode?: Maybe<Scalars['Int']['output']>;
  /** Message on why the job failed. */
  failureMessage?: Maybe<Scalars['String']['output']>;
  /** When a job has finished running. */
  finishedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the job. */
  id?: Maybe<Scalars['JobID']['output']>;
  /** Indicates the type of job. */
  kind?: Maybe<CiJobKind>;
  /** Whether the job has a manual action. */
  manualJob?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']['output']>;
  /** Pipeline the job belongs to. */
  pipeline?: Maybe<PipelineInterface>;
  /** Play path of the job. */
  playPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be played. */
  playable?: Maybe<Scalars['Boolean']['output']>;
  /** Project that the job belongs to. */
  project?: Maybe<ProjectInterface>;
  /** When the job was enqueued and marked as pending. */
  queuedAt?: Maybe<Scalars['Time']['output']>;
  /** How long the job was enqueued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']['output']>;
  /** Ref name of the job. */
  refName?: Maybe<Scalars['String']['output']>;
  /** Path to the ref. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Indicates that the job has been retried. */
  retried?: Maybe<Scalars['Boolean']['output']>;
  /** Retry path of the job. */
  retryPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be retried. */
  retryable?: Maybe<Scalars['Boolean']['output']>;
  /** Runner assigned to execute the job. */
  runner?: Maybe<CiRunner>;
  /** Indicates the job is scheduled. */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Schedule for the build. */
  scheduledAt?: Maybe<Scalars['Time']['output']>;
  /** Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise. */
  schedulingType?: Maybe<Scalars['String']['output']>;
  /** Short SHA1 ID of the commit. */
  shortSha?: Maybe<Scalars['String']['output']>;
  /** Policy or action that initiated the job. If not set, the value is inherited from the pipeline. */
  source?: Maybe<Scalars['String']['output']>;
  /** Stage of the job. */
  stage?: Maybe<CiStage>;
  /** When the job was started. */
  startedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the job. */
  status?: Maybe<CiJobStatus>;
  /** Indicates the job is stuck. */
  stuck?: Maybe<Scalars['Boolean']['output']>;
  /** Tags for the current job. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Trace generated by the job. */
  trace?: Maybe<CiJobTrace>;
  /** Whether the job was triggered. */
  triggered?: Maybe<Scalars['Boolean']['output']>;
  /** Permissions for the current user on the job. */
  userPermissions?: Maybe<JobPermissions>;
  /** Web path of the job. */
  webPath?: Maybe<Scalars['String']['output']>;
};


export type CiJobInterfaceArtifactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiJobInterface. */
export type CiJobInterfaceConnection = {
  __typename?: 'CiJobInterfaceConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJobInterface. */
export type CiJobInterfaceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiJobInterfaceEdge = {
  __typename?: 'CiJobInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobInterface>;
};

export type CiJobKind =
  /** Bridge CI job connecting a parent and child pipeline. */
  | 'BRIDGE'
  /** Standard CI job. */
  | 'BUILD';

export type CiJobMinimalAccess = CiJobInterface & {
  __typename?: 'CiJobMinimalAccess';
  /** Indicates the job is active. */
  active: Scalars['Boolean']['output'];
  /** Whether the job is allowed to fail. */
  allowFailure: Scalars['Boolean']['output'];
  /** Artifacts generated by the job. */
  artifacts?: Maybe<CiJobArtifactConnection>;
  /** URL for browsing the artifact's archive. */
  browseArtifactsPath?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the current user can play the job. */
  canPlayJob?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates the job can be canceled. */
  cancelable?: Maybe<Scalars['Boolean']['output']>;
  /** Path to the commit that triggered the job. */
  commitPath?: Maybe<Scalars['String']['output']>;
  /** Coverage level of the job. */
  coverage?: Maybe<Scalars['Float']['output']>;
  /** When the job was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Whether the job was created by a tag. */
  createdByTag: Scalars['Boolean']['output'];
  /** Detailed status of the job. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Duration of the job in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** When the job was erased. */
  erasedAt?: Maybe<Scalars['Time']['output']>;
  /** Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code. */
  exitCode?: Maybe<Scalars['Int']['output']>;
  /** Message on why the job failed. */
  failureMessage?: Maybe<Scalars['String']['output']>;
  /** When a job has finished running. */
  finishedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the job. */
  id?: Maybe<Scalars['JobID']['output']>;
  /** Indicates the type of job. */
  kind?: Maybe<CiJobKind>;
  /** Whether the job has a manual action. */
  manualJob?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']['output']>;
  /** Pipeline the job belongs to. */
  pipeline?: Maybe<PipelineInterface>;
  /** Play path of the job. */
  playPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be played. */
  playable?: Maybe<Scalars['Boolean']['output']>;
  /** Project that the job belongs to. */
  project?: Maybe<ProjectInterface>;
  /** When the job was enqueued and marked as pending. */
  queuedAt?: Maybe<Scalars['Time']['output']>;
  /** How long the job was enqueued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']['output']>;
  /** Ref name of the job. */
  refName?: Maybe<Scalars['String']['output']>;
  /** Path to the ref. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Indicates that the job has been retried. */
  retried?: Maybe<Scalars['Boolean']['output']>;
  /** Retry path of the job. */
  retryPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the job can be retried. */
  retryable?: Maybe<Scalars['Boolean']['output']>;
  /** Runner assigned to execute the job. */
  runner?: Maybe<CiRunner>;
  /** Indicates the job is scheduled. */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Schedule for the build. */
  scheduledAt?: Maybe<Scalars['Time']['output']>;
  /** Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise. */
  schedulingType?: Maybe<Scalars['String']['output']>;
  /** Short SHA1 ID of the commit. */
  shortSha: Scalars['String']['output'];
  /** Policy or action that initiated the job. If not set, the value is inherited from the pipeline. */
  source?: Maybe<Scalars['String']['output']>;
  /** Stage of the job. */
  stage?: Maybe<CiStage>;
  /** When the job was started. */
  startedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the job. */
  status?: Maybe<CiJobStatus>;
  /** Indicates the job is stuck. */
  stuck: Scalars['Boolean']['output'];
  /** Tags for the current job. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Trace generated by the job. */
  trace?: Maybe<CiJobTrace>;
  /** Whether the job was triggered. */
  triggered?: Maybe<Scalars['Boolean']['output']>;
  /** Permissions for the current user on the job. */
  userPermissions?: Maybe<JobPermissions>;
  /** Web path of the job. */
  webPath?: Maybe<Scalars['String']['output']>;
};


export type CiJobMinimalAccessArtifactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type CiJobSource =
  /** A job initiated by api. */
  | 'API'
  /** A job initiated by chat. */
  | 'CHAT'
  /** A job initiated by container registry push. */
  | 'CONTAINER_REGISTRY_PUSH'
  /** A job initiated by duo workflow. */
  | 'DUO_WORKFLOW'
  /** A job initiated by external. */
  | 'EXTERNAL'
  /** A job initiated by external pull request event. */
  | 'EXTERNAL_PULL_REQUEST_EVENT'
  /** A job initiated by merge request event. */
  | 'MERGE_REQUEST_EVENT'
  /** A job initiated by ondemand dast scan. */
  | 'ONDEMAND_DAST_SCAN'
  /** A job initiated by ondemand dast validation. */
  | 'ONDEMAND_DAST_VALIDATION'
  /** A job initiated by parent pipeline. */
  | 'PARENT_PIPELINE'
  /** A job initiated by pipeline. */
  | 'PIPELINE'
  /** A job initiated by pipeline execution policy. */
  | 'PIPELINE_EXECUTION_POLICY'
  /** A job initiated by pipeline execution policy schedule. */
  | 'PIPELINE_EXECUTION_POLICY_SCHEDULE'
  /** A job initiated by push. */
  | 'PUSH'
  /** A job initiated by scan execution policy. */
  | 'SCAN_EXECUTION_POLICY'
  /** A job initiated by schedule. */
  | 'SCHEDULE'
  /** A job initiated by security orchestration policy. */
  | 'SECURITY_ORCHESTRATION_POLICY'
  /** A job initiated by trigger. */
  | 'TRIGGER'
  /** A job initiated by unknown. */
  | 'UNKNOWN'
  /** A job initiated by web. */
  | 'WEB'
  /** A job initiated by webide. */
  | 'WEBIDE';

export type CiJobStatus =
  /** A job that is canceled. */
  | 'CANCELED'
  /** A job that is canceling. */
  | 'CANCELING'
  /** A job that is created. */
  | 'CREATED'
  /** A job that is failed. */
  | 'FAILED'
  /** A job that is manual. */
  | 'MANUAL'
  /** A job that is pending. */
  | 'PENDING'
  /** A job that is preparing. */
  | 'PREPARING'
  /** A job that is running. */
  | 'RUNNING'
  /** A job that is scheduled. */
  | 'SCHEDULED'
  /** A job that is skipped. */
  | 'SKIPPED'
  /** A job that is success. */
  | 'SUCCESS'
  /** A job that is waiting for callback. */
  | 'WAITING_FOR_CALLBACK'
  /** A job that is waiting for resource. */
  | 'WAITING_FOR_RESOURCE';

/** Group that can access the current project by authenticating with a CI/CD job token. */
export type CiJobTokenAccessibleGroup = {
  __typename?: 'CiJobTokenAccessibleGroup';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Full path of the group. */
  fullPath: Scalars['ID']['output'];
  /** ID of the group. */
  id: Scalars['ID']['output'];
  /** Name of the group. */
  name: Scalars['String']['output'];
  /** Path of the group. */
  path: Scalars['String']['output'];
  /** Web URL of the group. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiJobTokenAccessibleGroup. */
export type CiJobTokenAccessibleGroupConnection = {
  __typename?: 'CiJobTokenAccessibleGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobTokenAccessibleGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobTokenAccessibleGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobTokenAccessibleGroupEdge = {
  __typename?: 'CiJobTokenAccessibleGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobTokenAccessibleGroup>;
};

/** Project that can access the current project by authenticating with a CI/CD job token. */
export type CiJobTokenAccessibleProject = {
  __typename?: 'CiJobTokenAccessibleProject';
  /** URL to avatar image file of the project. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Full path of the project. */
  fullPath: Scalars['ID']['output'];
  /** ID of the project. */
  id: Scalars['ID']['output'];
  /** Name of the project (without namespace). */
  name: Scalars['String']['output'];
  /** Path of the project. */
  path: Scalars['String']['output'];
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiJobTokenAccessibleProject. */
export type CiJobTokenAccessibleProjectConnection = {
  __typename?: 'CiJobTokenAccessibleProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobTokenAccessibleProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobTokenAccessibleProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobTokenAccessibleProjectEdge = {
  __typename?: 'CiJobTokenAccessibleProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobTokenAccessibleProject>;
};

export type CiJobTokenAuthLog = {
  __typename?: 'CiJobTokenAuthLog';
  /**
   * Last authorization date time. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  lastAuthorizedAt: Scalars['Time']['output'];
  /**
   * Origin project. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  originProject: CiJobTokenAccessibleProject;
};

/** The connection type for CiJobTokenAuthLog. */
export type CiJobTokenAuthLogConnection = {
  __typename?: 'CiJobTokenAuthLogConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobTokenAuthLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobTokenAuthLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJobTokenAuthLog. */
export type CiJobTokenAuthLogConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiJobTokenAuthLogEdge = {
  __typename?: 'CiJobTokenAuthLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobTokenAuthLog>;
};

/** Autogenerated input type of CiJobTokenScopeAddGroupOrProject */
export type CiJobTokenScopeAddGroupOrProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Group or project to be added to the CI job token scope. */
  targetPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CiJobTokenScopeAddGroupOrProject. */
export type CiJobTokenScopeAddGroupOrProjectPayload = {
  __typename?: 'CiJobTokenScopeAddGroupOrProjectPayload';
  /** CI job token's access scope. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /**
   * Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlistEntry?: Maybe<CiJobTokenScopeAllowlistEntry>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CiJobTokenScopeAddProject */
export type CiJobTokenScopeAddProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Project to be added to the CI job token scope. */
  targetProjectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CiJobTokenScopeAddProject. */
export type CiJobTokenScopeAddProjectPayload = {
  __typename?: 'CiJobTokenScopeAddProjectPayload';
  /** CI job token's access scope. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /**
   * Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlistEntry?: Maybe<CiJobTokenScopeAllowlistEntry>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CiJobTokenScopeAllowlist = {
  __typename?: 'CiJobTokenScopeAllowlist';
  /** Allowlist of groups that can access the current project by authenticating with a CI/CD job token. */
  groupsAllowlist?: Maybe<CiJobTokenScopeAllowlistEntryConnection>;
  /** Allowlist of projects that can access the current project by authenticating with a CI/CD job token. */
  projectsAllowlist?: Maybe<CiJobTokenScopeAllowlistEntryConnection>;
};


export type CiJobTokenScopeAllowlistGroupsAllowlistArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobTokenScopeAllowlistProjectsAllowlistArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an allowlist entry for the CI_JOB_TOKEN */
export type CiJobTokenScopeAllowlistEntry = {
  __typename?: 'CiJobTokenScopeAllowlistEntry';
  /** User that added the entry. */
  addedBy?: Maybe<UserCore>;
  /** Indicates whether the entry is created by the autopopulation process. */
  autopopulated?: Maybe<Scalars['Boolean']['output']>;
  /** When the entry was created. */
  createdAt: Scalars['Time']['output'];
  /** Indicates whether default permissions are enabled (true) or fine-grained permissions are enabled (false). */
  defaultPermissions?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Direction of access. Defaults to INBOUND. Deprecated in GitLab 18.0: Outbound job token scope is being removed. This field can only be INBOUND.
   * @deprecated Outbound job token scope is being removed. This field can only be INBOUND. Deprecated in GitLab 18.0.
   */
  direction?: Maybe<Scalars['String']['output']>;
  /**
   * List of policies for the entry. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  jobTokenPolicies?: Maybe<Array<CiJobTokenScopePolicies>>;
  /** Project that owns the allowlist entry. */
  sourceProject: Project;
  /** Group or project allowed by the entry. */
  target?: Maybe<CiJobTokenScopeTarget>;
};

/** The connection type for CiJobTokenScopeAllowlistEntry. */
export type CiJobTokenScopeAllowlistEntryConnection = {
  __typename?: 'CiJobTokenScopeAllowlistEntryConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobTokenScopeAllowlistEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobTokenScopeAllowlistEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJobTokenScopeAllowlistEntry. */
export type CiJobTokenScopeAllowlistEntryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiJobTokenScopeAllowlistEntryEdge = {
  __typename?: 'CiJobTokenScopeAllowlistEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobTokenScopeAllowlistEntry>;
};

/** Direction of access. */
export type CiJobTokenScopeDirection =
  /** Target projects in the inbound allowlist can access the scope project through their job tokens. */
  | 'INBOUND'
  /** Job token scope project can access target project in the outbound allowlist. */
  | 'OUTBOUND';

/** CI_JOB_TOKEN policy */
export type CiJobTokenScopePolicies =
  /** Admin Deployments */
  | 'ADMIN_DEPLOYMENTS'
  /** Admin Environments */
  | 'ADMIN_ENVIRONMENTS'
  /** Admin Jobs */
  | 'ADMIN_JOBS'
  /** Admin Packages */
  | 'ADMIN_PACKAGES'
  /** Admin Pipelines */
  | 'ADMIN_PIPELINES'
  /** Admin Releases */
  | 'ADMIN_RELEASES'
  /** Admin Secure Files */
  | 'ADMIN_SECURE_FILES'
  /** Admin Terraform State */
  | 'ADMIN_TERRAFORM_STATE'
  /** Read Deployments */
  | 'READ_DEPLOYMENTS'
  /** Read Environments */
  | 'READ_ENVIRONMENTS'
  /** Read Jobs */
  | 'READ_JOBS'
  /** Read Merge Requests */
  | 'READ_MERGE_REQUESTS'
  /** Read Packages */
  | 'READ_PACKAGES'
  /** Read Pipelines */
  | 'READ_PIPELINES'
  /** Read Releases */
  | 'READ_RELEASES'
  /** Read Repositories */
  | 'READ_REPOSITORIES'
  /** Read Secure Files */
  | 'READ_SECURE_FILES'
  /** Read Terraform State */
  | 'READ_TERRAFORM_STATE'
  /** Read Work Items */
  | 'READ_WORK_ITEMS';

/** Autogenerated input type of CiJobTokenScopeRemoveGroup */
export type CiJobTokenScopeRemoveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Group to be removed from the CI job token scope. */
  targetGroupPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CiJobTokenScopeRemoveGroup. */
export type CiJobTokenScopeRemoveGroupPayload = {
  __typename?: 'CiJobTokenScopeRemoveGroupPayload';
  /** CI job token's access scope. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /**
   * Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlistEntry?: Maybe<CiJobTokenScopeAllowlistEntry>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CiJobTokenScopeRemoveProject */
export type CiJobTokenScopeRemoveProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Project to be removed from the CI job token scope. */
  targetProjectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CiJobTokenScopeRemoveProject. */
export type CiJobTokenScopeRemoveProjectPayload = {
  __typename?: 'CiJobTokenScopeRemoveProjectPayload';
  /** CI job token's access scope. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /**
   * Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlistEntry?: Maybe<CiJobTokenScopeAllowlistEntry>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents an object that is the target of a CI_JOB_TOKEN allowlist entry */
export type CiJobTokenScopeTarget = CiJobTokenAccessibleGroup | CiJobTokenAccessibleProject;

export type CiJobTokenScopeType = {
  __typename?: 'CiJobTokenScopeType';
  /** List of IDs of groups which have been created by the  autopopulation process. */
  groupAllowlistAutopopulatedIds: Array<Scalars['GroupID']['output']>;
  /** Allowlist of groups that can access the current project by authenticating with a CI/CD job token. */
  groupsAllowlist: CiJobTokenAccessibleGroupConnection;
  /** Count of groups that can access the current project by authenticating with a CI/CD job token. The count does not include subgroups. */
  groupsAllowlistCount: Scalars['Int']['output'];
  /** Allowlist of projects that can access the current project by authenticating with a CI/CD job token. */
  inboundAllowlist: CiJobTokenAccessibleProjectConnection;
  /** List of IDs of projects which have been created by the  autopopulation process. */
  inboundAllowlistAutopopulatedIds: Array<Scalars['ProjectID']['output']>;
  /** Count of projects that can access the current project by authenticating with a CI/CD job token. The count does not include nested projects. */
  inboundAllowlistCount: Scalars['Int']['output'];
  /**
   * Allow list of projects that are accessible using the current project's CI Job tokens. Deprecated in GitLab 18.0: Outbound job token scope is being removed. Only inbound allowlist is supported.
   * @deprecated Outbound job token scope is being removed. Only inbound allowlist is supported. Deprecated in GitLab 18.0.
   */
  outboundAllowlist: ProjectConnection;
  /**
   * Allow list of projects that can be accessed by CI Job tokens created by the project. Deprecated in GitLab 15.9: The `projects` attribute is being deprecated. Use `outbound_allowlist`.
   * @deprecated The `projects` attribute is being deprecated. Use `outbound_allowlist`. Deprecated in GitLab 15.9.
   */
  projects: ProjectConnection;
};


export type CiJobTokenScopeTypeGroupsAllowlistArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobTokenScopeTypeInboundAllowlistArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobTokenScopeTypeOutboundAllowlistArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiJobTokenScopeTypeProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of CiJobTokenScopeUpdatePolicies */
export type CiJobTokenScopeUpdatePoliciesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether default permissions are enabled (true) or fine-grained permissions are enabled (false). */
  defaultPermissions: Scalars['Boolean']['input'];
  /** List of policies added to the CI job token scope. */
  jobTokenPolicies: Array<CiJobTokenScopePolicies>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Group or project that the CI job token targets. */
  targetPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CiJobTokenScopeUpdatePolicies. */
export type CiJobTokenScopeUpdatePoliciesPayload = {
  __typename?: 'CiJobTokenScopeUpdatePoliciesPayload';
  /**
   * Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlistEntry?: Maybe<CiJobTokenScopeAllowlistEntry>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CiJobTrace = {
  __typename?: 'CiJobTrace';
  /**
   * HTML summary that contains the tail lines of the trace. Returns at most 16KB of raw bytes from the trace. The returned string might start with an unexpected invalid UTF-8 code point due to truncation. Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  htmlSummary: Scalars['String']['output'];
};


export type CiJobTraceHtmlSummaryArgs = {
  lastLines?: InputMaybe<Scalars['Int']['input']>;
};

/** Statistics for a group of CI jobs. */
export type CiJobsStatistics = {
  __typename?: 'CiJobsStatistics';
  /** Statistics for the amount of time that jobs were waiting to be picked up. The calculation is based on the 100 most recent jobs run by the 5000 most recently created runners in context. If no filter is applied to runners, the calculation uses the 100 most recent jobs globally. */
  queuedDuration?: Maybe<CiDurationStatistics>;
};

/** Autogenerated input type of CiLint */
export type CiLintInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Contents of `.gitlab-ci.yml`. */
  content: Scalars['String']['input'];
  /** Run pipeline creation simulation, or only do static check. */
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  /** Project of the CI config. */
  projectPath: Scalars['ID']['input'];
  /** Ref to use when linting. Default is the project default branch. */
  ref?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CiLint. */
export type CiLintPayload = {
  __typename?: 'CiLintPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Linted CI config and metadata. */
  config?: Maybe<CiConfigV2>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** CI/CD variables given to a manual job. */
export type CiManualVariable = CiVariable & {
  __typename?: 'CiManualVariable';
  /**
   * Scope defining the environments that can use the variable. Deprecated in GitLab 15.3: No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in GitLab 15.3.
   */
  environmentScope?: Maybe<Scalars['String']['output']>;
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiManualVariable. */
export type CiManualVariableConnection = {
  __typename?: 'CiManualVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiManualVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiManualVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiManualVariableEdge = {
  __typename?: 'CiManualVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiManualVariable>;
};

export type CiMinutesNamespaceMonthlyUsage = {
  __typename?: 'CiMinutesNamespaceMonthlyUsage';
  /** Total number of compute minutes used by all projects in the namespace. */
  minutes?: Maybe<Scalars['Int']['output']>;
  /** Month related to the usage data. */
  month?: Maybe<Scalars['String']['output']>;
  /** Month related to the usage data in ISO 8601 date format. */
  monthIso8601?: Maybe<Scalars['ISO8601Date']['output']>;
  /** Compute usage data for projects in the namespace. */
  projects?: Maybe<CiMinutesProjectMonthlyUsageConnection>;
  /** Total duration (in seconds) of shared runners use by the namespace for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']['output']>;
};


export type CiMinutesNamespaceMonthlyUsageProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiMinutesNamespaceMonthlyUsage. */
export type CiMinutesNamespaceMonthlyUsageConnection = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesNamespaceMonthlyUsageEdge = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesNamespaceMonthlyUsage>;
};

export type CiMinutesProjectMonthlyUsage = {
  __typename?: 'CiMinutesProjectMonthlyUsage';
  /** Number of compute minutes used by the project in the month. */
  minutes?: Maybe<Scalars['Int']['output']>;
  /** Project having the recorded usage. */
  project?: Maybe<Project>;
  /** Total duration (in seconds) of shared runners use by the project for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for CiMinutesProjectMonthlyUsage. */
export type CiMinutesProjectMonthlyUsageConnection = {
  __typename?: 'CiMinutesProjectMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesProjectMonthlyUsageEdge = {
  __typename?: 'CiMinutesProjectMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesProjectMonthlyUsage>;
};

/** Information about an asynchronous pipeline creation request */
export type CiPipelineCreationRequest = {
  __typename?: 'CiPipelineCreationRequest';
  /** Error message if pipeline creation failed. */
  error?: Maybe<Scalars['String']['output']>;
  /** Pipeline object created by the request. */
  pipeline?: Maybe<Pipeline>;
  /** ID of the created pipeline if creation was successful. */
  pipelineId?: Maybe<Scalars['CiPipelineID']['output']>;
  /** Current status of the pipeline creation. */
  status: CiPipelineCreationStatus;
};

/** The status of a pipeline creation */
export type CiPipelineCreationStatus =
  /** The pipeline creation is failed */
  | 'FAILED'
  /** The pipeline creation is in progress */
  | 'IN_PROGRESS'
  /** The pipeline creation is succeeded */
  | 'SUCCEEDED';

/** Ci Pipeline sources enum */
export type CiPipelineSources =
  /** Pipeline created by an API event */
  | 'API'
  /** Pipeline created by a chat event */
  | 'CHAT'
  /** Pipeline created by a container registry push event */
  | 'CONTAINER_REGISTRY_PUSH'
  /** Pipeline created by a duo workflow event */
  | 'DUO_WORKFLOW'
  /** Pipeline created by an external event */
  | 'EXTERNAL'
  /** Pipeline created by an external pull request event */
  | 'EXTERNAL_PULL_REQUEST_EVENT'
  /** Pipeline created by a merge request event */
  | 'MERGE_REQUEST_EVENT'
  /** Pipeline created by an ondemand dast scan event */
  | 'ONDEMAND_DAST_SCAN'
  /** Pipeline created by an ondemand dast validation event */
  | 'ONDEMAND_DAST_VALIDATION'
  /** Pipeline created by a parent pipeline event */
  | 'PARENT_PIPELINE'
  /** Pipeline created by a pipeline event */
  | 'PIPELINE'
  /** Pipeline created by a pipeline execution policy schedule event */
  | 'PIPELINE_EXECUTION_POLICY_SCHEDULE'
  /** Pipeline created by a push event */
  | 'PUSH'
  /** Pipeline created by a schedule event */
  | 'SCHEDULE'
  /** Pipeline created by a security orchestration policy event */
  | 'SECURITY_ORCHESTRATION_POLICY'
  /** Pipeline created by a trigger event */
  | 'TRIGGER'
  /** Pipeline created by an unknown event */
  | 'UNKNOWN'
  /** Pipeline created by a web event */
  | 'WEB'
  /** Pipeline created by a webide event */
  | 'WEBIDE';

export type CiProjectSubscription = {
  __typename?: 'CiProjectSubscription';
  /** Author of the subscription. */
  author?: Maybe<UserCore>;
  /** Downstream project of the subscription.When an upstream project's pipeline completes, a pipeline is triggered in the downstream project. */
  downstreamProject?: Maybe<CiSubscriptionsProjectDetails>;
  /** Global ID of the subscription. */
  id?: Maybe<Scalars['CiSubscriptionsProjectID']['output']>;
  /** Upstream project of the subscription.When an upstream project's pipeline completes, a pipeline is triggered in the downstream project. */
  upstreamProject?: Maybe<CiSubscriptionsProjectDetails>;
};

/** The connection type for CiProjectSubscription. */
export type CiProjectSubscriptionConnection = {
  __typename?: 'CiProjectSubscriptionConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiProjectSubscriptionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiProjectSubscription>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiProjectSubscription. */
export type CiProjectSubscriptionConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiProjectSubscriptionEdge = {
  __typename?: 'CiProjectSubscriptionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiProjectSubscription>;
};

/** CI/CD variables for a project. */
export type CiProjectVariable = CiVariable & {
  __typename?: 'CiProjectVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']['output']>;
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is hidden. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiProjectVariable. */
export type CiProjectVariableConnection = {
  __typename?: 'CiProjectVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiProjectVariableEdge>>>;
  /** Maximum amount of project CI/CD variables. */
  limit: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiProjectVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiProjectVariableEdge = {
  __typename?: 'CiProjectVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiProjectVariable>;
};

export type CiRunner = {
  __typename?: 'CiRunner';
  /** Access level of the runner. */
  accessLevel: CiRunnerAccessLevel;
  /**
   * Indicates the runner is allowed to receive jobs. Deprecated in GitLab 14.8: Use `paused`. This field is the inverse of `paused` and has no relationship to the runner's job execution status. For more details, see `jobExecutionStatus`.
   * @deprecated Use `paused`. This field is the inverse of `paused` and has no relationship to the runner's job execution status. For more details, see `jobExecutionStatus`. Deprecated in GitLab 14.8.
   */
  active: Scalars['Boolean']['output'];
  /** Admin URL of the runner. Only available for administrators. */
  adminUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp of last contact from the runner. */
  contactedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of creation of the runner. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that created the runner. */
  createdBy?: Maybe<UserCore>;
  /**
   * Type of runner registration. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  creationMethod?: Maybe<CiRunnerCreationMethod>;
  /** Runner creation state. Used to determine if a runner has been registered and has contacted the GitLab instance. */
  creationState?: Maybe<CiRunnerCreationState>;
  /** Description of the runner. */
  description?: Maybe<Scalars['String']['output']>;
  /** Admin form URL of the runner. Only available for administrators. */
  editAdminUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Ephemeral authentication token used for runner manager registration. Only available for the creator of the runner for a limited time during registration. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  ephemeralAuthenticationToken?: Maybe<Scalars['String']['output']>;
  /**
   * URL of the registration page of the runner manager. Only available for the creator of the runner for a limited time during registration. Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  ephemeralRegisterUrl?: Maybe<Scalars['String']['output']>;
  /** Groups the runner is associated with. For group runners only. */
  groups?: Maybe<GroupInterfaceConnection>;
  /** ID of the runner. */
  id: Scalars['CiRunnerID']['output'];
  /**
   * Number of jobs processed by the runner (limited to 1000, plus one to indicate that more items exist).
   * `jobCount` is an optimized version of `jobs { count }`, and can be requested for multiple runners on the same request.
   */
  jobCount?: Maybe<Scalars['Int']['output']>;
  /** Job execution status of the runner. */
  jobExecutionStatus?: Maybe<CiRunnerJobExecutionStatus>;
  /** Jobs assigned to the runner. This field can only be resolved for one runner in any single request. */
  jobs?: Maybe<CiJobInterfaceConnection>;
  /** Indicates the runner is locked. */
  locked?: Maybe<Scalars['Boolean']['output']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `maintenance_note` */
  maintenanceNoteHtml?: Maybe<Scalars['String']['output']>;
  /** Runner managers associated with the runner configuration. */
  managers?: Maybe<CiRunnerManagerConnection>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: Maybe<Scalars['Int']['output']>;
  /** Project that owns the runner. For project runners only. */
  ownerProject?: Maybe<ProjectInterface>;
  /** Indicates the runner is paused and not available to run jobs. */
  paused: Scalars['Boolean']['output'];
  /** Private projects' "compute cost factor" associated with the runner (GitLab.com only). */
  privateProjectsMinutesCostFactor?: Maybe<Scalars['Float']['output']>;
  /** Number of projects that the runner is associated with. The count includes projects that might not be visible to the current user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Find projects the runner is associated with. For project runners only. */
  projects?: Maybe<ProjectConnection>;
  /** Public projects' "compute cost factor" associated with the runner (GitLab.com only). */
  publicProjectsMinutesCostFactor?: Maybe<Scalars['Float']['output']>;
  /** URL of the temporary registration page of the runner. Only available before the runner is registered. Only available for administrators. */
  registerAdminUrl?: Maybe<Scalars['String']['output']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged: Scalars['Boolean']['output'];
  /** Type of the runner. */
  runnerType: CiRunnerType;
  /** First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID. */
  shortSha?: Maybe<Scalars['String']['output']>;
  /** Status of the runner. */
  status: CiRunnerStatus;
  /** Tags associated with the runner. */
  tagList?: Maybe<Array<Scalars['String']['output']>>;
  /** Runner token expiration time. */
  tokenExpiresAt?: Maybe<Scalars['Time']['output']>;
  /** Availability of upgrades for the runner. */
  upgradeStatus?: Maybe<CiRunnerUpgradeStatus>;
  /** Permissions for the current user on the resource */
  userPermissions: RunnerPermissions;
};


export type CiRunnerGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiRunnerJobCountArgs = {
  statuses?: InputMaybe<Array<CiJobStatus>>;
};


export type CiRunnerJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
};


export type CiRunnerManagersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<CiRunnerStatus>;
  systemId?: InputMaybe<Scalars['String']['input']>;
};


export type CiRunnerProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membership?: InputMaybe<Scalars['Boolean']['input']>;
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
  personal?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topics?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CiRunnerAccessLevel =
  /** A runner that is not protected. */
  | 'NOT_PROTECTED'
  /** A runner that is ref protected. */
  | 'REF_PROTECTED';

/** Runner cloud provider. */
export type CiRunnerCloudProvider =
  /** Google Kubernetes Engine. */
  | 'GKE'
  /** Google Cloud. */
  | 'GOOGLE_CLOUD';

/** Information used in runner cloud provisioning. */
export type CiRunnerCloudProvisioning = CiRunnerGkeProvisioning | CiRunnerGoogleCloudProvisioning;

/** Step used to provision the runner to Google Cloud. */
export type CiRunnerCloudProvisioningStep = {
  __typename?: 'CiRunnerCloudProvisioningStep';
  /** Instructions to provision the runner. */
  instructions?: Maybe<Scalars['String']['output']>;
  /** Identifier of the language used for the instructions field. This identifier can be any of the identifiers specified in the [list of supported languages and lexers](https://github.com/rouge-ruby/rouge/wiki/List-of-supported-languages-and-lexers). */
  languageIdentifier?: Maybe<Scalars['String']['output']>;
  /** Title of the step. */
  title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiRunner. */
export type CiRunnerConnection = {
  __typename?: 'CiRunnerConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiRunnerEdge>>>;
  /**
   * Jobs statistics for jobs executed by a collection of runners. Available only to admins.
   *
   */
  jobsStatistics?: Maybe<CiJobsStatistics>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiRunner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiRunner. */
export type CiRunnerConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type CiRunnerCreationMethod =
  /** Applies to a runner that was created by an authenticated user. */
  | 'AUTHENTICATED_USER'
  /** Applies to a runner that was created by a runner registration token. */
  | 'REGISTRATION_TOKEN';

export type CiRunnerCreationState =
  /** Applies to a runner that has been registered and has polled for CI/CD jobs at least once. */
  | 'FINISHED'
  /** Applies to a runner that has been created, but is not yet registered and running. */
  | 'STARTED';

/** An edge in a connection. */
export type CiRunnerEdge = {
  __typename?: 'CiRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** Web URL of the runner edit page. The value depends on where you put the field in the query. You can use it for projects or groups. */
  editUrl?: Maybe<Scalars['String']['output']>;
  /** The item at the end of the edge. */
  node?: Maybe<CiRunner>;
  /** Web URL of the runner. The value depends on where you put the field in the query. You can use it for projects or groups. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Information used for GKE runner provisioning. */
export type CiRunnerGkeProvisioning = {
  __typename?: 'CiRunnerGkeProvisioning';
  /** Instructions for setting up a Google Cloud project. */
  projectSetupShellScript?: Maybe<Scalars['String']['output']>;
  /** Steps used to provision a runner in GKE. */
  provisioningSteps?: Maybe<Array<CiRunnerGkeProvisioningStep>>;
};


/** Information used for GKE runner provisioning. */
export type CiRunnerGkeProvisioningProvisioningStepsArgs = {
  nodePools?: InputMaybe<Array<GoogleCloudNodePool>>;
  region: Scalars['GoogleCloudRegion']['input'];
  runnerToken: Scalars['String']['input'];
  zone: Scalars['GoogleCloudZone']['input'];
};

/** Step used to provision the runner to GKE. */
export type CiRunnerGkeProvisioningStep = {
  __typename?: 'CiRunnerGkeProvisioningStep';
  /** Instructions to provision the runner. */
  instructions?: Maybe<Scalars['String']['output']>;
  /** Identifier of the language used for the instructions field. This identifier can be any of the identifiers specified in the [list of supported languages and lexers](https://github.com/rouge-ruby/rouge/wiki/List-of-supported-languages-and-lexers). */
  languageIdentifier?: Maybe<Scalars['String']['output']>;
  /** Title of the step. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Information used for runner Google Cloud provisioning. */
export type CiRunnerGoogleCloudProvisioning = {
  __typename?: 'CiRunnerGoogleCloudProvisioning';
  /** Instructions for setting up a Google Cloud project. */
  projectSetupShellScript?: Maybe<Scalars['String']['output']>;
  /** Steps used to provision a runner in the cloud. */
  provisioningSteps?: Maybe<Array<CiRunnerCloudProvisioningStep>>;
};


/** Information used for runner Google Cloud provisioning. */
export type CiRunnerGoogleCloudProvisioningProvisioningStepsArgs = {
  ephemeralMachineType: Scalars['GoogleCloudMachineType']['input'];
  region: Scalars['GoogleCloudRegion']['input'];
  runnerToken?: InputMaybe<Scalars['String']['input']>;
  zone: Scalars['GoogleCloudZone']['input'];
};

export type CiRunnerJobExecutionStatus =
  /** Runner is busy. */
  | 'ACTIVE'
  /** Runner is idle. */
  | 'IDLE';

export type CiRunnerManager = {
  __typename?: 'CiRunnerManager';
  /** Architecture provided by the runner manager. */
  architectureName?: Maybe<Scalars['String']['output']>;
  /** Timestamp of last contact from the runner manager. */
  contactedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of creation of the runner manager. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Executor last advertised by the runner. */
  executorName?: Maybe<Scalars['String']['output']>;
  /** ID of the runner manager. */
  id: Scalars['CiRunnerManagerID']['output'];
  /** IP address of the runner manager. */
  ipAddress?: Maybe<Scalars['String']['output']>;
  /** Job execution status of the runner manager. */
  jobExecutionStatus?: Maybe<CiRunnerJobExecutionStatus>;
  /** Platform provided by the runner manager. */
  platformName?: Maybe<Scalars['String']['output']>;
  /** Revision of the runner. */
  revision?: Maybe<Scalars['String']['output']>;
  /** Runner configuration for the runner manager. */
  runner?: Maybe<CiRunner>;
  /** Status of the runner manager. */
  status: CiRunnerStatus;
  /** System ID associated with the runner manager. */
  systemId: Scalars['String']['output'];
  /** Availability of upgrades for the runner manager. */
  upgradeStatus?: Maybe<CiRunnerUpgradeStatus>;
  /** Version of the runner. */
  version?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CiRunnerManager. */
export type CiRunnerManagerConnection = {
  __typename?: 'CiRunnerManagerConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiRunnerManagerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiRunnerManager>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiRunnerManager. */
export type CiRunnerManagerConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiRunnerManagerEdge = {
  __typename?: 'CiRunnerManagerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiRunnerManager>;
};

/** Values for filtering runners in namespaces. */
export type CiRunnerMembershipFilter =
  /** Include all runners. This list includes runners for all projects in the group and subgroups, as well as for the parent groups and instance. Introduced in GitLab 15.5: **Status**: Experiment. */
  | 'ALL_AVAILABLE'
  /** Include runners that have either a direct or inherited relationship. These runners can be specific to a project or a group. */
  | 'DESCENDANTS'
  /** Include runners that have a direct relationship. */
  | 'DIRECT';

/** Values for sorting runners */
export type CiRunnerSort =
  /** Ordered by contacted_at in ascending order. */
  | 'CONTACTED_ASC'
  /** Ordered by contacted_at in descending order. */
  | 'CONTACTED_DESC'
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by number of running jobs in descending order (only available on Ultimate plans). Introduced in GitLab 16.2: **Status**: Experiment. */
  | 'MOST_ACTIVE_DESC'
  /** Ordered by token_expires_at in ascending order. */
  | 'TOKEN_EXPIRES_AT_ASC'
  /** Ordered by token_expires_at in descending order. */
  | 'TOKEN_EXPIRES_AT_DESC';

export type CiRunnerStatus =
  /** Runner that has never contacted the instance. */
  | 'NEVER_CONTACTED'
  /** Runner that has not contacted this instance within the last 2 hours. Will be considered `STALE` if offline for more than 7 days. */
  | 'OFFLINE'
  /** Runner that contacted this instance within the last 2 hours. */
  | 'ONLINE'
  /** Runner that has not contacted this instance within the last 7 days. */
  | 'STALE';

export type CiRunnerType =
  /** A runner that is group type. */
  | 'GROUP_TYPE'
  /** A runner that is instance type. */
  | 'INSTANCE_TYPE'
  /** A runner that is project type. */
  | 'PROJECT_TYPE';

export type CiRunnerUpgradeStatus =
  /** Upgrade is available for the runner. */
  | 'AVAILABLE'
  /** Runner version is not valid. */
  | 'INVALID'
  /** Upgrade is not available for the runner. */
  | 'NOT_AVAILABLE'
  /** Upgrade is available and recommended for the runner. */
  | 'RECOMMENDED';

/** Runner usage in minutes. */
export type CiRunnerUsage = {
  __typename?: 'CiRunnerUsage';
  /** Amount of builds executed during the selected period. Encoded as a string. */
  ciBuildCount: Scalars['BigInt']['output'];
  /** Number of minutes spent to process jobs during the selected period. Encoded as a string. */
  ciDuration: Scalars['BigInt']['output'];
  /**
   * Amount of minutes used during the selected period. Encoded as a string. Deprecated in GitLab 17.5: Use `ciDuration`.
   * @deprecated Use `ciDuration`. Deprecated in GitLab 17.5.
   */
  ciMinutesUsed: Scalars['BigInt']['output'];
  /** Runner that the usage refers to. Null means "Other runners". */
  runner?: Maybe<CiRunner>;
};

/** Runner usage in minutes by project. */
export type CiRunnerUsageByProject = {
  __typename?: 'CiRunnerUsageByProject';
  /** Amount of builds executed during the selected period. Encoded as a string. */
  ciBuildCount: Scalars['BigInt']['output'];
  /** Number of minutes spent to process jobs during the selected period. Encoded as a string. */
  ciDuration: Scalars['BigInt']['output'];
  /**
   * Amount of minutes used during the selected period. Encoded as a string. Deprecated in GitLab 17.5: Use `ciDuration`.
   * @deprecated Use `ciDuration`. Deprecated in GitLab 17.5.
   */
  ciMinutesUsed: Scalars['BigInt']['output'];
  /** Project that the usage refers to. Null means "Other projects". */
  project?: Maybe<Project>;
};

/** Represents the Geo replication and verification state of a ci_secure_file. */
export type CiSecureFileRegistry = {
  __typename?: 'CiSecureFileRegistry';
  /** Indicate if the checksums of the CiSecureFileRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the Ci Secure File. */
  ciSecureFileId: Scalars['ID']['output'];
  /** Timestamp when the CiSecureFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the CiSecureFileRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the CiSecureFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the CiSecureFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the CiSecureFileRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the CiSecureFileRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the CiSecureFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the CiSecureFileRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the CiSecureFileRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the CiSecureFileRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the CiSecureFileRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the CiSecureFileRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the CiSecureFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the CiSecureFileRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of CiSecureFileRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the CiSecureFileRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the CiSecureFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for CiSecureFileRegistry. */
export type CiSecureFileRegistryConnection = {
  __typename?: 'CiSecureFileRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiSecureFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiSecureFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiSecureFileRegistry. */
export type CiSecureFileRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CiSecureFileRegistryEdge = {
  __typename?: 'CiSecureFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiSecureFileRegistry>;
};

export type CiStage = {
  __typename?: 'CiStage';
  /** Detailed status of the stage. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Group of jobs for the stage. */
  groups?: Maybe<CiGroupConnection>;
  /** ID of the stage. */
  id: Scalars['ID']['output'];
  /** Jobs for the stage. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the pipeline stage. */
  status?: Maybe<Scalars['String']['output']>;
};


export type CiStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CiStageJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CiStage. */
export type CiStageConnection = {
  __typename?: 'CiStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiStageEdge = {
  __typename?: 'CiStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiStage>;
};

export type CiSubscriptionsProject = {
  __typename?: 'CiSubscriptionsProject';
  /** Author of the subscription. */
  author?: Maybe<UserCore>;
  /** Downstream project of the subscription. */
  downstreamProject?: Maybe<Project>;
  /** Global ID of the subscription. */
  id?: Maybe<Scalars['CiSubscriptionsProjectID']['output']>;
  /** Upstream project of the subscription. */
  upstreamProject?: Maybe<Project>;
};

/** The connection type for CiSubscriptionsProject. */
export type CiSubscriptionsProjectConnection = {
  __typename?: 'CiSubscriptionsProjectConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiSubscriptionsProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiSubscriptionsProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiSubscriptionsProject. */
export type CiSubscriptionsProjectConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type CiSubscriptionsProjectDetails = {
  __typename?: 'CiSubscriptionsProjectDetails';
  /** ID of the project. */
  id: Scalars['ID']['output'];
  /** Full path of the project. */
  name: Scalars['ID']['output'];
  /** Namespace of the project. */
  namespace: CiSubscriptionsProjectNamespaceDetails;
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type CiSubscriptionsProjectEdge = {
  __typename?: 'CiSubscriptionsProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CiSubscriptionsProject>;
};

export type CiSubscriptionsProjectNamespaceDetails = {
  __typename?: 'CiSubscriptionsProjectNamespaceDetails';
  /** ID of the project. */
  id: Scalars['ID']['output'];
  /** Full path of the project. */
  name: Scalars['ID']['output'];
};

/** GitLab CI/CD configuration template. */
export type CiTemplate = {
  __typename?: 'CiTemplate';
  /** Contents of the CI template. */
  content: Scalars['String']['output'];
  /** Name of the CI template. */
  name: Scalars['String']['output'];
};

export type CiVariable = {
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** Attributes for defining a CI/CD variable. */
export type CiVariableInput = {
  /** Name of the variable. */
  key: Scalars['String']['input'];
  /** Value of the variable. */
  value: Scalars['String']['input'];
  /** Type of variable. */
  variableType?: InputMaybe<CiVariableType>;
};

/** Values for sorting variables */
export type CiVariableSort =
  /** Sorted by key in ascending order. */
  | 'KEY_ASC'
  /** Sorted by key in descending order. */
  | 'KEY_DESC';

export type CiVariableType =
  /** Env var type. */
  | 'ENV_VAR'
  /** File type. */
  | 'FILE';

/** Represents the metrics of the last run virtual registry cleanup policy */
export type CleanupPolicyLastRunDetailedMetrics = {
  __typename?: 'CleanupPolicyLastRunDetailedMetrics';
  /**
   * Last run detail metrics of container. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  container?: Maybe<CleanupPolicyLastRunUpstreamMetrics>;
  /**
   * Last run detail metrics of maven. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  maven?: Maybe<CleanupPolicyLastRunUpstreamMetrics>;
};

/** Represents the metrics of the last run virtual registry cleanup policy of an upstream */
export type CleanupPolicyLastRunUpstreamMetrics = {
  __typename?: 'CleanupPolicyLastRunUpstreamMetrics';
  /**
   * Number of entries deleted. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  deletedEntriesCount: Scalars['Int']['output'];
  /**
   * Size in bytes of data deleted. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  deletedSize: Scalars['Int']['output'];
};

export type CloudConnectorProbeResult = {
  __typename?: 'CloudConnectorProbeResult';
  /** Additional details about the probe result. */
  details?: Maybe<Scalars['JSON']['output']>;
  /** Full list of errors about the probe result. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Additional message or details about the probe result. */
  message?: Maybe<Scalars['String']['output']>;
  /** Name of the probe. */
  name?: Maybe<Scalars['String']['output']>;
  /** Indicates if the probe was successful. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

export type CloudConnectorStatus = {
  __typename?: 'CloudConnectorStatus';
  /** Results of individual probes run during verification. */
  probeResults?: Maybe<Array<CloudConnectorProbeResult>>;
  /** Indicates if the setup verification was successful. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

export type ClusterAgent = {
  __typename?: 'ClusterAgent';
  /** Recent activity for the cluster agent. */
  activityEvents?: Maybe<ClusterAgentActivityEventConnection>;
  /** Active connections for the cluster agent */
  connections?: Maybe<ConnectedAgentConnection>;
  /** Timestamp the cluster agent was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User object, containing information about the person who created the agent. */
  createdByUser?: Maybe<UserCore>;
  /** ID of the cluster agent. */
  id: Scalars['ID']['output'];
  /** Whether the cluster agent is receptive or not. */
  isReceptive?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the cluster agent. */
  name?: Maybe<Scalars['String']['output']>;
  /** Project the cluster agent is associated with. */
  project?: Maybe<Project>;
  /** Tokens associated with the cluster agent. */
  tokens?: Maybe<ClusterAgentTokenConnection>;
  /** Timestamp the cluster agent was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** URL configurations for the cluster agent in case it is a receptive agent. */
  urlConfigurations?: Maybe<ClusterAgentUrlConfigurationConnection>;
  /** User access config for the cluster agent. */
  userAccessAuthorizations?: Maybe<ClusterAgentAuthorizationUserAccess>;
  /** Container images reported on the agent vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /** Web path of the cluster agent. */
  webPath?: Maybe<Scalars['String']['output']>;
  /** Workspaces associated with the agent. */
  workspaces?: Maybe<WorkspaceConnection>;
  /**
   * Workspaces agent config for the cluster agent. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  workspacesAgentConfig?: Maybe<WorkspacesAgentConfig>;
};


export type ClusterAgentActivityEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterAgentConnectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterAgentTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterAgentUrlConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterAgentVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterAgentWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

export type ClusterAgentActivityEvent = {
  __typename?: 'ClusterAgentActivityEvent';
  /** Agent token associated with the event. */
  agentToken?: Maybe<ClusterAgentToken>;
  /** Type of event. */
  kind?: Maybe<Scalars['String']['output']>;
  /** Severity of the event. */
  level?: Maybe<Scalars['String']['output']>;
  /** Timestamp the event was recorded. */
  recordedAt?: Maybe<Scalars['Time']['output']>;
  /** User associated with the event. */
  user?: Maybe<UserCore>;
};

/** The connection type for ClusterAgentActivityEvent. */
export type ClusterAgentActivityEventConnection = {
  __typename?: 'ClusterAgentActivityEventConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentActivityEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentActivityEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ClusterAgentActivityEvent. */
export type ClusterAgentActivityEventConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ClusterAgentActivityEventEdge = {
  __typename?: 'ClusterAgentActivityEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentActivityEvent>;
};

export type ClusterAgentAuthorizationCiAccess = {
  __typename?: 'ClusterAgentAuthorizationCiAccess';
  /** Authorized cluster agent. */
  agent?: Maybe<ClusterAgent>;
  /** Configuration for the authorized project. */
  config?: Maybe<Scalars['JSON']['output']>;
};

/** The connection type for ClusterAgentAuthorizationCiAccess. */
export type ClusterAgentAuthorizationCiAccessConnection = {
  __typename?: 'ClusterAgentAuthorizationCiAccessConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentAuthorizationCiAccessEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentAuthorizationCiAccess>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentAuthorizationCiAccessEdge = {
  __typename?: 'ClusterAgentAuthorizationCiAccessEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentAuthorizationCiAccess>;
};

export type ClusterAgentAuthorizationUserAccess = {
  __typename?: 'ClusterAgentAuthorizationUserAccess';
  /** Authorized cluster agent. */
  agent?: Maybe<ClusterAgent>;
  /** Configuration for the authorized project. */
  config?: Maybe<Scalars['JSON']['output']>;
};

/** The connection type for ClusterAgentAuthorizationUserAccess. */
export type ClusterAgentAuthorizationUserAccessConnection = {
  __typename?: 'ClusterAgentAuthorizationUserAccessConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentAuthorizationUserAccessEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentAuthorizationUserAccess>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentAuthorizationUserAccessEdge = {
  __typename?: 'ClusterAgentAuthorizationUserAccessEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentAuthorizationUserAccess>;
};

/** The connection type for ClusterAgent. */
export type ClusterAgentConnection = {
  __typename?: 'ClusterAgentConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ClusterAgent. */
export type ClusterAgentConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ClusterAgentDelete */
export type ClusterAgentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the cluster agent that will be deleted. */
  id: Scalars['ClustersAgentID']['input'];
};

/** Autogenerated return type of ClusterAgentDelete. */
export type ClusterAgentDeletePayload = {
  __typename?: 'ClusterAgentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type ClusterAgentEdge = {
  __typename?: 'ClusterAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgent>;
};

export type ClusterAgentToken = {
  __typename?: 'ClusterAgentToken';
  /** Cluster agent the token is associated with. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Timestamp the token was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User who created the token. */
  createdByUser?: Maybe<UserCore>;
  /** Description of the token. */
  description?: Maybe<Scalars['String']['output']>;
  /** Global ID of the token. */
  id: Scalars['ClustersAgentTokenID']['output'];
  /** Timestamp the token was last used. */
  lastUsedAt?: Maybe<Scalars['Time']['output']>;
  /** Name given to the token. */
  name?: Maybe<Scalars['String']['output']>;
  /** Current status of the token. */
  status?: Maybe<AgentTokenStatus>;
};

/** The connection type for ClusterAgentToken. */
export type ClusterAgentTokenConnection = {
  __typename?: 'ClusterAgentTokenConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ClusterAgentToken. */
export type ClusterAgentTokenConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the cluster agent that will be associated with the new token. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** Description of the token. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the token. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of ClusterAgentTokenCreate. */
export type ClusterAgentTokenCreatePayload = {
  __typename?: 'ClusterAgentTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Token secret value. Make sure you save it - you won't be able to access it again. */
  secret?: Maybe<Scalars['String']['output']>;
  /** Token created after mutation. */
  token?: Maybe<ClusterAgentToken>;
};

/** An edge in a connection. */
export type ClusterAgentTokenEdge = {
  __typename?: 'ClusterAgentTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentToken>;
};

/** Autogenerated input type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the agent token that will be revoked. */
  id: Scalars['ClustersAgentTokenID']['input'];
};

/** Autogenerated return type of ClusterAgentTokenRevoke. */
export type ClusterAgentTokenRevokePayload = {
  __typename?: 'ClusterAgentTokenRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type ClusterAgentUrlConfiguration = {
  __typename?: 'ClusterAgentUrlConfiguration';
  /** CA certificate of the URL configuration. It is used to verify the agent endpoint. */
  caCert?: Maybe<Scalars['String']['output']>;
  /** Client certificate if JWT authentication is used. */
  clientCert?: Maybe<Scalars['String']['output']>;
  /** Cluster agent of the URL configuration. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Global ID of the URL configuration. */
  id: Scalars['ClustersAgentsUrlConfigurationID']['output'];
  /** Public key if JWT authentication is used. */
  publicKey?: Maybe<Scalars['String']['output']>;
  /** TLS host of the URL configuration. It is used to verify the server name in the agent endpoint certificate. */
  tlsHost?: Maybe<Scalars['String']['output']>;
  /** URL of the URL configuration. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ClusterAgentUrlConfiguration. */
export type ClusterAgentUrlConfigurationConnection = {
  __typename?: 'ClusterAgentUrlConfigurationConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentUrlConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentUrlConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ClusterAgentUrlConfiguration. */
export type ClusterAgentUrlConfigurationConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ClusterAgentUrlConfigurationCreate */
export type ClusterAgentUrlConfigurationCreateInput = {
  /** Base64-encoded CA certificate in PEM format to verify the agent endpoint. */
  caCert?: InputMaybe<Scalars['String']['input']>;
  /** Base64-encoded client certificate in PEM format if mTLS authentication should be used. Must be provided with `client_key`. */
  clientCert?: InputMaybe<Scalars['String']['input']>;
  /** Base64-encoded client key in PEM format if mTLS authentication should be used. Must be provided with `client_cert`. */
  clientKey?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the cluster agent that will be associated with the new URL configuration. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** TLS host name to verify the server name in agent endpoint certificate. */
  tlsHost?: InputMaybe<Scalars['String']['input']>;
  /** URL for the new URL configuration. */
  url: Scalars['String']['input'];
};

/** Autogenerated return type of ClusterAgentUrlConfigurationCreate. */
export type ClusterAgentUrlConfigurationCreatePayload = {
  __typename?: 'ClusterAgentUrlConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** URL configuration created after mutation. */
  urlConfiguration?: Maybe<ClusterAgentUrlConfiguration>;
};

/** Autogenerated input type of ClusterAgentUrlConfigurationDelete */
export type ClusterAgentUrlConfigurationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the agent URL configuration that will be deleted. */
  id: Scalars['ClustersAgentsUrlConfigurationID']['input'];
};

/** Autogenerated return type of ClusterAgentUrlConfigurationDelete. */
export type ClusterAgentUrlConfigurationDeletePayload = {
  __typename?: 'ClusterAgentUrlConfigurationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type ClusterAgentUrlConfigurationEdge = {
  __typename?: 'ClusterAgentUrlConfigurationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentUrlConfiguration>;
};

/** Represents the code coverage activity for a group */
export type CodeCoverageActivity = {
  __typename?: 'CodeCoverageActivity';
  /** Average percentage of the different code coverage results available for the group. */
  averageCoverage?: Maybe<Scalars['Float']['output']>;
  /** Number of different code coverage results available for the group. */
  coverageCount?: Maybe<Scalars['Int']['output']>;
  /** Date when the code coverage was created. */
  date: Scalars['Date']['output'];
  /** Number of projects with code coverage results for the group. */
  projectCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for CodeCoverageActivity. */
export type CodeCoverageActivityConnection = {
  __typename?: 'CodeCoverageActivityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeCoverageActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeCoverageActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeCoverageActivityEdge = {
  __typename?: 'CodeCoverageActivityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeCoverageActivity>;
};

/** Represents the code coverage summary for a project */
export type CodeCoverageSummary = {
  __typename?: 'CodeCoverageSummary';
  /** Average percentage of the different code coverage results available for the project. */
  averageCoverage?: Maybe<Scalars['Float']['output']>;
  /** Number of different code coverage results available. */
  coverageCount?: Maybe<Scalars['Int']['output']>;
  /** Latest date when the code coverage was created for the project. */
  lastUpdatedOn?: Maybe<Scalars['Date']['output']>;
};

/** The code flow node type */
export type CodeFlowNodeType =
  /** Propagation node. */
  | 'PROPAGATION'
  /** Sink node. */
  | 'SINK'
  /** Source node. */
  | 'SOURCE';

/** Represents a code quality degradation on the pipeline. */
export type CodeQualityDegradation = {
  __typename?: 'CodeQualityDegradation';
  /** Description of the code quality degradation. */
  description: Scalars['String']['output'];
  /** Code Quality plugin that reported the finding. */
  engineName: Scalars['String']['output'];
  /** Unique fingerprint to identify the code quality degradation. For example, an MD5 hash. */
  fingerprint: Scalars['String']['output'];
  /** Line on which the code quality degradation occurred. */
  line: Scalars['Int']['output'];
  /** Relative path to the file containing the code quality degradation. */
  path: Scalars['String']['output'];
  /** Status of the degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN). */
  severity: CodeQualityDegradationSeverity;
  /** URL to the file along with line number. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CodeQualityDegradation. */
export type CodeQualityDegradationConnection = {
  __typename?: 'CodeQualityDegradationConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeQualityDegradationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeQualityDegradation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CodeQualityDegradation. */
export type CodeQualityDegradationConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CodeQualityDegradationEdge = {
  __typename?: 'CodeQualityDegradationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeQualityDegradation>;
};

export type CodeQualityDegradationSeverity =
  /** Code Quality degradation has a status of blocker. */
  | 'BLOCKER'
  /** Code Quality degradation has a status of critical. */
  | 'CRITICAL'
  /** Code Quality degradation has a status of info. */
  | 'INFO'
  /** Code Quality degradation has a status of major. */
  | 'MAJOR'
  /** Code Quality degradation has a status of minor. */
  | 'MINOR'
  /** Code Quality degradation has a status of unknown. */
  | 'UNKNOWN';

/** Code Quality report for a pipeline */
export type CodeQualityReportSummary = {
  __typename?: 'CodeQualityReportSummary';
  /** Total number of blocker status. */
  blocker?: Maybe<Scalars['Int']['output']>;
  /** Total number of Code Quality reports. */
  count?: Maybe<Scalars['Int']['output']>;
  /** Total number of critical status. */
  critical?: Maybe<Scalars['Int']['output']>;
  /** Total number of info status. */
  info?: Maybe<Scalars['Int']['output']>;
  /** Total number of major status. */
  major?: Maybe<Scalars['Int']['output']>;
  /** Total number of minor status. */
  minor?: Maybe<Scalars['Int']['output']>;
  /** Total number of unknown status. */
  unknown?: Maybe<Scalars['Int']['output']>;
};

export type CodeSuggestionEvent = {
  __typename?: 'CodeSuggestionEvent';
  /** Type of the event. */
  event: AiUsageEventType;
  /** Programming language in the context of the suggestion. */
  language?: Maybe<Scalars['String']['output']>;
  /** Size of the code suggestion measured in lines of code. */
  suggestionSize?: Maybe<Scalars['String']['output']>;
  /** When the event happened. */
  timestamp: Scalars['Time']['output'];
  /** Unique tracking number of sequence of events for one suggestion. */
  uniqueTrackingId?: Maybe<Scalars['String']['output']>;
  /** User associated with the event. */
  user: UserCore;
};

/** The connection type for CodeSuggestionEvent. */
export type CodeSuggestionEventConnection = {
  __typename?: 'CodeSuggestionEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeSuggestionEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeSuggestionEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeSuggestionEventEdge = {
  __typename?: 'CodeSuggestionEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeSuggestionEvent>;
};

/** Represents reports comparison for code quality. */
export type CodequalityReportsComparer = {
  __typename?: 'CodequalityReportsComparer';
  /** Compared codequality report. */
  report?: Maybe<CodequalityReportsComparerReport>;
  /** Compared codequality report generation status. */
  status?: Maybe<CodequalityReportsComparerReportGenerationStatus>;
};

/** Represents compared code quality report. */
export type CodequalityReportsComparerReport = {
  __typename?: 'CodequalityReportsComparerReport';
  /** All code quality degradations. */
  existingErrors?: Maybe<Array<CodequalityReportsComparerReportDegradation>>;
  /** New code quality degradations. */
  newErrors: Array<CodequalityReportsComparerReportDegradation>;
  /** Resolved code quality degradations. */
  resolvedErrors?: Maybe<Array<CodequalityReportsComparerReportDegradation>>;
  /** Status of report. */
  status: CodequalityReportsComparerStatus;
  /** Codequality report summary. */
  summary: CodequalityReportsComparerReportSummary;
};

/** Represents a degradation on the compared codequality report. */
export type CodequalityReportsComparerReportDegradation = {
  __typename?: 'CodequalityReportsComparerReportDegradation';
  /** Description of the code quality degradation. */
  description: Scalars['String']['output'];
  /** Code quality plugin that reported the degradation. */
  engineName?: Maybe<Scalars['String']['output']>;
  /** Relative path to the file containing the code quality degradation. */
  filePath: Scalars['String']['output'];
  /** Unique fingerprint to identify the code quality degradation. For example, an MD5 hash. */
  fingerprint: Scalars['String']['output'];
  /** Line on which the code quality degradation occurred. */
  line: Scalars['Int']['output'];
  /** Severity of the code quality degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN). */
  severity: CodeQualityDegradationSeverity;
  /** URL to the file along with line number. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Represents the generation status of the compared codequality report. */
export type CodequalityReportsComparerReportGenerationStatus =
  /** An error happened while generating the report. */
  | 'ERROR'
  /** Report was generated. */
  | 'PARSED'
  /** Report is being generated. */
  | 'PARSING';

/** Represents a summary of the compared codequality report. */
export type CodequalityReportsComparerReportSummary = {
  __typename?: 'CodequalityReportsComparerReportSummary';
  /** Count of code quality errors. */
  errored?: Maybe<Scalars['Int']['output']>;
  /** Count of resolved code quality degradations. */
  resolved?: Maybe<Scalars['Int']['output']>;
  /** Total count of code quality degradations. */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Represents the state of the code quality report. */
export type CodequalityReportsComparerStatus =
  /** Report generated and there are new code quality degradations. */
  | 'FAILED'
  /** Head report or base report not found. */
  | 'NOT_FOUND'
  /** No degradations found in the head pipeline report. */
  | 'SUCCESS';

export type CommentTemplatePath = {
  __typename?: 'CommentTemplatePath';
  /** Path of the comment template. */
  href: Scalars['String']['output'];
  /** Text used on the template path. */
  text: Scalars['String']['output'];
};

export type CommentTemplatePathType = {
  __typename?: 'CommentTemplatePathType';
  /** Management link to the comment template. */
  href: Scalars['String']['output'];
  /** Name of the comment template scope. */
  text: Scalars['String']['output'];
};

export type Commit = Todoable & {
  __typename?: 'Commit';
  /** Author of the commit. */
  author?: Maybe<UserCore>;
  /** Commit author's email. */
  authorEmail?: Maybe<Scalars['String']['output']>;
  /** Commit authors gravatar. */
  authorGravatar?: Maybe<Scalars['String']['output']>;
  /** Commit authors name. */
  authorName?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the commit was authored. */
  authoredDate?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of when the commit was committed. */
  committedDate?: Maybe<Scalars['Time']['output']>;
  /** Email of the committer. */
  committerEmail?: Maybe<Scalars['String']['output']>;
  /** Name of the committer. */
  committerName?: Maybe<Scalars['String']['output']>;
  /** Description of the commit message. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Diffs contained within the commit. This field can only be resolved for 10 diffs in any single request. */
  diffs?: Maybe<Array<Diff>>;
  /** Full title of the commit message. */
  fullTitle?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `full_title` */
  fullTitleHtml?: Maybe<Scalars['String']['output']>;
  /** ID (global ID) of the commit. */
  id: Scalars['ID']['output'];
  /** Raw commit message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** SHA ID of the first parent. */
  parentSha?: Maybe<Scalars['String']['output']>;
  /** Pipelines of the commit ordered latest first. */
  pipelines?: Maybe<PipelineConnection>;
  /** SHA1 ID of the commit. */
  sha: Scalars['String']['output'];
  /** Short SHA1 ID of the commit. */
  shortId: Scalars['String']['output'];
  /** Signature of the commit. */
  signature?: Maybe<CommitSignature>;
  /** Rendered HTML of the commit signature. */
  signatureHtml?: Maybe<Scalars['String']['output']>;
  /** Title of the commit message. */
  title?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Web path of the commit. */
  webPath: Scalars['String']['output'];
  /** Web URL of the commit. */
  webUrl: Scalars['String']['output'];
};


export type CommitPipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

export type CommitAction = {
  /** Action to perform: create, delete, move, update, or chmod. */
  action: CommitActionMode;
  /** Content of the file. */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Encoding of the file. Default is text. */
  encoding?: InputMaybe<CommitEncoding>;
  /** Enables/disables the execute flag on the file. */
  executeFilemode?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full path to the file. */
  filePath: Scalars['String']['input'];
  /** Last known file commit ID. */
  lastCommitId?: InputMaybe<Scalars['String']['input']>;
  /** Original full path to the file being moved. */
  previousPath?: InputMaybe<Scalars['String']['input']>;
};

/** Mode of a commit action */
export type CommitActionMode =
  /** Chmod command. */
  | 'CHMOD'
  /** Create command. */
  | 'CREATE'
  /** Delete command. */
  | 'DELETE'
  /** Move command. */
  | 'MOVE'
  /** Update command. */
  | 'UPDATE';

/** The connection type for Commit. */
export type CommitConnection = {
  __typename?: 'CommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CommitCreate */
export type CommitCreateInput = {
  /** Array of action hashes to commit as a batch. */
  actions: Array<CommitAction>;
  /** Name of the branch to commit into, it can be a new branch. */
  branch: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Raw commit message. */
  message: Scalars['String']['input'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID']['input'];
  /** If on a new branch, name of the original branch. */
  startBranch?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CommitCreate. */
export type CommitCreatePayload = {
  __typename?: 'CommitCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Commit after mutation. */
  commit?: Maybe<Commit>;
  /** ETag path for the commit's pipeline. */
  commitPipelinePath?: Maybe<Scalars['String']['output']>;
  /** Contents of the commit. */
  content?: Maybe<Array<Scalars['String']['output']>>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CommitData = {
  __typename?: 'CommitData';
  /** CSS class for age of commit. */
  ageMapClass: Scalars['String']['output'];
  /** Link to author avatar. */
  authorAvatar: Scalars['String']['output'];
  /** Link to the commit author. */
  commitAuthorLink: Scalars['String']['output'];
  /** Link to the commit. */
  commitLink: Scalars['String']['output'];
  /** Link to blame prior to the change. */
  projectBlameLink?: Maybe<Scalars['String']['output']>;
  /** Time of commit. */
  timeAgoTooltip: Scalars['String']['output'];
};

/** An edge in a connection. */
export type CommitEdge = {
  __typename?: 'CommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Commit>;
};

export type CommitEncoding =
  /** Base64 encoding. */
  | 'BASE64'
  /** Text encoding. */
  | 'TEXT';

export type CommitParentNames = {
  __typename?: 'CommitParentNames';
  /** Names of the commit parent (branch or tag). */
  names?: Maybe<Array<Scalars['String']['output']>>;
};

export type CommitReferences = {
  __typename?: 'CommitReferences';
  /** Get branch names containing a given commit. */
  containingBranches?: Maybe<CommitParentNames>;
  /** Get tag names containing a given commit. */
  containingTags?: Maybe<CommitParentNames>;
  /** Get branch names tipping at a given commit. */
  tippingBranches?: Maybe<CommitParentNames>;
  /** Get tag names tipping at a given commit. */
  tippingTags?: Maybe<CommitParentNames>;
};


export type CommitReferencesContainingBranchesArgs = {
  excludeTipped?: Scalars['Boolean']['input'];
  limit?: Scalars['Int']['input'];
};


export type CommitReferencesContainingTagsArgs = {
  excludeTipped?: Scalars['Boolean']['input'];
  limit?: Scalars['Int']['input'];
};


export type CommitReferencesTippingBranchesArgs = {
  limit?: Scalars['Int']['input'];
};


export type CommitReferencesTippingTagsArgs = {
  limit?: Scalars['Int']['input'];
};

/** Represents signing information for a commit */
export type CommitSignature = {
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']['output']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

/** Comparable security report type */
export type ComparableSecurityReportType =
  /** API fuzzing report */
  | 'API_FUZZING'
  /** Container scanning report */
  | 'CONTAINER_SCANNING'
  /** Coverage fuzzing report */
  | 'COVERAGE_FUZZING'
  /** DAST report */
  | 'DAST'
  /** Dependency scanning report */
  | 'DEPENDENCY_SCANNING'
  /** SAST report */
  | 'SAST'
  /** Secret detection report */
  | 'SECRET_DETECTION';

/** Represents compared security report. */
export type ComparedSecurityReport = {
  __typename?: 'ComparedSecurityReport';
  /**
   * New vulnerability findings. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  added?: Maybe<Array<ComparedSecurityReportFinding>>;
  /** Time of the base report creation. */
  baseReportCreatedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates whether the base report out of date. */
  baseReportOutOfDate?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Fixed vulnerability findings. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  fixed?: Maybe<Array<ComparedSecurityReportFinding>>;
  /** Time of the base report creation. */
  headReportCreatedAt?: Maybe<Scalars['Time']['output']>;
};

/** Represents finding. */
export type ComparedSecurityReportFinding = {
  __typename?: 'ComparedSecurityReportFinding';
  /**
   * Indicates whether the specific finding can be resolved with AI. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  aiResolutionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the vulnerability finding. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Details of the vulnerability finding. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  details: Array<VulnerabilityDetail>;
  /** IID of the pipeline. */
  foundByPipelineIid?: Maybe<Scalars['String']['output']>;
  /**
   * Identifiers of the vulnerability finding. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  identifiers?: Maybe<Array<VulnerabilityIdentifier>>;
  /**
   * Location of the vulnerability finding. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  location?: Maybe<VulnerabilityLocation>;
  /** Compared report vulnerability scanner. */
  scanner?: Maybe<ComparedSecurityReportScanner>;
  /** Severity of the vulnerability finding. */
  severity?: Maybe<VulnerabilitySeverity>;
  /** Finding status. */
  state?: Maybe<VulnerabilityState>;
  /** Title of the vulnerability finding. */
  title?: Maybe<Scalars['String']['output']>;
  /** UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier. */
  uuid?: Maybe<Scalars['String']['output']>;
};

/** Represents a compared report vulnerability scanner */
export type ComparedSecurityReportScanner = {
  __typename?: 'ComparedSecurityReportScanner';
  /** External ID of the vulnerability scanner. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** Name of the vulnerability scanner. */
  name?: Maybe<Scalars['String']['output']>;
  /** Vendor of the vulnerability scanner. */
  vendor?: Maybe<Scalars['String']['output']>;
};

/** Comparison operators for filtering */
export type ComparisonOperator =
  /** Equal to (=). */
  | 'EQUAL_TO'
  /** Greater than or equal to (>=). */
  | 'GREATER_THAN_OR_EQUAL_TO'
  /** Less than or equal to (<=). */
  | 'LESS_THAN_OR_EQUAL_TO';

/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFramework = {
  __typename?: 'ComplianceFramework';
  /** Hexadecimal representation of compliance framework's label color. */
  color: Scalars['String']['output'];
  /** Compliance requirements of the compliance framework. */
  complianceRequirements?: Maybe<ComplianceRequirementConnection>;
  /** Default compliance framework for the group. */
  default?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the compliance framework. */
  description: Scalars['String']['output'];
  /** Web UI path to edit the compliance framework. */
  editPath: Scalars['String']['output'];
  /** Compliance framework ID. */
  id: Scalars['ID']['output'];
  /** Name of the compliance framework. */
  name: Scalars['String']['output'];
  /** Namespace ID. */
  namespaceId: Scalars['TypesNamespaceID']['output'];
  /**
   * Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`. Ultimate only. Deprecated in GitLab 17.4: Use pipeline execution policies instead.
   * @deprecated Use pipeline execution policies instead. Deprecated in GitLab 17.4.
   */
  pipelineConfigurationFullPath?: Maybe<Scalars['String']['output']>;
  /** Pipeline Execution Policies of the compliance framework. */
  pipelineExecutionPolicies?: Maybe<PipelineExecutionPolicyConnection>;
  /** Pipeline Execution Schedule Policies of the compliance framework. */
  pipelineExecutionSchedulePolicies?: Maybe<PipelineExecutionSchedulePolicyConnection>;
  /** Projects associated with the compliance framework. */
  projects?: Maybe<ProjectConnection>;
  /** Scan Execution Policies of the compliance framework. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the compliance framework. */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Timestamp of when the compliance framework was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Vulnerability Management Policies of the compliance framework. */
  vulnerabilityManagementPolicies?: Maybe<VulnerabilityManagementPolicyConnection>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkComplianceRequirementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkPipelineExecutionPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkPipelineExecutionSchedulePoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkScanExecutionPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFrameworkVulnerabilityManagementPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ComplianceFramework. */
export type ComplianceFrameworkConnection = {
  __typename?: 'ComplianceFrameworkConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceFrameworkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceFramework>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ComplianceFramework. */
export type ComplianceFrameworkConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Framework coverage details for a specific compliance framework. */
export type ComplianceFrameworkCoverageDetail = {
  __typename?: 'ComplianceFrameworkCoverageDetail';
  /** Number of projects covered by the framework. */
  coveredCount: Scalars['Int']['output'];
  /** Compliance framework associated with the coverage detail. */
  framework: ComplianceFramework;
  /** ID of the framework. */
  id: Scalars['ID']['output'];
};

/** The connection type for ComplianceFrameworkCoverageDetail. */
export type ComplianceFrameworkCoverageDetailConnection = {
  __typename?: 'ComplianceFrameworkCoverageDetailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceFrameworkCoverageDetailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceFrameworkCoverageDetail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceFrameworkCoverageDetailEdge = {
  __typename?: 'ComplianceFrameworkCoverageDetailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceFrameworkCoverageDetail>;
};

/** Compliance framework Coverage summary for a group. */
export type ComplianceFrameworkCoverageSummary = {
  __typename?: 'ComplianceFrameworkCoverageSummary';
  /** Number of projects covered by at least one framework. */
  coveredCount: Scalars['Int']['output'];
  /** Total number of projects in the group. */
  totalProjects: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ComplianceFrameworkEdge = {
  __typename?: 'ComplianceFrameworkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceFramework>;
};

export type ComplianceFrameworkFilters = {
  /** ID of the compliance framework. */
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** IDs of the compliance framework. */
  ids?: InputMaybe<Array<Scalars['ComplianceManagementFrameworkID']['input']>>;
  /** Negated compliance framework filter input. */
  not?: InputMaybe<NegatedComplianceFrameworkFilters>;
  /** Checks presence of compliance framework of the project, "none" and "any" values are supported. */
  presenceFilter?: InputMaybe<ComplianceFrameworkPresenceFilter>;
};

export type ComplianceFrameworkInput = {
  /** New color representation of the compliance framework in hex format. e.g. #FCA121. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** Set the compliance framework as the default framework for the group. */
  default?: InputMaybe<Scalars['Boolean']['input']>;
  /** New description for the compliance framework. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** New name for the compliance framework. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Projects to add or remove from the compliance framework. */
  projects?: InputMaybe<ComplianceFrameworkProjectInput>;
};

/** ComplianceFramework of a project for filtering */
export type ComplianceFrameworkPresenceFilter =
  /** Any compliance framework is assigned. */
  | 'ANY'
  /** No compliance framework is assigned. */
  | 'NONE';

export type ComplianceFrameworkProjectInput = {
  /** IDs of the projects to add to the compliance framework. */
  addProjects: Array<Scalars['Int']['input']>;
  /** IDs of the projects to remove from the compliance framework. */
  removeProjects: Array<Scalars['Int']['input']>;
};

/** Values for sorting compliance frameworks. */
export type ComplianceFrameworkSort =
  /** Sort by compliance framework name, ascending order. */
  | 'NAME_ASC'
  /** Sort by compliance framework name, descending order. */
  | 'NAME_DESC'
  /** Sort by compliance framework updated date, ascending order. */
  | 'UPDATED_AT_ASC'
  /** Sort by compliance framework updated date, descending order. */
  | 'UPDATED_AT_DESC';

/** Compliance framework requiring attention. */
export type ComplianceFrameworksNeedingAttention = {
  __typename?: 'ComplianceFrameworksNeedingAttention';
  /** Compliance framework needing attention. */
  framework: ComplianceFramework;
  /** ID of the framework needing attention. */
  id: Scalars['ID']['output'];
  /** Number of projects with the framework applied. */
  projectsCount: Scalars['Int']['output'];
  /** Number of requirements in the framework. */
  requirementsCount: Scalars['Int']['output'];
  /** Requirements without controls. */
  requirementsWithoutControls?: Maybe<Array<ComplianceRequirement>>;
};

/** The connection type for ComplianceFrameworksNeedingAttention. */
export type ComplianceFrameworksNeedingAttentionConnection = {
  __typename?: 'ComplianceFrameworksNeedingAttentionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceFrameworksNeedingAttentionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceFrameworksNeedingAttention>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceFrameworksNeedingAttentionEdge = {
  __typename?: 'ComplianceFrameworksNeedingAttentionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceFrameworksNeedingAttention>;
};

/** Represents a ComplianceRequirement associated with a ComplianceFramework */
export type ComplianceRequirement = {
  __typename?: 'ComplianceRequirement';
  /** Compliance controls of the compliance requirement. */
  complianceRequirementsControls?: Maybe<ComplianceRequirementsControlConnection>;
  /** Description of the compliance requirement. */
  description: Scalars['String']['output'];
  /** Compliance framework associated with the requirement. */
  framework?: Maybe<ComplianceFramework>;
  /** Compliance requirement ID. */
  id: Scalars['ID']['output'];
  /** Name of the compliance requirement. */
  name: Scalars['String']['output'];
};


/** Represents a ComplianceRequirement associated with a ComplianceFramework */
export type ComplianceRequirementComplianceRequirementsControlsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ComplianceRequirement. */
export type ComplianceRequirementConnection = {
  __typename?: 'ComplianceRequirementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceRequirementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceRequirement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Lists down all the possible types of requirement controls. */
export type ComplianceRequirementControl = {
  __typename?: 'ComplianceRequirementControl';
  /** List of requirement controls. */
  controlExpressions: Array<ControlExpression>;
};

/** An edge in a connection. */
export type ComplianceRequirementEdge = {
  __typename?: 'ComplianceRequirementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceRequirement>;
};

export type ComplianceRequirementInput = {
  /** Compliance controls of the compliance requirement. */
  complianceRequirementsControls?: InputMaybe<Array<ComplianceRequirementsControlInput>>;
  /** New description for the compliance requirement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** New name for the compliance requirement. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a ComplianceRequirementsControl associated with a ComplianceRequirement */
export type ComplianceRequirementsControl = {
  __typename?: 'ComplianceRequirementsControl';
  /** Compliance requirement associated with the control. */
  complianceRequirement?: Maybe<ComplianceRequirement>;
  /** Type of the compliance control. */
  controlType: Scalars['String']['output'];
  /** Expression of the compliance control. */
  expression?: Maybe<Scalars['String']['output']>;
  /** Name of the external control. */
  externalControlName?: Maybe<Scalars['String']['output']>;
  /** URL of the external control. */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** Compliance requirements control ID. */
  id: Scalars['ID']['output'];
  /** Name of the compliance control. */
  name: Scalars['String']['output'];
  /** Whether ping is enabled for external controls. */
  pingEnabled: Scalars['Boolean']['output'];
};

/** The connection type for ComplianceRequirementsControl. */
export type ComplianceRequirementsControlConnection = {
  __typename?: 'ComplianceRequirementsControlConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceRequirementsControlEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceRequirementsControl>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceRequirementsControlEdge = {
  __typename?: 'ComplianceRequirementsControlEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceRequirementsControl>;
};

export type ComplianceRequirementsControlInput = {
  /** Type of the compliance control. */
  controlType?: InputMaybe<Scalars['String']['input']>;
  /** Expression of the compliance control. */
  expression?: InputMaybe<Scalars['String']['input']>;
  /** Name of the external control. */
  externalControlName?: InputMaybe<Scalars['String']['input']>;
  /** URL of the external control. */
  externalUrl?: InputMaybe<Scalars['String']['input']>;
  /** New name for the compliance requirement control. */
  name: Scalars['String']['input'];
  /** Whether ping is enabled for external controls. */
  pingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Secret token for an external control. */
  secretToken?: InputMaybe<Scalars['String']['input']>;
};

/** Compliance standards adherence for a project. */
export type ComplianceStandardsAdherence = {
  __typename?: 'ComplianceStandardsAdherence';
  /** Name of the check for the compliance standard. */
  checkName: ComplianceStandardsAdherenceCheckName;
  /** Compliance standards adherence ID. */
  id: Scalars['ID']['output'];
  /** Project adhering to the compliance standard. */
  project: Project;
  /** Name of the compliance standard. */
  standard: ComplianceStandardsAdherenceStandard;
  /** Status of the compliance standards adherence. */
  status: ComplianceStandardsAdherenceStatus;
  /** Timestamp when the adherence was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Name of the check for the compliance standard. */
export type ComplianceStandardsAdherenceCheckName =
  /** At least one non author approval */
  | 'AT_LEAST_ONE_NON_AUTHOR_APPROVAL'
  /** At least two approvals */
  | 'AT_LEAST_TWO_APPROVALS'
  /** Dast */
  | 'DAST'
  /** Prevent approval by merge request creator (author) */
  | 'PREVENT_APPROVAL_BY_MERGE_REQUEST_AUTHOR'
  /** Prevent approval by merge request committers */
  | 'PREVENT_APPROVAL_BY_MERGE_REQUEST_COMMITTERS'
  /** Sast */
  | 'SAST';

/** The connection type for ComplianceStandardsAdherence. */
export type ComplianceStandardsAdherenceConnection = {
  __typename?: 'ComplianceStandardsAdherenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceStandardsAdherenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceStandardsAdherence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceStandardsAdherenceEdge = {
  __typename?: 'ComplianceStandardsAdherenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceStandardsAdherence>;
};

export type ComplianceStandardsAdherenceInput = {
  /** Name of the check for the compliance standard. */
  checkName?: InputMaybe<ComplianceStandardsAdherenceCheckName>;
  /** Filter compliance standards adherence by project. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
  /** Name of the compliance standard. */
  standard?: InputMaybe<ComplianceStandardsAdherenceStandard>;
};

/** Name of the compliance standard. */
export type ComplianceStandardsAdherenceStandard =
  /** Gitlab */
  | 'GITLAB'
  /** Soc2 */
  | 'SOC2';

/** Status of the compliance standards adherence. */
export type ComplianceStandardsAdherenceStatus =
  /** Fail */
  | 'FAIL'
  /** Success */
  | 'SUCCESS';

export type ComplianceStandardsProjectAdherenceInput = {
  /** Name of the check for the compliance standard. */
  checkName?: InputMaybe<ComplianceStandardsAdherenceCheckName>;
  /** Name of the compliance standard. */
  standard?: InputMaybe<ComplianceStandardsAdherenceStandard>;
};

/** Compliance violation associated with a merged merge request. */
export type ComplianceViolation = {
  __typename?: 'ComplianceViolation';
  /** Compliance violation ID. */
  id: Scalars['ID']['output'];
  /** Merge request the compliance violation occurred in. */
  mergeRequest: MergeRequest;
  /** Reason the compliance violation occurred. */
  reason: ComplianceViolationReason;
  /** Severity of the compliance violation. */
  severityLevel: ComplianceViolationSeverity;
  /** User suspected of causing the compliance violation. */
  violatingUser: UserCore;
};

/** The connection type for ComplianceViolation. */
export type ComplianceViolationConnection = {
  __typename?: 'ComplianceViolationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceViolationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceViolation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceViolationEdge = {
  __typename?: 'ComplianceViolationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceViolation>;
};

export type ComplianceViolationInput = {
  /** Merge requests merged after the date (inclusive). */
  mergedAfter?: InputMaybe<Scalars['Date']['input']>;
  /** Merge requests merged before the date (inclusive). */
  mergedBefore?: InputMaybe<Scalars['Date']['input']>;
  /** Filter compliance violations by project. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
  /** Filter compliance violations by target branch. */
  targetBranch?: InputMaybe<Scalars['String']['input']>;
};

export type ComplianceViolationProjectInput = {
  /** Merge requests merged after the date (inclusive). */
  mergedAfter?: InputMaybe<Scalars['Date']['input']>;
  /** Merge requests merged before the date (inclusive). */
  mergedBefore?: InputMaybe<Scalars['Date']['input']>;
  /** Filter compliance violations by target branch. */
  targetBranch?: InputMaybe<Scalars['String']['input']>;
};

/** Reason for the compliance violation. */
export type ComplianceViolationReason =
  /** Approved by committer */
  | 'APPROVED_BY_COMMITTER'
  /** Approved by insufficient users */
  | 'APPROVED_BY_INSUFFICIENT_USERS'
  /** Approved by merge request author */
  | 'APPROVED_BY_MERGE_REQUEST_AUTHOR';

/** Severity of the compliance violation. */
export type ComplianceViolationSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM';

/** Compliance violation sort values. */
export type ComplianceViolationSort =
  /** Date merged in ascending order, further sorted by ID in ascending order. */
  | 'MERGED_AT_ASC'
  /** Date merged in descending order, further sorted by ID in descending order. */
  | 'MERGED_AT_DESC'
  /** Merge request title in ascending order, further sorted by ID in ascending order. */
  | 'MERGE_REQUEST_TITLE_ASC'
  /** Merge request title in descending order, further sorted by ID in descending order. */
  | 'MERGE_REQUEST_TITLE_DESC'
  /** Severity in ascending order, further sorted by ID in ascending order. */
  | 'SEVERITY_LEVEL_ASC'
  /** Severity in descending order, further sorted by ID in descending order. */
  | 'SEVERITY_LEVEL_DESC'
  /** Violation reason in ascending order, further sorted by ID in ascending order. */
  | 'VIOLATION_REASON_ASC'
  /** Violation reason in descending order, further sorted by ID in descending order. */
  | 'VIOLATION_REASON_DESC';

/** Compliance violation status of the project. */
export type ComplianceViolationStatus =
  /** Detected */
  | 'DETECTED'
  /** Dismissed */
  | 'DISMISSED'
  /** In review */
  | 'IN_REVIEW'
  /** Resolved */
  | 'RESOLVED';

/** A software dependency used by a project */
export type Component = {
  __typename?: 'Component';
  /** ID of the dependency. */
  id: Scalars['SbomComponentID']['output'];
  /** Name of the dependency. */
  name: Scalars['String']['output'];
};

/** A software dependency version used by a project */
export type ComponentVersion = {
  __typename?: 'ComponentVersion';
  /** ID of the dependency version. */
  id: Scalars['SbomComponentVersionID']['output'];
  /** Version of the dependency. */
  version: Scalars['String']['output'];
};

/** The connection type for ComponentVersion. */
export type ComponentVersionConnection = {
  __typename?: 'ComponentVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComponentVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComponentVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComponentVersionEdge = {
  __typename?: 'ComponentVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ComponentVersion>;
};

/** Composer metadata */
export type ComposerMetadata = {
  __typename?: 'ComposerMetadata';
  /** Data of the Composer JSON file. */
  composerJson: PackageComposerJsonType;
  /** Target SHA of the package. */
  targetSha: Scalars['String']['output'];
};

/** Conan file metadata */
export type ConanFileMetadata = PackageFileMetadata & {
  __typename?: 'ConanFileMetadata';
  /** Type of the Conan file. */
  conanFileType: ConanMetadatumFileTypeEnum;
  /** Reference of the Conan package. */
  conanPackageReference?: Maybe<Scalars['String']['output']>;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanFileMetadatumID']['output'];
  /** Revision of the package. */
  packageRevision?: Maybe<Scalars['String']['output']>;
  /** Revision of the Conan recipe. */
  recipeRevision: Scalars['String']['output'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** Conan metadata */
export type ConanMetadata = {
  __typename?: 'ConanMetadata';
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanMetadatumID']['output'];
  /** Channel of the Conan package. */
  packageChannel: Scalars['String']['output'];
  /** Username of the Conan package. */
  packageUsername: Scalars['String']['output'];
  /** Recipe of the Conan package. */
  recipe: Scalars['String']['output'];
  /** Recipe path of the Conan package. */
  recipePath: Scalars['String']['output'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** Conan file types */
export type ConanMetadatumFileTypeEnum =
  /** A package file type. */
  | 'PACKAGE_FILE'
  /** A recipe file type. */
  | 'RECIPE_FILE';

/** Autogenerated input type of ConfigureContainerScanning */
export type ConfigureContainerScanningInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfigureContainerScanning. */
export type ConfigureContainerScanningPayload = {
  __typename?: 'ConfigureContainerScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ConfigureDependencyScanning */
export type ConfigureDependencyScanningInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfigureDependencyScanning. */
export type ConfigureDependencyScanningPayload = {
  __typename?: 'ConfigureDependencyScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ConfigureSastIac */
export type ConfigureSastIacInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfigureSastIac. */
export type ConfigureSastIacPayload = {
  __typename?: 'ConfigureSastIacPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ConfigureSast */
export type ConfigureSastInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** SAST CI configuration for the project. */
  configuration: SastCiConfigurationInput;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfigureSast. */
export type ConfigureSastPayload = {
  __typename?: 'ConfigureSastPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ConfigureSecretDetection */
export type ConfigureSecretDetectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfigureSecretDetection. */
export type ConfigureSecretDetectionPayload = {
  __typename?: 'ConfigureSecretDetectionPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']['output']>;
};

/** Connection details for an Agent */
export type ConnectedAgent = {
  __typename?: 'ConnectedAgent';
  /** When the connection was established. */
  connectedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the connection. */
  connectionId?: Maybe<Scalars['BigInt']['output']>;
  /** Information about the Agent. */
  metadata?: Maybe<AgentMetadata>;
  /** Agent warnings list. */
  warnings?: Maybe<Array<AgentWarning>>;
};

/** The connection type for ConnectedAgent. */
export type ConnectedAgentConnection = {
  __typename?: 'ConnectedAgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectedAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ConnectedAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConnectedAgentEdge = {
  __typename?: 'ConnectedAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectedAgent>;
};

/** Values for sorting contacts */
export type ContactSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Description in ascending order. */
  | 'DESCRIPTION_ASC'
  /** Description in descending order. */
  | 'DESCRIPTION_DESC'
  /** Email in ascending order. */
  | 'EMAIL_ASC'
  /** Email in descending order. */
  | 'EMAIL_DESC'
  /** First name in ascending order. */
  | 'FIRST_NAME_ASC'
  /** First name in descending order. */
  | 'FIRST_NAME_DESC'
  /** Last name in ascending order. */
  | 'LAST_NAME_ASC'
  /** Last name in descending order. */
  | 'LAST_NAME_DESC'
  /** Organization in ascending order. */
  | 'ORGANIZATION_ASC'
  /** Organization in descending order. */
  | 'ORGANIZATION_DESC'
  /** Phone in ascending order. */
  | 'PHONE_ASC'
  /** Phone in descending order. */
  | 'PHONE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Represents the total number of contacts for the represented states. */
export type ContactStateCounts = {
  __typename?: 'ContactStateCounts';
  /** Number of contacts with state `ACTIVE` */
  active?: Maybe<Scalars['Int']['output']>;
  /** Number of contacts with state `ALL` */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of contacts with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']['output']>;
};

/** A tag expiration policy designed to keep only the images that matter most */
export type ContainerExpirationPolicy = {
  __typename?: 'ContainerExpirationPolicy';
  /** This container expiration policy schedule. */
  cadence: ContainerExpirationPolicyCadenceEnum;
  /** Timestamp of when the container expiration policy was created. */
  createdAt: Scalars['Time']['output'];
  /** Indicates whether the container expiration policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Number of tags to retain. */
  keepN?: Maybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching the regex pattern will expire. */
  nameRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Tags with names matching the regex pattern will be preserved. */
  nameRegexKeep?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Next time that the container expiration policy will get executed. */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
  /** Tags older than the given age will expire. */
  olderThan?: Maybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Timestamp of when the container expiration policy was updated. */
  updatedAt: Scalars['Time']['output'];
};

export type ContainerExpirationPolicyCadenceEnum =
  /** Every day */
  | 'EVERY_DAY'
  /** Every month */
  | 'EVERY_MONTH'
  /** Every three months */
  | 'EVERY_THREE_MONTHS'
  /** Every two weeks */
  | 'EVERY_TWO_WEEKS'
  /** Every week */
  | 'EVERY_WEEK';

export type ContainerExpirationPolicyKeepEnum =
  /** 50 tags per image name */
  | 'FIFTY_TAGS'
  /** 5 tags per image name */
  | 'FIVE_TAGS'
  /** 100 tags per image name */
  | 'ONE_HUNDRED_TAGS'
  /** 1 tag per image name */
  | 'ONE_TAG'
  /** 10 tags per image name */
  | 'TEN_TAGS'
  /** 25 tags per image name */
  | 'TWENTY_FIVE_TAGS';

export type ContainerExpirationPolicyOlderThanEnum =
  /** 14 days until tags are automatically removed */
  | 'FOURTEEN_DAYS'
  /** 90 days until tags are automatically removed */
  | 'NINETY_DAYS'
  /** 7 days until tags are automatically removed */
  | 'SEVEN_DAYS'
  /** 60 days until tags are automatically removed */
  | 'SIXTY_DAYS'
  /** 30 days until tags are automatically removed */
  | 'THIRTY_DAYS';

/** Represents the most restrictive permissions for a container image tag */
export type ContainerProtectionAccessLevel = AccessLevelInterface & {
  __typename?: 'ContainerProtectionAccessLevel';
  /**
   * Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  immutable: Scalars['Boolean']['output'];
  /**
   * Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can delete tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForDelete?: Maybe<ContainerProtectionTagRuleAccessLevel>;
  /**
   * Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can push tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForPush?: Maybe<ContainerProtectionTagRuleAccessLevel>;
};

/** A container repository protection rule designed to prevent users with a certain access level or lower from altering the container registry. */
export type ContainerProtectionRepositoryRule = {
  __typename?: 'ContainerProtectionRepositoryRule';
  /** ID of the container repository protection rule. */
  id: Scalars['ContainerRegistryProtectionRuleID']['output'];
  /** Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForDelete?: Maybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: Maybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Container repository path pattern protected by the protection rule. Must start with the projects full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the projects full path. */
  repositoryPathPattern: Scalars['String']['output'];
};

/** Access level for a container repository protection rule resource */
export type ContainerProtectionRepositoryRuleAccessLevel =
  /** Admin access. */
  | 'ADMIN'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Owner access. */
  | 'OWNER';

/** The connection type for ContainerProtectionRepositoryRule. */
export type ContainerProtectionRepositoryRuleConnection = {
  __typename?: 'ContainerProtectionRepositoryRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerProtectionRepositoryRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerProtectionRepositoryRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerProtectionRepositoryRuleEdge = {
  __typename?: 'ContainerProtectionRepositoryRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerProtectionRepositoryRule>;
};

/** A container repository tag protection rule designed to prevent users with a certain access level or lower from altering the container registry. */
export type ContainerProtectionTagRule = AccessLevelInterface & {
  __typename?: 'ContainerProtectionTagRule';
  /**
   * ID of the container repository tag protection rule. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  id: Scalars['ContainerRegistryProtectionTagRuleID']['output'];
  /**
   * Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  immutable: Scalars['Boolean']['output'];
  /**
   * Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can delete tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForDelete?: Maybe<ContainerProtectionTagRuleAccessLevel>;
  /**
   * Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can push tags.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  minimumAccessLevelForPush?: Maybe<ContainerProtectionTagRuleAccessLevel>;
  /**
   * The pattern that matches container image tags to protect. For example, `v1.*`. Wildcard character `*` allowed. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  tagNamePattern: Scalars['String']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: ContainerRegistryProtectionTagRulePermissions;
};

/** Access level of a container registry tag protection rule resource */
export type ContainerProtectionTagRuleAccessLevel =
  /** Admin access. Introduced in GitLab 17.8: **Status**: Experiment. */
  | 'ADMIN'
  /** Maintainer access. Introduced in GitLab 17.8: **Status**: Experiment. */
  | 'MAINTAINER'
  /** Owner access. Introduced in GitLab 17.8: **Status**: Experiment. */
  | 'OWNER';

/** The connection type for ContainerProtectionTagRule. */
export type ContainerProtectionTagRuleConnection = {
  __typename?: 'ContainerProtectionTagRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerProtectionTagRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerProtectionTagRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerProtectionTagRuleEdge = {
  __typename?: 'ContainerProtectionTagRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerProtectionTagRule>;
};

/** Represents a container virtual registry */
export type ContainerRegistry = RegistryInterface & {
  __typename?: 'ContainerRegistry';
  /** Description of the virtual registry. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the virtual registry. */
  id: Scalars['ID']['output'];
  /** Name of the virtual registry. */
  name: Scalars['String']['output'];
  /** Timestamp of when the virtual registry was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for ContainerRegistry. */
export type ContainerRegistryConnection = {
  __typename?: 'ContainerRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents container virtual registry details */
export type ContainerRegistryDetails = RegistryInterface & {
  __typename?: 'ContainerRegistryDetails';
  /** Description of the virtual registry. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the virtual registry. */
  id: Scalars['ID']['output'];
  /** Name of the virtual registry. */
  name: Scalars['String']['output'];
  /**
   * List of registry upstreams for the container virtual registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  registryUpstreams: Array<ContainerRegistryUpstreamWithUpstream>;
  /** Timestamp of when the virtual registry was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** An edge in a connection. */
export type ContainerRegistryEdge = {
  __typename?: 'ContainerRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRegistry>;
};

export type ContainerRegistryProtectionTagRulePermissions = {
  __typename?: 'ContainerRegistryProtectionTagRulePermissions';
  /** If `true`, the user can perform `destroy_container_registry_protection_tag_rule` on this resource */
  destroyContainerRegistryProtectionTagRule: Scalars['Boolean']['output'];
};

/** Represents a container virtual registry upstream and its relationship to the upstream. */
export type ContainerRegistryUpstreamWithUpstream = {
  __typename?: 'ContainerRegistryUpstreamWithUpstream';
  /**
   * ID of the registry upstream. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  id: Scalars['ID']['output'];
  /**
   * Position of the upstream registry in an ordered list. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  position: Scalars['Int']['output'];
  /**
   * Container upstream associated with the registry upstream. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  upstream: ContainerUpstream;
};

/** A container repository */
export type ContainerRepository = {
  __typename?: 'ContainerRepository';
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time']['output'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the container repository. */
  id: Scalars['ID']['output'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']['output']>;
  /** URL of the container repository. */
  location: Scalars['String']['output'];
  /**
   * Migration state of the container repository. Deprecated in GitLab 17.0: Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances.
   * @deprecated Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances. Deprecated in GitLab 17.0.
   */
  migrationState: Scalars['String']['output'];
  /** Name of the container repository. */
  name: Scalars['String']['output'];
  /** Path of the container repository. */
  path: Scalars['String']['output'];
  /** Project of the container registry. */
  project: Project;
  /** Whether any matching container protection rule exists for the container repository. */
  protectionRuleExists: Scalars['Boolean']['output'];
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Number of tags associated with the image. */
  tagsCount: Scalars['Int']['output'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: ContainerRepositoryPermissions;
};

/** Status of the tags cleanup of a container repository */
export type ContainerRepositoryCleanupStatus =
  /** Tags cleanup is ongoing. */
  | 'ONGOING'
  /** Tags cleanup is scheduled and is going to be executed shortly. */
  | 'SCHEDULED'
  /** Tags cleanup has been partially executed. There are still remaining tags to delete. */
  | 'UNFINISHED'
  /** Tags cleanup is not scheduled. This is the default state. */
  | 'UNSCHEDULED';

/** The connection type for ContainerRepository. */
export type ContainerRepositoryConnection = {
  __typename?: 'ContainerRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Details of a container repository */
export type ContainerRepositoryDetails = {
  __typename?: 'ContainerRepositoryDetails';
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time']['output'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the container repository. */
  id: Scalars['ID']['output'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when a repository tag was last created or updated. Only present for repositories that had tags created or updated after GitLab 16.11. */
  lastPublishedAt?: Maybe<Scalars['Time']['output']>;
  /** URL of the container repository. */
  location: Scalars['String']['output'];
  /** An image manifest from the container repository. */
  manifest?: Maybe<Scalars['String']['output']>;
  /**
   * Migration state of the container repository. Deprecated in GitLab 17.0: Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances.
   * @deprecated Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances. Deprecated in GitLab 17.0.
   */
  migrationState: Scalars['String']['output'];
  /** Name of the container repository. */
  name: Scalars['String']['output'];
  /** Path of the container repository. */
  path: Scalars['String']['output'];
  /** Project of the container registry. */
  project: Project;
  /** Whether any matching container protection rule exists for the container repository. */
  protectionRuleExists: Scalars['Boolean']['output'];
  /** Deduplicated size of the image repository in bytes. This is only available on GitLab.com for repositories created after `2021-11-04`. */
  size?: Maybe<Scalars['Float']['output']>;
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Tags of the container repository. */
  tags?: Maybe<ContainerRepositoryTagConnection>;
  /** Number of tags associated with the image. */
  tagsCount: Scalars['Int']['output'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: ContainerRepositoryPermissions;
};


/** Details of a container repository */
export type ContainerRepositoryDetailsManifestArgs = {
  reference: Scalars['String']['input'];
};


/** Details of a container repository */
export type ContainerRepositoryDetailsTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  referrerType?: InputMaybe<Scalars['String']['input']>;
  referrers?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<ContainerRepositoryTagSort>;
};

/** An edge in a connection. */
export type ContainerRepositoryEdge = {
  __typename?: 'ContainerRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepository>;
};

export type ContainerRepositoryPermissions = {
  __typename?: 'ContainerRepositoryPermissions';
  /** If `true`, the user can perform `destroy_container_image` on this resource */
  destroyContainerRepository: Scalars['Boolean']['output'];
};

/** A referrer for a container repository tag */
export type ContainerRepositoryReferrer = {
  __typename?: 'ContainerRepositoryReferrer';
  /** Artifact type of the referrer. */
  artifactType?: Maybe<Scalars['String']['output']>;
  /** Digest of the referrer. */
  digest?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: ContainerRepositoryTagPermissions;
};

/** Represents the Geo replication and verification state of an Container Repository. */
export type ContainerRepositoryRegistry = {
  __typename?: 'ContainerRepositoryRegistry';
  /** Indicate if the checksums of the ContainerRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ContainerRepository. */
  containerRepositoryId: Scalars['ID']['output'];
  /** Timestamp when the ContainerRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ContainerRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the ContainerRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the ContainerRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the ContainerRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ContainerRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the ContainerRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the ContainerRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the ContainerRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the ContainerRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the ContainerRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the ContainerRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the ContainerRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the ContainerRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of ContainerRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the ContainerRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the ContainerRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for ContainerRepositoryRegistry. */
export type ContainerRepositoryRegistryConnection = {
  __typename?: 'ContainerRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ContainerRepositoryRegistry. */
export type ContainerRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ContainerRepositoryRegistryEdge = {
  __typename?: 'ContainerRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryRegistry>;
};

/** Values for sorting container repositories */
export type ContainerRepositorySort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Status of a container repository */
export type ContainerRepositoryStatus =
  /** Delete Failed status. */
  | 'DELETE_FAILED'
  /** Delete Ongoing status. */
  | 'DELETE_ONGOING'
  /** Delete Scheduled status. */
  | 'DELETE_SCHEDULED';

/** A tag from a container repository */
export type ContainerRepositoryTag = {
  __typename?: 'ContainerRepositoryTag';
  /** Timestamp when the tag was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Digest of the tag. */
  digest?: Maybe<Scalars['String']['output']>;
  /** URL of the tag. */
  location: Scalars['String']['output'];
  /** Media type of the tag. */
  mediaType?: Maybe<Scalars['String']['output']>;
  /** Name of the tag. */
  name: Scalars['String']['output'];
  /** Path of the tag. */
  path: Scalars['String']['output'];
  /**
   * Minimum GitLab access level required to push and delete container image tags. If the value is `nil`, no minimum access level is enforced. Users with the Developer role or higher can push tags by default. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  protection?: Maybe<ContainerProtectionAccessLevel>;
  /** Timestamp when the tag was published. */
  publishedAt?: Maybe<Scalars['Time']['output']>;
  /** Referrers for the tag. */
  referrers?: Maybe<Array<ContainerRepositoryReferrer>>;
  /** Revision of the tag. */
  revision?: Maybe<Scalars['String']['output']>;
  /** Short revision of the tag. */
  shortRevision?: Maybe<Scalars['String']['output']>;
  /** Size of the tag. */
  totalSize?: Maybe<Scalars['BigInt']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: ContainerRepositoryTagPermissions;
};

/** The connection type for ContainerRepositoryTag. */
export type ContainerRepositoryTagConnection = {
  __typename?: 'ContainerRepositoryTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerRepositoryTagEdge = {
  __typename?: 'ContainerRepositoryTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryTag>;
};

export type ContainerRepositoryTagPermissions = {
  __typename?: 'ContainerRepositoryTagPermissions';
  /** If `true`, the user can perform `destroy_container_image_tag` on this resource */
  destroyContainerRepositoryTag: Scalars['Boolean']['output'];
};

/** Values for sorting tags */
export type ContainerRepositoryTagSort =
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC'
  /** Ordered by published_at in ascending order. Only available for GitLab.com. */
  | 'PUBLISHED_AT_ASC'
  /** Ordered by published_at in descending order. Only available for GitLab.com. */
  | 'PUBLISHED_AT_DESC';

/** A tag expiration policy using regex patterns to control which images to keep or expire. */
export type ContainerTagsExpirationPolicy = {
  __typename?: 'ContainerTagsExpirationPolicy';
  /** Schedule of the container expiration policy. */
  cadence?: Maybe<ContainerExpirationPolicyCadenceEnum>;
  /** Timestamp of when the container expiration policy was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates whether the container expiration policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Number of tags to retain. */
  keepN?: Maybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching the regex pattern will expire. */
  nameRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Tags with names matching the regex pattern will be preserved. */
  nameRegexKeep?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Next time that the container expiration policy will get executed. */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
  /** Tags older than the given age will expire. */
  olderThan?: Maybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Timestamp of when the container expiration policy was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** Represents a container upstream registry. */
export type ContainerUpstream = {
  __typename?: 'ContainerUpstream';
  /**
   * Time before the cache expires for the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  cacheValidityHours: Scalars['Int']['output'];
  /**
   * Description of the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  id: Scalars['ID']['output'];
  /**
   * Name of the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  name: Scalars['String']['output'];
  /**
   * Number of registries using the upstream. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  registriesCount: Scalars['Int']['output'];
  /**
   * URL of the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  url: Scalars['String']['output'];
  /**
   * Username to sign in to the upstream registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  username?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ContainerUpstream. */
export type ContainerUpstreamConnection = {
  __typename?: 'ContainerUpstreamConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerUpstreamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerUpstream>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ContainerUpstream. */
export type ContainerUpstreamConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ContainerUpstreamEdge = {
  __typename?: 'ContainerUpstreamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerUpstream>;
};

/** Presets for GitLab Duo Chat window based on current context */
export type ContextPreset = {
  __typename?: 'ContextPreset';
  /** Serialized representation of the AI resource in the current context. */
  aiResourceData?: Maybe<Scalars['String']['output']>;
  /** Array of questions that the user can ask GitLab Duo Chat from the current page. */
  questions?: Maybe<Array<Scalars['String']['output']>>;
};

/** Represents the contributions of a user. */
export type ContributionAnalyticsContribution = {
  __typename?: 'ContributionAnalyticsContribution';
  /** Number of issues closed by the user. */
  issuesClosed?: Maybe<Scalars['Int']['output']>;
  /** Number of issues created by the user. */
  issuesCreated?: Maybe<Scalars['Int']['output']>;
  /** Number of merge requests approved by the user. */
  mergeRequestsApproved?: Maybe<Scalars['Int']['output']>;
  /** Number of merge requests closed by the user. */
  mergeRequestsClosed?: Maybe<Scalars['Int']['output']>;
  /** Number of merge requests created by the user. */
  mergeRequestsCreated?: Maybe<Scalars['Int']['output']>;
  /** Number of merge requests merged by the user. */
  mergeRequestsMerged?: Maybe<Scalars['Int']['output']>;
  /** Number of repository pushes the user made. */
  repoPushed?: Maybe<Scalars['Int']['output']>;
  /** Total number of events contributed by the user. */
  totalEvents?: Maybe<Scalars['Int']['output']>;
  /** Contributor User object. */
  user?: Maybe<UserCore>;
};

/** The connection type for ContributionAnalyticsContribution. */
export type ContributionAnalyticsContributionConnection = {
  __typename?: 'ContributionAnalyticsContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContributionAnalyticsContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContributionAnalyticsContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContributionAnalyticsContributionEdge = {
  __typename?: 'ContributionAnalyticsContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ContributionAnalyticsContribution>;
};

/** Represents a control expression. */
export type ControlExpression = {
  __typename?: 'ControlExpression';
  /** Expression details for the control. */
  expression: ExpressionValue;
  /** ID for the control. */
  id: Scalars['ID']['output'];
  /** Name of the control. */
  name: Scalars['String']['output'];
};

/** Autogenerated input type of CorpusCreate */
export type CorpusCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project the corpus belongs to. */
  fullPath: Scalars['ID']['input'];
  /** ID of the corpus package. */
  packageId: Scalars['PackagesPackageID']['input'];
};

/** Autogenerated return type of CorpusCreate. */
export type CorpusCreatePayload = {
  __typename?: 'CorpusCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerability = NoteableInterface & Todoable & {
  __typename?: 'CountableVulnerability';
  /** Indicates whether the type of vulnerability can be resolved with AI. */
  aiResolutionAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the specific vulnerability can be resolved with AI. */
  aiResolutionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * AI workflows triggered for the vulnerability. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  aiWorkflows?: Maybe<VulnerabilityTriggeredWorkflowConnection>;
  /**
   * Indicates whether the vulnerability is about to be archived in the next month. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  archivalInformation: VulnerabilityArchivalInformation;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Timestamp of when the vulnerability state was changed to confirmed. */
  confirmedAt?: Maybe<Scalars['Time']['output']>;
  /** User that confirmed the vulnerability. */
  confirmedBy?: Maybe<UserCore>;
  /** Enrichment (EPSS score and KEV) for CVE vulnerabilities. */
  cveEnrichment?: Maybe<CveEnrichmentType>;
  /** CVSS information for the vulnerability. */
  cvss: Array<CvssType>;
  /**
   * Dependencies for the vulnerability. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  dependencies: DependencyConnection;
  /** Description of the vulnerability. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Details of the vulnerability. */
  details: Array<VulnerabilityDetail>;
  /** Timestamp of when the vulnerability was first detected. */
  detectedAt: Scalars['Time']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Reason for dismissal. Returns `null` for states other than `dismissed`. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** Timestamp of when the vulnerability state was changed to dismissed. */
  dismissedAt?: Maybe<Scalars['Time']['output']>;
  /** User that dismissed the vulnerability. */
  dismissedBy?: Maybe<UserCore>;
  /** List of external issue links related to the vulnerability. */
  externalIssueLinks: VulnerabilityExternalIssueLinkConnection;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']['output']>;
  /** Status of the secret token associated with this vulnerability */
  findingTokenStatus?: Maybe<VulnerabilityFindingTokenStatus>;
  /**
   * Flags set on the vulnerability. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  flags?: Maybe<VulnerabilityFlagConnection>;
  /** Indicates whether there is a remediation available for the vulnerability. */
  hasRemediations?: Maybe<Scalars['Boolean']['output']>;
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID']['output'];
  /** Identifiers of the vulnerability. */
  identifiers: Array<VulnerabilityIdentifier>;
  /**
   * Pipeline where the vulnerability was first detected. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  initialDetectedPipeline?: Maybe<Pipeline>;
  /** List of issue links related to the vulnerability. */
  issueLinks: VulnerabilityIssueLinkConnection;
  /**
   * Pipeline where the vulnerability was last detected. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  latestDetectedPipeline?: Maybe<Pipeline>;
  /**
   * Latest flag for the vulnerability. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  latestFlag?: Maybe<VulnerabilityFlag>;
  /**
   * Latest security report finding for the vulnerability. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  latestSecurityReportFinding?: Maybe<PipelineSecurityReportFinding>;
  /** List of links associated with the vulnerability. */
  links: Array<VulnerabilityLink>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Merge requests that are linked to fix the vulnerability. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /**
   * Indicates whether the vulnerability was auto-dismissed by a security policy. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  policyAutoDismissed?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Policy violation for the vulnerability. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  policyViolations?: Maybe<PolicyViolations>;
  /** Indicates whether the vulnerability is present on the default branch or not. */
  presentOnDefaultBranch: Scalars['Boolean']['output'];
  /** Primary identifier of the vulnerability. */
  primaryIdentifier?: Maybe<VulnerabilityIdentifier>;
  /** Project on which the vulnerability was found. */
  project?: Maybe<Project>;
  /**
   * Reachability status of the vulnerability. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  reachability?: Maybe<ReachabilityType>;
  /** Type of the security report that found the vulnerability (SAST, DEPENDENCY_SCANNING, CONTAINER_SCANNING, DAST, SECRET_DETECTION, COVERAGE_FUZZING, API_FUZZING, CLUSTER_IMAGE_SCANNING, CONTAINER_SCANNING_FOR_REGISTRY, GENERIC). `Scan Type` in the UI. */
  reportType?: Maybe<VulnerabilityReportType>;
  /**
   * Information about the representation of the vulnerability, such as resolved commit SHA. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  representationInformation?: Maybe<VulnerabilityRepresentationInformation>;
  /** Timestamp of when the vulnerability state was changed to resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User that resolved the vulnerability. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether the vulnerability is fixed on the default branch or not. */
  resolvedOnDefaultBranch: Scalars['Boolean']['output'];
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability (INFO, UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL) */
  severity?: Maybe<VulnerabilitySeverity>;
  /** List of severity changes for the vulnerability. */
  severityOverrides?: Maybe<SeverityOverrideConnection>;
  /** Recommended solution for the vulnerability. */
  solution?: Maybe<Scalars['String']['output']>;
  /** State of the vulnerability (DETECTED, CONFIRMED, RESOLVED, DISMISSED) */
  state?: Maybe<VulnerabilityState>;
  /** Comment given for the vulnerability state change. */
  stateComment?: Maybe<Scalars['String']['output']>;
  /** List of state transitions related to the vulnerability. */
  stateTransitions?: Maybe<VulnerabilityStateTransitionTypeConnection>;
  /** Title of the vulnerability. */
  title?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the vulnerability was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Number of user notes attached to the vulnerability. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: VulnerabilityPermissions;
  /** UUID of the vulnerability finding. Can be used to look up the associated security report finding. */
  uuid: Scalars['String']['output'];
  /** Path to the vulnerability's details page. */
  vulnerabilityPath?: Maybe<Scalars['String']['output']>;
  /** URL to the vulnerability's details page. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityAiWorkflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityDependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentIds?: InputMaybe<Array<Scalars['SbomComponentID']['input']>>;
  componentNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  sort?: InputMaybe<DependencySort>;
  sourceTypes?: InputMaybe<Array<SbomSourceType>>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityExternalIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityFlagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  linkType?: InputMaybe<VulnerabilityIssueLinkType>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilitySeverityOverridesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability. The connection type is countable. */
export type CountableVulnerabilityStateTransitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CountableVulnerability. */
export type CountableVulnerabilityConnection = {
  __typename?: 'CountableVulnerabilityConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CountableVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CountableVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CountableVulnerability. */
export type CountableVulnerabilityConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CountableVulnerabilityEdge = {
  __typename?: 'CountableVulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CountableVulnerability>;
};

/** Corpus for a coverage fuzzing job. */
export type CoverageFuzzingCorpus = {
  __typename?: 'CoverageFuzzingCorpus';
  /** ID of the corpus. */
  id: Scalars['AppSecFuzzingCoverageCorpusID']['output'];
  /** Package of the corpus. */
  package: PackageDetailsType;
};

/** The connection type for CoverageFuzzingCorpus. */
export type CoverageFuzzingCorpusConnection = {
  __typename?: 'CoverageFuzzingCorpusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CoverageFuzzingCorpusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CoverageFuzzingCorpus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CoverageFuzzingCorpusEdge = {
  __typename?: 'CoverageFuzzingCorpusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CoverageFuzzingCorpus>;
};

/** Autogenerated input type of CreateAlertIssue */
export type CreateAlertIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String']['input'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateAlertIssue. */
export type CreateAlertIssuePayload = {
  __typename?: 'CreateAlertIssuePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of CreateAnnotation */
export type CreateAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the cluster to add an annotation to. */
  clusterId?: InputMaybe<Scalars['ClustersClusterID']['input']>;
  /** Path to a file defining the dashboard on which the annotation should be added. */
  dashboardPath: Scalars['String']['input'];
  /** Description of the annotation. */
  description: Scalars['String']['input'];
  /** Timestamp indicating ending moment to which the annotation relates. */
  endingAt?: InputMaybe<Scalars['Time']['input']>;
  /** Global ID of the environment to add an annotation to. */
  environmentId?: InputMaybe<Scalars['EnvironmentID']['input']>;
  /** Timestamp indicating starting moment to which the annotation relates. */
  startingAt: Scalars['Time']['input'];
};

/** Autogenerated return type of CreateAnnotation. */
export type CreateAnnotationPayload = {
  __typename?: 'CreateAnnotationPayload';
  /** Created annotation. */
  annotation?: Maybe<MetricsDashboardAnnotation>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateBoard */
export type CreateBoardInput = {
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of CreateBoard. */
export type CreateBoardPayload = {
  __typename?: 'CreateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateBranch */
export type CreateBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the branch. */
  name: Scalars['String']['input'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Branch name or commit SHA to create branch from. */
  ref: Scalars['String']['input'];
};

/** Autogenerated return type of CreateBranch. */
export type CreateBranchPayload = {
  __typename?: 'CreateBranchPayload';
  /** Branch after mutation. */
  branch?: Maybe<Branch>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateClusterAgent */
export type CreateClusterAgentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the cluster agent. */
  name: Scalars['String']['input'];
  /** Full path of the associated project for the cluster agent. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateClusterAgent. */
export type CreateClusterAgentPayload = {
  __typename?: 'CreateClusterAgentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Cluster agent created after mutation. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateComplianceFramework */
export type CreateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the namespace to add the compliance framework to. */
  namespacePath: Scalars['ID']['input'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of CreateComplianceFramework. */
export type CreateComplianceFrameworkPayload = {
  __typename?: 'CreateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created compliance framework. */
  framework?: Maybe<ComplianceFramework>;
};

/** Autogenerated input type of CreateComplianceRequirement */
export type CreateComplianceRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance framework of the new requirement. */
  complianceFrameworkId: Scalars['ComplianceManagementFrameworkID']['input'];
  /** Controls to add to the compliance requirement. */
  controls?: InputMaybe<Array<ComplianceRequirementsControlInput>>;
  /** Parameters to update the compliance requirement with. */
  params: ComplianceRequirementInput;
};

/** Autogenerated return type of CreateComplianceRequirement. */
export type CreateComplianceRequirementPayload = {
  __typename?: 'CreateComplianceRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created compliance requirement. */
  requirement?: Maybe<ComplianceRequirement>;
};

/** Autogenerated input type of CreateComplianceRequirementsControl */
export type CreateComplianceRequirementsControlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance requirement of the new control. */
  complianceRequirementId: Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input'];
  /** Parameters to create the compliance requirement control. */
  params: ComplianceRequirementsControlInput;
};

/** Autogenerated return type of CreateComplianceRequirementsControl. */
export type CreateComplianceRequirementsControlPayload = {
  __typename?: 'CreateComplianceRequirementsControlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created compliance requirements control. */
  requirementsControl?: Maybe<ComplianceRequirementsControl>;
};

/** Autogenerated input type of CreateContainerProtectionRepositoryRule */
export type CreateContainerProtectionRepositoryRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForDelete?: InputMaybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: InputMaybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Full path of the project where a protection rule is located. */
  projectPath: Scalars['ID']['input'];
  /** Container repository path pattern protected by the protection rule. Must start with the projects full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the projects full path. */
  repositoryPathPattern: Scalars['String']['input'];
};

/** Autogenerated return type of CreateContainerProtectionRepositoryRule. */
export type CreateContainerProtectionRepositoryRulePayload = {
  __typename?: 'CreateContainerProtectionRepositoryRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Container repository protection rule after mutation. */
  containerProtectionRepositoryRule?: Maybe<ContainerProtectionRepositoryRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCustomDashboard */
export type CreateCustomDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Dashboard layout/config JSON. */
  config: Scalars['JSON']['input'];
  /** Dashboard description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Dashboard name. */
  name: Scalars['String']['input'];
  /** Namespace to scope the dashboard to. */
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Organization the dashboard belongs to. */
  organizationId: Scalars['OrganizationsOrganizationID']['input'];
};

/** Autogenerated return type of CreateCustomDashboard. */
export type CreateCustomDashboardPayload = {
  __typename?: 'CreateCustomDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Newly created dashboard. */
  dashboard?: Maybe<CustomDashboard>;
  /** Errors encountered during creation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Namespace full path the emoji is associated with. */
  groupPath: Scalars['ID']['input'];
  /** Name of the emoji. */
  name: Scalars['String']['input'];
  /** Location of the emoji file. */
  url: Scalars['String']['input'];
};

/** Autogenerated return type of CreateCustomEmoji. */
export type CreateCustomEmojiPayload = {
  __typename?: 'CreateCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** New custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateDiffNote */
export type CreateDiffNoteInput = {
  /** Content of the note. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID']['input'];
  /** Position of the note on a diff. */
  position: DiffPositionInput;
};

/** Autogenerated return type of CreateDiffNote. */
export type CreateDiffNotePayload = {
  __typename?: 'CreateDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** Content of the note. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID']['input'];
};

/** Autogenerated return type of CreateDiscussion. */
export type CreateDiscussionPayload = {
  __typename?: 'CreateDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of CreateEpic */
export type CreateEpicInput = {
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Color of the epic. */
  color?: InputMaybe<Scalars['Color']['input']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']['input']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID']['input'];
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']['input']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateEpic. */
export type CreateEpicPayload = {
  __typename?: 'CreateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created epic. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateImageDiffNote */
export type CreateImageDiffNoteInput = {
  /** Content of the note. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID']['input'];
  /** Position of the note on a diff. */
  position: DiffImagePositionInput;
};

/** Autogenerated return type of CreateImageDiffNote. */
export type CreateImageDiffNotePayload = {
  __typename?: 'CreateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** Array of user IDs to assign to the issue. */
  assigneeIds?: InputMaybe<Array<Scalars['UserID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the issue was created. Available only for admins and project owners. */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`. */
  discussionToResolve?: InputMaybe<Scalars['String']['input']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** IID (internal ID) of a project issue. Only admins and project owners can modify. */
  iid?: InputMaybe<Scalars['Int']['input']>;
  /** Global iteration cadence ID. Required when `iterationWildcardId` is provided. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  /** Global iteration ID. Mutually exlusive argument with `iterationWildcardId`. */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
  /** Iteration wildcard ID. Supported values are: `CURRENT`. Mutually exclusive argument with `iterationId`. iterationCadenceId also required when this argument is provided. */
  iterationWildcardId?: InputMaybe<IssueCreationIterationWildcardId>;
  /** IDs of labels to be added to the issue. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** IID of a merge request for which to resolve discussions. */
  mergeRequestToResolveDiscussionsOf?: InputMaybe<Scalars['MergeRequestID']['input']>;
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
  /** Global ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['IssueID']['input']>;
  /** Global ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['IssueID']['input']>;
  /** Project full path the issue is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Global ID of the status. */
  statusId?: InputMaybe<Scalars['WorkItemsStatusesStatusID']['input']>;
  /** Title of the issue. */
  title: Scalars['String']['input'];
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of CreateIssue. */
export type CreateIssuePayload = {
  __typename?: 'CreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateIteration */
export type CreateIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']['input']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateIteration. */
export type CreateIterationPayload = {
  __typename?: 'CreateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /** Content of the note. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the discussion the note is in reply to. */
  discussionId?: InputMaybe<Scalars['DiscussionID']['input']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']['input']>;
  /** SHA of the head commit which is used to ensure that the merge request has not been updated since the request was sent. */
  mergeRequestDiffHeadSha?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID']['input'];
};

/** Autogenerated return type of CreateNote. */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of CreatePackagesProtectionRule */
export type CreatePackagesProtectionRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: InputMaybe<PackagesProtectionRuleAccessLevel>;
  /** Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed. */
  packageNamePattern: Scalars['String']['input'];
  /** Package type protected by the protection rule. For example, `NPM`, `PYPI`. */
  packageType: PackagesProtectionRulePackageType;
  /** Full path of the project where a protection rule is located. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of CreatePackagesProtectionRule. */
export type CreatePackagesProtectionRulePayload = {
  __typename?: 'CreatePackagesProtectionRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Packages protection rule after mutation. */
  packageProtectionRule?: Maybe<PackagesProtectionRule>;
};

/** Autogenerated input type of CreateRequirement */
export type CreateRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateRequirement. */
export type CreateRequirementPayload = {
  __typename?: 'CreateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of CreateSnippet */
export type CreateSnippetInput = {
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the snippet is associated with. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Title of the snippet. */
  title: Scalars['String']['input'];
  /** Paths to files uploaded in the snippet description. */
  uploadedFiles?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Visibility level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
};

/** Autogenerated return type of CreateSnippet. */
export type CreateSnippetPayload = {
  __typename?: 'CreateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Autogenerated input type of CreateTestCase */
export type CreateTestCaseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Sets the test case confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Test case description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** IDs of labels to be added to the test case. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Project full path to create the test case in. */
  projectPath: Scalars['ID']['input'];
  /** Test case title. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateTestCase. */
export type CreateTestCasePayload = {
  __typename?: 'CreateTestCasePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Test case created. */
  testCase?: Maybe<Issue>;
};

/** Attributes to create value stream stage. */
export type CreateValueStreamStageInput = {
  /** Whether the stage is customized. If false, it assigns a built-in default stage by name. */
  custom?: InputMaybe<Scalars['Boolean']['input']>;
  /** End event identifier. */
  endEventIdentifier?: InputMaybe<ValueStreamStageEvent>;
  /** Label ID associated with the end event identifier. */
  endEventLabelId?: InputMaybe<Scalars['LabelID']['input']>;
  /** Whether the stage is hidden. */
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the stage. */
  name: Scalars['String']['input'];
  /** Start event identifier. */
  startEventIdentifier?: InputMaybe<ValueStreamStageEvent>;
  /** Label ID associated with the start event identifier. */
  startEventLabelId?: InputMaybe<Scalars['LabelID']['input']>;
};

/** Represents the current license */
export type CurrentLicense = {
  __typename?: 'CurrentLicense';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']['output']>;
  /** Number of billable users on the system. */
  billableUsersCount?: Maybe<Scalars['Int']['output']>;
  /** Date when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']['output']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']['output']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']['output']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']['output']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID']['output'];
  /** Date when the license was last synced. */
  lastSync?: Maybe<Scalars['Time']['output']>;
  /** Highest number of billable users on the system during the term of the current license. */
  maximumUserCount?: Maybe<Scalars['Int']['output']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']['output']>;
  /** Name of the subscription plan. */
  plan: Scalars['String']['output'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']['output']>;
  /** Indicates if the license is a trial. */
  trial?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the license. */
  type: Scalars['String']['output'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']['output']>;
  /** Number of users over the paid users in the license. */
  usersOverLicenseCount?: Maybe<Scalars['Int']['output']>;
};

/** The currently authenticated GitLab user. */
export type CurrentUser = Todoable & User & {
  __typename?: 'CurrentUser';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests the current user is an assignee or a reviewer of. */
  assigneeOrReviewerMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * List of additional contexts enabled for Code Suggestions. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  codeSuggestionsContexts: Array<Scalars['String']['output']>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User access to AI chat feature. Introduced in GitLab 16.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.8.
   */
  duoChatAvailable: Scalars['Boolean']['output'];
  /**
   * List of available features for AI chat. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  duoChatAvailableFeatures: Array<Scalars['String']['output']>;
  /**
   * User access to code suggestions feature. Introduced in GitLab 16.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.8.
   */
  duoCodeSuggestionsAvailable: Scalars['Boolean']['output'];
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /**
   * Most-recently viewed issues for the current user. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  recentlyViewedIssues?: Maybe<Array<Issue>>;
  /** Most-recently viewed items for the current user. */
  recentlyViewedItems?: Maybe<Array<RecentlyViewedItem>>;
  /**
   * Most-recently viewed merge requests for the current user. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  recentlyViewedMergeRequests?: Maybe<Array<MergeRequest>>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /**
   * List all runners the current user manages. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  runners?: Maybe<CiRunnerConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /**
   * User preferences for the given work item type and namespace. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  workItemPreferences?: Maybe<WorkItemTypesUserPreference>;
  /**
   * Find work items visible to the current user. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  workItems?: Maybe<WorkItemConnection>;
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserAssigneeOrReviewerMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assignedReviewStates?: InputMaybe<Array<MergeRequestReviewState>>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerReviewStates?: InputMaybe<Array<MergeRequestReviewState>>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignableToProjectPath?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  creatorId?: InputMaybe<Scalars['UserID']['input']>;
  creatorUsername?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  versionPrefix?: InputMaybe<Scalars['String']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** The currently authenticated GitLab user. */
export type CurrentUserSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserWorkItemPreferencesArgs = {
  namespacePath: Scalars['ID']['input'];
  workItemTypeId?: InputMaybe<Scalars['WorkItemsTypeID']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The currently authenticated GitLab user. */
export type CurrentUserWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

export type CurrentUserTodos = {
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
};


export type CurrentUserTodosCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};

/** Customizable analytics dashboard */
export type CustomDashboard = {
  __typename?: 'CustomDashboard';
  /** Dashboard layout and widget configuration. */
  config: Scalars['JSON']['output'];
  /** Timestamp when the dashboard was created. */
  createdAt: Scalars['Time']['output'];
  /** User who created the dashboard. */
  createdBy: UserCore;
  /** Optional summary or purpose of the dashboard. */
  description?: Maybe<Scalars['String']['output']>;
  /** Global ID of the custom dashboard. */
  id: Scalars['AnalyticsCustomDashboardsDashboardID']['output'];
  /** Version used for optimistic concurrency control. */
  lockVersion: Scalars['Int']['output'];
  /** Display name of the dashboard. */
  name: Scalars['String']['output'];
  /** Namespace scope of the dashboard, if any. */
  namespace?: Maybe<Namespace>;
  /** Organization that owns the dashboard. */
  organization: Organization;
  /** Project scope of the dashboard, if any. */
  project?: Maybe<Project>;
  /** Timestamp when the dashboard was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** User who last updated the dashboard. */
  updatedBy?: Maybe<UserCore>;
};

/** A custom emoji uploaded by user */
export type CustomEmoji = {
  __typename?: 'CustomEmoji';
  /** Timestamp of when the custom emoji was created. */
  createdAt: Scalars['Time']['output'];
  /** Whether the emoji is an external link. */
  external: Scalars['Boolean']['output'];
  /** ID of the emoji. */
  id: Scalars['CustomEmojiID']['output'];
  /** Name of the emoji. */
  name: Scalars['String']['output'];
  /** Link to file of the emoji. */
  url: Scalars['String']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: CustomEmojiPermissions;
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: 'CustomEmojiConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CustomEmoji. */
export type CustomEmojiConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: 'CustomEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

export type CustomEmojiPermissions = {
  __typename?: 'CustomEmojiPermissions';
  /** If `true`, the user can perform `create_custom_emoji` on this resource */
  createCustomEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `delete_custom_emoji` on this resource */
  deleteCustomEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_custom_emoji` on this resource */
  readCustomEmoji: Scalars['Boolean']['output'];
};

/** Represents a custom field */
export type CustomField = {
  __typename?: 'CustomField';
  /** Whether the custom field is active. */
  active: Scalars['Boolean']['output'];
  /** Timestamp when the custom field was created. */
  createdAt: Scalars['Time']['output'];
  /** User that created the custom field. */
  createdBy?: Maybe<UserCore>;
  /** Type of custom field. */
  fieldType: CustomFieldType;
  /** Global ID of the custom field. */
  id: Scalars['IssuablesCustomFieldID']['output'];
  /** Name of the custom field. */
  name: Scalars['String']['output'];
  /** Available options for a select field. */
  selectOptions?: Maybe<Array<CustomFieldSelectOption>>;
  /** Timestamp when the custom field was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** User that last updated the custom field. */
  updatedBy?: Maybe<UserCore>;
  /** Work item types that the custom field is available on. */
  workItemTypes?: Maybe<Array<WorkItemType>>;
};

/** Autogenerated input type of CustomFieldArchive */
export type CustomFieldArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the custom field. */
  id: Scalars['IssuablesCustomFieldID']['input'];
};

/** Autogenerated return type of CustomFieldArchive. */
export type CustomFieldArchivePayload = {
  __typename?: 'CustomFieldArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Archived custom field. */
  customField?: Maybe<CustomField>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** The connection type for CustomField. */
export type CustomFieldConnection = {
  __typename?: 'CustomFieldConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomField>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CustomField. */
export type CustomFieldConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of CustomFieldCreate */
export type CustomFieldCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Type of custom field. */
  fieldType: CustomFieldType;
  /** Group path where the custom field is created. */
  groupPath: Scalars['ID']['input'];
  /** Name of the custom field. */
  name: Scalars['String']['input'];
  /** Available options for a select field. */
  selectOptions?: InputMaybe<Array<CustomFieldSelectOptionInput>>;
  /** Work item type global IDs associated to the custom field. */
  workItemTypeIds?: InputMaybe<Array<Scalars['WorkItemsTypeID']['input']>>;
};

/** Autogenerated return type of CustomFieldCreate. */
export type CustomFieldCreatePayload = {
  __typename?: 'CustomFieldCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created custom field. */
  customField?: Maybe<CustomField>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type CustomFieldEdge = {
  __typename?: 'CustomFieldEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomField>;
};

/** Represents a custom field select option */
export type CustomFieldSelectOption = {
  __typename?: 'CustomFieldSelectOption';
  /** Global ID of the custom field select option. */
  id: Scalars['IssuablesCustomFieldSelectOptionID']['output'];
  /** Value of the custom field select option. */
  value: Scalars['String']['output'];
};

/** Attributes for the custom field select option */
export type CustomFieldSelectOptionInput = {
  /** Global ID of the custom field select option to update. Creates a new record if not provided. */
  id?: InputMaybe<Scalars['IssuablesCustomFieldSelectOptionID']['input']>;
  /** Value of the custom field select option. */
  value: Scalars['String']['input'];
};

/** Type of custom field */
export type CustomFieldType =
  /** Date field type. */
  | 'DATE'
  /** Multi select field type. */
  | 'MULTI_SELECT'
  /** Number field type. */
  | 'NUMBER'
  /** Single select field type. */
  | 'SINGLE_SELECT'
  /** Text field type. */
  | 'TEXT';

/** Autogenerated input type of CustomFieldUnarchive */
export type CustomFieldUnarchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the custom field. */
  id: Scalars['IssuablesCustomFieldID']['input'];
};

/** Autogenerated return type of CustomFieldUnarchive. */
export type CustomFieldUnarchivePayload = {
  __typename?: 'CustomFieldUnarchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Unarchived custom field. */
  customField?: Maybe<CustomField>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CustomFieldUpdate */
export type CustomFieldUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the custom field. */
  id: Scalars['IssuablesCustomFieldID']['input'];
  /** Name of the custom field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Available options for a select field. */
  selectOptions?: InputMaybe<Array<CustomFieldSelectOptionInput>>;
  /** Work item type global IDs associated to the custom field. */
  workItemTypeIds?: InputMaybe<Array<Scalars['WorkItemsTypeID']['input']>>;
};

/** Autogenerated return type of CustomFieldUpdate. */
export type CustomFieldUpdatePayload = {
  __typename?: 'CustomFieldUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated custom field. */
  customField?: Maybe<CustomField>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CustomRoleInterface = {
  /** Timestamp of when the member role was created. */
  createdAt: Scalars['Time']['output'];
  /**
   * Web UI path to edit the custom role. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  editPath: Scalars['String']['output'];
};

export type CustomerRelationsContact = {
  __typename?: 'CustomerRelationsContact';
  /** State of the contact. */
  active: Scalars['Boolean']['output'];
  /** Timestamp the contact was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of or notes for the contact. */
  description?: Maybe<Scalars['String']['output']>;
  /** Email address of the contact. */
  email?: Maybe<Scalars['String']['output']>;
  /** First name of the contact. */
  firstName: Scalars['String']['output'];
  /** Internal ID of the contact. */
  id: Scalars['ID']['output'];
  /** Last name of the contact. */
  lastName: Scalars['String']['output'];
  /** Organization of the contact. */
  organization?: Maybe<CustomerRelationsOrganization>;
  /** Phone number of the contact. */
  phone?: Maybe<Scalars['String']['output']>;
  /** Timestamp the contact was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for CustomerRelationsContact. */
export type CustomerRelationsContactConnection = {
  __typename?: 'CustomerRelationsContactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsContactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsContact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsContactCreate */
export type CustomerRelationsContactCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** First name of the contact. */
  firstName: Scalars['String']['input'];
  /** Group for the contact. */
  groupId: Scalars['GroupID']['input'];
  /** Last name of the contact. */
  lastName: Scalars['String']['input'];
  /** Organization for the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']['input']>;
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CustomerRelationsContactCreate. */
export type CustomerRelationsContactCreatePayload = {
  __typename?: 'CustomerRelationsContactCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type CustomerRelationsContactEdge = {
  __typename?: 'CustomerRelationsContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsContact>;
};

export type CustomerRelationsContactState =
  /** Active contacts. */
  | 'active'
  /** All available contacts. */
  | 'all'
  /** Inactive contacts. */
  | 'inactive';

/** Autogenerated input type of CustomerRelationsContactUpdate */
export type CustomerRelationsContactUpdateInput = {
  /** State of the contact. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** First name of the contact. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the contact. */
  id: Scalars['CustomerRelationsContactID']['input'];
  /** Last name of the contact. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Organization of the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']['input']>;
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CustomerRelationsContactUpdate. */
export type CustomerRelationsContactUpdatePayload = {
  __typename?: 'CustomerRelationsContactUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type CustomerRelationsOrganization = {
  __typename?: 'CustomerRelationsOrganization';
  /** State of the organization. */
  active: Scalars['Boolean']['output'];
  /** Timestamp the organization was created. */
  createdAt: Scalars['Time']['output'];
  /** Standard billing rate for the organization. */
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Description of or notes for the organization. */
  description?: Maybe<Scalars['String']['output']>;
  /** Internal ID of the organization. */
  id: Scalars['ID']['output'];
  /** Name of the organization. */
  name: Scalars['String']['output'];
  /** Timestamp the organization was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for CustomerRelationsOrganization. */
export type CustomerRelationsOrganizationConnection = {
  __typename?: 'CustomerRelationsOrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsOrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsOrganization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsOrganizationCreate */
export type CustomerRelationsOrganizationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']['input']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Group for the organization. */
  groupId: Scalars['GroupID']['input'];
  /** Name of the organization. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of CustomerRelationsOrganizationCreate. */
export type CustomerRelationsOrganizationCreatePayload = {
  __typename?: 'CustomerRelationsOrganizationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Organization after the mutation. */
  organization?: Maybe<CustomerRelationsOrganization>;
};

/** An edge in a connection. */
export type CustomerRelationsOrganizationEdge = {
  __typename?: 'CustomerRelationsOrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsOrganization>;
};

export type CustomerRelationsOrganizationState =
  /** Active organizations. */
  | 'active'
  /** All available organizations. */
  | 'all'
  /** Inactive organizations. */
  | 'inactive';

/** Autogenerated input type of CustomerRelationsOrganizationUpdate */
export type CustomerRelationsOrganizationUpdateInput = {
  /** State of the organization. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']['input']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the organization. */
  id: Scalars['CustomerRelationsOrganizationID']['input'];
  /** Name of the organization. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CustomerRelationsOrganizationUpdate. */
export type CustomerRelationsOrganizationUpdatePayload = {
  __typename?: 'CustomerRelationsOrganizationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Organization after the mutation. */
  organization: CustomerRelationsOrganization;
};

export type CustomizableAdminPermission = {
  __typename?: 'CustomizableAdminPermission';
  /** Description of the permission. */
  description?: Maybe<Scalars['String']['output']>;
  /** Localized name of the permission. */
  name: Scalars['String']['output'];
  /** Requirements of the permission. */
  requirements?: Maybe<Array<MemberRoleAdminPermission>>;
  /** Value of the permission. */
  value: MemberRoleAdminPermission;
};

/** The connection type for CustomizableAdminPermission. */
export type CustomizableAdminPermissionConnection = {
  __typename?: 'CustomizableAdminPermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomizableAdminPermissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomizableAdminPermission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomizableAdminPermissionEdge = {
  __typename?: 'CustomizableAdminPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomizableAdminPermission>;
};

/** Represents a customizable dashboard. */
export type CustomizableDashboard = {
  __typename?: 'CustomizableDashboard';
  /** Category of dashboard. */
  category: CustomizableDashboardCategory;
  /** Project which contains the dashboard definition. */
  configurationProject?: Maybe<Project>;
  /** Description of the dashboard. */
  description?: Maybe<Scalars['String']['output']>;
  /** Errors on yaml definition. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Dashboard global filters. */
  filters?: Maybe<Scalars['JSON']['output']>;
  /** Panels shown on the dashboard. */
  panels?: Maybe<CustomizableDashboardPanelConnection>;
  /** Slug of the dashboard. */
  slug: Scalars['String']['output'];
  /**
   * Status of the dashboard. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  status?: Maybe<Scalars['String']['output']>;
  /** Title of the dashboard. */
  title?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the dashboard is user-defined or provided by GitLab. */
  userDefined: Scalars['Boolean']['output'];
};


/** Represents a customizable dashboard. */
export type CustomizableDashboardPanelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Categories for customizable dashboards. */
export type CustomizableDashboardCategory =
  /** Analytics category for customizable dashboards. */
  | 'ANALYTICS';

/** The connection type for CustomizableDashboard. */
export type CustomizableDashboardConnection = {
  __typename?: 'CustomizableDashboardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomizableDashboardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomizableDashboard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomizableDashboardEdge = {
  __typename?: 'CustomizableDashboardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomizableDashboard>;
};

/** Represents a customizable dashboard panel. */
export type CustomizableDashboardPanel = {
  __typename?: 'CustomizableDashboardPanel';
  /** Description of the position and size of the panel. */
  gridAttributes?: Maybe<Scalars['JSON']['output']>;
  /** Overrides for the visualization query object. */
  queryOverrides?: Maybe<Scalars['JSON']['output']>;
  /** Title of the panel. */
  title?: Maybe<Scalars['String']['output']>;
  /** Tooltip for the panel containing descriptive text and an optional link. */
  tooltip?: Maybe<CustomizableDashboardPanelTooltip>;
  /** Visualization of the panel. */
  visualization?: Maybe<CustomizableDashboardVisualization>;
};

/** The connection type for CustomizableDashboardPanel. */
export type CustomizableDashboardPanelConnection = {
  __typename?: 'CustomizableDashboardPanelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomizableDashboardPanelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomizableDashboardPanel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomizableDashboardPanelEdge = {
  __typename?: 'CustomizableDashboardPanelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomizableDashboardPanel>;
};

/** Tooltip for a customizable dashboard panel. */
export type CustomizableDashboardPanelTooltip = {
  __typename?: 'CustomizableDashboardPanelTooltip';
  /** Popover text content. When `descriptionLink` is provided, must include %{linkStart} and %{linkEnd} placeholders around the link text. */
  description: Scalars['String']['output'];
  /** Optional URL for link insertion in the `description` between %{linkStart} and %{linkEnd} placeholders. */
  descriptionLink?: Maybe<Scalars['String']['output']>;
};

/** Represents a customizable dashboard visualization. */
export type CustomizableDashboardVisualization = {
  __typename?: 'CustomizableDashboardVisualization';
  /** Data of the visualization. */
  data: Scalars['JSON']['output'];
  /** Validation errors in the visualization. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Options of the visualization. */
  options: Scalars['JSON']['output'];
  /** Slug of the visualization. */
  slug: Scalars['String']['output'];
  /** Type of the visualization. */
  type: Scalars['String']['output'];
};

/** The connection type for CustomizableDashboardVisualization. */
export type CustomizableDashboardVisualizationConnection = {
  __typename?: 'CustomizableDashboardVisualizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomizableDashboardVisualizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomizableDashboardVisualization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomizableDashboardVisualizationEdge = {
  __typename?: 'CustomizableDashboardVisualizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomizableDashboardVisualization>;
};

export type CustomizableStandardPermission = {
  __typename?: 'CustomizableStandardPermission';
  /** Objects the permission is available for. */
  availableFor: Array<Scalars['String']['output']>;
  /** Description of the permission. */
  description?: Maybe<Scalars['String']['output']>;
  /** Group access levels from which the permission is allowed. */
  enabledForGroupAccessLevels?: Maybe<Array<AccessLevelEnum>>;
  /** Project access levels from which the permission is allowed. */
  enabledForProjectAccessLevels?: Maybe<Array<AccessLevelEnum>>;
  /** Localized name of the permission. */
  name: Scalars['String']['output'];
  /** Requirements of the permission. */
  requirements?: Maybe<Array<MemberRoleStandardPermission>>;
  /** Value of the permission. */
  value: MemberRoleStandardPermission;
};

/** The connection type for CustomizableStandardPermission. */
export type CustomizableStandardPermissionConnection = {
  __typename?: 'CustomizableStandardPermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomizableStandardPermissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomizableStandardPermission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomizableStandardPermissionEdge = {
  __typename?: 'CustomizableStandardPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomizableStandardPermission>;
};

/** Represents a CVE's Enrichment (EPSS score). */
export type CveEnrichmentType = {
  __typename?: 'CveEnrichmentType';
  /** CVE identifier of relevant vulnerability. */
  cve: Scalars['String']['output'];
  /** EPSS score for the CVE. */
  epssScore: Scalars['Float']['output'];
  /** Whether the CVE appears in the CISA KEV catalog. */
  isKnownExploit: Scalars['Boolean']['output'];
};

/** Values for a CVSS severity */
export type CvssSeverity =
  /** Critical severity. */
  | 'CRITICAL'
  /** High severity. */
  | 'HIGH'
  /** Low severity. */
  | 'LOW'
  /** Medium severity. */
  | 'MEDIUM'
  /** Not a vulnerability. */
  | 'NONE';

/** Represents a vulnerability's CVSS score. */
export type CvssType = {
  __typename?: 'CvssType';
  /** Base score of the CVSS. */
  baseScore: Scalars['Float']['output'];
  /** Overall score of the CVSS. */
  overallScore: Scalars['Float']['output'];
  /** Severity calculated from the overall score. */
  severity: CvssSeverity;
  /** CVSS vector string. */
  vector: Scalars['String']['output'];
  /** Vendor who assigned the CVSS score. */
  vendor: Scalars['String']['output'];
  /** Version of the CVSS. */
  version: Scalars['Float']['output'];
};

/** Autogenerated input type of DastOnDemandScanCreate */
export type DastOnDemandScanCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scanner profile to be used for the scan. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']['input']>;
  /** ID of the site profile to be used for the scan. */
  dastSiteProfileId: Scalars['DastSiteProfileID']['input'];
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of DastOnDemandScanCreate. */
export type DastOnDemandScanCreatePayload = {
  __typename?: 'DastOnDemandScanCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']['output']>;
};

/** Represents a DAST Pre Scan Verification */
export type DastPreScanVerification = {
  __typename?: 'DastPreScanVerification';
  /** Pre Scan Verifications Steps. */
  preScanVerificationSteps?: Maybe<Array<DastPreScanVerificationStep>>;
  /** Status of the pre scan verification. */
  status?: Maybe<DastPreScanVerificationStatus>;
  /** Whether or not the configuration has changed after the last pre scan run. */
  valid: Scalars['Boolean']['output'];
};

/** Check type of the pre scan verification step. */
export type DastPreScanVerificationCheckType =
  /** Authentication check */
  | 'AUTHENTICATION'
  /** Connection check */
  | 'CONNECTION'
  /** Crawling check */
  | 'CRAWLING';

/** Status of DAST pre scan verification. */
export type DastPreScanVerificationStatus =
  /** Pre Scan Verification complete without errors. */
  | 'COMPLETE'
  /** Pre Scan Verification finished with one or more errors. */
  | 'COMPLETE_WITH_ERRORS'
  /** Pre Scan Validation unable to finish. */
  | 'FAILED'
  /** Pre Scan Verification in execution. */
  | 'RUNNING';

/** Represents a DAST Pre Scan Verification Step */
export type DastPreScanVerificationStep = {
  __typename?: 'DastPreScanVerificationStep';
  /** Type of the pre scan verification check. */
  checkType?: Maybe<DastPreScanVerificationCheckType>;
  /** Errors that occurred in the pre scan verification step. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Name of the pre scan verification step. Deprecated in GitLab 15.10: This was renamed.
   * @deprecated This was renamed. Please use `DastPreScanVerificationStep.checkType`. Deprecated in GitLab 15.10.
   */
  name?: Maybe<Scalars['String']['output']>;
  /** Whether or not the pre scan verification step has errors. */
  success: Scalars['Boolean']['output'];
};

/** Represents a DAST Profile */
export type DastProfile = {
  __typename?: 'DastProfile';
  /** Associated branch. */
  branch?: Maybe<DastProfileBranch>;
  /** DAST Pre Scan Verification associated with the site profile. Will always return `null` if `dast_on_demand_scans_scheduler` feature flag is disabled. */
  dastPreScanVerification?: Maybe<DastPreScanVerification>;
  /** Associated profile schedule. */
  dastProfileSchedule?: Maybe<DastProfileSchedule>;
  /** Associated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Associated site profile. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Description of the scan. */
  description?: Maybe<Scalars['String']['output']>;
  /** Relative web path to the edit page of a profile. */
  editPath?: Maybe<Scalars['String']['output']>;
  /** ID of the profile. */
  id: Scalars['DastProfileID']['output'];
  /** Name of the profile. */
  name?: Maybe<Scalars['String']['output']>;
  /** Runner tags associated with the profile. */
  tagList?: Maybe<Array<Scalars['String']['output']>>;
};

/** Represents a DAST Profile Branch */
export type DastProfileBranch = {
  __typename?: 'DastProfileBranch';
  /** Indicates whether or not the branch exists. */
  exists?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the branch. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadence = {
  __typename?: 'DastProfileCadence';
  /** Duration of the DAST profile cadence. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** Unit for the duration of DAST profile cadence. */
  unit?: Maybe<DastProfileCadenceUnit>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadenceInput = {
  /** Duration of the DAST Profile Cadence. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Unit for the duration of DAST Profile Cadence. */
  unit?: InputMaybe<DastProfileCadenceUnit>;
};

/** Unit for the duration of Dast Profile Cadence. */
export type DastProfileCadenceUnit =
  /** DAST Profile Cadence duration in days. */
  | 'DAY'
  /** DAST Profile Cadence duration in months. */
  | 'MONTH'
  /** DAST Profile Cadence duration in weeks. */
  | 'WEEK'
  /** DAST Profile Cadence duration in years. */
  | 'YEAR';

/** The connection type for DastProfile. */
export type DastProfileConnection = {
  __typename?: 'DastProfileConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for DastProfile. */
export type DastProfileConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of DastProfileCreate */
export type DastProfileCreateInput = {
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Represents a DAST Profile Schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId: Scalars['DastScannerProfileID']['input'];
  /** ID of the site profile to be associated. */
  dastSiteProfileId: Scalars['DastSiteProfileID']['input'];
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Project the profile belongs to. */
  fullPath: Scalars['ID']['input'];
  /** Name of the profile. */
  name: Scalars['String']['input'];
  /** Run scan using profile after creation. Defaults to false. */
  runAfterCreate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the runner tags associated with the profile. */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of DastProfileCreate. */
export type DastProfileCreatePayload = {
  __typename?: 'DastProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** URL of the pipeline that was created. Requires `runAfterCreate` to be set to `true`. */
  pipelineUrl?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DastProfileDelete */
export type DastProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID']['input'];
};

/** Autogenerated return type of DastProfileDelete. */
export type DastProfileDeletePayload = {
  __typename?: 'DastProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type DastProfileEdge = {
  __typename?: 'DastProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DastProfile>;
};

/** Autogenerated input type of DastProfileRun */
export type DastProfileRunInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the profile to be used for the scan. */
  id: Scalars['DastProfileID']['input'];
};

/** Autogenerated return type of DastProfileRun. */
export type DastProfileRunPayload = {
  __typename?: 'DastProfileRunPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']['output']>;
};

/** Represents a DAST profile schedule. */
export type DastProfileSchedule = {
  __typename?: 'DastProfileSchedule';
  /** Status of the DAST profile schedule. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Cadence of the DAST profile schedule. */
  cadence?: Maybe<DastProfileCadence>;
  /** ID of the DAST profile schedule. */
  id: Scalars['DastProfileScheduleID']['output'];
  /** Next run time of the DAST profile schedule in the given timezone. */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the current owner of the DAST profile schedule. */
  ownerValid?: Maybe<Scalars['Boolean']['output']>;
  /** Start time of the DAST profile schedule in the given timezone. */
  startsAt?: Maybe<Scalars['Time']['output']>;
  /** Time zone of the start time of the DAST profile schedule. */
  timezone?: Maybe<Scalars['String']['output']>;
};

/** Input type for DAST Profile Schedules */
export type DastProfileScheduleInput = {
  /** Status of a Dast Profile Schedule. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Cadence of a Dast Profile Schedule. */
  cadence?: InputMaybe<DastProfileCadenceInput>;
  /** Start time of a Dast Profile Schedule. */
  startsAt?: InputMaybe<Scalars['Time']['input']>;
  /** Time Zone for the Start time of a Dast Profile Schedule. */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of DastProfileUpdate */
export type DastProfileUpdateInput = {
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Represents a DAST profile schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']['input']>;
  /** ID of the site profile to be associated. */
  dastSiteProfileId?: InputMaybe<Scalars['DastSiteProfileID']['input']>;
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID']['input'];
  /** Name of the profile. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Run scan using profile after update. Defaults to false. */
  runAfterUpdate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the runner tags associated with the profile. */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of DastProfileUpdate. */
export type DastProfileUpdatePayload = {
  __typename?: 'DastProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** The URL of the pipeline that was created. Requires the input argument `runAfterUpdate` to be set to `true` when calling the mutation, otherwise no pipeline will be created. */
  pipelineUrl?: Maybe<Scalars['String']['output']>;
};

/** Scan method to be used by the scanner. */
export type DastScanMethodType =
  /** GraphQL scan method. */
  | 'GRAPHQL'
  /** HAR scan method. */
  | 'HAR'
  /** OpenAPI scan method. */
  | 'OPENAPI'
  /** Postman scan method. */
  | 'POSTMAN_COLLECTION'
  /** Website scan method. */
  | 'WEBSITE';

export type DastScanTypeEnum =
  /** Active DAST scan. This scan will make active attacks against the target site. */
  | 'ACTIVE'
  /** Passive DAST scan. This scan will not make active attacks against the target site. */
  | 'PASSIVE';

/** Represents a DAST scanner profile */
export type DastScannerProfile = {
  __typename?: 'DastScannerProfile';
  /** Relative web path to the edit page of a scanner profile. */
  editPath?: Maybe<Scalars['String']['output']>;
  /** ID of the DAST scanner profile. */
  id: Scalars['DastScannerProfileID']['output'];
  /** Name of the DAST scanner profile. */
  profileName?: Maybe<Scalars['String']['output']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']['output']>>;
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: Maybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages: Scalars['Boolean']['output'];
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: Maybe<Scalars['Int']['output']>;
  /**
   * Runner tags associated with the scanner profile. Deprecated in GitLab 15.8: Moved to DastProfile.
   * @deprecated Moved to DastProfile. Deprecated in GitLab 15.8.
   */
  tagList?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: Maybe<Scalars['Int']['output']>;
  /** Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider. */
  useAjaxSpider: Scalars['Boolean']['output'];
};

/** The connection type for DastScannerProfile. */
export type DastScannerProfileConnection = {
  __typename?: 'DastScannerProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastScannerProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastScannerProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastScannerProfileCreate */
export type DastScannerProfileCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project the scanner profile belongs to. */
  fullPath: Scalars['ID']['input'];
  /** Name of the scanner profile. */
  profileName: Scalars['String']['input'];
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']['input']>;
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: InputMaybe<Scalars['Int']['input']>;
  /** Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider. */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of DastScannerProfileCreate. */
export type DastScannerProfileCreatePayload = {
  __typename?: 'DastScannerProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * ID of the scanner profile. Deprecated in GitLab 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in GitLab 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']['output']>;
};

/** Autogenerated input type of DastScannerProfileDelete */
export type DastScannerProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scanner profile to be deleted. */
  id: Scalars['DastScannerProfileID']['input'];
};

/** Autogenerated return type of DastScannerProfileDelete. */
export type DastScannerProfileDeletePayload = {
  __typename?: 'DastScannerProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type DastScannerProfileEdge = {
  __typename?: 'DastScannerProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DastScannerProfile>;
};

/** Autogenerated input type of DastScannerProfileUpdate */
export type DastScannerProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the scanner profile to be updated. */
  id: Scalars['DastScannerProfileID']['input'];
  /** Name of the scanner profile. */
  profileName: Scalars['String']['input'];
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']['input']>;
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout: Scalars['Int']['input'];
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout: Scalars['Int']['input'];
  /** Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider. */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of DastScannerProfileUpdate. */
export type DastScannerProfileUpdatePayload = {
  __typename?: 'DastScannerProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * ID of the scanner profile. Deprecated in GitLab 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in GitLab 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']['output']>;
};

/** Represents a DAST Site Profile */
export type DastSiteProfile = {
  __typename?: 'DastSiteProfile';
  /** Target authentication details. */
  auth?: Maybe<DastSiteProfileAuth>;
  /** Relative web path to the edit page of a site profile. */
  editPath?: Maybe<Scalars['String']['output']>;
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: Maybe<Array<Scalars['String']['output']>>;
  /** ID of the site profile. */
  id: Scalars['DastSiteProfileID']['output'];
  /** Normalized URL of the target to be scanned. */
  normalizedTargetUrl?: Maybe<Scalars['String']['output']>;
  /** Optional variables that can be configured for DAST scans. */
  optionalVariables?: Maybe<Array<Scalars['JSON']['output']>>;
  /** Name of the site profile. */
  profileName?: Maybe<Scalars['String']['output']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']['output']>>;
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: Maybe<Scalars['String']['output']>;
  /** Scan File Path used as input for the scanner. */
  scanFilePath?: Maybe<Scalars['String']['output']>;
  /** Scan method used by the scanner. */
  scanMethod?: Maybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: Maybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: DastSiteProfilePermissions;
  /** Site profile validation start time. */
  validationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Current validation status of the site profile. */
  validationStatus?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** DastSiteProfile authentication */
export type DastSiteProfileAuth = {
  __typename?: 'DastSiteProfileAuth';
  /** Indicates whether authentication is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Redacted password to authenticate with on the target website. */
  password?: Maybe<Scalars['String']['output']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: Maybe<Scalars['String']['output']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: Maybe<Scalars['String']['output']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: Maybe<Scalars['String']['output']>;
  /** Username to authenticate with on the target website. */
  username?: Maybe<Scalars['String']['output']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: Maybe<Scalars['String']['output']>;
};

/** Input type for DastSiteProfile authentication */
export type DastSiteProfileAuthInput = {
  /** Indicates whether authentication is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Password to authenticate with on the target. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: InputMaybe<Scalars['String']['input']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: InputMaybe<Scalars['String']['input']>;
  /** Username to authenticate with on the target. */
  username?: InputMaybe<Scalars['String']['input']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for DastSiteProfile. */
export type DastSiteProfileConnection = {
  __typename?: 'DastSiteProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteProfileCreate */
export type DastSiteProfileCreateInput = {
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** URLs to skip during an authenticated scan. Defaults to `[]`. */
  excludedUrls?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID']['input'];
  /** Optional variables that can be configured for DAST scans. */
  optionalVariables?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Name of the site profile. */
  profileName: Scalars['String']['input'];
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']['input']>;
  /** File Path or URL used as input for the scan method. */
  scanFilePath?: InputMaybe<Scalars['String']['input']>;
  /** Scan method by the scanner. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DastSiteProfileCreate. */
export type DastSiteProfileCreatePayload = {
  __typename?: 'DastSiteProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Site Profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * ID of the site profile. Deprecated in GitLab 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in GitLab 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']['output']>;
};

/** Autogenerated input type of DastSiteProfileDelete */
export type DastSiteProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the site profile to be deleted. */
  id: Scalars['DastSiteProfileID']['input'];
};

/** Autogenerated return type of DastSiteProfileDelete. */
export type DastSiteProfileDeletePayload = {
  __typename?: 'DastSiteProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type DastSiteProfileEdge = {
  __typename?: 'DastSiteProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteProfile>;
};

/** Check permissions for the current user on site profile */
export type DastSiteProfilePermissions = {
  __typename?: 'DastSiteProfilePermissions';
  /** If `true`, the user can perform `create_on_demand_dast_scan` on this resource */
  createOnDemandDastScan: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DastSiteProfileUpdate */
export type DastSiteProfileUpdateInput = {
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID of the site profile to be updated. */
  id: Scalars['DastSiteProfileID']['input'];
  /** Optional variables that can be configured for DAST scans. */
  optionalVariables?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Name of the site profile. */
  profileName: Scalars['String']['input'];
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']['input']>;
  /** File Path or URL used as input for the scan method. */
  scanFilePath?: InputMaybe<Scalars['String']['input']>;
  /** Scan method by the scanner. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DastSiteProfileUpdate. */
export type DastSiteProfileUpdatePayload = {
  __typename?: 'DastSiteProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Site profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * ID of the site profile. Deprecated in GitLab 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in GitLab 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']['output']>;
};

export type DastSiteProfileValidationStatusEnum =
  /** Site validation process finished but failed. */
  | 'FAILED_VALIDATION'
  /** Site validation process is in progress. */
  | 'INPROGRESS_VALIDATION'
  /** No site validation exists. */
  | 'NONE'
  /** Site validation process finished successfully. */
  | 'PASSED_VALIDATION'
  /** Site validation process has not started. */
  | 'PENDING_VALIDATION';

/** Autogenerated input type of DastSiteTokenCreate */
export type DastSiteTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project the site token belongs to. */
  fullPath: Scalars['ID']['input'];
  /** URL of the target to be validated. */
  targetUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DastSiteTokenCreate. */
export type DastSiteTokenCreatePayload = {
  __typename?: 'DastSiteTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** ID of the site token. */
  id?: Maybe<Scalars['DastSiteTokenID']['output']>;
  /** Current validation status of the target. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
  /** Token string. */
  token?: Maybe<Scalars['String']['output']>;
};

/** Represents a DAST Site Validation */
export type DastSiteValidation = {
  __typename?: 'DastSiteValidation';
  /** Global ID of the site validation. */
  id: Scalars['DastSiteValidationID']['output'];
  /** Normalized URL of the target to be validated. */
  normalizedTargetUrl?: Maybe<Scalars['String']['output']>;
  /** Status of the site validation. */
  status: DastSiteProfileValidationStatusEnum;
  /** Timestamp of when the validation started. */
  validationStartedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for DastSiteValidation. */
export type DastSiteValidationConnection = {
  __typename?: 'DastSiteValidationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteValidationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteValidation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteValidationCreate */
export type DastSiteValidationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the site token. */
  dastSiteTokenId: Scalars['DastSiteTokenID']['input'];
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID']['input'];
  /** Validation strategy to be used. */
  strategy?: InputMaybe<DastSiteValidationStrategyEnum>;
  /** Path to be requested during validation. */
  validationPath: Scalars['String']['input'];
};

/** Autogenerated return type of DastSiteValidationCreate. */
export type DastSiteValidationCreatePayload = {
  __typename?: 'DastSiteValidationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** ID of the site validation. */
  id?: Maybe<Scalars['DastSiteValidationID']['output']>;
  /** Current validation status. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** An edge in a connection. */
export type DastSiteValidationEdge = {
  __typename?: 'DastSiteValidationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteValidation>;
};

/** Autogenerated input type of DastSiteValidationRevoke */
export type DastSiteValidationRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project the site validation belongs to. */
  fullPath: Scalars['ID']['input'];
  /** Normalized URL of the target to be revoked. */
  normalizedTargetUrl: Scalars['String']['input'];
};

/** Autogenerated return type of DastSiteValidationRevoke. */
export type DastSiteValidationRevokePayload = {
  __typename?: 'DastSiteValidationRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type DastSiteValidationStatusEnum =
  /** Site validation process finished but failed. */
  | 'FAILED_VALIDATION'
  /** Site validation process is in progress. */
  | 'INPROGRESS_VALIDATION'
  /** Site validation process finished successfully. */
  | 'PASSED_VALIDATION'
  /** Site validation process has not started. */
  | 'PENDING_VALIDATION';

export type DastSiteValidationStrategyEnum =
  /** Header validation. */
  | 'HEADER'
  /** Meta tag validation. */
  | 'META_TAG'
  /** Text file validation. */
  | 'TEXT_FILE';

export type DastTargetTypeEnum =
  /** API target. */
  | 'API'
  /** Website target. */
  | 'WEBSITE';

/** Color of the data visualization palette */
export type DataVisualizationColorEnum =
  /** Aqua color */
  | 'AQUA'
  /** Blue color */
  | 'BLUE'
  /** Green color */
  | 'GREEN'
  /** Magenta color */
  | 'MAGENTA'
  /** Orange color */
  | 'ORANGE';

/** Weight of the data visualization palette */
export type DataVisualizationWeightEnum =
  /** 50 weight */
  | 'WEIGHT_50'
  /** 100 weight */
  | 'WEIGHT_100'
  /** 200 weight */
  | 'WEIGHT_200'
  /** 300 weight */
  | 'WEIGHT_300'
  /** 400 weight */
  | 'WEIGHT_400'
  /** 500 weight */
  | 'WEIGHT_500'
  /** 600 weight */
  | 'WEIGHT_600'
  /** 700 weight */
  | 'WEIGHT_700'
  /** 800 weight */
  | 'WEIGHT_800'
  /** 900 weight */
  | 'WEIGHT_900'
  /** 950 weight */
  | 'WEIGHT_950';

/** Autogenerated input type of DeleteAnnotation */
export type DeleteAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the annotation to delete. */
  id: Scalars['String']['input'];
};

/** Autogenerated return type of DeleteAnnotation. */
export type DeleteAnnotationPayload = {
  __typename?: 'DeleteAnnotationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteContainerProtectionRepositoryRule */
export type DeleteContainerProtectionRepositoryRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the container repository protection rule to delete. */
  id: Scalars['ContainerRegistryProtectionRuleID']['input'];
};

/** Autogenerated return type of DeleteContainerProtectionRepositoryRule. */
export type DeleteContainerProtectionRepositoryRulePayload = {
  __typename?: 'DeleteContainerProtectionRepositoryRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Container repository protection rule that was deleted successfully. */
  containerProtectionRepositoryRule?: Maybe<ContainerProtectionRepositoryRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteContainerProtectionTagRule */
export type DeleteContainerProtectionTagRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the tag protection rule to delete. */
  id: Scalars['ContainerRegistryProtectionTagRuleID']['input'];
};

/** Autogenerated return type of DeleteContainerProtectionTagRule. */
export type DeleteContainerProtectionTagRulePayload = {
  __typename?: 'DeleteContainerProtectionTagRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Deleted protection rule for container image tags. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  containerProtectionTagRule?: Maybe<ContainerProtectionTagRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteConversationThread */
export type DeleteConversationThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the thread to delete. */
  threadId: Scalars['AiConversationThreadID']['input'];
};

/** Autogenerated return type of DeleteConversationThread. */
export type DeleteConversationThreadPayload = {
  __typename?: 'DeleteConversationThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** List of errors that occurred whilst trying to delete the thread. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if thread was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteDuoWorkflowsWorkflow */
export type DeleteDuoWorkflowsWorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the workflow to delete. */
  workflowId: Scalars['AiDuoWorkflowsWorkflowID']['input'];
};

/** Autogenerated return type of DeleteDuoWorkflowsWorkflow. */
export type DeleteDuoWorkflowsWorkflowPayload = {
  __typename?: 'DeleteDuoWorkflowsWorkflowPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** List of errors that occurred whilst trying to delete the workflow. */
  errors: Array<Scalars['String']['output']>;
  /** Returns true if workflow was successfully deleted. */
  success: Scalars['Boolean']['output'];
};

/** The response from the AdminSidekiqQueuesDeleteJobs mutation */
export type DeleteJobsResponse = {
  __typename?: 'DeleteJobsResponse';
  /** Whether or not the entire queue was processed in time; if not, retrying the same request is safe. */
  completed?: Maybe<Scalars['Boolean']['output']>;
  /** Number of matching jobs deleted. */
  deletedJobs?: Maybe<Scalars['Int']['output']>;
  /** Queue size after processing. */
  queueSize?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of DeletePackagesProtectionRule */
export type DeletePackagesProtectionRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the package protection rule to delete. */
  id: Scalars['PackagesProtectionRuleID']['input'];
};

/** Autogenerated return type of DeletePackagesProtectionRule. */
export type DeletePackagesProtectionRulePayload = {
  __typename?: 'DeletePackagesProtectionRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Packages protection rule that was deleted successfully. */
  packageProtectionRule?: Maybe<PackagesProtectionRule>;
};

/** Autogenerated input type of DeletePagesDeployment */
export type DeletePagesDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Pages Deployment. */
  id: Scalars['PagesDeploymentID']['input'];
};

/** Autogenerated return type of DeletePagesDeployment. */
export type DeletePagesDeploymentPayload = {
  __typename?: 'DeletePagesDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted Pages Deployment. */
  pagesDeployment: PagesDeployment;
};

export type DeletedNote = {
  __typename?: 'DeletedNote';
  /** ID of the discussion for the deleted note. */
  discussionId?: Maybe<Scalars['DiscussionID']['output']>;
  /** ID of the deleted note. */
  id: Scalars['NoteID']['output'];
  /** Whether deleted note is the last note in the discussion. */
  lastDiscussionNote?: Maybe<Scalars['Boolean']['output']>;
};

/** A software dependency used by a project */
export type Dependency = DependencyInterface & {
  __typename?: 'Dependency';
  /** Version of the dependency. */
  componentVersion?: Maybe<ComponentVersion>;
  /**
   * Ancestor dependency paths for a dependency. \
   *       Returns `null` if `dependency_graph_graphql` feature flag is disabled. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  dependencyPaths?: Maybe<DependencyPathPage>;
  /**
   * Indicates whether the dependency has any dependency paths. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  hasDependencyPaths: Scalars['Boolean']['output'];
  /** ID of the dependency. */
  id: Scalars['GlobalID']['output'];
  /** Licenses associated to the dependency. */
  licenses?: Maybe<Array<License>>;
  /** Information about where the dependency is located. */
  location?: Maybe<Location>;
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Description of the tool used to manage the dependency. */
  packager?: Maybe<PackageManager>;
  /** Information about reachability of a dependency. */
  reachability?: Maybe<ReachabilityType>;
  /**
   * Version of the dependency. Deprecated in GitLab 18.1: Replaced by component_version.
   * @deprecated Replaced by component_version. Deprecated in GitLab 18.1.
   */
  version?: Maybe<Scalars['String']['output']>;
  /** Vulnerabilities associated with the dependency. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** Number of vulnerabilities within the dependency. */
  vulnerabilityCount: Scalars['Int']['output'];
};


/** A software dependency used by a project */
export type DependencyDependencyPathsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A software dependency used by a project */
export type DependencyVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A software dependency aggregation used by a group */
export type DependencyAggregation = DependencyInterface & {
  __typename?: 'DependencyAggregation';
  /** Version of the dependency. */
  componentVersion?: Maybe<ComponentVersion>;
  /**
   * Ancestor dependency paths for a dependency. \
   *       Returns `null` if `dependency_graph_graphql` feature flag is disabled. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  dependencyPaths?: Maybe<DependencyPathPage>;
  /** ID of the dependency. */
  id: Scalars['GlobalID']['output'];
  /** Licenses associated to the dependency. */
  licenses?: Maybe<Array<License>>;
  /** Information about where the dependency is located. */
  location?: Maybe<Location>;
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Number of occurrences of the dependency across projects. */
  occurrenceCount: Scalars['Int']['output'];
  /** Description of the tool used to manage the dependency. */
  packager?: Maybe<PackageManager>;
  /** Information about reachability of a dependency. */
  reachability?: Maybe<ReachabilityType>;
  /**
   * Version of the dependency. Deprecated in GitLab 18.1: Replaced by component_version.
   * @deprecated Replaced by component_version. Deprecated in GitLab 18.1.
   */
  version?: Maybe<Scalars['String']['output']>;
  /** Vulnerabilities associated with the dependency. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** Number of vulnerabilities within the dependency. */
  vulnerabilityCount: Scalars['Int']['output'];
};


/** A software dependency aggregation used by a group */
export type DependencyAggregationDependencyPathsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A software dependency aggregation used by a group */
export type DependencyAggregationVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DependencyAggregation. */
export type DependencyAggregationConnection = {
  __typename?: 'DependencyAggregationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyAggregationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyAggregation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyAggregationEdge = {
  __typename?: 'DependencyAggregationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyAggregation>;
};

/** The connection type for Dependency. */
export type DependencyConnection = {
  __typename?: 'DependencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Dependency>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyEdge = {
  __typename?: 'DependencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Dependency>;
};

export type DependencyInterface = {
  /** Version of the dependency. */
  componentVersion?: Maybe<ComponentVersion>;
  /**
   * Ancestor dependency paths for a dependency. \
   *       Returns `null` if `dependency_graph_graphql` feature flag is disabled. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  dependencyPaths?: Maybe<DependencyPathPage>;
  /** ID of the dependency. */
  id: Scalars['GlobalID']['output'];
  /** Licenses associated to the dependency. */
  licenses?: Maybe<Array<License>>;
  /** Information about where the dependency is located. */
  location?: Maybe<Location>;
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Description of the tool used to manage the dependency. */
  packager?: Maybe<PackageManager>;
  /** Information about reachability of a dependency. */
  reachability?: Maybe<ReachabilityType>;
  /**
   * Version of the dependency. Deprecated in GitLab 18.1: Replaced by component_version.
   * @deprecated Replaced by component_version. Deprecated in GitLab 18.1.
   */
  version?: Maybe<Scalars['String']['output']>;
  /** Vulnerabilities associated with the dependency. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** Number of vulnerabilities within the dependency. */
  vulnerabilityCount: Scalars['Int']['output'];
};


export type DependencyInterfaceDependencyPathsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type DependencyInterfaceVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents metadata associated with a dependency link */
export type DependencyLinkMetadata = NugetDependencyLinkMetadata;

/** Ancestor path of a given dependency. */
export type DependencyPath = {
  __typename?: 'DependencyPath';
  /** Indicates if the path is cyclic. */
  isCyclic: Scalars['Boolean']['output'];
  /** Name of the dependency. */
  path: Array<DependencyPathPartial>;
};

/** Edge for a paginated dependency path for SBOM occurrences */
export type DependencyPathEdge = {
  __typename?: 'DependencyPathEdge';
  /** Cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** Dependency path node. */
  node?: Maybe<DependencyPath>;
};

/** Paginated dependency paths for SBOM occurrences */
export type DependencyPathPage = {
  __typename?: 'DependencyPathPage';
  /** List of dependency path edges. */
  edges: Array<DependencyPathEdge>;
  /** List of dependency paths. */
  nodes: Array<DependencyPath>;
  /** Pagination information for dependency paths. */
  pageInfo: DependencyPathPageInfo;
};

export type DependencyPathPageInfo = {
  __typename?: 'DependencyPathPageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items?. */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items?. */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** Ancestor path partial of a given dependency. */
export type DependencyPathPartial = {
  __typename?: 'DependencyPathPartial';
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Version of the dependency. */
  version: Scalars['String']['output'];
};

/** Dependency proxy blob */
export type DependencyProxyBlob = {
  __typename?: 'DependencyProxyBlob';
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Name of the blob. */
  fileName: Scalars['String']['output'];
  /** Size of the blob file. */
  size: Scalars['String']['output'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for DependencyProxyBlob. */
export type DependencyProxyBlobConnection = {
  __typename?: 'DependencyProxyBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyBlobEdge = {
  __typename?: 'DependencyProxyBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlob>;
};

/** Represents the Geo replication and verification state of a dependency_proxy_blob */
export type DependencyProxyBlobRegistry = {
  __typename?: 'DependencyProxyBlobRegistry';
  /** Indicate if the checksums of the DependencyProxyBlobRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the DependencyProxyBlobRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Dependency Proxy Blob. */
  dependencyProxyBlobId: Scalars['ID']['output'];
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DependencyProxyBlobRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the DependencyProxyBlobRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the DependencyProxyBlobRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the DependencyProxyBlobRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DependencyProxyBlobRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the DependencyProxyBlobRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the DependencyProxyBlobRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the DependencyProxyBlobRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the DependencyProxyBlobRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the DependencyProxyBlobRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the DependencyProxyBlobRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the DependencyProxyBlobRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the DependencyProxyBlobRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of DependencyProxyBlobRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the DependencyProxyBlobRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the DependencyProxyBlobRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for DependencyProxyBlobRegistry. */
export type DependencyProxyBlobRegistryConnection = {
  __typename?: 'DependencyProxyBlobRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlobRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for DependencyProxyBlobRegistry. */
export type DependencyProxyBlobRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type DependencyProxyBlobRegistryEdge = {
  __typename?: 'DependencyProxyBlobRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlobRegistry>;
};

/** Group-level Dependency Proxy TTL policy settings */
export type DependencyProxyImageTtlGroupPolicy = {
  __typename?: 'DependencyProxyImageTtlGroupPolicy';
  /** Timestamp of creation. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled: Scalars['Boolean']['output'];
  /** Number of days to retain a cached image file. */
  ttl?: Maybe<Scalars['Int']['output']>;
  /** Timestamp of the most recent update. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** Dependency proxy manifest */
export type DependencyProxyManifest = {
  __typename?: 'DependencyProxyManifest';
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Digest of the manifest. */
  digest: Scalars['String']['output'];
  /** Name of the manifest. */
  fileName: Scalars['String']['output'];
  /** ID of the manifest. */
  id: Scalars['DependencyProxyManifestID']['output'];
  /** Name of the image. */
  imageName: Scalars['String']['output'];
  /** Size of the manifest file. */
  size: Scalars['String']['output'];
  /** Status of the manifest (default, pending_destruction, processing, error) */
  status: DependencyProxyManifestStatus;
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for DependencyProxyManifest. */
export type DependencyProxyManifestConnection = {
  __typename?: 'DependencyProxyManifestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyManifestEdge = {
  __typename?: 'DependencyProxyManifestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyManifest>;
};

/** Represents the Geo replication and verification state of a dependency_proxy_manifest */
export type DependencyProxyManifestRegistry = {
  __typename?: 'DependencyProxyManifestRegistry';
  /** Indicate if the checksums of the DependencyProxyManifestRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the DependencyProxyManifestRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Dependency Proxy Manifest. */
  dependencyProxyManifestId: Scalars['ID']['output'];
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DependencyProxyManifestRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the DependencyProxyManifestRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the DependencyProxyManifestRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the DependencyProxyManifestRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DependencyProxyManifestRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the DependencyProxyManifestRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the DependencyProxyManifestRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the DependencyProxyManifestRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the DependencyProxyManifestRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the DependencyProxyManifestRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the DependencyProxyManifestRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the DependencyProxyManifestRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the DependencyProxyManifestRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of DependencyProxyManifestRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the DependencyProxyManifestRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the DependencyProxyManifestRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for DependencyProxyManifestRegistry. */
export type DependencyProxyManifestRegistryConnection = {
  __typename?: 'DependencyProxyManifestRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyManifestRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyManifestRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for DependencyProxyManifestRegistry. */
export type DependencyProxyManifestRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type DependencyProxyManifestRegistryEdge = {
  __typename?: 'DependencyProxyManifestRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyManifestRegistry>;
};

export type DependencyProxyManifestStatus =
  /** Dependency proxy manifest has a status of default. */
  | 'DEFAULT'
  /** Dependency proxy manifest has a status of error. */
  | 'ERROR'
  /** Dependency proxy manifest has a status of pending_destruction. */
  | 'PENDING_DESTRUCTION'
  /** Dependency proxy manifest has a status of processing. */
  | 'PROCESSING';

/** Project-level Dependency Proxy for packages settings */
export type DependencyProxyPackagesSetting = {
  __typename?: 'DependencyProxyPackagesSetting';
  /** Indicates whether the dependency proxy for packages is enabled for the project. */
  enabled: Scalars['Boolean']['output'];
  /** URL for the external Maven packages registry. */
  mavenExternalRegistryUrl?: Maybe<Scalars['String']['output']>;
  /** Username for the external Maven packages registry. */
  mavenExternalRegistryUsername?: Maybe<Scalars['String']['output']>;
};

/** Group-level Dependency Proxy settings */
export type DependencyProxySetting = {
  __typename?: 'DependencyProxySetting';
  /** Indicates whether the dependency proxy is enabled for the group. */
  enabled: Scalars['Boolean']['output'];
  /** Identity credential used to authenticate with Docker Hub when pulling images. Can be a username (for password or personal access token (PAT)) or organization name (for organization access token (OAT)). */
  identity?: Maybe<Scalars['String']['output']>;
};

/** Values for sorting dependencies */
export type DependencySort =
  /** License by ascending order. */
  | 'LICENSE_ASC'
  /** License by descending order. */
  | 'LICENSE_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Packager by ascending order. */
  | 'PACKAGER_ASC'
  /** Packager by descending order. */
  | 'PACKAGER_DESC'
  /** Severity by ascending order. */
  | 'SEVERITY_ASC'
  /** Severity by descending order. */
  | 'SEVERITY_DESC';

/** The deployment of an environment */
export type Deployment = {
  __typename?: 'Deployment';
  /** Approval summary of the deployment.This field can only be resolved for one deployment in any single request. */
  approvalSummary?: Maybe<DeploymentApprovalSummary>;
  /** Current approvals of the deployment. */
  approvals?: Maybe<Array<DeploymentApproval>>;
  /** Commit details of the deployment. */
  commit?: Maybe<Commit>;
  /** When the deployment record was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** When the deployment finished. */
  finishedAt?: Maybe<Scalars['Time']['output']>;
  /** Global ID of the deployment. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Project-level internal ID of the deployment. */
  iid?: Maybe<Scalars['String']['output']>;
  /** Pipeline job of the deployment. */
  job?: Maybe<CiJob>;
  /** Number of pending unified approvals on the deployment. */
  pendingApprovalCount?: Maybe<Scalars['Int']['output']>;
  /** Git-Ref that the deployment ran on. */
  ref?: Maybe<Scalars['String']['output']>;
  /** Path to the Git-Ref that the deployment ran on. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Git-SHA that the deployment ran on. */
  sha?: Maybe<Scalars['String']['output']>;
  /** Status of the deployment. */
  status?: Maybe<DeploymentStatus>;
  /** True or false if the deployment ran on a Git-tag. */
  tag?: Maybe<Scalars['Boolean']['output']>;
  /** Git tags that contain this deployment. This field can only be resolved for two deployments in any single request. */
  tags?: Maybe<Array<DeploymentTag>>;
  /** User who executed the deployment. */
  triggerer?: Maybe<UserCore>;
  /** When the deployment record was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: DeploymentPermissions;
  /** Web path to the deployment page. */
  webPath?: Maybe<Scalars['String']['output']>;
};

/** Approval of the deployment. */
export type DeploymentApproval = {
  __typename?: 'DeploymentApproval';
  /** Additional comment. */
  comment?: Maybe<Scalars['String']['output']>;
  /** When the user approved/rejected first time. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Whether the deployment was approved/rejected. */
  status?: Maybe<DeploymentsApprovalStatus>;
  /** When the user updated the approval. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User who approved or rejected the deployment. */
  user?: Maybe<UserCore>;
};

/** Approval summary of the deployment. */
export type DeploymentApprovalSummary = {
  __typename?: 'DeploymentApprovalSummary';
  /** Approval Rules for the deployment. */
  rules?: Maybe<Array<ProtectedEnvironmentApprovalRuleForSummary>>;
  /** Status of the approvals. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** Total pending approval count. */
  totalPendingApprovalCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of required approvals. */
  totalRequiredApprovals?: Maybe<Scalars['Int']['output']>;
};

/** Status of the deployment approval summary. */
export type DeploymentApprovalSummaryStatus =
  /** Summarized deployment approval status that is approved. */
  | 'APPROVED'
  /** Summarized deployment approval status that is pending approval. */
  | 'PENDING_APPROVAL'
  /** Summarized deployment approval status that is rejected. */
  | 'REJECTED';

/** The connection type for Deployment. */
export type DeploymentConnection = {
  __typename?: 'DeploymentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DeploymentEdge = {
  __typename?: 'DeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Deployment>;
};

export type DeploymentPermissions = {
  __typename?: 'DeploymentPermissions';
  /** Indicates the user can perform `approve_deployment` on this resource. This field can only be resolved for one environment in any single request. */
  approveDeployment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_deployment` on this resource */
  destroyDeployment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_deployment` on this resource */
  updateDeployment: Scalars['Boolean']['output'];
};

/** All deployment statuses. */
export type DeploymentStatus =
  /** A deployment that is blocked. */
  | 'BLOCKED'
  /** A deployment that is canceled. */
  | 'CANCELED'
  /** A deployment that is created. */
  | 'CREATED'
  /** A deployment that is failed. */
  | 'FAILED'
  /** A deployment that is running. */
  | 'RUNNING'
  /** A deployment that is skipped. */
  | 'SKIPPED'
  /** A deployment that is success. */
  | 'SUCCESS';

/** Tags for a given deployment */
export type DeploymentTag = {
  __typename?: 'DeploymentTag';
  /** Name of the git tag. */
  name?: Maybe<Scalars['String']['output']>;
  /** Path for the tag. */
  path?: Maybe<Scalars['String']['output']>;
  /** Web path for the tag. */
  webPath?: Maybe<Scalars['String']['output']>;
};

/** All environment deployment tiers. */
export type DeploymentTier =
  /** Development. */
  | 'DEVELOPMENT'
  /** Other. */
  | 'OTHER'
  /** Production. */
  | 'PRODUCTION'
  /** Staging. */
  | 'STAGING'
  /** Testing. */
  | 'TESTING';

/** Status of the deployment approval. */
export type DeploymentsApprovalStatus =
  /** A deployment approval that is approved. */
  | 'APPROVED'
  /** A deployment approval that is rejected. */
  | 'REJECTED';

/** Values for ordering deployments by a specific field */
export type DeploymentsOrderByInput = {
  /** Order by Created time. */
  createdAt?: InputMaybe<SortDirectionEnum>;
  /** Order by Finished time. */
  finishedAt?: InputMaybe<SortDirectionEnum>;
};

export type DescriptionVersion = {
  __typename?: 'DescriptionVersion';
  /**
   * Whether current user can delete description version associated to the note metadata. Deprecated in GitLab 15.7: For backwards compatibility with REST API version and to be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in GitLab 15.7.
   */
  canDelete?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Web path to delete description version associated to the note metadata. Deprecated in GitLab 15.7: For backwards compatibility with REST API version and to be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in GitLab 15.7.
   */
  deletePath?: Maybe<Scalars['String']['output']>;
  /**
   * Whether description version associated to the note metadata is deleted. Deprecated in GitLab 15.7: For backwards compatibility with REST API version and to be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in GitLab 15.7.
   */
  deleted?: Maybe<Scalars['Boolean']['output']>;
  /** Content of the given description version. */
  description?: Maybe<Scalars['String']['output']>;
  /** Description diff between versions. */
  diff?: Maybe<Scalars['String']['output']>;
  /**
   * Web path to description version associated to the note metadata. Deprecated in GitLab 15.7: For backwards compatibility with REST API version and to be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in GitLab 15.7.
   */
  diffPath?: Maybe<Scalars['String']['output']>;
  /** ID of the description version. */
  id: Scalars['DescriptionVersionID']['output'];
};


export type DescriptionVersionDiffArgs = {
  versionId?: InputMaybe<Scalars['DescriptionVersionID']['input']>;
};

/** A single design */
export type Design = CurrentUserTodos & DesignFields & NoteableInterface & Todoable & {
  __typename?: 'Design';
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Description of the design. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Diff refs for the design. */
  diffRefs: DiffRefs;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** How the design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String']['output'];
  /** Full path to the design file. */
  fullPath: Scalars['ID']['output'];
  /** ID of the design. */
  id: Scalars['ID']['output'];
  /** URL of the full-sized image. */
  image: Scalars['String']['output'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the design was imported. */
  imported: Scalars['Boolean']['output'];
  /** Import source of the design. */
  importedFrom: ImportSource;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Total count of user-created notes for the design. */
  notesCount: Scalars['Int']['output'];
  /** Project the design belongs to. */
  project: Project;
  /** All versions related to this design ordered newest first. */
  versions: DesignVersionConnection;
  /** URL of the design. */
  webUrl: Scalars['String']['output'];
};


/** A single design */
export type DesignCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A single design */
export type DesignCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** A single design */
export type DesignDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A single design */
export type DesignNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A single design */
export type DesignVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']['input']>;
  earlierOrEqualToSha?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A design pinned to a specific version. The image field reflects the design as of the associated version */
export type DesignAtVersion = DesignFields & {
  __typename?: 'DesignAtVersion';
  /** Underlying design. */
  design: Design;
  /** Diff refs for the design. */
  diffRefs: DiffRefs;
  /** How the design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String']['output'];
  /** Full path to the design file. */
  fullPath: Scalars['ID']['output'];
  /** ID of the design. */
  id: Scalars['ID']['output'];
  /** URL of the full-sized image. */
  image: Scalars['String']['output'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']['output']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for the design. */
  notesCount: Scalars['Int']['output'];
  /** Project the design belongs to. */
  project: Project;
  /** Version the design-at-versions is pinned to. */
  version: DesignVersion;
};

/** The connection type for DesignAtVersion. */
export type DesignAtVersionConnection = {
  __typename?: 'DesignAtVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignAtVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignAtVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignAtVersionEdge = {
  __typename?: 'DesignAtVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignAtVersion>;
};

/** A collection of designs */
export type DesignCollection = {
  __typename?: 'DesignCollection';
  /** Copy state of the design collection. */
  copyState?: Maybe<DesignCollectionCopyState>;
  /** Find a specific design. */
  design?: Maybe<Design>;
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** All designs for the design collection. */
  designs: DesignConnection;
  /** Issue associated with the design collection. */
  issue: Issue;
  /** Project associated with the design collection. */
  project: Project;
  /** A specific version. */
  version?: Maybe<DesignVersion>;
  /** All versions related to all designs, ordered newest first. */
  versions: DesignVersionConnection;
};


/** A collection of designs */
export type DesignCollectionDesignArgs = {
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['DesignManagementDesignID']['input']>;
};


/** A collection of designs */
export type DesignCollectionDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID']['input'];
};


/** A collection of designs */
export type DesignCollectionDesignsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  atVersion?: InputMaybe<Scalars['DesignManagementVersionID']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filenames?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A collection of designs */
export type DesignCollectionVersionArgs = {
  id?: InputMaybe<Scalars['DesignManagementVersionID']['input']>;
  sha?: InputMaybe<Scalars['String']['input']>;
};


/** A collection of designs */
export type DesignCollectionVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']['input']>;
  earlierOrEqualToSha?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Copy state of a DesignCollection */
export type DesignCollectionCopyState =
  /** The DesignCollection encountered an error during a copy */
  | 'ERROR'
  /** The DesignCollection is being copied */
  | 'IN_PROGRESS'
  /** The DesignCollection has no copy in progress */
  | 'READY';

/** The connection type for Design. */
export type DesignConnection = {
  __typename?: 'DesignConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Design>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignEdge = {
  __typename?: 'DesignEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Design>;
};

export type DesignFields = {
  /** Diff refs for the design. */
  diffRefs: DiffRefs;
  /** How the design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String']['output'];
  /** Full path to the design file. */
  fullPath: Scalars['ID']['output'];
  /** ID of the design. */
  id: Scalars['ID']['output'];
  /** URL of the full-sized image. */
  image: Scalars['String']['output'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']['output']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for the design. */
  notesCount: Scalars['Int']['output'];
  /** Project the design belongs to. */
  project: Project;
};

export type DesignManagement = {
  __typename?: 'DesignManagement';
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** Find a version. */
  version?: Maybe<DesignVersion>;
};


export type DesignManagementDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID']['input'];
};


export type DesignManagementVersionArgs = {
  id: Scalars['DesignManagementVersionID']['input'];
};

/** Autogenerated input type of DesignManagementDelete */
export type DesignManagementDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Filenames of the designs to delete. */
  filenames: Array<Scalars['String']['input']>;
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID']['input'];
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of DesignManagementDelete. */
export type DesignManagementDeletePayload = {
  __typename?: 'DesignManagementDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** New version in which the designs are deleted. */
  version?: Maybe<DesignVersion>;
};

/** Autogenerated input type of DesignManagementMove */
export type DesignManagementMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the design to move. */
  id: Scalars['DesignManagementDesignID']['input'];
  /** ID of the immediately following design. */
  next?: InputMaybe<Scalars['DesignManagementDesignID']['input']>;
  /** ID of the immediately preceding design. */
  previous?: InputMaybe<Scalars['DesignManagementDesignID']['input']>;
};

/** Autogenerated return type of DesignManagementMove. */
export type DesignManagementMovePayload = {
  __typename?: 'DesignManagementMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Current state of the collection. */
  designCollection?: Maybe<DesignCollection>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents the Geo replication and verification state of a Design Management Repository */
export type DesignManagementRepositoryRegistry = {
  __typename?: 'DesignManagementRepositoryRegistry';
  /** Indicate if the checksums of the DesignManagementRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the DesignManagementRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Design Management Repository. */
  designManagementRepositoryId: Scalars['ID']['output'];
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DesignManagementRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the DesignManagementRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the DesignManagementRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the DesignManagementRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the DesignManagementRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the DesignManagementRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the DesignManagementRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the DesignManagementRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the DesignManagementRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the DesignManagementRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the DesignManagementRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the DesignManagementRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the DesignManagementRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of DesignManagementRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the DesignManagementRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the DesignManagementRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for DesignManagementRepositoryRegistry. */
export type DesignManagementRepositoryRegistryConnection = {
  __typename?: 'DesignManagementRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignManagementRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignManagementRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for DesignManagementRepositoryRegistry. */
export type DesignManagementRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type DesignManagementRepositoryRegistryEdge = {
  __typename?: 'DesignManagementRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignManagementRepositoryRegistry>;
};

/** Autogenerated input type of DesignManagementUpdate */
export type DesignManagementUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the design. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the design to update. */
  id: Scalars['DesignManagementDesignID']['input'];
};

/** Autogenerated return type of DesignManagementUpdate. */
export type DesignManagementUpdatePayload = {
  __typename?: 'DesignManagementUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated design. */
  design: Design;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DesignManagementUpload */
export type DesignManagementUploadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Files to upload. */
  files: Array<Scalars['Upload']['input']>;
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID']['input'];
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of DesignManagementUpload. */
export type DesignManagementUploadPayload = {
  __typename?: 'DesignManagementUploadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Designs that were uploaded by the mutation. */
  designs: Array<Design>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Any designs that were skipped from the upload due to there being no change to their content since their last version */
  skippedDesigns: Array<Design>;
};

/** A specific version in which designs were added, modified or deleted */
export type DesignVersion = {
  __typename?: 'DesignVersion';
  /** Author of the version. */
  author: UserCore;
  /** Timestamp of when the version was created. */
  createdAt: Scalars['Time']['output'];
  /** A particular design as of this version, provided it is visible at this version. */
  designAtVersion: DesignAtVersion;
  /** All designs that were changed in the version. */
  designs: DesignConnection;
  /** All designs that are visible at this version, as of this version. */
  designsAtVersion: DesignAtVersionConnection;
  /** ID of the design version. */
  id: Scalars['ID']['output'];
  /** SHA of the design version. */
  sha: Scalars['ID']['output'];
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignAtVersionArgs = {
  designId?: InputMaybe<Scalars['DesignManagementDesignID']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['DesignManagementDesignAtVersionID']['input']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsAtVersionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filenames?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DesignVersion. */
export type DesignVersionConnection = {
  __typename?: 'DesignVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignVersionEdge = {
  __typename?: 'DesignVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignVersion>;
};

/** Mutation event of a design within a version */
export type DesignVersionEvent =
  /** A creation event */
  | 'CREATION'
  /** A deletion event */
  | 'DELETION'
  /** A modification event */
  | 'MODIFICATION'
  /** No change. */
  | 'NONE';

/** Autogenerated input type of DestroyBoard */
export type DestroyBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardID']['input'];
};

/** Autogenerated input type of DestroyBoardList */
export type DestroyBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the list to destroy. Only label lists are accepted. */
  listId: Scalars['ListID']['input'];
};

/** Autogenerated return type of DestroyBoardList. */
export type DestroyBoardListPayload = {
  __typename?: 'DestroyBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** List after mutation. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of DestroyBoard. */
export type DestroyBoardPayload = {
  __typename?: 'DestroyBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyComplianceFramework */
export type DestroyComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance framework to destroy. */
  id: Scalars['ComplianceManagementFrameworkID']['input'];
};

/** Autogenerated return type of DestroyComplianceFramework. */
export type DestroyComplianceFrameworkPayload = {
  __typename?: 'DestroyComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyComplianceRequirement */
export type DestroyComplianceRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance requirement to destroy. */
  id: Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input'];
};

/** Autogenerated return type of DestroyComplianceRequirement. */
export type DestroyComplianceRequirementPayload = {
  __typename?: 'DestroyComplianceRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyComplianceRequirementsControl */
export type DestroyComplianceRequirementsControlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance requirement control to destroy. */
  id: Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementsControlID']['input'];
};

/** Autogenerated return type of DestroyComplianceRequirementsControl. */
export type DestroyComplianceRequirementsControlPayload = {
  __typename?: 'DestroyComplianceRequirementsControlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyContainerRepository */
export type DestroyContainerRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID']['input'];
};

/** Autogenerated return type of DestroyContainerRepository. */
export type DestroyContainerRepositoryPayload = {
  __typename?: 'DestroyContainerRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Container repository policy after scheduling the deletion. */
  containerRepository: ContainerRepository;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyContainerRepositoryTags */
export type DestroyContainerRepositoryTagsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID']['input'];
  /** Container repository tag(s) to delete. Total number can't be greater than 20 */
  tagNames: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of DestroyContainerRepositoryTags. */
export type DestroyContainerRepositoryTagsPayload = {
  __typename?: 'DestroyContainerRepositoryTagsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Deleted container repository tags. */
  deletedTagNames: Array<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyCustomEmoji */
export type DestroyCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the custom emoji to destroy. */
  id: Scalars['CustomEmojiID']['input'];
};

/** Autogenerated return type of DestroyCustomEmoji. */
export type DestroyCustomEmojiPayload = {
  __typename?: 'DestroyCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Deleted custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyEpicBoard */
export type DestroyEpicBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardsEpicBoardID']['input'];
};

/** Autogenerated return type of DestroyEpicBoard. */
export type DestroyEpicBoardPayload = {
  __typename?: 'DestroyEpicBoardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic board after mutation. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyNote */
export type DestroyNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the note to destroy. */
  id: Scalars['NoteID']['input'];
};

/** Autogenerated return type of DestroyNote. */
export type DestroyNotePayload = {
  __typename?: 'DestroyNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of DestroyPackageFile */
export type DestroyPackageFileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Package file. */
  id: Scalars['PackagesPackageFileID']['input'];
};

/** Autogenerated return type of DestroyPackageFile. */
export type DestroyPackageFilePayload = {
  __typename?: 'DestroyPackageFilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyPackageFiles */
export type DestroyPackageFilesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the Package file. */
  ids: Array<Scalars['PackagesPackageFileID']['input']>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPackageFiles. */
export type DestroyPackageFilesPayload = {
  __typename?: 'DestroyPackageFilesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyPackage */
export type DestroyPackageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Package. */
  id: Scalars['PackagesPackageID']['input'];
};

/** Autogenerated return type of DestroyPackage. */
export type DestroyPackagePayload = {
  __typename?: 'DestroyPackagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyPackages */
export type DestroyPackagesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the Packages. Max 100 */
  ids: Array<Scalars['PackagesPackageID']['input']>;
};

/** Autogenerated return type of DestroyPackages. */
export type DestroyPackagesPayload = {
  __typename?: 'DestroyPackagesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroySnippet */
export type DestroySnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the snippet to destroy. */
  id: Scalars['SnippetID']['input'];
};

/** Autogenerated return type of DestroySnippet. */
export type DestroySnippetPayload = {
  __typename?: 'DestroySnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Details of the import status of a project. */
export type DetailedImportStatus = {
  __typename?: 'DetailedImportStatus';
  /** ID of the import state. */
  id?: Maybe<Scalars['ProjectImportStateID']['output']>;
  /** Last error of the import. */
  lastError?: Maybe<Scalars['String']['output']>;
  /** Time of the last successful update. */
  lastSuccessfulUpdateAt?: Maybe<Scalars['Time']['output']>;
  /** Time of the last update. */
  lastUpdateAt?: Maybe<Scalars['Time']['output']>;
  /** Time of the start of the last update. */
  lastUpdateStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Current status of the import. */
  status?: Maybe<Scalars['String']['output']>;
  /** Import url. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Detailed representation of whether a GitLab merge request can be merged. */
export type DetailedMergeStatus =
  /** Merge request approvals currently syncing. */
  | 'APPROVALS_SYNCING'
  /** Merge request dependencies must be merged. */
  | 'BLOCKED_STATUS'
  /** Currently checking for mergeability. */
  | 'CHECKING'
  /** Pipeline must succeed before merging. */
  | 'CI_MUST_PASS'
  /** Pipeline is still running. */
  | 'CI_STILL_RUNNING'
  /** Source branch exists and contains commits. */
  | 'COMMITS_STATUS'
  /** There are conflicts between the source and target branches. */
  | 'CONFLICT'
  /** Discussions must be resolved before merging. */
  | 'DISCUSSIONS_NOT_RESOLVED'
  /** Merge request must not be draft before merging. */
  | 'DRAFT_STATUS'
  /** Status checks must pass. */
  | 'EXTERNAL_STATUS_CHECKS'
  /** Either the title or description must reference a Jira issue. */
  | 'JIRA_ASSOCIATION'
  /** Merge request includes locked LFS files. */
  | 'LOCKED_LFS_FILES'
  /** Merge request includes locked paths. */
  | 'LOCKED_PATHS'
  /** Branch can be merged. */
  | 'MERGEABLE'
  /** Merge request may not be merged until after the specified time. */
  | 'MERGE_TIME'
  /** Merge request needs to be rebased. */
  | 'NEED_REBASE'
  /** Merge request must be approved before merging. */
  | 'NOT_APPROVED'
  /** Merge request must be open before merging. */
  | 'NOT_OPEN'
  /** Merge request diff is being created. */
  | 'PREPARING'
  /** Indicates a reviewer has requested changes. */
  | 'REQUESTED_CHANGES'
  /** All policy rules must be satisfied. */
  | 'SECURITY_POLICIES_VIOLATIONS'
  /** Merge request title does not match required regex. */
  | 'TITLE_NOT_MATCHING'
  /** Merge status has not been checked. */
  | 'UNCHECKED';

export type DetailedStatus = {
  __typename?: 'DetailedStatus';
  /** Action information for the status. This includes method, button title, icon, path, and title. */
  action?: Maybe<StatusAction>;
  /** Path of the deployment details for the status. */
  deploymentDetailsPath?: Maybe<Scalars['String']['output']>;
  /** Path of the details for the status. */
  detailsPath?: Maybe<Scalars['String']['output']>;
  /** Favicon of the status. */
  favicon?: Maybe<Scalars['String']['output']>;
  /**
   * Group of the status. Deprecated in GitLab 16.4: The `group` attribute is deprecated. Use `name` instead.
   * @deprecated The `group` attribute is deprecated. Use `name` instead. Deprecated in GitLab 16.4.
   */
  group?: Maybe<Scalars['String']['output']>;
  /** Indicates if the status has further details. */
  hasDetails?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Icon of the status. Deprecated in GitLab 16.4: The `icon` attribute is deprecated. Use `name` to identify the status to display instead.
   * @deprecated The `icon` attribute is deprecated. Use `name` to identify the status to display instead. Deprecated in GitLab 16.4.
   */
  icon?: Maybe<Scalars['String']['output']>;
  /** ID for a detailed status. */
  id: Scalars['String']['output'];
  /** Human-readable label of the status (e.g. success). */
  label?: Maybe<Scalars['String']['output']>;
  /** Machine-readable status name (e.g. SUCCESS). */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Text of the status. Deprecated in GitLab 16.4: The `text` attribute is being deprecated. Use `label` instead.
   * @deprecated The `text` attribute is being deprecated. Use `label` instead. Deprecated in GitLab 16.4.
   */
  text?: Maybe<Scalars['String']['output']>;
  /** Tooltip associated with the status. */
  tooltip?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DevfileValidate */
export type DevfileValidateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Input devfile. */
  devfileYaml: Scalars['String']['input'];
};

/** Autogenerated return type of DevfileValidate. */
export type DevfileValidatePayload = {
  __typename?: 'DevfileValidatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Status whether devfile is valid or not. */
  valid?: Maybe<Scalars['Boolean']['output']>;
};

/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespace = {
  __typename?: 'DevopsAdoptionEnabledNamespace';
  /** Namespace where data should be displayed. */
  displayNamespace?: Maybe<Namespace>;
  /** ID of the enabled namespace. */
  id: Scalars['ID']['output'];
  /** Metrics snapshot for previous month for the enabled namespace. */
  latestSnapshot?: Maybe<DevopsAdoptionSnapshot>;
  /** Namespace which should be calculated. */
  namespace?: Maybe<Namespace>;
  /** Data snapshots of the namespace. */
  snapshots?: Maybe<DevopsAdoptionSnapshotConnection>;
};


/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespaceSnapshotsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endTimeAfter?: InputMaybe<Scalars['Time']['input']>;
  endTimeBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DevopsAdoptionEnabledNamespace. */
export type DevopsAdoptionEnabledNamespaceConnection = {
  __typename?: 'DevopsAdoptionEnabledNamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionEnabledNamespaceEdge = {
  __typename?: 'DevopsAdoptionEnabledNamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionEnabledNamespace>;
};

/** Snapshot */
export type DevopsAdoptionSnapshot = {
  __typename?: 'DevopsAdoptionSnapshot';
  /** Total number of projects with existing CODEOWNERS file. */
  codeOwnersUsedCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of projects with enabled coverage fuzzing. */
  coverageFuzzingEnabledCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of projects with enabled DAST. */
  dastEnabledCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of projects with enabled dependency scanning. */
  dependencyScanningEnabledCount?: Maybe<Scalars['Int']['output']>;
  /** At least one deployment succeeded. */
  deploySucceeded: Scalars['Boolean']['output'];
  /** End time for the snapshot where the data points were collected. */
  endTime: Scalars['Time']['output'];
  /** At least one issue was opened. */
  issueOpened: Scalars['Boolean']['output'];
  /** At least one merge request was approved. */
  mergeRequestApproved: Scalars['Boolean']['output'];
  /** At least one merge request was opened. */
  mergeRequestOpened: Scalars['Boolean']['output'];
  /** At least one pipeline succeeded. */
  pipelineSucceeded: Scalars['Boolean']['output'];
  /** Time the snapshot was recorded. */
  recordedAt: Scalars['Time']['output'];
  /** At least one runner was used. */
  runnerConfigured: Scalars['Boolean']['output'];
  /** Total number of projects with enabled SAST. */
  sastEnabledCount?: Maybe<Scalars['Int']['output']>;
  /** Start time for the snapshot where the data points were collected. */
  startTime: Scalars['Time']['output'];
  /** Total number of projects. */
  totalProjectsCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of projects with vulnerability management used at least once. */
  vulnerabilityManagementUsedCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for DevopsAdoptionSnapshot. */
export type DevopsAdoptionSnapshotConnection = {
  __typename?: 'DevopsAdoptionSnapshotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionSnapshotEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionSnapshot>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionSnapshotEdge = {
  __typename?: 'DevopsAdoptionSnapshotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionSnapshot>;
};

export type Diff = {
  __typename?: 'Diff';
  /** Old file mode of the file. */
  aMode?: Maybe<Scalars['String']['output']>;
  /** New file mode of the file. */
  bMode?: Maybe<Scalars['String']['output']>;
  /** File diffs are excluded but can be fetched on request. */
  collapsed?: Maybe<Scalars['String']['output']>;
  /** Indicates if the file has been removed.  */
  deletedFile?: Maybe<Scalars['String']['output']>;
  /** Diff representation of the changes made to the file. */
  diff?: Maybe<Scalars['String']['output']>;
  /** Indicates if the file has just been added.  */
  newFile?: Maybe<Scalars['String']['output']>;
  /** New path of the file. */
  newPath?: Maybe<Scalars['String']['output']>;
  /** Old path of the file. */
  oldPath?: Maybe<Scalars['String']['output']>;
  /** Indicates if the file has been renamed. */
  renamedFile?: Maybe<Scalars['String']['output']>;
  /** File diffs are excluded and cannot be retrieved. */
  tooLarge?: Maybe<Scalars['String']['output']>;
};

export type DiffImagePositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']['input']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String']['input'];
  /** Total height of the image. */
  height: Scalars['Int']['input'];
  /** The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required */
  paths: DiffPathsInput;
  /** SHA of the branch being compared against. */
  startSha: Scalars['String']['input'];
  /** Total width of the image. */
  width: Scalars['Int']['input'];
  /** X position of the note. */
  x: Scalars['Int']['input'];
  /** Y position of the note. */
  y: Scalars['Int']['input'];
};

export type DiffPathsInput = {
  /** Path of the file on the HEAD SHA. */
  newPath?: InputMaybe<Scalars['String']['input']>;
  /** Path of the file on the start SHA. */
  oldPath?: InputMaybe<Scalars['String']['input']>;
};

export type DiffPosition = {
  __typename?: 'DiffPosition';
  /** Information about the branch, HEAD, and base at the time of commenting. */
  diffRefs: DiffRefs;
  /** Path of the file that was changed. */
  filePath: Scalars['String']['output'];
  /** Total height of the image. */
  height?: Maybe<Scalars['Int']['output']>;
  /** Line on HEAD SHA that was changed. */
  newLine?: Maybe<Scalars['Int']['output']>;
  /** Path of the file on the HEAD SHA. */
  newPath?: Maybe<Scalars['String']['output']>;
  /** Line on start SHA that was changed. */
  oldLine?: Maybe<Scalars['Int']['output']>;
  /** Path of the file on the start SHA. */
  oldPath?: Maybe<Scalars['String']['output']>;
  /** Type of file the position refers to. */
  positionType: DiffPositionType;
  /** Total width of the image. */
  width?: Maybe<Scalars['Int']['output']>;
  /** X position of the note. */
  x?: Maybe<Scalars['Int']['output']>;
  /** Y position of the note. */
  y?: Maybe<Scalars['Int']['output']>;
};

export type DiffPositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']['input']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String']['input'];
  /** Line on HEAD SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/api/discussions/#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field. */
  newLine?: InputMaybe<Scalars['Int']['input']>;
  /** Line on start SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/api/discussions/#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field. */
  oldLine?: InputMaybe<Scalars['Int']['input']>;
  /** The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required */
  paths: DiffPathsInput;
  /** SHA of the branch being compared against. */
  startSha: Scalars['String']['input'];
};

/** Type of file the position refers to */
export type DiffPositionType =
  /** Unknown file type. */
  | 'file'
  /** An image. */
  | 'image'
  /** Text file. */
  | 'text';

export type DiffRefs = {
  __typename?: 'DiffRefs';
  /** Merge base of the branch the comment was made on. */
  baseSha?: Maybe<Scalars['String']['output']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String']['output'];
  /** SHA of the branch being compared against. */
  startSha: Scalars['String']['output'];
};

/** Changes to a single file */
export type DiffStats = {
  __typename?: 'DiffStats';
  /** Number of lines added to the file. */
  additions: Scalars['Int']['output'];
  /** Number of lines deleted from the file. */
  deletions: Scalars['Int']['output'];
  /** File path, relative to repository root. */
  path: Scalars['String']['output'];
};

/** Aggregated summary of changes */
export type DiffStatsSummary = {
  __typename?: 'DiffStatsSummary';
  /** Number of lines added. */
  additions: Scalars['Int']['output'];
  /** Number of lines changed. */
  changes: Scalars['Int']['output'];
  /** Number of lines deleted. */
  deletions: Scalars['Int']['output'];
  /** Number of files changed. */
  fileCount: Scalars['Int']['output'];
};

/** Autogenerated input type of DisableDevopsAdoptionNamespace */
export type DisableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** One or many IDs of the enabled namespaces to disable. */
  id: Array<Scalars['AnalyticsDevopsAdoptionEnabledNamespaceID']['input']>;
};

/** Autogenerated return type of DisableDevopsAdoptionNamespace. */
export type DisableDevopsAdoptionNamespacePayload = {
  __typename?: 'DisableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type Discussion = BaseDiscussionInterface & ResolvableInterface & {
  __typename?: 'Discussion';
  /** Timestamp of the discussion's creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the discussion. */
  id: Scalars['DiscussionID']['output'];
  /** Object which the discussion belongs to. */
  noteable?: Maybe<NoteableType>;
  /** All notes in the discussion. */
  notes: NoteConnection;
  /** ID used to reply to the discussion. */
  replyId: Scalars['DiscussionID']['output'];
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean']['output'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean']['output'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: DiscussionPermissions;
};


export type DiscussionNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Discussion. */
export type DiscussionConnection = {
  __typename?: 'DiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DiscussionEdge = {
  __typename?: 'DiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Discussion>;
};

export type DiscussionPermissions = {
  __typename?: 'DiscussionPermissions';
  /** If `true`, the user can perform `resolve_note` on this resource */
  resolveNote: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DiscussionToggleResolve */
export type DiscussionToggleResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the discussion. */
  id: Scalars['DiscussionID']['input'];
  /** Will resolve the discussion when true, and unresolve the discussion when false. */
  resolve: Scalars['Boolean']['input'];
};

/** Autogenerated return type of DiscussionToggleResolve. */
export type DiscussionToggleResolvePayload = {
  __typename?: 'DiscussionToggleResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Discussion after mutation. */
  discussion?: Maybe<Discussion>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DismissPolicyViolations */
export type DismissPolicyViolationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment explaining the dismissal of the policy violations. */
  comment: Scalars['String']['input'];
  /** Type of dismissal for the policy violations. */
  dismissalTypes: Array<DismissalType>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** IDs of warn mode policies with violations to dismiss. */
  securityPolicyIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of DismissPolicyViolations. */
export type DismissPolicyViolationsPayload = {
  __typename?: 'DismissPolicyViolationsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Represents the different dismissal types for security policy violations. */
export type DismissalType =
  /** Dismissal due to emergency hot fix. */
  | 'EMERGENCY_HOT_FIX'
  /** Dismissal due to other reasons. */
  | 'OTHER'
  /** Dismissal due to policy false positive. */
  | 'POLICY_FALSE_POSITIVE'
  /** Dismissal due to scanner false positive. */
  | 'SCANNER_FALSE_POSITIVE';

/** All information related to DORA metrics. */
export type Dora = {
  __typename?: 'Dora';
  /** DORA metrics for the current group or project. */
  metrics?: Maybe<Array<DoraMetric>>;
};


/** All information related to DORA metrics. */
export type DoraMetricsArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  environmentTiers?: InputMaybe<Array<DeploymentTier>>;
  interval?: InputMaybe<DoraMetricBucketingInterval>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

export type DoraMetric = {
  __typename?: 'DoraMetric';
  /** Percentage of deployments that caused incidents in production. */
  changeFailureRate?: Maybe<Scalars['Float']['output']>;
  /** Date of the data point. */
  date?: Maybe<Scalars['String']['output']>;
  /** Number of deployments per day. */
  deploymentFrequency?: Maybe<Scalars['Float']['output']>;
  /** Median time to deploy a merged merge request. */
  leadTimeForChanges?: Maybe<Scalars['Float']['output']>;
  /** Median time to close an incident. */
  timeToRestoreService?: Maybe<Scalars['Float']['output']>;
};

/** All possible ways that DORA metrics can be aggregated. */
export type DoraMetricBucketingInterval =
  /** All data points are combined into a single value. */
  | 'ALL'
  /** Data points are combined into chunks by day. */
  | 'DAILY'
  /** Data points are combined into chunks by month. */
  | 'MONTHLY';

/** Aggregated DORA score counts for projects for the last complete month. */
export type DoraPerformanceScoreCount = {
  __typename?: 'DoraPerformanceScoreCount';
  /** Number of projects that score "high" on the metric. */
  highProjectsCount?: Maybe<Scalars['Int']['output']>;
  /** Number of projects that score "low" on the metric. */
  lowProjectsCount?: Maybe<Scalars['Int']['output']>;
  /** Number of projects that score "medium" on the metric. */
  mediumProjectsCount?: Maybe<Scalars['Int']['output']>;
  /** Name of the DORA metric. */
  metricName: Scalars['String']['output'];
  /** Number of projects with no data for the metric. */
  noDataProjectsCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for DoraPerformanceScoreCount. */
export type DoraPerformanceScoreCountConnection = {
  __typename?: 'DoraPerformanceScoreCountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DoraPerformanceScoreCountEdge>>>;
  /** Count of projects without any DORA scores within the scope. */
  noDoraDataProjectsCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DoraPerformanceScoreCount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Count of total projects. */
  totalProjectsCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DoraPerformanceScoreCountEdge = {
  __typename?: 'DoraPerformanceScoreCountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DoraPerformanceScoreCount>;
};

/** Filter parameters for projects to be aggregated for DORA metrics. */
export type DoraProjectFilterInput = {
  /** Filter projects by topic. */
  topic?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Settings for Duo context exclusion rules */
export type DuoContextExclusionSettings = {
  __typename?: 'DuoContextExclusionSettings';
  /** List of rules for excluding files from Duo context. */
  exclusionRules?: Maybe<Array<Scalars['String']['output']>>;
};

/** Input for Duo context exclusion settings */
export type DuoContextExclusionSettingsInput = {
  /** List of rules for excluding files from Duo context. */
  exclusionRules: Array<Scalars['String']['input']>;
};

/** A message in a Duo Workflow chat log */
export type DuoMessage = {
  __typename?: 'DuoMessage';
  /** Content of the message. */
  content: Scalars['String']['output'];
  /** Correlation ID of the message. */
  correlationId?: Maybe<Scalars['String']['output']>;
  /** Type of the message. */
  messageType: Scalars['String']['output'];
  /** Role of the message. */
  role?: Maybe<Scalars['String']['output']>;
  /** Status of the message. */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the message. */
  timestamp?: Maybe<Scalars['String']['output']>;
  /** Tool information for the message. */
  toolInfo?: Maybe<Scalars['String']['output']>;
};

/** GitLab Duo settings */
export type DuoSettings = {
  __typename?: 'DuoSettings';
  /** Timeout in seconds for requests to the AI gateway server. */
  aiGatewayTimeoutSeconds?: Maybe<Scalars['Int']['output']>;
  /**
   * URL for local AI gateway server. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  aiGatewayUrl?: Maybe<Scalars['String']['output']>;
  /**
   * URL for local Duo Agent Platform service. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  duoAgentPlatformServiceUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates whether GitLab Duo Core features are enabled. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  duoCoreFeaturesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Minimum access level required to enable Duo Agent Platform. Returns `null` if `dap_instance_customizable_permissions` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  minimumAccessLevelEnableOnProjects?: Maybe<AccessLevelEnum>;
  /**
   * Minimum access level required to execute Duo Agent Platform. Returns `null` if `dap_instance_customizable_permissions` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  minimumAccessLevelExecute?: Maybe<AccessLevelEnum>;
  /**
   * Minimum access level required to execute Duo Agent Platform features in CI/CD. Returns `null` if `dap_instance_customizable_permissions` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  minimumAccessLevelExecuteAsync?: Maybe<AccessLevelEnum>;
  /**
   * Minimum access level required to manage Duo Agent Platform. Returns `null` if `dap_instance_customizable_permissions` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  minimumAccessLevelManage?: Maybe<AccessLevelEnum>;
  /**
   * Timestamp of last GitLab Duo setting update. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  updatedAt: Scalars['Time']['output'];
};

/** Autogenerated input type of DuoSettingsUpdate */
export type DuoSettingsUpdateInput = {
  /** Timeout for AI gateway request. */
  aiGatewayTimeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  /** URL for local AI gateway server. */
  aiGatewayUrl?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** URL for the local Duo Agent Platform service. */
  duoAgentPlatformServiceUrl?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether GitLab Duo Core features are enabled. */
  duoCoreFeaturesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of DuoSettingsUpdate. */
export type DuoSettingsUpdatePayload = {
  __typename?: 'DuoSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** GitLab Duo settings after mutation. */
  duoSettings: DuoSettings;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of DuoUserFeedback */
export type DuoUserFeedbackInput = {
  /** Global ID of the agent to answer the chat. */
  agentVersionId?: InputMaybe<Scalars['AiAgentVersionID']['input']>;
  /** ID of the AI Message. */
  aiMessageId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Tracking event data. */
  trackingEvent?: InputMaybe<TrackingEventInput>;
};

/** Autogenerated return type of DuoUserFeedback. */
export type DuoUserFeedbackPayload = {
  __typename?: 'DuoUserFeedbackPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** GitLab Duo Agent Platform session */
export type DuoWorkflow = {
  __typename?: 'DuoWorkflow';
  /** Privileges granted to the agent during execution. */
  agentPrivilegesNames?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * ID of the AI catalog item version that triggered the workflow. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  aiCatalogItemVersionId?: Maybe<Scalars['AiCatalogItemVersionID']['output']>;
  /** Allow the agent to request user input. */
  allowAgentToRequestUser?: Maybe<Scalars['Boolean']['output']>;
  /** Archived due to retention policy. */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the session was created. */
  createdAt: Scalars['Time']['output'];
  /** Environment, like IDE or web. */
  environment?: Maybe<WorkflowEnvironment>;
  /** First checkpoint of the session. */
  firstCheckpoint?: Maybe<DuoWorkflowEvent>;
  /** Goal of the session. */
  goal?: Maybe<Scalars['String']['output']>;
  /** Human-readable status of the session. */
  humanStatus: Scalars['String']['output'];
  /** ID of the session. */
  id: Scalars['ID']['output'];
  /** URL to the latest executor logs of the workflow. */
  lastExecutorLogsUrl?: Maybe<Scalars['String']['output']>;
  /** Latest checkpoint of the session. */
  latestCheckpoint?: Maybe<DuoWorkflowEvent>;
  /** Has MCP been enabled for the namespace. */
  mcpEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** namespace that the session is in. */
  namespace?: Maybe<Namespace>;
  /** ID of the namespace. */
  namespaceId?: Maybe<Scalars['TypesNamespaceID']['output']>;
  /** Privileges pre-approved for the agent during execution. */
  preApprovedAgentPrivilegesNames?: Maybe<Array<Scalars['String']['output']>>;
  /** Project that the session is in. */
  project?: Maybe<Project>;
  /** ID of the project. */
  projectId?: Maybe<Scalars['ProjectID']['output']>;
  /** Workflow got created but has no checkpoints. */
  stalled?: Maybe<Scalars['Boolean']['output']>;
  /** Status of the session. */
  status?: Maybe<DuoWorkflowStatus>;
  /** Status group of the flow session. */
  statusGroup?: Maybe<DuoWorkflowStatusGroup>;
  /** Status name of the session. */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the session was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** ID of the user. */
  userId: Scalars['UserID']['output'];
  /** Permissions of the current user for the workflow. */
  userPermissions?: Maybe<DuoWorkflowPermissions>;
  /** GitLab Duo Agent Platform flow type based on its capabilities. */
  workflowDefinition?: Maybe<Scalars['String']['output']>;
};

/** The connection type for DuoWorkflow. */
export type DuoWorkflowConnection = {
  __typename?: 'DuoWorkflowConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DuoWorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DuoWorkflow>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DuoWorkflowEdge = {
  __typename?: 'DuoWorkflowEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DuoWorkflow>;
};

/** Duo Agent Platform enablement status checks. */
export type DuoWorkflowEnablement = {
  __typename?: 'DuoWorkflowEnablement';
  /** Enablement checks. */
  checks?: Maybe<Array<DuoWorkflowEnablementCheck>>;
  /** Indicates whether Duo Agent Platform is enabled for current user and the project. */
  enabled: Scalars['Boolean']['output'];
  /** Indicates if Duo Agent Platform foundational flows are enabled for the project. */
  foundationalFlowsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if Duo Agent Platform remote flows are enabled for the project. */
  remoteFlowsEnabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents single Duo Agent Platform enablement check. */
export type DuoWorkflowEnablementCheck = {
  __typename?: 'DuoWorkflowEnablementCheck';
  /** Description of status check. */
  message?: Maybe<Scalars['String']['output']>;
  /** Name of the status check. */
  name: Scalars['String']['output'];
  /** Whether the check was successful or not. */
  value: Scalars['Boolean']['output'];
};

/** Events that describe the history and progress of a GitLab Duo Agent Platform session */
export type DuoWorkflowEvent = {
  __typename?: 'DuoWorkflowEvent';
  /**
   * Checkpoint of the event. Deprecated in GitLab 18.7: Checkpoints are big & contain internal langgraph details.
   * @deprecated Checkpoints are big & contain internal langgraph details. Deprecated in GitLab 18.7.
   */
  checkpoint?: Maybe<Scalars['JsonString']['output']>;
  /** Messages from the ui_chat_log for the checkpoint. */
  duoMessages?: Maybe<Array<DuoMessage>>;
  /** Message errors. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Granular status of the session's execution. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  executionStatus: Scalars['String']['output'];
  /** Metadata associated with the event. */
  metadata?: Maybe<Scalars['JsonString']['output']>;
  /**
   * UUID v7 timestamp identifier of the parent message for branched conversations or responses. Deprecated in GitLab 18.6: Use `parentTs` instead.
   * @deprecated Use `parentTs` instead. Deprecated in GitLab 18.6.
   */
  parentTimestamp?: Maybe<Scalars['String']['output']>;
  /** UUID v7 timestamp identifier of the parent message for branched conversations or responses. */
  parentTs?: Maybe<Scalars['String']['output']>;
  /** UUID v7 timestamp identifier for the conversation thread/session in LangGraph state management. */
  threadTs?: Maybe<Scalars['String']['output']>;
  /**
   * UUID v7 timestamp identifier for the conversation thread in LangGraph state management. Deprecated in GitLab 18.6: Use `threadTs` instead.
   * @deprecated Use `threadTs` instead. Deprecated in GitLab 18.6.
   */
  timestamp?: Maybe<Scalars['String']['output']>;
  /** GitLab Duo Agent Platform flow type based on its capabilities. */
  workflowDefinition?: Maybe<Scalars['String']['output']>;
  /** Goal of the session. */
  workflowGoal?: Maybe<Scalars['String']['output']>;
  /** Status of the session. */
  workflowStatus?: Maybe<DuoWorkflowStatus>;
};

/** The connection type for DuoWorkflowEvent. */
export type DuoWorkflowEventConnection = {
  __typename?: 'DuoWorkflowEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DuoWorkflowEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DuoWorkflowEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DuoWorkflowEventEdge = {
  __typename?: 'DuoWorkflowEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DuoWorkflowEvent>;
};

/** Check permissions for the current user on a Duo workflow. */
export type DuoWorkflowPermissions = {
  __typename?: 'DuoWorkflowPermissions';
  /** If `true`, the user can perform `delete_duo_workflow` on this resource */
  deleteDuoWorkflow: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_duo_workflow` on this resource */
  readDuoWorkflow: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_duo_workflow` on this resource */
  updateDuoWorkflow: Scalars['Boolean']['output'];
};

/** The status of the workflow. */
export type DuoWorkflowStatus =
  /** The workflow is created. */
  | 'CREATED'
  /** The workflow is failed. */
  | 'FAILED'
  /** The workflow is finished. */
  | 'FINISHED'
  /** The workflow is input_required. */
  | 'INPUT_REQUIRED'
  /** The workflow is paused. */
  | 'PAUSED'
  /** The workflow is plan_approval_required. */
  | 'PLAN_APPROVAL_REQUIRED'
  /** The workflow is running. */
  | 'RUNNING'
  /** The workflow is stopped. */
  | 'STOPPED'
  /** The workflow is tool_call_approval_required. */
  | 'TOOL_CALL_APPROVAL_REQUIRED';

/** The status group of the flow session. */
export type DuoWorkflowStatusGroup =
  /** Flow sessions with a status group of active. */
  | 'ACTIVE'
  /** Flow sessions with a status group of awaiting_input. */
  | 'AWAITING_INPUT'
  /** Flow sessions with a status group of canceled. */
  | 'CANCELED'
  /** Flow sessions with a status group of completed. */
  | 'COMPLETED'
  /** Flow sessions with a status group of failed. */
  | 'FAILED'
  /** Flow sessions with a status group of paused. */
  | 'PAUSED';

/** Values for sorting Duo Workflows. */
export type DuoWorkflowsWorkflowSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** By status ascending order. */
  | 'STATUS_ASC'
  /** By status descending order. */
  | 'STATUS_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Autogenerated input type of EchoCreate */
export type EchoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Errors to return to the user. */
  errors?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Messages to return to the user. */
  messages?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of EchoCreate. */
export type EchoCreatePayload = {
  __typename?: 'EchoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Messages returned to the user. */
  echoes?: Maybe<Array<Scalars['String']['output']>>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type EgressNode = {
  __typename?: 'EgressNode';
  /** Artifacts egress for that project in that period of time. */
  artifactsEgress: Scalars['BigInt']['output'];
  /** First day of the node range. There is one node per month. */
  date: Scalars['String']['output'];
  /** Packages egress for that project in that period of time. */
  packagesEgress: Scalars['BigInt']['output'];
  /** Registry egress for that project in that period of time. */
  registryEgress: Scalars['BigInt']['output'];
  /** Repository egress for that project in that period of time. */
  repositoryEgress: Scalars['BigInt']['output'];
  /** Total egress for that project in that period of time. */
  totalEgress: Scalars['BigInt']['output'];
};

/** The connection type for EgressNode. */
export type EgressNodeConnection = {
  __typename?: 'EgressNodeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EgressNodeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EgressNode>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EgressNodeEdge = {
  __typename?: 'EgressNodeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EgressNode>;
};

export type Email = {
  __typename?: 'Email';
  /** Timestamp the email was confirmed. */
  confirmedAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp the email was created. */
  createdAt: Scalars['Time']['output'];
  /** Email address. */
  email: Scalars['String']['output'];
  /** Internal ID of the email. */
  id: Scalars['ID']['output'];
  /** Timestamp the email was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for Email. */
export type EmailConnection = {
  __typename?: 'EmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Email>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EmailEdge = {
  __typename?: 'EmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Email>;
};

export type EmailParticipantType = {
  __typename?: 'EmailParticipantType';
  /** Email address of the email participant. For guests, the email address is obfuscated. */
  email: Scalars['String']['output'];
};

/** The connection type for EmailParticipantType. */
export type EmailParticipantTypeConnection = {
  __typename?: 'EmailParticipantTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EmailParticipantTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EmailParticipantType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EmailParticipantTypeEdge = {
  __typename?: 'EmailParticipantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EmailParticipantType>;
};

/** Autogenerated input type of EnableDevopsAdoptionNamespace */
export type EnableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  /** Namespace ID. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of EnableDevopsAdoptionNamespace. */
export type EnableDevopsAdoptionNamespacePayload = {
  __typename?: 'EnableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Enabled namespace after mutation. */
  enabledNamespace?: Maybe<DevopsAdoptionEnabledNamespace>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Types of scans enabled on a merge request */
export type EnabledSecurityScans = {
  __typename?: 'EnabledSecurityScans';
  /** `true` if there is a Api fuzzing scan in the pipeline */
  apiFuzzing: Scalars['Boolean']['output'];
  /** `true` if there is a Cluster image scanning scan in the pipeline */
  clusterImageScanning: Scalars['Boolean']['output'];
  /** `true` if there is a Container scanning scan in the pipeline */
  containerScanning: Scalars['Boolean']['output'];
  /** `true` if there is a Coverage fuzzing scan in the pipeline */
  coverageFuzzing: Scalars['Boolean']['output'];
  /** `true` if there is a Dast scan in the pipeline */
  dast: Scalars['Boolean']['output'];
  /** `true` if there is a Dependency scanning scan in the pipeline */
  dependencyScanning: Scalars['Boolean']['output'];
  /** Returns `true` when report processing has been completed. */
  ready: Scalars['Boolean']['output'];
  /** `true` if there is a Sast scan in the pipeline */
  sast: Scalars['Boolean']['output'];
  /** `true` if there is a Secret detection scan in the pipeline */
  secretDetection: Scalars['Boolean']['output'];
};

export type Entry = {
  /** Flat path of the entry. */
  flatPath: Scalars['String']['output'];
  /** ID of the entry. */
  id: Scalars['ID']['output'];
  /** Name of the entry. */
  name: Scalars['String']['output'];
  /** Path of the entry. */
  path: Scalars['String']['output'];
  /** SHA of the entry. */
  sha: Scalars['String']['output'];
  /** Type of tree entry. */
  type: EntryType;
};

/** Type of a tree entry */
export type EntryType =
  /** File tree type. */
  | 'blob'
  /** Commit tree type. */
  | 'commit'
  /** Directory tree type. */
  | 'tree';

/** Describes where code is deployed for a project */
export type Environment = {
  __typename?: 'Environment';
  /** When the environment is going to be deleted automatically. */
  autoDeleteAt?: Maybe<Scalars['Time']['output']>;
  /** When the environment is going to be stopped automatically. */
  autoStopAt?: Maybe<Scalars['Time']['output']>;
  /** Auto stop setting of the environment. */
  autoStopSetting?: Maybe<AutoStopSetting>;
  /** Cluster agent of the environment. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** When the environment was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Deployment freeze periods of the environment. */
  deployFreezes?: Maybe<Array<CiFreezePeriod>>;
  /** Deployments of the environment. This field can only be resolved for one environment in any single request. */
  deployments?: Maybe<DeploymentConnection>;
  /** Number of deployments in the environment for display. Returns the precise number up to 999, and "999+" for counts exceeding this limit. */
  deploymentsDisplayCount?: Maybe<Scalars['String']['output']>;
  /** Description of the environment. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Folder name of the environment. */
  environmentType?: Maybe<Scalars['String']['output']>;
  /** External URL of the environment. */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** Flux resource path of the environment. */
  fluxResourcePath?: Maybe<Scalars['String']['output']>;
  /** ID of the environment. */
  id: Scalars['ID']['output'];
  /** Kubernetes namespace of the environment. */
  kubernetesNamespace?: Maybe<Scalars['String']['output']>;
  /** Last deployment of the environment. */
  lastDeployment?: Maybe<Deployment>;
  /** Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned. */
  latestOpenedMostSevereAlert?: Maybe<AlertManagementAlert>;
  /** Human-readable name of the environment. */
  name: Scalars['String']['output'];
  /** Path to the environment. */
  path: Scalars['String']['output'];
  /** Protected Environments for the environment. */
  protectedEnvironments?: Maybe<ProtectedEnvironmentConnection>;
  /** Slug of the environment. */
  slug?: Maybe<Scalars['String']['output']>;
  /** State of the environment, for example: available/stopped. */
  state: Scalars['String']['output'];
  /** Deployment tier of the environment. */
  tier?: Maybe<DeploymentTier>;
  /** When the environment was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Permissions for the current user on the resource. This field can only be resolved for one environment in any single request. */
  userPermissions: EnvironmentPermissions;
};


/** Describes where code is deployed for a project */
export type EnvironmentDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DeploymentsOrderByInput>;
  statuses?: InputMaybe<Array<DeploymentStatus>>;
};


/** Describes where code is deployed for a project */
export type EnvironmentLastDeploymentArgs = {
  status: DeploymentStatus;
};


/** Describes where code is deployed for a project */
export type EnvironmentProtectedEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Environment. */
export type EnvironmentConnection = {
  __typename?: 'EnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EnvironmentCreate */
export type EnvironmentCreateInput = {
  /** Auto stop setting of the environment. */
  autoStopSetting?: InputMaybe<AutoStopSetting>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Cluster agent of the environment. */
  clusterAgentId?: InputMaybe<Scalars['ClustersAgentID']['input']>;
  /** Description of the environment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** External URL of the environment. */
  externalUrl?: InputMaybe<Scalars['String']['input']>;
  /** Flux resource path of the environment. */
  fluxResourcePath?: InputMaybe<Scalars['String']['input']>;
  /** Kubernetes namespace of the environment. */
  kubernetesNamespace?: InputMaybe<Scalars['String']['input']>;
  /** Name of the environment. */
  name: Scalars['String']['input'];
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
  /** Tier of the environment. */
  tier?: InputMaybe<DeploymentTier>;
};

/** Autogenerated return type of EnvironmentCreate. */
export type EnvironmentCreatePayload = {
  __typename?: 'EnvironmentCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created environment. */
  environment?: Maybe<Environment>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of EnvironmentDelete */
export type EnvironmentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the environment to Delete. */
  id: Scalars['EnvironmentID']['input'];
};

/** Autogenerated return type of EnvironmentDelete. */
export type EnvironmentDeletePayload = {
  __typename?: 'EnvironmentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type EnvironmentEdge = {
  __typename?: 'EnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Environment>;
};

export type EnvironmentPermissions = {
  __typename?: 'EnvironmentPermissions';
  /** If `true`, the user can perform `destroy_environment` on this resource */
  destroyEnvironment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `stop_environment` on this resource */
  stopEnvironment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_environment` on this resource */
  updateEnvironment: Scalars['Boolean']['output'];
};

/** Autogenerated input type of EnvironmentStop */
export type EnvironmentStopInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Force environment to stop without executing on_stop actions. */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the environment to stop. */
  id: Scalars['EnvironmentID']['input'];
};

/** Autogenerated return type of EnvironmentStop. */
export type EnvironmentStopPayload = {
  __typename?: 'EnvironmentStopPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Environment after attempt to stop. */
  environment?: Maybe<Environment>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of EnvironmentUpdate */
export type EnvironmentUpdateInput = {
  /** Auto stop setting of the environment. */
  autoStopSetting?: InputMaybe<AutoStopSetting>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Cluster agent of the environment. */
  clusterAgentId?: InputMaybe<Scalars['ClustersAgentID']['input']>;
  /** Description of the environment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** External URL of the environment. */
  externalUrl?: InputMaybe<Scalars['String']['input']>;
  /** Flux resource path of the environment. */
  fluxResourcePath?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the environment to update. */
  id: Scalars['EnvironmentID']['input'];
  /** Kubernetes namespace of the environment. */
  kubernetesNamespace?: InputMaybe<Scalars['String']['input']>;
  /** Tier of the environment. */
  tier?: InputMaybe<DeploymentTier>;
};

/** Autogenerated return type of EnvironmentUpdate. */
export type EnvironmentUpdatePayload = {
  __typename?: 'EnvironmentUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Environment after attempt to update. */
  environment?: Maybe<Environment>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of EnvironmentsCanaryIngressUpdate */
export type EnvironmentsCanaryIngressUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the environment to update. */
  id: Scalars['EnvironmentID']['input'];
  /** Weight of the Canary Ingress. */
  weight: Scalars['Int']['input'];
};

/** Autogenerated return type of EnvironmentsCanaryIngressUpdate. */
export type EnvironmentsCanaryIngressUpdatePayload = {
  __typename?: 'EnvironmentsCanaryIngressUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents an epic */
export type Epic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'Epic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of emoji reactions associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']['output']>;
  /** Count of epics blocking the epic. */
  blockedByCount?: Maybe<Scalars['Int']['output']>;
  /** Epics blocking the epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that the epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']['output']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** Color of the epic. */
  color?: Maybe<Scalars['String']['output']>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int']['output'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']['output']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']['output']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']['output']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean']['output'];
  /** Indicates if the epic has children in the specified timeframe. */
  hasChildrenWithinTimeframe: Scalars['Boolean']['output'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean']['output'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean']['output'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID']['output'];
  /** Internal ID of the epic. */
  iid: Scalars['String']['output'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** Work items linked to the epic. */
  linkedWorkItems?: Maybe<LinkedWorkItemTypeConnection>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']['output']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']['output']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']['output']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']['output']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']['output']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean']['output'];
  /** Text color generated for the epic. */
  textColor?: Maybe<Scalars['String']['output']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int']['output'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int']['output'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** Web path of the epic. */
  webPath: Scalars['String']['output'];
  /** Web URL of the epic. */
  webUrl: Scalars['String']['output'];
  /** ID of the corresponding work item for a legacy epic. */
  workItemId: Scalars['WorkItemID']['output'];
};


/** Represents an epic */
export type EpicAncestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Represents an epic */
export type EpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Represents an epic */
export type EpicCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic */
export type EpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicLinkedWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WorkItemRelatedLinkType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic */
export type EpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of EpicAddIssue */
export type EpicAddIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID']['input'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID']['input'];
  /** IID of the issue to be added. */
  issueIid: Scalars['String']['input'];
  /** Full path of the project the issue belongs to. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of EpicAddIssue. */
export type EpicAddIssuePayload = {
  __typename?: 'EpicAddIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Epic-issue relationship. */
  epicIssue?: Maybe<EpicIssue>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents an epic board */
export type EpicBoard = {
  __typename?: 'EpicBoard';
  /** Whether or not display epic colors. */
  displayColors?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the epic board. */
  id: Scalars['BoardsEpicBoardID']['output'];
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Epic board lists. */
  lists?: Maybe<EpicListConnection>;
  /** Name of the epic board. */
  name?: Maybe<Scalars['String']['output']>;
  /** Web path of the epic board. */
  webPath: Scalars['String']['output'];
  /** Web URL of the epic board. */
  webUrl: Scalars['String']['output'];
};


/** Represents an epic board */
export type EpicBoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an epic board */
export type EpicBoardListsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  epicFilters?: InputMaybe<EpicFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['BoardsEpicListID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for EpicBoard. */
export type EpicBoardConnection = {
  __typename?: 'EpicBoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicBoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicBoard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EpicBoardCreate */
export type EpicBoardCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not display epic colors. */
  displayColors?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']['input']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of EpicBoardCreate. */
export type EpicBoardCreatePayload = {
  __typename?: 'EpicBoardCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Created epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type EpicBoardEdge = {
  __typename?: 'EpicBoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicBoard>;
};

/** Autogenerated input type of EpicBoardListCreate */
export type EpicBoardListCreateInput = {
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardsEpicBoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']['input']>;
};

/** Autogenerated return type of EpicBoardListCreate. */
export type EpicBoardListCreatePayload = {
  __typename?: 'EpicBoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Epic list in the epic board. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardListDestroy */
export type EpicBoardListDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the epic board list to destroy. */
  listId: Scalars['BoardsEpicListID']['input'];
};

/** Autogenerated return type of EpicBoardListDestroy. */
export type EpicBoardListDestroyPayload = {
  __typename?: 'EpicBoardListDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Epic board list. `null` if the board was destroyed successfully. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardUpdate */
export type EpicBoardUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not display epic colors. */
  displayColors?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Epic board global ID. */
  id: Scalars['BoardsEpicBoardID']['input'];
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of EpicBoardUpdate. */
export type EpicBoardUpdatePayload = {
  __typename?: 'EpicBoardUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** The connection type for Epic. */
export type EpicConnection = {
  __typename?: 'EpicConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Epic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Epic. */
export type EpicConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Counts of descendent epics */
export type EpicDescendantCount = {
  __typename?: 'EpicDescendantCount';
  /** Number of closed child epics. */
  closedEpics?: Maybe<Scalars['Int']['output']>;
  /** Number of closed epic issues. */
  closedIssues?: Maybe<Scalars['Int']['output']>;
  /** Number of opened child epics. */
  openedEpics?: Maybe<Scalars['Int']['output']>;
  /** Number of opened epic issues. */
  openedIssues?: Maybe<Scalars['Int']['output']>;
};

/** Total weight of open and closed descendant issues */
export type EpicDescendantWeights = {
  __typename?: 'EpicDescendantWeights';
  /**
   * Total weight of completed (closed) issues in the epic, including epic descendants. Deprecated in GitLab 16.6: Use `closedIssuesTotal`.
   * @deprecated Use `closedIssuesTotal`. Deprecated in GitLab 16.6.
   */
  closedIssues?: Maybe<Scalars['Int']['output']>;
  /**
   * Total weight of completed (closed) issues in this epic, including epic descendants,
   *     encoded as a string.
   */
  closedIssuesTotal?: Maybe<Scalars['BigInt']['output']>;
  /**
   * Total weight of opened issues in the epic, including epic descendants. Deprecated in GitLab 16.6: Use `OpenedIssuesTotal`.
   * @deprecated Use `OpenedIssuesTotal`. Deprecated in GitLab 16.6.
   */
  openedIssues?: Maybe<Scalars['Int']['output']>;
  /** Total weight of opened issues in the epic, including epic descendants, encoded as a string. */
  openedIssuesTotal?: Maybe<Scalars['BigInt']['output']>;
};

/** An edge in a connection. */
export type EpicEdge = {
  __typename?: 'EpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Epic>;
};

export type EpicFilters = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Negated epic arguments. */
  not?: InputMaybe<NegatedEpicBoardIssueInput>;
  /** List of arguments with inclusive OR. */
  or?: InputMaybe<UnionedEpicFilterInput>;
  /** Search query for epic title or description. */
  search?: InputMaybe<Scalars['String']['input']>;
};

/** Health status of child issues */
export type EpicHealthStatus = {
  __typename?: 'EpicHealthStatus';
  /** Number of issues at risk. */
  issuesAtRisk?: Maybe<Scalars['Int']['output']>;
  /** Number of issues that need attention. */
  issuesNeedingAttention?: Maybe<Scalars['Int']['output']>;
  /** Number of issues on track. */
  issuesOnTrack?: Maybe<Scalars['Int']['output']>;
};

/** Relationship between an epic and an issue */
export type EpicIssue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'EpicIssue';
  /**
   * Alert associated to the issue. Deprecated in GitLab 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in GitLab 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean']['output'];
  /** Count of issues blocking the issue. */
  blockedByCount?: Maybe<Scalars['Int']['output']>;
  /** Issues blocking the issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues the issue is blocking. */
  blockingCount: Scalars['Int']['output'];
  /** Issue the issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean']['output'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time']['output'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Collection of design images associated with the issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int']['output'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled. Deprecated in GitLab 16.3: Use `emails_enabled`.
   * @deprecated Use `emails_enabled`. Deprecated in GitLab 16.3.
   */
  emailsDisabled: Scalars['Boolean']['output'];
  /** Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled. */
  emailsEnabled: Scalars['Boolean']['output'];
  /**
   * Epic to which the issue belongs. Deprecated in GitLab 17.5: Replaced by WorkItem type.
   * @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5.
   */
  epic?: Maybe<Epic>;
  /** ID of the epic-issue relation. */
  epicIssueId: Scalars['ID']['output'];
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /** Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated. */
  externalAuthor?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean']['output'];
  /**
   * Indicates if the issue has a parent work item. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  hasParent: Scalars['Boolean']['output'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /** Indicates the issue is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']['output']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']['output']>;
  /** Global ID of the epic-issue relation. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Internal ID of the issue. */
  iid: Scalars['String']['output'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /**
   * Work items linked to the issue. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  linkedWorkItems?: Maybe<LinkedWorkItemTypeConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int']['output'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']['output']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId?: Maybe<Scalars['Int']['output']>;
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /** Merge requests related to the issue. This field can only be resolved for one issue in any single request. */
  relatedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Related vulnerabilities of the issue. */
  relatedVulnerabilities?: Maybe<VulnerabilityConnection>;
  /** URI path of the epic-issue relation. */
  relationPath?: Maybe<Scalars['String']['output']>;
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']['output']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']['output']>;
  /** State of the issue. */
  state: IssueState;
  /**
   * Status of the issue. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  status?: Maybe<WorkItemStatus>;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean']['output'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int']['output'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Total time (in seconds) reported as spent on the issue. */
  totalTimeSpent: Scalars['Int']['output'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int']['output'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int']['output'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String']['output'];
  /** Web URL of the issue. */
  webUrl: Scalars['String']['output'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']['output']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueIssuableResourceLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  incidentId: Scalars['IssueID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueLinkedWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WorkItemRelatedLinkType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueRelatedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueRelatedVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for EpicIssue. */
export type EpicIssueConnection = {
  __typename?: 'EpicIssueConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int']['output'];
};


/** The connection type for EpicIssue. */
export type EpicIssueConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type EpicIssueEdge = {
  __typename?: 'EpicIssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicIssue>;
};

/** Represents an epic board list */
export type EpicList = {
  __typename?: 'EpicList';
  /** Indicates if the list is collapsed for the user. */
  collapsed?: Maybe<Scalars['Boolean']['output']>;
  /** List epics. */
  epics?: Maybe<EpicConnection>;
  /** Global ID of the board list. */
  id: Scalars['BoardsEpicListID']['output'];
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Type of the list. */
  listType: Scalars['String']['output'];
  /** Epic list metatada. */
  metadata?: Maybe<EpicListMetadata>;
  /** Position of the list within the board. */
  position?: Maybe<Scalars['Int']['output']>;
  /** Title of the list. */
  title: Scalars['String']['output'];
};


/** Represents an epic board list */
export type EpicListEpicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<EpicFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for EpicList. */
export type EpicListConnection = {
  __typename?: 'EpicListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EpicListEdge = {
  __typename?: 'EpicListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicList>;
};

/** Represents epic board list metadata */
export type EpicListMetadata = {
  __typename?: 'EpicListMetadata';
  /** Count of epics in the list. */
  epicsCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Total weight of all issues in the list. Introduced in GitLab 14.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 14.7.
   */
  totalWeight?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of EpicMoveList */
export type EpicMoveListInput = {
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the epic to mutate. */
  epicId: Scalars['EpicID']['input'];
  /** ID of the board list that the epic will be moved from. Required if moving between lists. */
  fromListId?: InputMaybe<Scalars['BoardsEpicListID']['input']>;
  /** ID of epic that should be placed after the current epic. */
  moveAfterId?: InputMaybe<Scalars['EpicID']['input']>;
  /** ID of epic that should be placed before the current epic. */
  moveBeforeId?: InputMaybe<Scalars['EpicID']['input']>;
  /** Position of epics within the board list. Positions start at 0. Use -1 to move to the end of the list. */
  positionInList?: InputMaybe<Scalars['Int']['input']>;
  /** ID of the list the epic will be in after mutation. */
  toListId: Scalars['BoardsEpicListID']['input'];
};

/** Autogenerated return type of EpicMoveList. */
export type EpicMoveListPayload = {
  __typename?: 'EpicMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Check permissions for the current user on an epic */
export type EpicPermissions = {
  __typename?: 'EpicPermissions';
  /** If `true`, the user can perform `admin_epic` on this resource */
  adminEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_epic_relation` on this resource */
  adminEpicRelation: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_epic` on this resource */
  createEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_epic` on this resource */
  destroyEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_epic` on this resource */
  readEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_epic_iid` on this resource */
  readEpicIid: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_epic` on this resource */
  updateEpic: Scalars['Boolean']['output'];
};

/** Autogenerated input type of EpicSetSubscription */
export type EpicSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID']['input'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID']['input'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean']['input'];
};

/** Autogenerated return type of EpicSetSubscription. */
export type EpicSetSubscriptionPayload = {
  __typename?: 'EpicSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Roadmap sort values */
export type EpicSort =
  /** Sort by created_at by ascending order. */
  | 'CREATED_AT_ASC'
  /** Sort by created_at by descending order. */
  | 'CREATED_AT_DESC'
  /** Sort by end date in ascending order. */
  | 'END_DATE_ASC'
  /** Sort by end date in descending order. */
  | 'END_DATE_DESC'
  /** Sort by start date in ascending order. */
  | 'START_DATE_ASC'
  /** Sort by start date in descending order. */
  | 'START_DATE_DESC'
  /** Sort by title in ascending order. */
  | 'TITLE_ASC'
  /** Sort by title in descending order. */
  | 'TITLE_DESC'
  /** Sort by updated_at by ascending order. */
  | 'UPDATED_AT_ASC'
  /** Sort by updated_at by descending order. */
  | 'UPDATED_AT_DESC'
  /** End date at ascending order. Deprecated in GitLab 13.11: Use END_DATE_ASC. */
  | 'end_date_asc'
  /** End date at descending order. Deprecated in GitLab 13.11: Use END_DATE_DESC. */
  | 'end_date_desc'
  /** Start date at ascending order. Deprecated in GitLab 13.11: Use START_DATE_ASC. */
  | 'start_date_asc'
  /** Start date at descending order. Deprecated in GitLab 13.11: Use START_DATE_DESC. */
  | 'start_date_desc';

/** State of an epic */
export type EpicState =
  /** All epics. */
  | 'all'
  /** Closed epics. */
  | 'closed'
  /** Open epics. */
  | 'opened';

/** State event of an epic */
export type EpicStateEvent =
  /** Close the epic. */
  | 'CLOSE'
  /** Reopen the epic. */
  | 'REOPEN';

/** A node of an epic tree. */
export type EpicTreeNodeFieldsInputType = {
  /** ID of the epic issue or issue the epic or issue is switched with. */
  adjacentReferenceId?: InputMaybe<Scalars['EpicTreeSortingID']['input']>;
  /** ID of the epic issue or epic that is being moved. */
  id: Scalars['EpicTreeSortingID']['input'];
  /** ID of the new parent epic. */
  newParentId?: InputMaybe<Scalars['EpicID']['input']>;
  /** Type of switch. Valid values are `after` or `before`. */
  relativePosition?: InputMaybe<MoveType>;
};

/** Autogenerated input type of EpicTreeReorder */
export type EpicTreeReorderInput = {
  /** ID of the base epic of the tree. */
  baseEpicId: Scalars['EpicID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Parameters for updating the tree positions. */
  moved: EpicTreeNodeFieldsInputType;
};

/** Autogenerated return type of EpicTreeReorder. */
export type EpicTreeReorderPayload = {
  __typename?: 'EpicTreeReorderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Epic ID wildcard values */
export type EpicWildcardId =
  /** Any epic is assigned. */
  | 'ANY'
  /** No epic is assigned. */
  | 'NONE';

/** Represents a stack trace */
export type ErrorTrackingStackTrace = {
  __typename?: 'ErrorTrackingStackTrace';
  /** Absolute path of the stack trace. */
  absolutePath?: Maybe<Scalars['String']['output']>;
  /** Column number of the stack trace. */
  columnNumber?: Maybe<Scalars['Int']['output']>;
  /** Context of the stack trace. */
  context?: Maybe<Array<WorkItemWidgetErrorTrackingStackTraceContext>>;
  /** Filename of the stack trace. */
  filename?: Maybe<Scalars['String']['output']>;
  /** Name of the function where the error occured. */
  function?: Maybe<Scalars['String']['output']>;
  /** Line number of the stack trace. */
  lineNumber?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for ErrorTrackingStackTrace. */
export type ErrorTrackingStackTraceConnection = {
  __typename?: 'ErrorTrackingStackTraceConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ErrorTrackingStackTraceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ErrorTrackingStackTrace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ErrorTrackingStackTrace. */
export type ErrorTrackingStackTraceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ErrorTrackingStackTraceEdge = {
  __typename?: 'ErrorTrackingStackTraceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ErrorTrackingStackTrace>;
};

/** Status of the error tracking service */
export type ErrorTrackingStatus =
  /** Error tracking service respond with an error. */
  | 'ERROR'
  /** Sentry issue not found. */
  | 'NOT_FOUND'
  /** Error tracking service is not ready. */
  | 'RETRY'
  /** Successfuly fetch the stack trace. */
  | 'SUCCESS';

/** Autogenerated input type of EscalationPolicyCreate */
export type EscalationPolicyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the escalation policy. */
  name: Scalars['String']['input'];
  /** Project to create the escalation policy for. */
  projectPath: Scalars['ID']['input'];
  /** Steps of the escalation policy. */
  rules: Array<EscalationRuleInput>;
};

/** Autogenerated return type of EscalationPolicyCreate. */
export type EscalationPolicyCreatePayload = {
  __typename?: 'EscalationPolicyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyDestroy */
export type EscalationPolicyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Escalation policy internal ID to remove. */
  id: Scalars['IncidentManagementEscalationPolicyID']['input'];
};

/** Autogenerated return type of EscalationPolicyDestroy. */
export type EscalationPolicyDestroyPayload = {
  __typename?: 'EscalationPolicyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation policy */
export type EscalationPolicyType = {
  __typename?: 'EscalationPolicyType';
  /** Description of the escalation policy. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationPolicyID']['output']>;
  /** Name of the escalation policy. */
  name?: Maybe<Scalars['String']['output']>;
  /** Steps of the escalation policy. */
  rules?: Maybe<Array<EscalationRuleType>>;
};

/** The connection type for EscalationPolicyType. */
export type EscalationPolicyTypeConnection = {
  __typename?: 'EscalationPolicyTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EscalationPolicyTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EscalationPolicyType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EscalationPolicyTypeEdge = {
  __typename?: 'EscalationPolicyTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyUpdate */
export type EscalationPolicyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementEscalationPolicyID']['input'];
  /** Name of the escalation policy. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Steps of the escalation policy. */
  rules?: InputMaybe<Array<EscalationRuleInput>>;
};

/** Autogenerated return type of EscalationPolicyUpdate. */
export type EscalationPolicyUpdatePayload = {
  __typename?: 'EscalationPolicyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation rule */
export type EscalationRuleInput = {
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds: Scalars['Int']['input'];
  /** On-call schedule to notify. */
  oncallScheduleIid?: InputMaybe<Scalars['ID']['input']>;
  /** Status required to prevent the rule from activating. */
  status: EscalationRuleStatus;
  /** Username of the user to notify. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Escalation rule statuses */
export type EscalationRuleStatus =
  /** . */
  | 'ACKNOWLEDGED'
  /** . */
  | 'RESOLVED';

/** Represents an escalation rule for an escalation policy */
export type EscalationRuleType = {
  __typename?: 'EscalationRuleType';
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds?: Maybe<Scalars['Int']['output']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationRuleID']['output']>;
  /** On-call schedule to notify. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
  /** Status required to prevent the rule from activating. */
  status?: Maybe<EscalationRuleStatus>;
  /** User to notify. */
  user?: Maybe<UserCore>;
};

/** Representing an event */
export type Event = {
  __typename?: 'Event';
  /** Action of the event. */
  action: EventAction;
  /** Author of the event. */
  author: UserCore;
  /** When the event was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the event. */
  id: Scalars['ID']['output'];
  /** Project of the event. */
  project?: Maybe<Project>;
  /** Target of the event. */
  target?: Maybe<EventTargetType>;
  /** When the event was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Event action */
export type EventAction =
  /** Approved action */
  | 'APPROVED'
  /** Closed action */
  | 'CLOSED'
  /** Commented action */
  | 'COMMENTED'
  /** Created action */
  | 'CREATED'
  /** Destroyed action */
  | 'DESTROYED'
  /** Expired action */
  | 'EXPIRED'
  /** Joined action */
  | 'JOINED'
  /** Left action */
  | 'LEFT'
  /** Merged action */
  | 'MERGED'
  /** Pushed action */
  | 'PUSHED'
  /** Reopened action */
  | 'REOPENED'
  /** Updated action */
  | 'UPDATED';

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Event>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/** Represents an object that can be the subject of an event. */
export type EventTargetType = Design | Issue | MergeRequest | Milestone | Note | Project | Snippet | UserCore | WikiPage;

export type Eventable = {
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
};


export type EventableEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Enum for the security scanners used with exclusions */
export type ExclusionScannerEnum =
  /** Secret Push Protection. */
  | 'SECRET_PUSH_PROTECTION';

/** Enum for types of exclusion for a security scanner */
export type ExclusionTypeEnum =
  /** File or directory location. */
  | 'PATH'
  /** Raw value to ignore. */
  | 'RAW_VALUE'
  /** Regex pattern matching rules. */
  | 'REGEX_PATTERN'
  /** Scanner rule identifier. */
  | 'RULE';

/** Autogenerated input type of ExportRequirements */
export type ExportRequirementsInput = {
  /** Filter requirements by author username. */
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full project path the requirements are associated with. */
  projectPath: Scalars['ID']['input'];
  /** Search query for requirement title. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** List of selected requirements fields to be exported. */
  selectedFields?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List requirements by sort order. */
  sort?: InputMaybe<Sort>;
  /** Filter requirements by state. */
  state?: InputMaybe<RequirementState>;
};

/** Autogenerated return type of ExportRequirements. */
export type ExportRequirementsPayload = {
  __typename?: 'ExportRequirementsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Defines the common fields for all expressions. */
export type ExpressionInterface = {
  /** Field the expression applies to. */
  field: Scalars['String']['output'];
  /** Operator of the expression. */
  operator: Scalars['String']['output'];
};

/** Represents possible value types for an expression. */
export type ExpressionValue = BooleanExpression | IntegerExpression | StringExpression;

/** Values for status of the Web IDE Extension Marketplace opt-in for the user */
export type ExtensionsMarketplaceOptInStatus =
  /** Web IDE Extension Marketplace opt-in status: DISABLED. */
  | 'DISABLED'
  /** Web IDE Extension Marketplace opt-in status: ENABLED. */
  | 'ENABLED'
  /** Web IDE Extension Marketplace opt-in status: UNSET. */
  | 'UNSET';

/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestination = ExternalAuditEventDestinationInterface & {
  __typename?: 'ExternalAuditEventDestination';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** Group the destination belongs to. */
  group: Group;
  /** List of additional HTTP headers sent with each event. */
  headers: AuditEventStreamingHeaderConnection;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** List of subgroup or project filters for the destination. */
  namespaceFilter?: Maybe<AuditEventStreamingHttpNamespaceFilter>;
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String']['output'];
};


/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestinationHeadersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ExternalAuditEventDestination. */
export type ExternalAuditEventDestinationConnection = {
  __typename?: 'ExternalAuditEventDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalAuditEventDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalAuditEventDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ExternalAuditEventDestinationCreate */
export type ExternalAuditEventDestinationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination URL. */
  destinationUrl: Scalars['String']['input'];
  /** Group path. */
  groupPath: Scalars['ID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Verification token. */
  verificationToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ExternalAuditEventDestinationCreate. */
export type ExternalAuditEventDestinationCreatePayload = {
  __typename?: 'ExternalAuditEventDestinationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Destination created. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Autogenerated input type of ExternalAuditEventDestinationDestroy */
export type ExternalAuditEventDestinationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of external audit event destination to destroy. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
};

/** Autogenerated return type of ExternalAuditEventDestinationDestroy. */
export type ExternalAuditEventDestinationDestroyPayload = {
  __typename?: 'ExternalAuditEventDestinationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type ExternalAuditEventDestinationEdge = {
  __typename?: 'ExternalAuditEventDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalAuditEventDestination>;
};

export type ExternalAuditEventDestinationInterface = {
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String']['output'];
};

/** Autogenerated input type of ExternalAuditEventDestinationUpdate */
export type ExternalAuditEventDestinationUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination URL to change. */
  destinationUrl?: InputMaybe<Scalars['String']['input']>;
  /** ID of external audit event destination to update. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ExternalAuditEventDestinationUpdate. */
export type ExternalAuditEventDestinationUpdatePayload = {
  __typename?: 'ExternalAuditEventDestinationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated destination. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Represents an external issue */
export type ExternalIssue = {
  __typename?: 'ExternalIssue';
  /** Timestamp of when the issue was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Type of external tracker. */
  externalTracker?: Maybe<Scalars['String']['output']>;
  /** Relative reference of the issue in the external tracker. */
  relativeReference?: Maybe<Scalars['String']['output']>;
  /** Status of the issue in the external tracker. */
  status?: Maybe<Scalars['String']['output']>;
  /** Title of the issue in the external tracker. */
  title?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the issue was updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** URL to the issue in the external tracker. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Describes an external status check. */
export type ExternalStatusCheck = {
  __typename?: 'ExternalStatusCheck';
  /** External URL for the status check. */
  externalUrl: Scalars['String']['output'];
  /** Whether or not HMAC secret is enabled for the status check. */
  hmac: Scalars['Boolean']['output'];
  /** ID of the rule. */
  id: Scalars['GlobalID']['output'];
  /** Name of the rule. */
  name: Scalars['String']['output'];
};

/** The connection type for ExternalStatusCheck. */
export type ExternalStatusCheckConnection = {
  __typename?: 'ExternalStatusCheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalStatusCheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalStatusCheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ExternalStatusCheckEdge = {
  __typename?: 'ExternalStatusCheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalStatusCheck>;
};

export type FeatureFlag = {
  __typename?: 'FeatureFlag';
  /** Whether the feature flag is active. */
  active: Scalars['Boolean']['output'];
  /** Global ID of the feature flag. */
  id: Scalars['OperationsFeatureFlagID']['output'];
  /** Name of the feature flag. */
  name: Scalars['String']['output'];
  /** Path to feature flag. */
  path: Scalars['String']['output'];
  /** Reference to feature flag. */
  reference: Scalars['String']['output'];
};

/** The connection type for FeatureFlag. */
export type FeatureFlagConnection = {
  __typename?: 'FeatureFlagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FeatureFlagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<FeatureFlag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type FeatureFlagEdge = {
  __typename?: 'FeatureFlagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<FeatureFlag>;
};

export type FileUpload = {
  __typename?: 'FileUpload';
  /** Global ID of the upload. */
  id: Scalars['UploadID']['output'];
  /** Path of the upload. */
  path: Scalars['String']['output'];
  /** Size of the upload in bytes. */
  size: Scalars['Int']['output'];
};

/** Represents security reports comparison for vulnerability findings. */
export type FindingReportsComparer = {
  __typename?: 'FindingReportsComparer';
  /**
   * Compared security report. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  report?: Maybe<ComparedSecurityReport>;
  /** Comparison status. */
  status?: Maybe<FindingReportsComparerStatus>;
  /** Text explaining the status. */
  statusReason?: Maybe<Scalars['String']['output']>;
};

/** Report comparison status */
export type FindingReportsComparerStatus =
  /** An error happened while generating the report. */
  | 'ERROR'
  /** Report was generated. */
  | 'PARSED'
  /** Report is being generated. */
  | 'PARSING';

/** Details of the fork project compared to its upstream project. */
export type ForkDetails = {
  __typename?: 'ForkDetails';
  /** Number of commits ahead of upstream. */
  ahead?: Maybe<Scalars['Int']['output']>;
  /** Number of commits behind upstream. */
  behind?: Maybe<Scalars['Int']['output']>;
  /** Indicates if the fork conflicts with its upstream project. */
  hasConflicts?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if there is a synchronization in progress. */
  isSyncing?: Maybe<Scalars['Boolean']['output']>;
};

export type GeoNode = {
  __typename?: 'GeoNode';
  /** Find Ci Secure File registries on this Geo node */
  ciSecureFileRegistries?: Maybe<CiSecureFileRegistryConnection>;
  /** Maximum concurrency of container repository sync for the secondary node. */
  containerRepositoriesMaxCapacity?: Maybe<Scalars['Int']['output']>;
  /** Find Container Repository registries on this Geo node. */
  containerRepositoryRegistries?: Maybe<ContainerRepositoryRegistryConnection>;
  /**
   * Find Dependency Proxy Blob registries on this Geo node. Introduced in GitLab 15.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.6.
   */
  dependencyProxyBlobRegistries?: Maybe<DependencyProxyBlobRegistryConnection>;
  /** Find Dependency Proxy Manifest registries on this Geo node. */
  dependencyProxyManifestRegistries?: Maybe<DependencyProxyManifestRegistryConnection>;
  /**
   * Find Design Management Repository registries on this Geo node. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  designManagementRepositoryRegistries?: Maybe<DesignManagementRepositoryRegistryConnection>;
  /** Indicates whether the Geo node is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Maximum concurrency of LFS/attachment backfill for the secondary node. */
  filesMaxCapacity?: Maybe<Scalars['Int']['output']>;
  /** Find group wiki repository registries on this Geo node. */
  groupWikiRepositoryRegistries?: Maybe<GroupWikiRepositoryRegistryConnection>;
  /** ID of the GeoNode. */
  id: Scalars['ID']['output'];
  /** URL defined on the primary node secondary nodes should use to contact it. */
  internalUrl?: Maybe<Scalars['String']['output']>;
  /** Find Job Artifact registries on this Geo node. */
  jobArtifactRegistries?: Maybe<JobArtifactRegistryConnection>;
  /** Find LFS object registries on this Geo node. */
  lfsObjectRegistries?: Maybe<LfsObjectRegistryConnection>;
  /** Find merge request diff registries on this Geo node. */
  mergeRequestDiffRegistries?: Maybe<MergeRequestDiffRegistryConnection>;
  /** Interval (in days) in which the repository verification is valid. After expiry, it is reverted. */
  minimumReverificationInterval?: Maybe<Scalars['Int']['output']>;
  /** Unique identifier for the Geo node. */
  name?: Maybe<Scalars['String']['output']>;
  /** Package file registries of the GeoNode. */
  packageFileRegistries?: Maybe<PackageFileRegistryConnection>;
  /**
   * Find Packages::Nuget::Symbols registries on this Geo node. Ignored if `geo_packages_nuget_symbol_replication` feature flag is disabled. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  packagesNugetSymbolRegistries?: Maybe<PackagesNugetSymbolRegistryConnection>;
  /** Find Pages Deployment registries on this Geo node */
  pagesDeploymentRegistries?: Maybe<PagesDeploymentRegistryConnection>;
  /** Find pipeline artifact registries on this Geo node. */
  pipelineArtifactRegistries?: Maybe<PipelineArtifactRegistryConnection>;
  /** Indicates whether the Geo node is the primary. */
  primary?: Maybe<Scalars['Boolean']['output']>;
  /** Find Project registries on this Geo node. Ignored if `geo_project_repository_replication` feature flag is disabled. */
  projectRepositoryRegistries?: Maybe<ProjectRepositoryRegistryConnection>;
  /** Find Project Wiki Repository registries on this Geo node. Ignored if `geo_project_wiki_repository_replication` feature flag is disabled. */
  projectWikiRepositoryRegistries?: Maybe<ProjectWikiRepositoryRegistryConnection>;
  /** Maximum concurrency of repository backfill for the secondary node. */
  reposMaxCapacity?: Maybe<Scalars['Int']['output']>;
  /** Namespaces that should be synced, if `selective_sync_type` == `namespaces`. */
  selectiveSyncNamespaces?: Maybe<NamespaceConnection>;
  /** Repository storages whose projects should be synced, if `selective_sync_type` == `shards`. */
  selectiveSyncShards?: Maybe<Array<Scalars['String']['output']>>;
  /** Indicates if syncing is limited to only specific groups, or shards. */
  selectiveSyncType?: Maybe<Scalars['String']['output']>;
  /** Find snippet repository registries on this Geo node. */
  snippetRepositoryRegistries?: Maybe<SnippetRepositoryRegistryConnection>;
  /** Indicates if the secondary node will replicate blobs in Object Storage. */
  syncObjectStorage?: Maybe<Scalars['Boolean']['output']>;
  /** Find terraform state version registries on this Geo node. */
  terraformStateVersionRegistries?: Maybe<TerraformStateVersionRegistryConnection>;
  /** Find Upload registries on this Geo node */
  uploadRegistries?: Maybe<UploadRegistryConnection>;
  /** User-facing URL for the Geo node. */
  url?: Maybe<Scalars['String']['output']>;
  /** Maximum concurrency of repository verification for the secondary node. */
  verificationMaxCapacity?: Maybe<Scalars['Int']['output']>;
};


export type GeoNodeCiSecureFileRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoCiSecureFileRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeContainerRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoContainerRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDependencyProxyBlobRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoDependencyProxyBlobRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDependencyProxyManifestRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoDependencyProxyManifestRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDesignManagementRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoDesignManagementRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeGroupWikiRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoGroupWikiRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeJobArtifactRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoJobArtifactRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeLfsObjectRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoLfsObjectRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeMergeRequestDiffRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoMergeRequestDiffRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePackageFileRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoPackageFileRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePackagesNugetSymbolRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoPackagesNugetSymbolRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePagesDeploymentRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoPagesDeploymentRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePipelineArtifactRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoPipelineArtifactRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeProjectRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoProjectRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeProjectWikiRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoProjectWikiRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeSelectiveSyncNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GeoNodeSnippetRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoSnippetRepositoryRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeTerraformStateVersionRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoTerraformStateVersionRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeUploadRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['GeoUploadRegistryID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  sort?: InputMaybe<GeoRegistrySort>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};

/** Action to trigger on multiple Geo registries */
export type GeoRegistriesBulkAction =
  /** Resync multiple registries. */
  | 'RESYNC_ALL'
  /** Reverify multiple registries. */
  | 'REVERIFY_ALL';

/** Autogenerated input type of GeoRegistriesBulkUpdate */
export type GeoRegistriesBulkUpdateInput = {
  /** Action to be executed on Geo registries. */
  action: GeoRegistriesBulkAction;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Execute the action on registries selected by their ID. */
  ids?: InputMaybe<Array<Scalars['GeoBaseRegistryID']['input']>>;
  /** Class of the Geo registries to be updated. */
  registryClass: GeoRegistryClass;
  /** Execute the action on registries selected by their replication state. */
  replicationState?: InputMaybe<ReplicationStateEnum>;
  /** Execute the action on registries selected by their verification state. */
  verificationState?: InputMaybe<VerificationStateEnum>;
};

/** Autogenerated return type of GeoRegistriesBulkUpdate. */
export type GeoRegistriesBulkUpdatePayload = {
  __typename?: 'GeoRegistriesBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated Geo registry class. */
  registryClass?: Maybe<GeoRegistryClass>;
};

/** Autogenerated input type of GeoRegistriesUpdate */
export type GeoRegistriesUpdateInput = {
  /** Action to be executed on a Geo registry. */
  action: GeoRegistryAction;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Geo registry entry to be updated. */
  registryId: Scalars['GeoBaseRegistryID']['input'];
};

/** Autogenerated return type of GeoRegistriesUpdate. */
export type GeoRegistriesUpdatePayload = {
  __typename?: 'GeoRegistriesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated Geo registry entry. */
  registry?: Maybe<Registrable>;
};

/** Action to trigger on an individual Geo registry */
export type GeoRegistryAction =
  /** Resync a registry. */
  | 'RESYNC'
  /** Reverify a registry. */
  | 'REVERIFY';

/** Geo registry class */
export type GeoRegistryClass =
  /** Geo::CiSecureFileRegistry registry class */
  | 'CI_SECURE_FILE_REGISTRY'
  /** Geo::ContainerRepositoryRegistry registry class */
  | 'CONTAINER_REPOSITORY_REGISTRY'
  /** Geo::DependencyProxyBlobRegistry registry class */
  | 'DEPENDENCY_PROXY_BLOB_REGISTRY'
  /** Geo::DependencyProxyManifestRegistry registry class */
  | 'DEPENDENCY_PROXY_MANIFEST_REGISTRY'
  /** Geo::DesignManagementRepositoryRegistry registry class */
  | 'DESIGN_MANAGEMENT_REPOSITORY_REGISTRY'
  /** Geo::GroupWikiRepositoryRegistry registry class */
  | 'GROUP_WIKI_REPOSITORY_REGISTRY'
  /** Geo::JobArtifactRegistry registry class */
  | 'JOB_ARTIFACT_REGISTRY'
  /** Geo::LfsObjectRegistry registry class */
  | 'LFS_OBJECT_REGISTRY'
  /** Geo::MergeRequestDiffRegistry registry class */
  | 'MERGE_REQUEST_DIFF_REGISTRY'
  /** Geo::PackagesNugetSymbolRegistry registry class */
  | 'PACKAGES_NUGET_SYMBOL_REGISTRY'
  /** Geo::PackageFileRegistry registry class */
  | 'PACKAGE_FILE_REGISTRY'
  /** Geo::PagesDeploymentRegistry registry class */
  | 'PAGES_DEPLOYMENT_REGISTRY'
  /** Geo::PipelineArtifactRegistry registry class */
  | 'PIPELINE_ARTIFACT_REGISTRY'
  /** Geo::ProjectRepositoryRegistry registry class */
  | 'PROJECT_REPOSITORY_REGISTRY'
  /** Geo::ProjectWikiRepositoryRegistry registry class */
  | 'PROJECT_WIKI_REPOSITORY_REGISTRY'
  /** Geo::SnippetRepositoryRegistry registry class */
  | 'SNIPPET_REPOSITORY_REGISTRY'
  /** Geo::TerraformStateVersionRegistry registry class */
  | 'TERRAFORM_STATE_VERSION_REGISTRY'
  /** Geo::UploadRegistry registry class */
  | 'UPLOAD_REGISTRY';

/** Values for sorting Geo registries */
export type GeoRegistrySort =
  /** ID by ascending order. */
  | 'ID_ASC'
  /** ID by descending order. */
  | 'ID_DESC'
  /** Latest sync date by ascending order. */
  | 'LAST_SYNCED_AT_ASC'
  /** Latest sync date by descending order. */
  | 'LAST_SYNCED_AT_DESC'
  /** Latest verification date by ascending order. */
  | 'VERIFIED_AT_ASC'
  /** Latest verification date by descending order. */
  | 'VERIFIED_AT_DESC';

/** A feature flag for the GitLab instance. */
export type GitlabInstanceFeatureFlag = {
  __typename?: 'GitlabInstanceFeatureFlag';
  /** Indicates whether the GitLab instance feature flag is enabled or not. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the GitLab instance feature flag. */
  name: Scalars['String']['output'];
};

/** Autogenerated input type of GitlabSubscriptionActivate */
export type GitlabSubscriptionActivateInput = {
  /** Activation code received after purchasing a GitLab subscription. */
  activationCode: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of GitlabSubscriptionActivate. */
export type GitlabSubscriptionActivatePayload = {
  __typename?: 'GitlabSubscriptionActivatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Array of future subscriptions. */
  futureSubscriptions?: Maybe<Array<SubscriptionFutureEntry>>;
  /** Current license. */
  license?: Maybe<CurrentLicense>;
};

/** Describes daily the usage of GitLab Credits */
export type GitlabSubscriptionDailyUsage = {
  __typename?: 'GitlabSubscriptionDailyUsage';
  /** GitLab Credits consumed on the date. */
  creditsUsed: Scalars['Float']['output'];
  /** Date when credits were used. */
  date: Scalars['ISO8601Date']['output'];
};

/** Describes the subscription history of a given namespace */
export type GitlabSubscriptionHistory = {
  __typename?: 'GitlabSubscriptionHistory';
  /** Indicates what type of change in the subscription has happened. */
  changeType?: Maybe<SubscriptionHistoryChangeType>;
  /** Timestamp of the subscription history entry creation. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Subscription end date. */
  endDate?: Maybe<Scalars['Time']['output']>;
  /** Maximum seats used in subscription. */
  maxSeatsUsed?: Maybe<Scalars['Int']['output']>;
  /** Seats purchased in subscription. */
  seats?: Maybe<Scalars['Int']['output']>;
  /** Seats being used in subscription. */
  seatsInUse?: Maybe<Scalars['Int']['output']>;
  /** Subscription start date. */
  startDate?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for GitlabSubscriptionHistory. */
export type GitlabSubscriptionHistoryConnection = {
  __typename?: 'GitlabSubscriptionHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GitlabSubscriptionHistoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GitlabSubscriptionHistory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GitlabSubscriptionHistoryEdge = {
  __typename?: 'GitlabSubscriptionHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GitlabSubscriptionHistory>;
};

/** Describes the usage of GitLab Credits for the subscription's monthly commitment */
export type GitlabSubscriptionMonthlyCommitment = {
  __typename?: 'GitlabSubscriptionMonthlyCommitment';
  /** Total of GitLab Credits consumed from the subscription's monthly commitment. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Array of daily usage of the subscription's monthly commitment. */
  dailyUsage?: Maybe<Array<GitlabSubscriptionDailyUsage>>;
  /** Total of GitLab Credits allocated as a subscription's monthly commitment. */
  totalCredits?: Maybe<Scalars['Float']['output']>;
};

/** GitLab Credits used from the Monthly Waiver allocation */
export type GitlabSubscriptionMonthlyWaiver = {
  __typename?: 'GitlabSubscriptionMonthlyWaiver';
  /** GitLab Credits used from the Monthly Waiver allocation. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Array of daily usage of the Monthly Waiver allocation. */
  dailyUsage?: Maybe<Array<GitlabSubscriptionDailyUsage>>;
  /** Total of GitLab Credits allocated as Monthly Waiver. */
  totalCredits?: Maybe<Scalars['Float']['output']>;
};

/** Describes the overage of consumables for the subscription */
export type GitlabSubscriptionOverage = {
  __typename?: 'GitlabSubscriptionOverage';
  /** Overage consumed by the subscription. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Array of daily overage usage. */
  dailyUsage?: Maybe<Array<GitlabSubscriptionDailyUsage>>;
  /** Whether GitLab Credits overage is allowed for the subscription. */
  isAllowed?: Maybe<Scalars['Boolean']['output']>;
};

/** Describes the usage of consumables under the subscription */
export type GitlabSubscriptionUsage = {
  __typename?: 'GitlabSubscriptionUsage';
  /** Indicates whether the subscription is currently eligible to accept overage terms. */
  canAcceptOverageTerms: Scalars['Boolean']['output'];
  /** Indicates whether the Duo AI promo (DAP) is enabled for the subscription. */
  dapPromoEnabled: Scalars['Boolean']['output'];
  /** Indicates if the Customer Portal GitLab Credits API is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** End date of the period covered by the usage data. */
  endDate?: Maybe<Scalars['ISO8601Date']['output']>;
  /** Indicates if the GitLab instance has an outdated API contract with the Customer Portal. */
  isOutdatedClient?: Maybe<Scalars['Boolean']['output']>;
  /** Date and time when the last usage event resulted in a wallet transaction. */
  lastEventTransactionAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Monthly commitment usage for the subscription. */
  monthlyCommitment?: Maybe<GitlabSubscriptionMonthlyCommitment>;
  /** Monthly waiver usage for the subscription. */
  monthlyWaiver?: Maybe<GitlabSubscriptionMonthlyWaiver>;
  /** Overage statistics. */
  overage?: Maybe<GitlabSubscriptionOverage>;
  /** Indicates whether overage terms have been accepted for the subscription. */
  overageTermsAccepted: Scalars['Boolean']['output'];
  /** URL to purchase GitLab Credits. */
  purchaseCreditsPath?: Maybe<Scalars['String']['output']>;
  /** Start date of the period covered by the usage data. */
  startDate?: Maybe<Scalars['ISO8601Date']['output']>;
  /** Full URL to the GitLab Credits usage dashboard in the Customer Portal. */
  subscriptionPortalUsageDashboardUrl?: Maybe<Scalars['String']['output']>;
  /** Consumption usage for users under the subscription. */
  usersUsage?: Maybe<GitlabSubscriptionUsageUsersUsage>;
};

/** Describes the location of a subscription usage event. */
export type GitlabSubscriptionUsageEventLocation = Group | Project;

/** Describes the user with their usage data */
export type GitlabSubscriptionUsageUser = {
  __typename?: 'GitlabSubscriptionUsageUser';
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Billable events from the user. */
  events?: Maybe<GitlabSubscriptionUsageUserEventConnection>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** Human-readable name of the user. */
  name: Scalars['String']['output'];
  /** Usage of consumables for a user under the subscription. */
  usage?: Maybe<GitlabSubscriptionUsageUserUsage>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
};


/** Describes the user with their usage data */
export type GitlabSubscriptionUsageUserEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GitlabSubscriptionUsageUser. */
export type GitlabSubscriptionUsageUserConnection = {
  __typename?: 'GitlabSubscriptionUsageUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GitlabSubscriptionUsageUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GitlabSubscriptionUsageUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GitlabSubscriptionUsageUserEdge = {
  __typename?: 'GitlabSubscriptionUsageUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GitlabSubscriptionUsageUser>;
};

/** Describes a usage event for the subscription. */
export type GitlabSubscriptionUsageUserEvent = {
  __typename?: 'GitlabSubscriptionUsageUserEvent';
  /** GitLab Credits consumed on the date. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Event type. */
  eventType?: Maybe<Scalars['String']['output']>;
  /** User-friendly display name for the event flow type. */
  flowType?: Maybe<Scalars['String']['output']>;
  /** Event location: project or namespace. */
  location?: Maybe<GitlabSubscriptionUsageEventLocation>;
  /** Date and time of the event. */
  timestamp?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

/** The connection type for GitlabSubscriptionUsageUserEvent. */
export type GitlabSubscriptionUsageUserEventConnection = {
  __typename?: 'GitlabSubscriptionUsageUserEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GitlabSubscriptionUsageUserEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GitlabSubscriptionUsageUserEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GitlabSubscriptionUsageUserEventEdge = {
  __typename?: 'GitlabSubscriptionUsageUserEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GitlabSubscriptionUsageUserEvent>;
};

/** Describes the usage of consumables for a user under the subscription */
export type GitlabSubscriptionUsageUserUsage = {
  __typename?: 'GitlabSubscriptionUsageUserUsage';
  /** GitLab Credits used by the user. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Monthly Commitment GitLab Credits used by the user. */
  monthlyCommitmentCreditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Monthly Waiver GitLab Credits used by the user. */
  monthlyWaiverCreditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Overage GitLab Credits used by the user. */
  overageCreditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Total GitLab Credits available for the user. */
  totalCredits?: Maybe<Scalars['Float']['output']>;
};

/** Describes the usage of consumables by users under the subscription */
export type GitlabSubscriptionUsageUsersUsage = {
  __typename?: 'GitlabSubscriptionUsageUsersUsage';
  /** GitLab Credits used by consumers of the subscription. */
  creditsUsed?: Maybe<Scalars['Float']['output']>;
  /** Array of daily usage of GitLab Credits. */
  dailyUsage?: Maybe<Array<GitlabSubscriptionDailyUsage>>;
  /** Total number of users consuming GitLab Credits. */
  totalUsersUsingCredits?: Maybe<Scalars['Int']['output']>;
  /** Total number of users consuming GitLab Credits from the subscription monthly commitment. */
  totalUsersUsingMonthlyCommitment?: Maybe<Scalars['Int']['output']>;
  /** Total number of users consuming overage. */
  totalUsersUsingOverage?: Maybe<Scalars['Int']['output']>;
  /** List of users with their usage data. */
  users?: Maybe<GitlabSubscriptionUsageUserConnection>;
};


/** Describes the usage of consumables by users under the subscription */
export type GitlabSubscriptionUsageUsersUsageUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Types of add-ons */
export type GitlabSubscriptionsAddOnType =
  /** GitLab Duo Pro add-on. */
  | 'CODE_SUGGESTIONS'
  /** GitLab Duo with Amazon Q add-on. */
  | 'DUO_AMAZON_Q'
  /** GitLab Duo Core add-on. Introduced in GitLab 18.0: **Status**: Experiment. */
  | 'DUO_CORE'
  /** GitLab Duo Enterprise add-on. */
  | 'DUO_ENTERPRISE';

/** Role of User */
export type GitlabSubscriptionsUserRole =
  /** Developer. */
  | 'DEVELOPER'
  /** Guest. */
  | 'GUEST'
  /** Maintainer. */
  | 'MAINTAINER'
  /** Owner. */
  | 'OWNER'
  /** Planner. */
  | 'PLANNER'
  /** Reporter. */
  | 'REPORTER';

/** Values for sorting users */
export type GitlabSubscriptionsUserSort =
  /** Id by ascending order. */
  | 'ID_ASC'
  /** Id by descending order. */
  | 'ID_DESC'
  /** Last activity by ascending order. */
  | 'LAST_ACTIVITY_ON_ASC'
  /** Last activity by descending order. */
  | 'LAST_ACTIVITY_ON_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC';

/** A base type of Google Artifact Registry artifacts */
export type GoogleCloudArtifactRegistryArtifact = GoogleCloudArtifactRegistryDockerImage;

/** The connection type for GoogleCloudArtifactRegistryArtifact. */
export type GoogleCloudArtifactRegistryArtifactConnection = {
  __typename?: 'GoogleCloudArtifactRegistryArtifactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GoogleCloudArtifactRegistryArtifactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GoogleCloudArtifactRegistryArtifact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Details type of Google Artifact Registry artifacts */
export type GoogleCloudArtifactRegistryArtifactDetails = GoogleCloudArtifactRegistryDockerImageDetails;

/** An edge in a connection. */
export type GoogleCloudArtifactRegistryArtifactEdge = {
  __typename?: 'GoogleCloudArtifactRegistryArtifactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GoogleCloudArtifactRegistryArtifact>;
};

/** Values for sorting artifacts */
export type GoogleCloudArtifactRegistryArtifactsSort =
  /** Ordered by `build_time` in ascending order. */
  | 'BUILD_TIME_ASC'
  /** Ordered by `build_time` in descending order. */
  | 'BUILD_TIME_DESC'
  /** Ordered by `image_size_bytes` in ascending order. */
  | 'IMAGE_SIZE_BYTES_ASC'
  /** Ordered by `image_size_bytes` in descending order. */
  | 'IMAGE_SIZE_BYTES_DESC'
  /** Ordered by `media_type` in ascending order. */
  | 'MEDIA_TYPE_ASC'
  /** Ordered by `media_type` in descending order. */
  | 'MEDIA_TYPE_DESC'
  /** Ordered by `name` in ascending order. */
  | 'NAME_ASC'
  /** Ordered by `name` in descending order. */
  | 'NAME_DESC'
  /** Ordered by `update_time` in ascending order. */
  | 'UPDATE_TIME_ASC'
  /** Ordered by `update_time` in descending order. */
  | 'UPDATE_TIME_DESC'
  /** Ordered by `upload_time` in ascending order. */
  | 'UPLOAD_TIME_ASC'
  /** Ordered by `upload_time` in descending order. */
  | 'UPLOAD_TIME_DESC';

/** Represents a docker artifact of Google Artifact Registry */
export type GoogleCloudArtifactRegistryDockerImage = {
  __typename?: 'GoogleCloudArtifactRegistryDockerImage';
  /** Image's digest. */
  digest: Scalars['String']['output'];
  /** Image's name. */
  image: Scalars['String']['output'];
  /** Unique image name. */
  name: Scalars['String']['output'];
  /** Tags attached to the image. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Time when the image was last updated. */
  updateTime?: Maybe<Scalars['Time']['output']>;
  /** Time when the image was uploaded. */
  uploadTime?: Maybe<Scalars['Time']['output']>;
  /** Google Cloud URI to access the image. */
  uri: Scalars['String']['output'];
};

/** Represents details about docker artifact of Google Artifact Registry */
export type GoogleCloudArtifactRegistryDockerImageDetails = {
  __typename?: 'GoogleCloudArtifactRegistryDockerImageDetails';
  /** Google Cloud URL to access the image. */
  artifactRegistryImageUrl: Scalars['String']['output'];
  /** Time when the image was built. */
  buildTime?: Maybe<Scalars['Time']['output']>;
  /** Image's digest. */
  digest: Scalars['String']['output'];
  /** Image's name. */
  image: Scalars['String']['output'];
  /** Calculated size of the image. */
  imageSizeBytes?: Maybe<Scalars['String']['output']>;
  /** Location of the Artifact Registry repository. */
  location: Scalars['String']['output'];
  /** Media type of the image. */
  mediaType?: Maybe<Scalars['String']['output']>;
  /** Unique image name. */
  name: Scalars['String']['output'];
  /** ID of the Google Cloud project. */
  projectId: Scalars['String']['output'];
  /** Repository on the Google Artifact Registry. */
  repository: Scalars['String']['output'];
  /** Tags attached to the image. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Time when the image was last updated. */
  updateTime?: Maybe<Scalars['Time']['output']>;
  /** Time when the image was uploaded. */
  uploadTime?: Maybe<Scalars['Time']['output']>;
  /** Google Cloud URI to access the image. */
  uri: Scalars['String']['output'];
};

/** Represents a repository of Google Artifact Registry */
export type GoogleCloudArtifactRegistryRepository = {
  __typename?: 'GoogleCloudArtifactRegistryRepository';
  /** Google Cloud URL to access the repository. */
  artifactRegistryRepositoryUrl: Scalars['String']['output'];
  /** Google Artifact Registry repository artifacts. Returns `null` if GitLab.com feature is unavailable. */
  artifacts?: Maybe<GoogleCloudArtifactRegistryArtifactConnection>;
  /** ID of the Google Cloud project. */
  projectId: Scalars['String']['output'];
  /** Repository on the Google Artifact Registry. */
  repository: Scalars['String']['output'];
};


/** Represents a repository of Google Artifact Registry */
export type GoogleCloudArtifactRegistryRepositoryArtifactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<GoogleCloudArtifactRegistryArtifactsSort>;
};

/** Autogenerated input type of GoogleCloudLoggingConfigurationCreate */
export type GoogleCloudLoggingConfigurationCreateInput = {
  /** Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials. */
  clientEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName: Scalars['String']['input'];
  /** Group path. */
  groupPath: Scalars['ID']['input'];
  /** Unique identifier used to distinguish and manage different logs within the same Google Cloud project.(defaults to `audit_events`). */
  logIdName?: InputMaybe<Scalars['String']['input']>;
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service. */
  privateKey: Scalars['String']['input'];
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationCreate. */
export type GoogleCloudLoggingConfigurationCreatePayload = {
  __typename?: 'GoogleCloudLoggingConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** configuration created. */
  googleCloudLoggingConfiguration?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of GoogleCloudLoggingConfigurationDestroy */
export type GoogleCloudLoggingConfigurationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Google Cloud logging configuration to destroy. */
  id: Scalars['AuditEventsGoogleCloudLoggingConfigurationID']['input'];
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationDestroy. */
export type GoogleCloudLoggingConfigurationDestroyPayload = {
  __typename?: 'GoogleCloudLoggingConfigurationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type GoogleCloudLoggingConfigurationInterface = {
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Client email. */
  clientEmail: Scalars['String']['output'];
  /** Google project ID. */
  googleProjectIdName: Scalars['String']['output'];
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Log ID. */
  logIdName: Scalars['String']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** Stores Google Cloud Logging configurations associated with IAM service accounts,used for generating access tokens. */
export type GoogleCloudLoggingConfigurationType = GoogleCloudLoggingConfigurationInterface & {
  __typename?: 'GoogleCloudLoggingConfigurationType';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Client email. */
  clientEmail: Scalars['String']['output'];
  /** Google project ID. */
  googleProjectIdName: Scalars['String']['output'];
  /** Group the configuration belongs to. */
  group: Group;
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Log ID. */
  logIdName: Scalars['String']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** The connection type for GoogleCloudLoggingConfigurationType. */
export type GoogleCloudLoggingConfigurationTypeConnection = {
  __typename?: 'GoogleCloudLoggingConfigurationTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GoogleCloudLoggingConfigurationTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GoogleCloudLoggingConfigurationType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GoogleCloudLoggingConfigurationTypeEdge = {
  __typename?: 'GoogleCloudLoggingConfigurationTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of GoogleCloudLoggingConfigurationUpdate */
export type GoogleCloudLoggingConfigurationUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials. */
  clientEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName?: InputMaybe<Scalars['String']['input']>;
  /** ID of the google Cloud configuration to update. */
  id: Scalars['AuditEventsGoogleCloudLoggingConfigurationID']['input'];
  /** Unique identifier used to distinguish and manage different logs within the same Google Cloud project. */
  logIdName?: InputMaybe<Scalars['String']['input']>;
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service. */
  privateKey?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationUpdate. */
export type GoogleCloudLoggingConfigurationUpdatePayload = {
  __typename?: 'GoogleCloudLoggingConfigurationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** configuration updated. */
  googleCloudLoggingConfiguration?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** Attributes for defining Node Pool in GKE */
export type GoogleCloudNodePool = {
  /** Image to use on the pool. */
  imageType: Scalars['GoogleCloudImage']['input'];
  /** Labels for the node pool of the runner. */
  labels?: InputMaybe<Array<GoogleCloudNodePoolLabel>>;
  /** Machine type to use. */
  machineType: Scalars['GoogleCloudMachineType']['input'];
  /** Name of the node pool. */
  name: Scalars['String']['input'];
  /** Node count of the pool. */
  nodeCount: Scalars['Int']['input'];
};

/** Labels for the Node Pool of a GKE cluster. */
export type GoogleCloudNodePoolLabel = {
  /** Key of the label. */
  key: Scalars['String']['input'];
  /** Value of the label. */
  value: Scalars['String']['input'];
};

/** GPG signature for a signed commit */
export type GpgSignature = CommitSignature & {
  __typename?: 'GpgSignature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']['output']>;
  /** ID of the GPG key. */
  gpgKeyPrimaryKeyid?: Maybe<Scalars['String']['output']>;
  /** User email associated with the GPG key. */
  gpgKeyUserEmail?: Maybe<Scalars['String']['output']>;
  /** User name associated with the GPG key. */
  gpgKeyUserName?: Maybe<Scalars['String']['output']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

export type GrafanaIntegration = {
  __typename?: 'GrafanaIntegration';
  /** Timestamp of the issue's creation. */
  createdAt: Scalars['Time']['output'];
  /** Indicates whether Grafana integration is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** URL for the Grafana host for the Grafana integration. */
  grafanaUrl: Scalars['String']['output'];
  /** Internal ID of the Grafana integration. */
  id: Scalars['ID']['output'];
  /** Timestamp of the issue's last activity. */
  updatedAt: Scalars['Time']['output'];
};

/** Attributes for a granular scope of an access token. */
export type GranularScopeInput = {
  /** Access to configure for the granular scope. */
  access: AccessTokenGranularScopeAccess;
  /** List of permissions for the granular scope. */
  permissions: Array<Scalars['String']['input']>;
  /** IDs of groups or projects to associate with each granular scope. */
  resourceIds?: InputMaybe<Array<Scalars['GlobalID']['input']>>;
};

export type Group = GroupInterface & Todoable & {
  __typename?: 'Group';
  /**
   * Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  achievements?: Maybe<AchievementConnection>;
  /**
   * Path for the namespace's achievements. Returns `null` if the namespace is not a group, or the `achievements` feature flag is disabled. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  achievementsPath?: Maybe<Scalars['String']['output']>;
  /** Size limit for repositories in the namespace in bytes. This limit only applies to namespaces under Project limit enforcement. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']['output']>;
  /** The actual storage size limit (in bytes) based on the enforcement type of either repository or namespace. This limit is agnostic of enforcement type. */
  actualSizeLimit?: Maybe<Scalars['Float']['output']>;
  /**
   * Users in the namespace hierarchy that add ons are applicable for. This only applies to root namespaces. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  addOnEligibleUsers?: Maybe<AddOnUserConnection>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']['output']>;
  /** Admin path for editing group. Only available to admins. */
  adminEditPath?: Maybe<Scalars['String']['output']>;
  /** Admin path of the group. Only available to admins. */
  adminShowPath?: Maybe<Scalars['String']['output']>;
  /**
   * AI-related metrics. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  aiMetrics?: Maybe<AiMetrics>;
  /**
   * AI-related metrics with three months of data retention. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  aiMetricsBasic?: Maybe<AiMetricsBasic>;
  /**
   * AI settings for the namespace. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  aiSettings?: Maybe<AiNamespaceSettings>;
  /**
   * AI-related data. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  aiUsageData?: Maybe<AiUsageData>;
  /**
   * AI-related user metrics. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  aiUserMetrics?: Maybe<AiUserMetricsConnection>;
  /** Indicates whether to regularly prune stale group runners. Defaults to false. */
  allowStaleRunnerPruning: Scalars['Boolean']['output'];
  /** Amazon S3 configurations that receive audit events belonging to the group. */
  amazonS3Configurations?: Maybe<AmazonS3ConfigurationTypeConnection>;
  /** Status for all analyzers in the group. */
  analyzerStatuses?: Maybe<Array<AnalyzerGroupStatusType>>;
  /** Approval Policies of the project */
  approvalPolicies?: Maybe<ApprovalPolicyConnection>;
  /**
   * Indicates if the group or any ancestor is archived. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether Auto DevOps is enabled for all projects within the group. */
  autoDevopsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Search users for autocompletion */
  autocompleteUsers?: Maybe<Array<AutocompletedUser>>;
  /**
   * Features available on the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  availableFeatures: NamespaceAvailableFeatures;
  /**
   * Security scan profiles available for the group. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  availableSecurityScanProfiles?: Maybe<Array<ScanProfileType>>;
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Number of billable users in the group. */
  billableMembersCount?: Maybe<Scalars['Int']['output']>;
  /** A single board of the group. */
  board?: Maybe<Board>;
  /** Boards of the group. */
  boards?: Maybe<BoardConnection>;
  /**
   * Namespace CI/CD settings for the namespace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  ciCdSettings?: Maybe<CiCdSettings>;
  /** Time taken for CI jobs to be picked up by this group's runners by percentile. Available to users with Maintainer role for the group. Enable the ClickHouse database backend to use this query. */
  ciQueueingHistory?: Maybe<QueueingDelayHistory>;
  /** List of the group's CI/CD variables. */
  ciVariables?: Maybe<CiGroupVariableConnection>;
  /** Cluster agents associated with projects in the group and its subgroups. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Represents the code coverage activity for this group. */
  codeCoverageActivities?: Maybe<CodeCoverageActivityConnection>;
  /**
   * Summary of compliance framework coverage in a group and its subgroups. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  complianceFrameworkCoverageSummary?: Maybe<ComplianceFrameworkCoverageSummary>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /**
   * Detailed compliance framework coverage for each framework in the group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  complianceFrameworksCoverageDetails?: Maybe<ComplianceFrameworkCoverageDetailConnection>;
  /**
   * Frameworks missing either project assignments or requirements definitions. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  complianceFrameworksNeedingAttention?: Maybe<ComplianceFrameworksNeedingAttentionConnection>;
  /**
   * Compliance control status summary showing count of passed, failed, and pending controls. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  complianceRequirementControlCoverage?: Maybe<RequirementControlCoverage>;
  /**
   * Compliance requirement coverage statistics for the group. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  complianceRequirementCoverage?: Maybe<RequirementCoverage>;
  /**
   * Find software dependency versions by component name. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  componentVersions: ComponentVersionConnection;
  /**
   * Find software dependencies by name. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  components?: Maybe<Array<Component>>;
  /** Counts of contacts by state for the group. */
  contactStateCounts?: Maybe<ContactStateCounts>;
  /** Find contacts of this group. */
  contacts?: Maybe<CustomerRelationsContactConnection>;
  /** Container repositories of the group. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the group. */
  containerRepositoriesCount: Scalars['Int']['output'];
  /** Includes at least one project where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement. */
  containsLockedProjects?: Maybe<Scalars['Boolean']['output']>;
  /** Provides the aggregated contributions by users within the group and its subgroups */
  contributions?: Maybe<ContributionAnalyticsContributionConnection>;
  /** Timestamp of the group creation. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean']['output'];
  /** Custom emoji in this namespace. */
  customEmoji?: Maybe<CustomEmojiConnection>;
  /**
   * A custom field configured for the group. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  customField?: Maybe<CustomField>;
  /**
   * Custom fields configured for the group. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  customFields?: Maybe<CustomFieldConnection>;
  /** Visualizations of the group or associated configuration project. */
  customizableDashboardVisualizations?: Maybe<CustomizableDashboardVisualizationConnection>;
  /** Customizable dashboards for the group. */
  customizableDashboards?: Maybe<CustomizableDashboardConnection>;
  /** Data transfer data point for a specific period. This is mocked data under a development feature flag. */
  dataTransfer?: Maybe<GroupDataTransfer>;
  /** Software dependencies used by projects under this group. */
  dependencies?: Maybe<DependencyConnection>;
  /**
   * Software dependencies used by projects under this group. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  dependencyAggregations?: Maybe<DependencyAggregationConnection>;
  /** Number of dependency proxy blobs cached in the group. */
  dependencyProxyBlobCount: Scalars['Int']['output'];
  /** Dependency Proxy blobs. */
  dependencyProxyBlobs?: Maybe<DependencyProxyBlobConnection>;
  /** Number of dependency proxy images cached in the group. */
  dependencyProxyImageCount: Scalars['Int']['output'];
  /** Prefix for pulling images when using the dependency proxy. */
  dependencyProxyImagePrefix: Scalars['String']['output'];
  /** Dependency proxy TTL policy for the group. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Dependency Proxy manifests. */
  dependencyProxyManifests?: Maybe<DependencyProxyManifestConnection>;
  /** Dependency Proxy settings for the group. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Total size of the dependency proxy cached images. */
  dependencyProxyTotalSize: Scalars['String']['output'];
  /** Total size of the dependency proxy cached images in bytes, encoded as a string. */
  dependencyProxyTotalSizeBytes: Scalars['BigInt']['output'];
  /**
   * Total size of the dependency proxy cached images in bytes. Deprecated in GitLab 16.1: Use `dependencyProxyTotalSizeBytes`.
   * @deprecated Use `dependencyProxyTotalSizeBytes`. Deprecated in GitLab 16.1.
   */
  dependencyProxyTotalSizeInBytes: Scalars['Int']['output'];
  /** List of descendant groups of this group. */
  descendantGroups?: Maybe<GroupConnection>;
  /** Count of direct descendant groups of the group. */
  descendantGroupsCount: Scalars['Int']['output'];
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates whether the namespace is designated to centrally manage security policies. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  designatedAsCsp: Scalars['Boolean']['output'];
  /** Group's DORA metrics. */
  dora?: Maybe<GroupDora>;
  /** Group's DORA scores for all projects by DORA key metric for the last complete month. */
  doraPerformanceScoreCounts?: Maybe<DoraPerformanceScoreCountConnection>;
  /**
   * Indicates whether GitLab Duo features are enabled for the group. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  duoFeaturesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Path for editing group. */
  editPath: Scalars['String']['output'];
  /** Indicates if a group has email notifications disabled. */
  emailsDisabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if a group has email notifications enabled. */
  emailsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the group has limited users for a free plan. */
  enforceFreeUserCap?: Maybe<Scalars['Boolean']['output']>;
  /** Environment scopes of the group. */
  environmentScopes?: Maybe<CiGroupEnvironmentScopeConnection>;
  /**
   * Find a single epic. Deprecated in GitLab 17.5: Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/).
   * @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5.
   */
  epic?: Maybe<Epic>;
  /**
   * Find a single epic board. Deprecated in GitLab 17.5: Replaced by WorkItem type.
   * @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5.
   */
  epicBoard?: Maybe<EpicBoard>;
  /**
   * Find epic boards. Deprecated in GitLab 17.5: Replaced by WorkItem type.
   * @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5.
   */
  epicBoards?: Maybe<EpicBoardConnection>;
  /**
   * Find epics. Deprecated in GitLab 17.5: Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/).
   * @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5.
   */
  epics?: Maybe<EpicConnection>;
  /**
   * Indicates if Epics are enabled for namespace. Deprecated in GitLab 17.5: Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/).
   * @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5.
   */
  epicsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** External locations that receive audit events belonging to the group. */
  externalAuditEventDestinations?: Maybe<ExternalAuditEventDestinationConnection>;
  /**
   * External destinations that receive audit events belonging to the group. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  externalAuditEventStreamingDestinations?: Maybe<GroupAuditEventStreamingDestinationConnection>;
  /**
   * Flow metrics for value stream analytics. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  flowMetrics?: Maybe<GroupValueStreamAnalyticsFlowMetrics>;
  /** Full name of the group. */
  fullName?: Maybe<Scalars['String']['output']>;
  /** Full path of the group. */
  fullPath: Scalars['ID']['output'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /** Google Cloud logging configurations that receive audit events belonging to the group. */
  googleCloudLoggingConfigurations?: Maybe<GoogleCloudLoggingConfigurationTypeConnection>;
  /** A membership of a user within this group. */
  groupMembers?: Maybe<GroupMemberConnection>;
  /** Count of direct members of the group. */
  groupMembersCount: Scalars['Int']['output'];
  /** ID of the group. */
  id?: Maybe<Scalars['ID']['output']>;
  /**
   * Import source users of the namespace. This field can only be resolved for one namespace in any single request. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  importSourceUsers?: Maybe<ImportSourceUserConnection>;
  /** Indicates if group is linked to a subscription. */
  isLinkedToSubscription?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if the group is archived. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isSelfArchived?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if group deletion is in progress. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  isSelfDeletionInProgress: Scalars['Boolean']['output'];
  /**
   * Indicates if group deletion is scheduled. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  isSelfDeletionScheduled: Scalars['Boolean']['output'];
  /** Issues for projects in this group. */
  issues?: Maybe<IssueConnection>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Label available on the group. */
  label?: Maybe<Label>;
  /** Labels available on this group. */
  labels?: Maybe<LabelConnection>;
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Licensed features available on the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  licensedFeatures: NamespaceAvailableFeatures;
  /**
   * Lifecycle templates available to the namespace. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  lifecycleTemplates?: Maybe<Array<WorkItemLifecycle>>;
  /**
   * Lifecycles of work items available to the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  lifecycles?: Maybe<WorkItemLifecycleConnection>;
  /**
   * Namespace relevant paths to create links on the UI. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  linkPaths?: Maybe<NamespacesLinkPaths>;
  /**
   * Indicates if the GitLab Duo features enabled setting is enforced for all subgroups. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  lockDuoFeaturesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if math rendering limits are locked for all descendant groups. */
  lockMathRenderingLimitsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Namespace relevant paths to create markdown links on the UI. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  markdownPaths?: Maybe<MarkdownPaths>;
  /**
   * Indicates if group or any ancestor is scheduled to be deleted. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  markedForDeletion: Scalars['Boolean']['output'];
  /**
   * Date when group was scheduled to be deleted. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  markedForDeletionOn?: Maybe<Scalars['Time']['output']>;
  /** Indicates if math rendering limits are used for the group. */
  mathRenderingLimitsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Maximum access level of the current user in the group. */
  maxAccessLevel: AccessLevel;
  /**
   * Custom roles available for the group. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  memberRoles?: Maybe<MemberRoleConnection>;
  /** Indicates if a group is disabled from getting mentioned. */
  mentionsDisabled?: Maybe<Scalars['Boolean']['output']>;
  /** Compliance violations reported on merge requests merged within the group. */
  mergeRequestViolations?: Maybe<ComplianceViolationConnection>;
  /** Merge requests for projects in this group. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /**
   * Indicates if merge requests are enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  mergeRequestsEnabled: Scalars['Boolean']['output'];
  /**
   * Metadata information for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  metadata?: Maybe<NamespaceMetadata>;
  /** Milestones of the group. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the group. */
  name?: Maybe<Scalars['String']['output']>;
  /** Namespace settings for the namespace. */
  namespaceSettings?: Maybe<NamespaceSettings>;
  /**
   * Path for editing group at the organization level. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  organizationEditPath?: Maybe<Scalars['String']['output']>;
  /** Counts of organizations by status for the group. */
  organizationStateCounts?: Maybe<OrganizationStateCounts>;
  /** Find organizations of this group. */
  organizations?: Maybe<CustomerRelationsOrganizationConnection>;
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** Packages of the group. This field can only be resolved for one group in any single request. */
  packages?: Maybe<PackageConnection>;
  /** List of the namespaces's Pages Deployments. */
  pagesDeployments?: Maybe<PagesDeploymentConnection>;
  /** Parent group. */
  parent?: Maybe<Group>;
  /** Path of the namespace. */
  path: Scalars['String']['output'];
  /** Pending member promotions of the group. */
  pendingMemberApprovals?: Maybe<MemberApprovalConnection>;
  /**
   * A pending membership of a user within this group. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  pendingMembers?: Maybe<PendingMemberInterfaceConnection>;
  /**
   * For groups pending deletion, returns the group's scheduled deletion date. For groups not pending deletion, returns a theoretical date based on current settings if marked for deletion today. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  permanentDeletionDate?: Maybe<Scalars['String']['output']>;
  /** Pipeline analytics. */
  pipelineAnalytics?: Maybe<PipelineAnalytics>;
  /** Pipeline Execution Policies of the namespace. */
  pipelineExecutionPolicies?: Maybe<PipelineExecutionPolicyConnection>;
  /** Pipeline Execution Schedule Policies of the namespace. */
  pipelineExecutionSchedulePolicies?: Maybe<PipelineExecutionSchedulePolicyConnection>;
  /**
   * Subscription plan associated with the namespace. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  plan?: Maybe<NamespacePlan>;
  /**
   * Number of product analytics events namespace is permitted to store per cycle. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  productAnalyticsStoredEventsLimit?: Maybe<Scalars['Int']['output']>;
  /**
   * Compliance statuses for the projects in a group and its subgroups. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  projectComplianceRequirementsStatus?: Maybe<ProjectComplianceRequirementStatusConnection>;
  /** Compliance standards adherence for the projects in a group and its subgroups. */
  projectComplianceStandardsAdherence?: Maybe<ComplianceStandardsAdherenceConnection>;
  /**
   * Compliance violations for the projects in a group and its subgroups. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  projectComplianceViolations?: Maybe<ProjectComplianceViolationConnection>;
  /** Permission level required to create projects in the group. */
  projectCreationLevel?: Maybe<Scalars['String']['output']>;
  /**
   * Statistics of the projects in the group. Only available from [Query.groups](#querygroups). Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  projectStatistics?: Maybe<NamespaceProjectStatistics>;
  /** Projects within this namespace. Returns projects from the parent group if namespace is project. */
  projects: ProjectConnection;
  /** Count of direct projects in the group. */
  projectsCount: Scalars['Int']['output'];
  /** List of recently visited boards of the group. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** Releases belonging to projects in the group. */
  releases?: Maybe<ReleaseConnection>;
  /**
   * Cluster agents in the namespace with remote development capabilities Deprecated in GitLab 17.8: Use `workspacesClusterAgents`.
   * @deprecated Use `workspacesClusterAgents`. Deprecated in GitLab 17.8.
   */
  remoteDevelopmentClusterAgents?: Maybe<ClusterAgentConnection>;
  /** Number of projects in the root namespace where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement. */
  repositorySizeExcessProjectCount?: Maybe<Scalars['Int']['output']>;
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if all users in the group are required to set up two-factor authentication. */
  requireTwoFactorAuthentication?: Maybe<Scalars['Boolean']['output']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /**
   * Information used for provisioning the runner on a cloud provider. Returns `null` if the GitLab instance is not a SaaS instance. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  runnerCloudProvisioning?: Maybe<CiRunnerCloudProvisioning>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** Saved replies available to the group. This field can only be resolved for one group in any single request. */
  savedReplies?: Maybe<GroupSavedReplyConnection>;
  /** Saved reply in the group. This field can only be resolved for one group in any single request. */
  savedReply?: Maybe<GroupSavedReply>;
  /**
   * Saved views associated with the namespace. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  savedViews?: Maybe<WorkItemSavedViewTypeConnection>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /**
   * Scan Result Policies of the project Deprecated in GitLab 16.9: Use `approvalPolicies`.
   * @deprecated Use `approvalPolicies`. Deprecated in GitLab 16.9.
   */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Security categories for the group. */
  securityCategories?: Maybe<Array<SecurityCategory>>;
  /**
   * Security metrics.This feature is currently under development and not yet available for general use. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  securityMetrics?: Maybe<SecurityMetrics>;
  /**
   * List of security policies configured for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  securityPolicies?: Maybe<SecurityPolicyTypeConnection>;
  /** Security policy project assigned to the namespace. */
  securityPolicyProject?: Maybe<Project>;
  /** Security policy project suggestions */
  securityPolicyProjectSuggestions?: Maybe<ProjectConnection>;
  /** Indicates if sharing a project with another group within the group is prevented. */
  shareWithGroupLock?: Maybe<Scalars['Boolean']['output']>;
  /** List of shared groups this group was invited to. */
  sharedGroups?: Maybe<GroupConnection>;
  /** List of shared projects this group was invited to. */
  sharedProjects?: Maybe<ProjectConnection>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /**
   * Data needed to render the sidebar for the namespace. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  sidebar?: Maybe<NamespaceSidebar>;
  /**
   * Finds a single default role for the group. Available only for SaaS. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  standardRole?: Maybe<StandardRole>;
  /**
   * Default roles available for the group. Available only for SaaS. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  standardRoles?: Maybe<StandardRoleConnection>;
  /** Group statistics. */
  stats?: Maybe<GroupStats>;
  /**
   * Statuses of work items available to the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  statuses?: Maybe<WorkItemStatusConnection>;
  /** The storage limit (in bytes) included with the root namespace plan. This limit only applies to namespaces under namespace limit enforcement. */
  storageSizeLimit?: Maybe<Scalars['Float']['output']>;
  /** Permission level required to create subgroups within the group. */
  subgroupCreationLevel?: Maybe<Scalars['String']['output']>;
  /**
   * Maximum number of subscribed saved views allowed on the namespace. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  subscribedSavedViewLimit: Scalars['Int']['output'];
  /**
   * Find subscription history records. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  subscriptionHistory?: Maybe<GitlabSubscriptionHistoryConnection>;
  /**
   * Timelog categories for the namespace. Introduced in GitLab 15.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the group and its subgroups. */
  timelogs: TimelogConnection;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']['output']>;
  /** Total excess repository size of all projects in the root namespace in bytes. This only applies to namespaces under Project limit enforcement. */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']['output']>;
  /** Time before two-factor authentication is enforced. */
  twoFactorGracePeriod?: Maybe<Scalars['Int']['output']>;
  /** Timestamp of when the group was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
  /** Information about Value Stream Analytics within the group. */
  valueStreamAnalytics?: Maybe<ValueStreamAnalytics>;
  /**
   * Aggregated usage counts within the group Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  valueStreamDashboardUsageOverview?: Maybe<ValueStreamDashboardCount>;
  /** Value streams available to the group. */
  valueStreams?: Maybe<ValueStreamConnection>;
  /**
   * Virtual registries cleanup policy of the group. Returns null if the `maven_virtual_registry` or `virtual_registry_cleanup_policies`feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  virtualRegistriesCleanupPolicy?: Maybe<VirtualRegistryCleanupPolicy>;
  /**
   * Container virtual registries registered to the group. Returns null if the `container_virtual_registry` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  virtualRegistriesContainerRegistries?: Maybe<ContainerRegistryConnection>;
  /**
   * Container upstreams registered to the group. Returns null if the `container_virtual_registry` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  virtualRegistriesContainerUpstreams?: Maybe<ContainerUpstreamConnection>;
  /**
   * Maven virtual registries registered to the group. Returns null if the `maven_virtual_registry` feature flag is disabled. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  virtualRegistriesPackagesMavenRegistries?: Maybe<MavenRegistryConnection>;
  /**
   * Maven upstream registries registered to the group. Returns null if the `maven_virtual_registry` feature flag is disabled. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  virtualRegistriesPackagesMavenUpstreams?: Maybe<MavenUpstreamConnection>;
  /**
   * Virtual registries settings for the group. Returns null if the `maven_virtual_registry` feature flag is disabled. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  virtualRegistriesSetting?: Maybe<VirtualRegistriesSetting>;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']['output']>;
  /** Vulnerabilities reported on the projects in the group and its subgroups. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects in the group and its subgroups. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades?: Maybe<Array<VulnerableProjectsByGrade>>;
  /** Search for vulnerabilities by identifier. */
  vulnerabilityIdentifierSearch?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Vulnerability Management Policies of the project. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  vulnerabilityManagementPolicies?: Maybe<VulnerabilityManagementPolicyConnection>;
  /** Counts for each vulnerability severity in the group and its subgroups. */
  vulnerabilityNamespaceStatistic?: Maybe<VulnerabilityNamespaceStatisticType>;
  /** Vulnerability scanners reported on the project vulnerabilities of the group and its subgroups. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the group and its subgroups. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /**
   * Indicates whether web-based commit signing is enabled for the group. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  webBasedCommitSigningEnabled: Scalars['Boolean']['output'];
  /** Web path of the group. */
  webPath: Scalars['String']['output'];
  /** Web URL of the group. */
  webUrl: Scalars['String']['output'];
  /**
   * A single group webhook. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  webhook?: Maybe<GroupHook>;
  /**
   * Find a work item by IID directly associated with the group. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  workItem?: Maybe<WorkItem>;
  /**
   * Work item description templates available to the namespace. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  workItemDescriptionTemplates?: Maybe<WorkItemDescriptionTemplateConnection>;
  /**
   * Counts of work items by state for the namespace. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  workItemStateCounts?: Maybe<WorkItemStateCountsType>;
  /** Work item types available to the group. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
  /**
   * Work items that belong to the namespace. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  workItems?: Maybe<WorkItemConnection>;
  /**
   * List of available widgets for the given work items. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  workItemsWidgets?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Cluster agents in the namespace with workspaces capabilities Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  workspacesClusterAgents?: Maybe<ClusterAgentConnection>;
};


export type GroupAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['AchievementsAchievementID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupAddOnEligibleUsersArgs = {
  addOnPurchaseIds: Array<Scalars['GitlabSubscriptionsAddOnPurchaseID']['input']>;
  addOnType: GitlabSubscriptionsAddOnType;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignedSeat?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GitlabSubscriptionsUserSort>;
};


export type GroupAiMetricsArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type GroupAiMetricsBasicArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type GroupAiUserMetricsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AiUserMetricsSort>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type GroupAmazonS3ConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupApprovalPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupAutocompleteUsersArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
};


export type GroupAvailableSecurityScanProfilesArgs = {
  gitlabRecommended?: InputMaybe<Scalars['Boolean']['input']>;
  type?: InputMaybe<SecurityScanProfileType>;
};


export type GroupBillableMembersCountArgs = {
  requestedHostedPlan?: InputMaybe<Scalars['String']['input']>;
};


export type GroupBoardArgs = {
  id: Scalars['BoardID']['input'];
};


export type GroupBoardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['BoardID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupCiQueueingHistoryArgs = {
  fromTime?: InputMaybe<Scalars['Time']['input']>;
  toTime?: InputMaybe<Scalars['Time']['input']>;
};


export type GroupCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type GroupClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasRemoteDevelopmentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  hasWorkspacesAgentConfig?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupCodeCoverageActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['Date']['input'];
};


export type GroupComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  ids?: InputMaybe<Array<Scalars['ComplianceManagementFrameworkID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ComplianceFrameworkSort>;
};


export type GroupComplianceFrameworksCoverageDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupComplianceFrameworksNeedingAttentionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupComponentVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentName: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupComponentsArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type GroupContactStateCountsArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<CustomerRelationsContactState>;
};


export type GroupContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsContactID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ContactSort>;
  state?: InputMaybe<CustomerRelationsContactState>;
};


export type GroupContainerRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ContainerRepositorySort>;
};


export type GroupContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  from: Scalars['ISO8601Date']['input'];
  to: Scalars['ISO8601Date']['input'];
};


export type GroupCustomEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupCustomFieldArgs = {
  id: Scalars['IssuablesCustomFieldID']['input'];
};


export type GroupCustomFieldsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  fieldType?: InputMaybe<CustomFieldType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['WorkItemsTypeID']['input']>;
};


export type GroupCustomizableDashboardVisualizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type GroupCustomizableDashboardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<CustomizableDashboardCategory>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type GroupDataTransferArgs = {
  from?: InputMaybe<Scalars['Date']['input']>;
  to?: InputMaybe<Scalars['Date']['input']>;
};


export type GroupDependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentIds?: InputMaybe<Array<Scalars['SbomComponentID']['input']>>;
  componentNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  sort?: InputMaybe<DependencySort>;
  sourceTypes?: InputMaybe<Array<SbomSourceType>>;
};


export type GroupDependencyAggregationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentIds?: InputMaybe<Array<Scalars['SbomComponentID']['input']>>;
  componentNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  projectCountMax?: InputMaybe<Scalars['Int']['input']>;
  projectCountMin?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<DependencySort>;
  sourceTypes?: InputMaybe<Array<SbomSourceType>>;
};


export type GroupDependencyProxyBlobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupDependencyProxyManifestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupDescendantGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeParentDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  owned?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


export type GroupDoraPerformanceScoreCountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectFilters?: InputMaybe<DoraProjectFilterInput>;
};


export type GroupEnvironmentScopesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type GroupEpicArgs = {
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


export type GroupEpicBoardArgs = {
  id: Scalars['BoardsEpicBoardID']['input'];
};


export type GroupEpicBoardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupEpicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  iidStartsWith?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


export type GroupExternalAuditEventDestinationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupExternalAuditEventStreamingDestinationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']['input']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  memberRoleId?: InputMaybe<Scalars['Int']['input']>;
  role: GitlabSubscriptionsUserRole;
};


export type GroupGoogleCloudLoggingConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupGroupMembersArgs = {
  accessLevels?: InputMaybe<Array<AccessLevelEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  enterprise?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relations?: InputMaybe<Array<GroupMemberRelation>>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MemberSort>;
};


export type GroupImportSourceUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<SourceUserSort>;
  statuses?: InputMaybe<Array<ImportSourceUserStatus>>;
};


export type GroupIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  epicId?: InputMaybe<Scalars['String']['input']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type GroupIterationCadencesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  automatic?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  durationInWeeks?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type GroupIterationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IterationSort>;
  state?: InputMaybe<IterationState>;
  timeframe?: InputMaybe<Timeframe>;
};


export type GroupLabelArgs = {
  title: Scalars['String']['input'];
};


export type GroupLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyGroupLabels?: InputMaybe<Scalars['Boolean']['input']>;
  searchIn?: Array<LabelSearchFieldList>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type GroupLifecyclesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupMemberRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type GroupMergeRequestViolationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ComplianceViolationInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ComplianceViolationSort>;
};


export type GroupMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


export type GroupMilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  containingDate?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  searchTitle?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MilestoneSort>;
  state?: InputMaybe<MilestoneStateEnum>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type GroupOrganizationStateCountsArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
};


export type GroupOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsOrganizationID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<OrganizationSort>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
};


export type GroupPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeVersionless?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageName?: InputMaybe<Scalars['String']['input']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  packageVersion?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<PackageGroupSort>;
  status?: InputMaybe<PackageStatus>;
};


export type GroupPagesDeploymentsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Sort>;
  versioned?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GroupPendingMemberApprovalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupPendingMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupPipelineAnalyticsArgs = {
  fromTime?: InputMaybe<Scalars['Time']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<CiPipelineSources>;
  toTime?: InputMaybe<Scalars['Time']['input']>;
};


export type GroupPipelineExecutionPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupPipelineExecutionSchedulePoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupProjectComplianceRequirementsStatusArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<GroupProjectRequirementComplianceStatusInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectComplianceRequirementStatusOrderBy>;
};


export type GroupProjectComplianceStandardsAdherenceArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ComplianceStandardsAdherenceInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupProjectComplianceViolationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ProjectComplianceViolationFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  complianceFrameworkFilters?: InputMaybe<ComplianceFrameworkFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  sbomComponentId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withNamespaceDomainPages?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GroupRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupReleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<GroupReleaseSort>;
};


export type GroupRemoteDevelopmentClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: NamespaceClusterAgentFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupRunnerCloudProvisioningArgs = {
  cloudProjectId: Scalars['GoogleCloudProject']['input'];
  provider: CiRunnerCloudProvider;
};


export type GroupRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  creatorId?: InputMaybe<Scalars['UserID']['input']>;
  creatorUsername?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membership?: InputMaybe<CiRunnerMembershipFilter>;
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  versionPrefix?: InputMaybe<Scalars['String']['input']>;
};


export type GroupSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupSavedReplyArgs = {
  id: Scalars['GroupsSavedReplyID']['input'];
};


export type GroupSavedViewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['WorkItemsSavedViewsSavedViewID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemsSavedViewsSort>;
  subscribedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GroupScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupSecurityMetricsArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
};


export type GroupSecurityPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  type?: InputMaybe<PolicyType>;
};


export type GroupSecurityPolicyProjectSuggestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyLinked?: InputMaybe<Scalars['Boolean']['input']>;
  search: Scalars['String']['input'];
};


export type GroupSharedGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


export type GroupSharedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
};


export type GroupStandardRoleArgs = {
  accessLevel?: InputMaybe<Array<MemberAccessLevel>>;
};


export type GroupStandardRolesArgs = {
  accessLevel?: InputMaybe<Array<MemberAccessLevel>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupSubscriptionHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type GroupValueStreamDashboardUsageOverviewArgs = {
  identifier: ValueStreamDashboardMetric;
  timeframe: Timeframe;
};


export type GroupValueStreamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupVirtualRegistriesContainerRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupVirtualRegistriesContainerUpstreamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  upstreamName?: InputMaybe<Scalars['String']['input']>;
};


export type GroupVirtualRegistriesPackagesMavenRegistriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupVirtualRegistriesPackagesMavenUpstreamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  upstreamName?: InputMaybe<Scalars['String']['input']>;
};


export type GroupVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  identifierName?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type GroupVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['ISO8601Date']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['ISO8601Date']['input'];
};


export type GroupVulnerabilityGradesArgs = {
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  letterGrade?: InputMaybe<VulnerabilityGrade>;
};


export type GroupVulnerabilityIdentifierSearchArgs = {
  name: Scalars['String']['input'];
};


export type GroupVulnerabilityManagementPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupVulnerabilitySeveritiesCountArgs = {
  capped?: InputMaybe<Scalars['Boolean']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type GroupWebhookArgs = {
  id: Scalars['GroupHookID']['input'];
};


export type GroupWorkItemArgs = {
  iid: Scalars['String']['input'];
};


export type GroupWorkItemDescriptionTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupWorkItemStateCountsArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type GroupWorkItemTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<IssueType>;
};


export type GroupWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type GroupWorkItemsWidgetsArgs = {
  ids: Array<Scalars['WorkItemsTypeID']['input']>;
  union?: Scalars['Boolean']['input'];
};


export type GroupWorkspacesClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: NamespaceClusterAgentFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a subgroup or project filter that belongs to a group level external audit event streaming destination. */
export type GroupAuditEventNamespaceFilter = {
  __typename?: 'GroupAuditEventNamespaceFilter';
  /** Destination to which the filter belongs. */
  externalStreamingDestination: GroupAuditEventStreamingDestination;
  /** ID of the filter. */
  id: Scalars['ID']['output'];
  /** Group or project namespace the filter belongs to. */
  namespace: Namespace;
};

/** Represents an external destination to stream group level audit events. */
export type GroupAuditEventStreamingDestination = AuditEventStreamingDestinationInterface & {
  __typename?: 'GroupAuditEventStreamingDestination';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Category of the external destination to send audit events to. */
  category: Scalars['String']['output'];
  /** Config of the external destination. */
  config: Scalars['JSON']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** Group to which the destination belongs. */
  group: Group;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** List of subgroup or project filters for the destination. */
  namespaceFilters?: Maybe<Array<GroupAuditEventNamespaceFilter>>;
  /** Secret token for the destination, will be non-empty value only for http category. */
  secretToken: Scalars['String']['output'];
};

/** The connection type for GroupAuditEventStreamingDestination. */
export type GroupAuditEventStreamingDestinationConnection = {
  __typename?: 'GroupAuditEventStreamingDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupAuditEventStreamingDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupAuditEventStreamingDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupAuditEventStreamingDestinationEdge = {
  __typename?: 'GroupAuditEventStreamingDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupAuditEventStreamingDestination>;
};

/** Autogenerated input type of GroupAuditEventStreamingDestinationsCreate */
export type GroupAuditEventStreamingDestinationsCreateInput = {
  /** Destination category. */
  category: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination config. */
  config: Scalars['JSON']['input'];
  /** Group path. */
  groupPath: Scalars['ID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret token. */
  secretToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of GroupAuditEventStreamingDestinationsCreate. */
export type GroupAuditEventStreamingDestinationsCreatePayload = {
  __typename?: 'GroupAuditEventStreamingDestinationsCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Destination created. */
  externalAuditEventDestination?: Maybe<GroupAuditEventStreamingDestination>;
};

/** Autogenerated input type of GroupAuditEventStreamingDestinationsDelete */
export type GroupAuditEventStreamingDestinationsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the audit events external streaming destination to delete. */
  id: Scalars['AuditEventsGroupExternalStreamingDestinationID']['input'];
};

/** Autogenerated return type of GroupAuditEventStreamingDestinationsDelete. */
export type GroupAuditEventStreamingDestinationsDeletePayload = {
  __typename?: 'GroupAuditEventStreamingDestinationsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of GroupAuditEventStreamingDestinationsUpdate */
export type GroupAuditEventStreamingDestinationsUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Destination category. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination config. */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** ID of external audit event destination to update. */
  id: Scalars['AuditEventsGroupExternalStreamingDestinationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret token. */
  secretToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of GroupAuditEventStreamingDestinationsUpdate. */
export type GroupAuditEventStreamingDestinationsUpdatePayload = {
  __typename?: 'GroupAuditEventStreamingDestinationsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated destination. */
  externalAuditEventDestination?: Maybe<GroupAuditEventStreamingDestination>;
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Group. */
export type GroupConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type GroupDataTransfer = {
  __typename?: 'GroupDataTransfer';
  /** Data nodes. */
  egressNodes?: Maybe<EgressNodeConnection>;
};


export type GroupDataTransferEgressNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** All information related to group DORA metrics. */
export type GroupDora = {
  __typename?: 'GroupDora';
  /** DORA metrics for the current group or project. */
  metrics?: Maybe<Array<DoraMetric>>;
  /** Projects within this group with at least 1 DORA metric for given period. */
  projects: ProjectConnection;
};


/** All information related to group DORA metrics. */
export type GroupDoraMetricsArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  environmentTiers?: InputMaybe<Array<DeploymentTier>>;
  interval?: InputMaybe<DoraMetricBucketingInterval>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


/** All information related to group DORA metrics. */
export type GroupDoraProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  complianceFrameworkFilters?: InputMaybe<ComplianceFrameworkFilters>;
  endDate: Scalars['Date']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  sbomComponentId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  startDate: Scalars['Date']['input'];
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withNamespaceDomainPages?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

export type GroupHook = {
  __typename?: 'GroupHook';
  /** Auto-disabling status of the webhook. */
  alertStatus: WebhookAlertStatus;
  /** Strategy for filtering push events by branch name. */
  branchFilterStrategy: WebhookBranchFilterStrategy;
  /** Whether the webhook is triggered on confidential issues events. */
  confidentialIssuesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on confidential note events. */
  confidentialNoteEvents: Scalars['Boolean']['output'];
  /** Timestamp of when the webhook was created. */
  createdAt: Scalars['Time']['output'];
  /** List of custom header names for the webhook. */
  customHeaders?: Maybe<Array<WebhookCustomHeader>>;
  /** Custom payload template for the webhook request body. */
  customWebhookTemplate?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on deployment events. */
  deploymentEvents: Scalars['Boolean']['output'];
  /** Description of the webhook. */
  description?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the webhook will be automatically re-enabled if temporarily disabled. */
  disabledUntil?: Maybe<Scalars['Time']['output']>;
  /** Whether the webhook is triggered on emoji events. */
  emojiEvents: Scalars['Boolean']['output'];
  /** Whether SSL verification is done when triggering the webhook. */
  enableSslVerification?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the webhook is triggered on feature flag events. */
  featureFlagEvents: Scalars['Boolean']['output'];
  /** ID of the webhook. */
  id: Scalars['GroupHookID']['output'];
  /** Whether the webhook is triggered on issues events. */
  issuesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on job events. */
  jobEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on member events. */
  memberEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on merge request events. */
  mergeRequestsEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on milestone events. */
  milestoneEvents: Scalars['Boolean']['output'];
  /** Name of the webhook. */
  name?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on note events. */
  noteEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on pipeline events. */
  pipelineEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on project events. */
  projectEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on push events. */
  pushEvents: Scalars['Boolean']['output'];
  /** Trigger hook on push events for matching branches only. */
  pushEventsBranchFilter?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on releases events. */
  releasesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on resource access token events. */
  resourceAccessTokenEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on subgroup events. */
  subgroupEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on tag push events. */
  tagPushEvents: Scalars['Boolean']['output'];
  /** URL of the webhook. */
  url: Scalars['String']['output'];
  /** List of URL variable masks to hide sensitive portions of the webhook URL. */
  urlVariables?: Maybe<Array<WebhookUrlVariable>>;
  /** Whether the webhook is triggered on vulnerability events. */
  vulnerabilityEvents: Scalars['Boolean']['output'];
  /** A single webhook event. */
  webhookEvent?: Maybe<WebhookEvent>;
  /** List of recent webhook events. This field can only be resolved for one webhook in any single request. */
  webhookEvents?: Maybe<WebhookEventConnection>;
  /** Whether the webhook is triggered on wiki page events. */
  wikiPageEvents: Scalars['Boolean']['output'];
};


export type GroupHookWebhookEventArgs = {
  id: Scalars['WebHookLogID']['input'];
  timestampRange?: InputMaybe<TimestampRange>;
};


export type GroupHookWebhookEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  timestampRange?: InputMaybe<TimestampRange>;
};

/** Returns either a "Group" type for users with :read_group permission, or a "GroupMinimalAccess" type for users with only :read_group_metadata permission. */
export type GroupInterface = {
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Full name of the group. */
  fullName?: Maybe<Scalars['String']['output']>;
  /** Full path of the group. */
  fullPath: Scalars['ID']['output'];
  /** ID of the group. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Name of the group. */
  name?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the group. */
  userPermissions?: Maybe<GroupPermissions>;
  /** Web URL of the group. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for GroupInterface. */
export type GroupInterfaceConnection = {
  __typename?: 'GroupInterfaceConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for GroupInterface. */
export type GroupInterfaceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type GroupInterfaceEdge = {
  __typename?: 'GroupInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupInterface>;
};

/** Represents a Group Membership */
export type GroupMember = MemberInterface & {
  __typename?: 'GroupMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** Group that a user is a member of. */
  group?: Maybe<Group>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Group notification email for user. Only available for admins. */
  notificationEmail?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupMemberPermissions;
};


/** Represents a Group Membership */
export type GroupMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

/** Autogenerated input type of GroupMemberBulkUpdate */
export type GroupMemberBulkUpdateInput = {
  /** Access level to update the members to. */
  accessLevel: MemberAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Date and time the membership expires. */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  /** Global ID of the group. */
  groupId: Scalars['GroupID']['input'];
  /** Global IDs of the members. */
  userIds: Array<Scalars['UserID']['input']>;
};

/** Autogenerated return type of GroupMemberBulkUpdate. */
export type GroupMemberBulkUpdatePayload = {
  __typename?: 'GroupMemberBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group members after mutation. */
  groupMembers?: Maybe<Array<GroupMember>>;
  /** List of queued pending members approvals. */
  queuedMemberApprovals?: Maybe<MemberApprovalConnection>;
};


/** Autogenerated return type of GroupMemberBulkUpdate. */
export type GroupMemberBulkUpdatePayloadQueuedMemberApprovalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GroupMember. */
export type GroupMemberConnection = {
  __typename?: 'GroupMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupMemberEdge = {
  __typename?: 'GroupMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMember>;
};

export type GroupMemberPermissions = {
  __typename?: 'GroupMemberPermissions';
  /** If `true`, the user can perform `create_custom_emoji` on this resource */
  createCustomEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_projects` on this resource */
  createProjects: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_group` on this resource */
  readGroup: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_group` on this resource */
  removeGroup: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `view_edit_page` on this resource */
  viewEditPage: Scalars['Boolean']['output'];
};

/** Group member relation */
export type GroupMemberRelation =
  /** Members in the group's subgroups. */
  | 'DESCENDANTS'
  /** Members in the group itself. */
  | 'DIRECT'
  /** Members in the group's ancestor groups. */
  | 'INHERITED'
  /** Invited group's members. */
  | 'SHARED_FROM_GROUPS';

/** Autogenerated input type of GroupMembersExport */
export type GroupMembersExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the group. */
  groupId: Scalars['GroupID']['input'];
};

/** Autogenerated return type of GroupMembersExport. */
export type GroupMembersExportPayload = {
  __typename?: 'GroupMembersExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Export request result message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Limited group data accessible to users without full group read access (e.g. non-members with READ_ADMIN_CICD admin custom role). */
export type GroupMinimalAccess = GroupInterface & {
  __typename?: 'GroupMinimalAccess';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Full name of the group. */
  fullName: Scalars['String']['output'];
  /** Full path of the group. */
  fullPath: Scalars['ID']['output'];
  /** ID of the group. */
  id: Scalars['ID']['output'];
  /** Name of the group. */
  name: Scalars['String']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
  /** Web URL of the group. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

export type GroupNamespaceLinks = NamespacesLinkPaths & {
  __typename?: 'GroupNamespaceLinks';
  /**
   * Path for autocomplete award emojis. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  autocompleteAwardEmojisPath?: Maybe<Scalars['String']['output']>;
  /**
   * Calendar path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  calendarPath?: Maybe<Scalars['String']['output']>;
  /** Namespace contribution guide path. */
  contributionGuidePath?: Maybe<Scalars['String']['output']>;
  /** Help page path for emails. */
  emailsHelpPagePath?: Maybe<Scalars['String']['output']>;
  /** Namespace epics_list. */
  epicsList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the epics list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  epicsListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace group_issues. */
  groupIssues?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the group. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues_list. */
  issuesList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the issues list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  issuesListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues settings path. */
  issuesSettings?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_fetch. */
  labelsFetch?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_manage. */
  labelsManage?: Maybe<Scalars['String']['output']>;
  /** Help page path for Markdown. */
  markdownHelpPath?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the namespace (project.namespace.full_path or group full_path). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  namespaceFullPath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_comment_template_paths. */
  newCommentTemplate?: Maybe<Array<CommentTemplatePath>>;
  /**
   * Path to create a new issue. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newIssuePath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_project. */
  newProject?: Maybe<Scalars['String']['output']>;
  /**
   * New trial path for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newTrialPath?: Maybe<Scalars['String']['output']>;
  /** Help page path for quick actions. */
  quickActionsHelpPath?: Maybe<Scalars['String']['output']>;
  /** Namespace register_path. */
  register?: Maybe<Scalars['String']['output']>;
  /** Namespace report_abuse. */
  reportAbuse?: Maybe<Scalars['String']['output']>;
  /**
   * RSS path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rssPath?: Maybe<Scalars['String']['output']>;
  /** Namespace sign_in_path. */
  signIn?: Maybe<Scalars['String']['output']>;
  /**
   * User email for export CSV. Returns `null` for user namespaces. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  userExportEmail?: Maybe<Scalars['String']['output']>;
};

export type GroupNamespaceMarkdownPaths = MarkdownPaths & {
  __typename?: 'GroupNamespaceMarkdownPaths';
  /** Supported paths for autocomplete sources for a given namespace. */
  autocompleteSourcesPath?: Maybe<Scalars['JSON']['output']>;
  /** Path for the markdown preview for given namespace. */
  markdownPreviewPath?: Maybe<Scalars['String']['output']>;
  /** Uploads path for a given namespace. */
  uploadsPath?: Maybe<Scalars['String']['output']>;
};


export type GroupNamespaceMarkdownPathsAutocompleteSourcesPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['String']['input']>;
};


export type GroupNamespaceMarkdownPathsMarkdownPreviewPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
};

export type GroupNamespaceMetadata = NamespaceMetadata & {
  __typename?: 'GroupNamespaceMetadata';
  /**
   * ID of the group. Returns null for user namespaces. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupId?: Maybe<Scalars['String']['output']>;
  /**
   * Whether the group has any projects. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  hasProjects?: Maybe<Scalars['Boolean']['output']>;
  /**
   * User preference for initial sort order. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  initialSort?: Maybe<Scalars['String']['output']>;
  /**
   * Whether issue repositioning is disabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isIssueRepositioningDisabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Maximum allowed attachment size (humanized). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  maxAttachmentSize?: Maybe<Scalars['String']['output']>;
  /**
   * Whether to show the new work item link. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  showNewWorkItem?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Time tracking limit to hours setting. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  timeTrackingLimitToHours?: Maybe<Scalars['Boolean']['output']>;
};

/** User permission on groups */
export type GroupPermission =
  /** Groups where the user can create projects. */
  | 'CREATE_PROJECTS'
  /** Groups where the user can import projects to. */
  | 'IMPORT_PROJECTS'
  /** Groups where the user can transfer projects to. */
  | 'TRANSFER_PROJECTS';

export type GroupPermissions = {
  __typename?: 'GroupPermissions';
  /** If `true`, the user can perform `admin_ai_catalog_item_consumer` on this resource */
  adminAiCatalogItemConsumer: Scalars['Boolean']['output'];
  /** If `true`, the user is an instance administrator. */
  adminAllResources: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_work_item_lifecycle` on this resource */
  adminWorkItemLifecycle: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `archive_group` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  archiveGroup: Scalars['Boolean']['output'];
  /** If `true`, the user can leave this group. */
  canLeave: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_custom_emoji` on this resource */
  createCustomEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_projects` on this resource */
  createProjects: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `generate_description` on this resource */
  generateDescription: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_crm_contact` on this resource */
  readCrmContact: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_crm_organization` on this resource */
  readCrmOrganization: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_group` on this resource */
  readGroup: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `read_runner_cloud_provisioning_info` on this resource Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  readRunnerCloudProvisioningInfo: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_group` on this resource */
  removeGroup: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `view_edit_page` on this resource */
  viewEditPage: Scalars['Boolean']['output'];
};

export type GroupProjectRequirementComplianceStatusInput = {
  /** Filter compliance requirement statuses by compliance framework. */
  frameworkId?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** Filter compliance requirement statuses by project. */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  /** Filter compliance requirement statuses by compliance requirement. */
  requirementId?: InputMaybe<Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input']>;
};

/** Values for sorting releases belonging to a group */
export type GroupReleaseSort =
  /** Released at by ascending order. */
  | 'RELEASED_AT_ASC'
  /** Released at by descending order. */
  | 'RELEASED_AT_DESC';

/** Contains release-related statistics about a group */
export type GroupReleaseStats = {
  __typename?: 'GroupReleaseStats';
  /** Total number of releases in all descendant projects of the group. */
  releasesCount?: Maybe<Scalars['Int']['output']>;
  /** Percentage of the group's descendant projects that have at least one release. */
  releasesPercentage?: Maybe<Scalars['Int']['output']>;
};

export type GroupSavedReply = {
  __typename?: 'GroupSavedReply';
  /** Content of the saved reply. */
  content: Scalars['String']['output'];
  /** Global ID of the group-level saved reply. */
  id: Scalars['GroupsSavedReplyID']['output'];
  /** Name of the saved reply. */
  name: Scalars['String']['output'];
};

/** The connection type for GroupSavedReply. */
export type GroupSavedReplyConnection = {
  __typename?: 'GroupSavedReplyConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupSavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupSavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for GroupSavedReply. */
export type GroupSavedReplyConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of GroupSavedReplyCreate */
export type GroupSavedReplyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Group for the save reply. */
  groupId: Scalars['GroupID']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of GroupSavedReplyCreate. */
export type GroupSavedReplyCreatePayload = {
  __typename?: 'GroupSavedReplyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<GroupSavedReply>;
};

/** Autogenerated input type of GroupSavedReplyDestroy */
export type GroupSavedReplyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the group-level saved reply. */
  id: Scalars['GroupsSavedReplyID']['input'];
};

/** Autogenerated return type of GroupSavedReplyDestroy. */
export type GroupSavedReplyDestroyPayload = {
  __typename?: 'GroupSavedReplyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<GroupSavedReply>;
};

/** An edge in a connection. */
export type GroupSavedReplyEdge = {
  __typename?: 'GroupSavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupSavedReply>;
};

/** Autogenerated input type of GroupSavedReplyUpdate */
export type GroupSavedReplyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Global ID of the group-level saved reply. */
  id: Scalars['GroupsSavedReplyID']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of GroupSavedReplyUpdate. */
export type GroupSavedReplyUpdatePayload = {
  __typename?: 'GroupSavedReplyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<GroupSavedReply>;
};

/** Representation of a group secrets manager. */
export type GroupSecretsManager = {
  __typename?: 'GroupSecretsManager';
  /** Group the secrets manager belongs to. */
  group: Group;
  /** Status of the group secrets manager. */
  status?: Maybe<GroupSecretsManagerStatus>;
};

/** Autogenerated input type of GroupSecretsManagerDeprovision */
export type GroupSecretsManagerDeprovisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group of the secrets manager. */
  groupPath: Scalars['ID']['input'];
};

/** Autogenerated return type of GroupSecretsManagerDeprovision. */
export type GroupSecretsManagerDeprovisionPayload = {
  __typename?: 'GroupSecretsManagerDeprovisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group secrets manager. */
  groupSecretsManager?: Maybe<GroupSecretsManager>;
};

/** Autogenerated input type of GroupSecretsManagerInitialize */
export type GroupSecretsManagerInitializeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group of the secrets manager. */
  groupPath: Scalars['ID']['input'];
};

/** Autogenerated return type of GroupSecretsManagerInitialize. */
export type GroupSecretsManagerInitializePayload = {
  __typename?: 'GroupSecretsManagerInitializePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group secrets manager. */
  groupSecretsManager?: Maybe<GroupSecretsManager>;
};

/** Values for the group secrets manager status */
export type GroupSecretsManagerStatus =
  /** Secrets manager has been provisioned and enabled. */
  | 'ACTIVE'
  /** Secrets manager is being deprovisioned. */
  | 'DEPROVISIONING'
  /** Secrets manager is being provisioned. */
  | 'PROVISIONING';

/** Representation of a group secrets permission. */
export type GroupSecretsPermission = {
  __typename?: 'GroupSecretsPermission';
  /** Actions that can be performed on secrets. */
  actions: Array<SecretsManagementAction>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: Maybe<Scalars['ISO8601Date']['output']>;
  /** User who created the Secret Permission. */
  grantedBy?: Maybe<UserCore>;
  /** Group the secret permission belong to. */
  group: Group;
  /** Who is provided access to. For eg: User/Role/MemberRole/Group. */
  principal: Principal;
};

/** The connection type for GroupSecretsPermission. */
export type GroupSecretsPermissionConnection = {
  __typename?: 'GroupSecretsPermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupSecretsPermissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupSecretsPermission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of GroupSecretsPermissionDelete */
export type GroupSecretsPermissionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group permissions for the secret. */
  groupPath: Scalars['ID']['input'];
  /** Whose permission to be deleted. */
  principal: PrincipalInput;
};

/** Autogenerated return type of GroupSecretsPermissionDelete. */
export type GroupSecretsPermissionDeletePayload = {
  __typename?: 'GroupSecretsPermissionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted Secrets Permission. */
  secretsPermission?: Maybe<GroupSecretsPermission>;
};

/** An edge in a connection. */
export type GroupSecretsPermissionEdge = {
  __typename?: 'GroupSecretsPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupSecretsPermission>;
};

/** Autogenerated input type of GroupSecretsPermissionUpdate */
export type GroupSecretsPermissionUpdateInput = {
  /** Actions that can be performed on secrets. */
  actions: Array<SecretsManagementAction>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** Group to which the permissions are added. */
  groupPath: Scalars['ID']['input'];
  /** User/MemberRole/Role/Group that is provided access. */
  principal: PrincipalInput;
};

/** Autogenerated return type of GroupSecretsPermissionUpdate. */
export type GroupSecretsPermissionUpdatePayload = {
  __typename?: 'GroupSecretsPermissionUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Secrets Permission that was created. */
  secretsPermission?: Maybe<GroupSecretsPermission>;
};

/** Represents the source of a security policy belonging to a group */
export type GroupSecurityPolicySource = {
  __typename?: 'GroupSecurityPolicySource';
  /** Indicates whether the policy is inherited from parent group. */
  inherited: Scalars['Boolean']['output'];
  /** Project the policy is associated with. */
  namespace?: Maybe<Namespace>;
};

/** Values for sorting groups */
export type GroupSort =
  /** Sort by created at, ascending order. */
  | 'CREATED_AT_ASC'
  /** Sort by created at, descending order. */
  | 'CREATED_AT_DESC'
  /** Sort by ID, ascending order. */
  | 'ID_ASC'
  /** Sort by ID, descending order. */
  | 'ID_DESC'
  /** Sort by name, ascending order. */
  | 'NAME_ASC'
  /** Sort by name, descending order. */
  | 'NAME_DESC'
  /** Sort by path, ascending order. */
  | 'PATH_ASC'
  /** Sort by path, descending order. */
  | 'PATH_DESC'
  /** Most similar to the search query. */
  | 'SIMILARITY'
  /** Sort by updated at, ascending order. */
  | 'UPDATED_AT_ASC'
  /** Sort by updated at, descending order. */
  | 'UPDATED_AT_DESC';

/** Contains statistics about a group */
export type GroupStats = {
  __typename?: 'GroupStats';
  /** Statistics related to releases within the group. */
  releaseStats?: Maybe<GroupReleaseStats>;
};

/** Autogenerated input type of GroupUpdate */
export type GroupUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether GitLab Duo features are enabled for the group. Introduced in GitLab 16.10: **Status**: Experiment. */
  duoFeaturesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full path of the group that will be updated. */
  fullPath: Scalars['ID']['input'];
  /** Indicates if the GitLab Duo features enabled setting is enforced for all subgroups. Introduced in GitLab 16.10: **Status**: Experiment. */
  lockDuoFeaturesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if math rendering limits are locked for all descendant groups. */
  lockMathRenderingLimitsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if math rendering limits are used for the group. */
  mathRenderingLimitsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the group. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Path of the namespace. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: InputMaybe<SharedRunnersSetting>;
  /** OAuth provider required for step-up authentication. */
  stepUpAuthRequiredOauthProvider?: InputMaybe<Scalars['String']['input']>;
  /** Visibility of the namespace. */
  visibility?: InputMaybe<VisibilityLevelsEnum>;
};

/** Autogenerated return type of GroupUpdate. */
export type GroupUpdatePayload = {
  __typename?: 'GroupUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group after update. */
  group?: Maybe<Group>;
};

/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetrics = {
  __typename?: 'GroupValueStreamAnalyticsFlowMetrics';
  /** Median time from first commit to issue closed */
  cycleTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of production deployments in the given period. */
  deploymentCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of issues opened in the given period. */
  issueCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of open issues closed (completed) in the given period. Maximum value is 10,001. */
  issuesCompletedCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from when the issue was created to when it was closed. */
  leadTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from merge request creation to merge request merged. */
  timeToMerge?: Maybe<ValueStreamAnalyticsMetric>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsCycleTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsDeploymentCountArgs = {
  from: Scalars['Time']['input'];
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsIssueCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsIssuesCompletedCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsLeadTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsTimeToMergeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  from: Scalars['Time']['input'];
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  to: Scalars['Time']['input'];
};

/** Represents the Geo sync and verification state of a group wiki repository */
export type GroupWikiRepositoryRegistry = {
  __typename?: 'GroupWikiRepositoryRegistry';
  /** Indicate if the checksums of the GroupWikiRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the GroupWikiRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the Group Wiki Repository. */
  groupWikiRepositoryId: Scalars['ID']['output'];
  /** ID of the GroupWikiRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the GroupWikiRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the GroupWikiRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the GroupWikiRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the GroupWikiRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the GroupWikiRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the GroupWikiRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the GroupWikiRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the GroupWikiRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the GroupWikiRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the GroupWikiRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of GroupWikiRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the GroupWikiRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the GroupWikiRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for GroupWikiRepositoryRegistry. */
export type GroupWikiRepositoryRegistryConnection = {
  __typename?: 'GroupWikiRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupWikiRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupWikiRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for GroupWikiRepositoryRegistry. */
export type GroupWikiRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type GroupWikiRepositoryRegistryEdge = {
  __typename?: 'GroupWikiRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupWikiRepositoryRegistry>;
};

/** Values for grouping compute usage data. */
export type GroupingEnum =
  /** Aggregate usage data across all namespaces in the instance. */
  | 'INSTANCE_AGGREGATE'
  /** Group data by individual root namespace. */
  | 'PER_ROOT_NAMESPACE';

export type Groups = {
  __typename?: 'Groups';
  /** Commit responsible for specified group. */
  commit: Commit;
  /** HTML data derived from commit needed to present blame. */
  commitData?: Maybe<CommitData>;
  /** Starting line number for the commit group. */
  lineno: Scalars['Int']['output'];
  /** Array of lines added for the commit group. */
  lines: Array<Scalars['String']['output']>;
  /** Path to the file in the commit's first parent. */
  previousPath?: Maybe<Scalars['String']['output']>;
  /** Number of contiguous lines which the blame spans for the commit group. */
  span: Scalars['Int']['output'];
};

/** Health status of an issue or epic */
export type HealthStatus =
  /** At risk */
  | 'atRisk'
  /** Needs attention */
  | 'needsAttention'
  /** On track */
  | 'onTrack';

/** Health status of an issue or epic for filtering */
export type HealthStatusFilter =
  /** Any health status is assigned. */
  | 'ANY'
  /** No health status is assigned. */
  | 'NONE'
  /** At risk */
  | 'atRisk'
  /** Needs attention */
  | 'needsAttention'
  /** On track */
  | 'onTrack';

/** Helm file metadata */
export type HelmFileMetadata = PackageFileMetadata & {
  __typename?: 'HelmFileMetadata';
  /** Channel of the Helm chart. */
  channel: Scalars['String']['output'];
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Metadata of the Helm chart. */
  metadata: PackageHelmMetadataType;
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

export type HierarchyFilterInput = {
  /** Whether to include work items of descendant parents when filtering by parent_ids. */
  includeDescendantWorkItems?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter work items by global IDs of their parent items (maximum is 100 items). */
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
};

/** Autogenerated input type of HttpIntegrationCreate */
export type HttpIntegrationCreateInput = {
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the integration. */
  name: Scalars['String']['input'];
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']['input']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID']['input'];
  /** Type of integration to create. Cannot be changed after creation. */
  type?: InputMaybe<AlertManagementIntegrationType>;
};

/** Autogenerated return type of HttpIntegrationCreate. */
export type HttpIntegrationCreatePayload = {
  __typename?: 'HttpIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Alerting integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationDestroy */
export type HttpIntegrationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the integration to remove. */
  id: Scalars['AlertManagementHttpIntegrationID']['input'];
};

/** Autogenerated return type of HttpIntegrationDestroy. */
export type HttpIntegrationDestroyPayload = {
  __typename?: 'HttpIntegrationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Alerting integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationResetToken */
export type HttpIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID']['input'];
};

/** Autogenerated return type of HttpIntegrationResetToken. */
export type HttpIntegrationResetTokenPayload = {
  __typename?: 'HttpIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Alerting integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationUpdate */
export type HttpIntegrationUpdateInput = {
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID']['input'];
  /** Name of the integration. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']['input']>;
};

/** Autogenerated return type of HttpIntegrationUpdate. */
export type HttpIntegrationUpdatePayload = {
  __typename?: 'HttpIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Alerting integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** IDE settings and feature flags. */
export type Ide = {
  __typename?: 'Ide';
  /** Indicates whether AI assisted code suggestions are enabled. */
  codeSuggestionsEnabled: Scalars['Boolean']['output'];
};

export type ImagePullSecrets = {
  __typename?: 'ImagePullSecrets';
  /** Name of the Kubernetes image pull secret. */
  name: Scalars['String']['output'];
  /** Namespace of the kubernetes image pull secret. */
  namespace: Scalars['String']['output'];
};

/** Import source */
export type ImportSource =
  /** Bitbucket */
  | 'BITBUCKET'
  /** Bitbucket Server */
  | 'BITBUCKET_SERVER'
  /** Custom Template */
  | 'CUSTOM_TEMPLATE'
  /** Fogbugz */
  | 'FOGBUGZ'
  /** Git */
  | 'GIT'
  /** Gitea */
  | 'GITEA'
  /** Github */
  | 'GITHUB'
  /** Gitlab Group */
  | 'GITLAB_GROUP'
  /** Gitlab Migration */
  | 'GITLAB_MIGRATION'
  /** Gitlab Project */
  | 'GITLAB_PROJECT'
  /** Jira */
  | 'JIRA'
  /** Manifest */
  | 'MANIFEST'
  /** Not imported */
  | 'NONE';

export type ImportSourceUser = {
  __typename?: 'ImportSourceUser';
  /** Timestamp of when the source user was created. */
  createdAt: Scalars['Time']['output'];
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['output'];
  /** Name of the importer. */
  importType: ImportSource;
  /** Placeholder user associated with the import source user. */
  placeholderUser?: Maybe<UserCore>;
  /** User that contributions are reassigned to. */
  reassignToUser?: Maybe<UserCore>;
  /** User that did the reassignment. */
  reassignedByUser?: Maybe<UserCore>;
  /** Error message if reassignment failed. */
  reassignmentError?: Maybe<Scalars['String']['output']>;
  /** Source instance hostname. */
  sourceHostname: Scalars['String']['output'];
  /** Name of user in the source instance. */
  sourceName?: Maybe<Scalars['String']['output']>;
  /** ID of the user in the source instance. */
  sourceUserIdentifier: Scalars['String']['output'];
  /** Username of user in the source instance. */
  sourceUsername?: Maybe<Scalars['String']['output']>;
  /** Status of the mapping. */
  status: ImportSourceUserStatus;
};

/** Autogenerated input type of ImportSourceUserCancelReassignment */
export type ImportSourceUserCancelReassignmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['input'];
};

/** Autogenerated return type of ImportSourceUserCancelReassignment. */
export type ImportSourceUserCancelReassignmentPayload = {
  __typename?: 'ImportSourceUserCancelReassignmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mapping of a user on source instance to a user on destination instance after mutation. */
  importSourceUser?: Maybe<ImportSourceUser>;
};

/** The connection type for ImportSourceUser. */
export type ImportSourceUserConnection = {
  __typename?: 'ImportSourceUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ImportSourceUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ImportSourceUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ImportSourceUserEdge = {
  __typename?: 'ImportSourceUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ImportSourceUser>;
};

/** Autogenerated input type of ImportSourceUserKeepAllAsPlaceholder */
export type ImportSourceUserKeepAllAsPlaceholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the namespace. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of ImportSourceUserKeepAllAsPlaceholder. */
export type ImportSourceUserKeepAllAsPlaceholderPayload = {
  __typename?: 'ImportSourceUserKeepAllAsPlaceholderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Number of successfully updated mappings of users on source instance to their destination users. */
  updatedImportSourceUserCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of ImportSourceUserKeepAsPlaceholder */
export type ImportSourceUserKeepAsPlaceholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['input'];
};

/** Autogenerated return type of ImportSourceUserKeepAsPlaceholder. */
export type ImportSourceUserKeepAsPlaceholderPayload = {
  __typename?: 'ImportSourceUserKeepAsPlaceholderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mapping of a user on source instance to a user on destination instance after mutation. */
  importSourceUser?: Maybe<ImportSourceUser>;
};

/** Autogenerated input type of ImportSourceUserReassign */
export type ImportSourceUserReassignInput = {
  /** Global ID of the assignee user. */
  assigneeUserId: Scalars['UserID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['input'];
};

/** Autogenerated return type of ImportSourceUserReassign. */
export type ImportSourceUserReassignPayload = {
  __typename?: 'ImportSourceUserReassignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mapping of a user on source instance to a user on destination instance after mutation. */
  importSourceUser?: Maybe<ImportSourceUser>;
};

/** Autogenerated input type of ImportSourceUserResendNotification */
export type ImportSourceUserResendNotificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['input'];
};

/** Autogenerated return type of ImportSourceUserResendNotification. */
export type ImportSourceUserResendNotificationPayload = {
  __typename?: 'ImportSourceUserResendNotificationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mapping of a user on source instance to a user on destination instance after mutation. */
  importSourceUser?: Maybe<ImportSourceUser>;
};

export type ImportSourceUserStatus =
  /** An import source user mapping that is awaiting approval. */
  | 'AWAITING_APPROVAL'
  /** An import source user mapping that is completed. */
  | 'COMPLETED'
  /** An import source user mapping that is failed. */
  | 'FAILED'
  /** An import source user mapping that is keep as placeholder. */
  | 'KEEP_AS_PLACEHOLDER'
  /** An import source user mapping that is pending reassignment. */
  | 'PENDING_REASSIGNMENT'
  /** An import source user mapping that is reassignment in progress. */
  | 'REASSIGNMENT_IN_PROGRESS'
  /** An import source user mapping that is rejected. */
  | 'REJECTED';

/** Autogenerated input type of ImportSourceUserUndoKeepAsPlaceholder */
export type ImportSourceUserUndoKeepAsPlaceholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the mapping of a user on source instance to a user on destination instance. */
  id: Scalars['ImportSourceUserID']['input'];
};

/** Autogenerated return type of ImportSourceUserUndoKeepAsPlaceholder. */
export type ImportSourceUserUndoKeepAsPlaceholderPayload = {
  __typename?: 'ImportSourceUserUndoKeepAsPlaceholderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mapping of a user on source instance to a user on destination instance after mutation. */
  importSourceUser?: Maybe<ImportSourceUser>;
};

/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotation = {
  __typename?: 'IncidentManagementOncallRotation';
  /** Active period for the on-call rotation. */
  activePeriod?: Maybe<OncallRotationActivePeriodType>;
  /** End date and time of the on-call rotation. */
  endsAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the on-call rotation. */
  id: Scalars['IncidentManagementOncallRotationID']['output'];
  /** Length of the on-call schedule, in the units specified by lengthUnit. */
  length?: Maybe<Scalars['Int']['output']>;
  /** Unit of the on-call rotation length. */
  lengthUnit?: Maybe<OncallRotationUnitEnum>;
  /** Name of the on-call rotation. */
  name: Scalars['String']['output'];
  /** Participants of the on-call rotation. */
  participants?: Maybe<OncallParticipantTypeConnection>;
  /** Blocks of time for which a participant is on-call within a given time frame. Time frame cannot exceed one month. */
  shifts?: Maybe<IncidentManagementOncallShiftConnection>;
  /** Start date of the on-call rotation. */
  startsAt?: Maybe<Scalars['Time']['output']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationShiftsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endTime: Scalars['Time']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startTime: Scalars['Time']['input'];
};

/** The connection type for IncidentManagementOncallRotation. */
export type IncidentManagementOncallRotationConnection = {
  __typename?: 'IncidentManagementOncallRotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallRotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallRotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallRotationEdge = {
  __typename?: 'IncidentManagementOncallRotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallRotation>;
};

/** Describes an incident management on-call schedule */
export type IncidentManagementOncallSchedule = {
  __typename?: 'IncidentManagementOncallSchedule';
  /** Description of the on-call schedule. */
  description?: Maybe<Scalars['String']['output']>;
  /** Internal ID of the on-call schedule. */
  iid: Scalars['String']['output'];
  /** Name of the on-call schedule. */
  name: Scalars['String']['output'];
  oncallUsers?: Maybe<Array<UserCore>>;
  /** On-call rotation for the on-call schedule. */
  rotation?: Maybe<IncidentManagementOncallRotation>;
  /** On-call rotations for the on-call schedule. */
  rotations: IncidentManagementOncallRotationConnection;
  /** Time zone of the on-call schedule. */
  timezone: Scalars['String']['output'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationArgs = {
  id: Scalars['IncidentManagementOncallRotationID']['input'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for IncidentManagementOncallSchedule. */
export type IncidentManagementOncallScheduleConnection = {
  __typename?: 'IncidentManagementOncallScheduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallScheduleEdge = {
  __typename?: 'IncidentManagementOncallScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallSchedule>;
};

/** A block of time for which a participant is on-call. */
export type IncidentManagementOncallShift = {
  __typename?: 'IncidentManagementOncallShift';
  /** End time of the on-call shift. */
  endsAt?: Maybe<Scalars['Time']['output']>;
  /** Participant assigned to the on-call shift. */
  participant?: Maybe<OncallParticipantType>;
  /** Start time of the on-call shift. */
  startsAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for IncidentManagementOncallShift. */
export type IncidentManagementOncallShiftConnection = {
  __typename?: 'IncidentManagementOncallShiftConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallShiftEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallShift>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallShiftEdge = {
  __typename?: 'IncidentManagementOncallShiftEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallShift>;
};

/** CI/CD variables a project inherits from its parent group and ancestors. */
export type InheritedCiVariable = {
  __typename?: 'InheritedCiVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']['output']>;
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']['output']>;
  /** Indicates the path to the CI/CD settings of the group the variable belongs to. */
  groupCiCdSettingsPath?: Maybe<Scalars['String']['output']>;
  /** Indicates group the variable belongs to. */
  groupName?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is hidden. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for InheritedCiVariable. */
export type InheritedCiVariableConnection = {
  __typename?: 'InheritedCiVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InheritedCiVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InheritedCiVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InheritedCiVariableEdge = {
  __typename?: 'InheritedCiVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InheritedCiVariable>;
};

/** Stores instance level Amazon S3 configurations for audit event streaming. */
export type InstanceAmazonS3ConfigurationType = AmazonS3ConfigurationInterface & {
  __typename?: 'InstanceAmazonS3ConfigurationType';
  /** Access key ID of the Amazon S3 account. */
  accessKeyXid: Scalars['String']['output'];
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** AWS region where the bucket is created. */
  awsRegion: Scalars['String']['output'];
  /** Name of the bucket where the audit events would be logged. */
  bucketName: Scalars['String']['output'];
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** The connection type for InstanceAmazonS3ConfigurationType. */
export type InstanceAmazonS3ConfigurationTypeConnection = {
  __typename?: 'InstanceAmazonS3ConfigurationTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstanceAmazonS3ConfigurationTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InstanceAmazonS3ConfigurationType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InstanceAmazonS3ConfigurationTypeEdge = {
  __typename?: 'InstanceAmazonS3ConfigurationTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InstanceAmazonS3ConfigurationType>;
};

/** Represents a subgroup or project filter that belongs to an instance level external audit event streaming destination. */
export type InstanceAuditEventNamespaceFilter = {
  __typename?: 'InstanceAuditEventNamespaceFilter';
  /** Destination to which the filter belongs. */
  externalStreamingDestination: InstanceAuditEventStreamingDestination;
  /** ID of the filter. */
  id: Scalars['ID']['output'];
  /** Group or project namespace the filter belongs to. */
  namespace: Namespace;
};

/** Represents an external destination to stream instance level audit events. */
export type InstanceAuditEventStreamingDestination = AuditEventStreamingDestinationInterface & {
  __typename?: 'InstanceAuditEventStreamingDestination';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Category of the external destination to send audit events to. */
  category: Scalars['String']['output'];
  /** Config of the external destination. */
  config: Scalars['JSON']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** List of subgroup or project filters for the destination. */
  namespaceFilters?: Maybe<Array<InstanceAuditEventNamespaceFilter>>;
  /** Secret token for the destination, will be non-empty value only for http category. */
  secretToken: Scalars['String']['output'];
};

/** The connection type for InstanceAuditEventStreamingDestination. */
export type InstanceAuditEventStreamingDestinationConnection = {
  __typename?: 'InstanceAuditEventStreamingDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstanceAuditEventStreamingDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InstanceAuditEventStreamingDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InstanceAuditEventStreamingDestinationEdge = {
  __typename?: 'InstanceAuditEventStreamingDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InstanceAuditEventStreamingDestination>;
};

/** Autogenerated input type of InstanceAuditEventStreamingDestinationsCreate */
export type InstanceAuditEventStreamingDestinationsCreateInput = {
  /** Destination category. */
  category: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination config. */
  config: Scalars['JSON']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret token. */
  secretToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of InstanceAuditEventStreamingDestinationsCreate. */
export type InstanceAuditEventStreamingDestinationsCreatePayload = {
  __typename?: 'InstanceAuditEventStreamingDestinationsCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Destination created. */
  externalAuditEventDestination?: Maybe<InstanceAuditEventStreamingDestination>;
};

/** Autogenerated input type of InstanceAuditEventStreamingDestinationsDelete */
export type InstanceAuditEventStreamingDestinationsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the audit events external streaming destination to delete. */
  id: Scalars['AuditEventsInstanceExternalStreamingDestinationID']['input'];
};

/** Autogenerated return type of InstanceAuditEventStreamingDestinationsDelete. */
export type InstanceAuditEventStreamingDestinationsDeletePayload = {
  __typename?: 'InstanceAuditEventStreamingDestinationsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of InstanceAuditEventStreamingDestinationsUpdate */
export type InstanceAuditEventStreamingDestinationsUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Destination category. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination config. */
  config?: InputMaybe<Scalars['JSON']['input']>;
  /** ID of external audit event destination to update. */
  id: Scalars['AuditEventsInstanceExternalStreamingDestinationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Secret token. */
  secretToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of InstanceAuditEventStreamingDestinationsUpdate. */
export type InstanceAuditEventStreamingDestinationsUpdatePayload = {
  __typename?: 'InstanceAuditEventStreamingDestinationsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated destination. */
  externalAuditEventDestination?: Maybe<InstanceAuditEventStreamingDestination>;
};

/** Represents an external resource to send instance audit events to */
export type InstanceExternalAuditEventDestination = ExternalAuditEventDestinationInterface & {
  __typename?: 'InstanceExternalAuditEventDestination';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String']['output'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']['output']>;
  /** List of additional HTTP headers sent with each event. */
  headers: AuditEventsStreamingInstanceHeaderConnection;
  /** ID of the destination. */
  id: Scalars['ID']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String']['output'];
};


/** Represents an external resource to send instance audit events to */
export type InstanceExternalAuditEventDestinationHeadersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for InstanceExternalAuditEventDestination. */
export type InstanceExternalAuditEventDestinationConnection = {
  __typename?: 'InstanceExternalAuditEventDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstanceExternalAuditEventDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InstanceExternalAuditEventDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationCreate */
export type InstanceExternalAuditEventDestinationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination URL. */
  destinationUrl: Scalars['String']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationCreate. */
export type InstanceExternalAuditEventDestinationCreatePayload = {
  __typename?: 'InstanceExternalAuditEventDestinationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Destination created. */
  instanceExternalAuditEventDestination?: Maybe<InstanceExternalAuditEventDestination>;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationDestroy */
export type InstanceExternalAuditEventDestinationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the external instance audit event destination to destroy. */
  id: Scalars['AuditEventsInstanceExternalAuditEventDestinationID']['input'];
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationDestroy. */
export type InstanceExternalAuditEventDestinationDestroyPayload = {
  __typename?: 'InstanceExternalAuditEventDestinationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type InstanceExternalAuditEventDestinationEdge = {
  __typename?: 'InstanceExternalAuditEventDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InstanceExternalAuditEventDestination>;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationUpdate */
export type InstanceExternalAuditEventDestinationUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Destination URL to change. */
  destinationUrl?: InputMaybe<Scalars['String']['input']>;
  /** ID of the external instance audit event destination to update. */
  id: Scalars['AuditEventsInstanceExternalAuditEventDestinationID']['input'];
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationUpdate. */
export type InstanceExternalAuditEventDestinationUpdatePayload = {
  __typename?: 'InstanceExternalAuditEventDestinationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated destination. */
  instanceExternalAuditEventDestination?: Maybe<InstanceExternalAuditEventDestination>;
};

/** Autogenerated input type of InstanceGoogleCloudLoggingConfigurationCreate */
export type InstanceGoogleCloudLoggingConfigurationCreateInput = {
  /** Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials. */
  clientEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName: Scalars['String']['input'];
  /** Unique identifier used to distinguish and manage different logs within the same Google Cloud project.(defaults to `audit_events`). */
  logIdName?: InputMaybe<Scalars['String']['input']>;
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service. */
  privateKey: Scalars['String']['input'];
};

/** Autogenerated return type of InstanceGoogleCloudLoggingConfigurationCreate. */
export type InstanceGoogleCloudLoggingConfigurationCreatePayload = {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** configuration created. */
  instanceGoogleCloudLoggingConfiguration?: Maybe<InstanceGoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of InstanceGoogleCloudLoggingConfigurationDestroy */
export type InstanceGoogleCloudLoggingConfigurationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Google Cloud logging configuration to destroy. */
  id: Scalars['AuditEventsInstanceGoogleCloudLoggingConfigurationID']['input'];
};

/** Autogenerated return type of InstanceGoogleCloudLoggingConfigurationDestroy. */
export type InstanceGoogleCloudLoggingConfigurationDestroyPayload = {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Stores instance level Google Cloud Logging configurations associated with IAM service accounts,used for generating access tokens. */
export type InstanceGoogleCloudLoggingConfigurationType = GoogleCloudLoggingConfigurationInterface & {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationType';
  /** Active status of the destination. */
  active: Scalars['Boolean']['output'];
  /** Client email. */
  clientEmail: Scalars['String']['output'];
  /** Google project ID. */
  googleProjectIdName: Scalars['String']['output'];
  /** ID of the configuration. */
  id: Scalars['ID']['output'];
  /** Log ID. */
  logIdName: Scalars['String']['output'];
  /** Name of the external destination to send audit events to. */
  name: Scalars['String']['output'];
};

/** The connection type for InstanceGoogleCloudLoggingConfigurationType. */
export type InstanceGoogleCloudLoggingConfigurationTypeConnection = {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstanceGoogleCloudLoggingConfigurationTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InstanceGoogleCloudLoggingConfigurationType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InstanceGoogleCloudLoggingConfigurationTypeEdge = {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InstanceGoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of InstanceGoogleCloudLoggingConfigurationUpdate */
export type InstanceGoogleCloudLoggingConfigurationUpdateInput = {
  /** Active status of the destination. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials. */
  clientEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName?: InputMaybe<Scalars['String']['input']>;
  /** ID of the instance google Cloud configuration to update. */
  id: Scalars['AuditEventsInstanceGoogleCloudLoggingConfigurationID']['input'];
  /** Unique identifier used to distinguish and manage different logs within the same Google Cloud project. */
  logIdName?: InputMaybe<Scalars['String']['input']>;
  /** Destination name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service. */
  privateKey?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of InstanceGoogleCloudLoggingConfigurationUpdate. */
export type InstanceGoogleCloudLoggingConfigurationUpdatePayload = {
  __typename?: 'InstanceGoogleCloudLoggingConfigurationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** configuration updated. */
  instanceGoogleCloudLoggingConfiguration?: Maybe<InstanceGoogleCloudLoggingConfigurationType>;
};

export type InstanceSecurityDashboard = {
  __typename?: 'InstanceSecurityDashboard';
  /** Cluster agents associated with projects selected in the Instance Security Dashboard. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Projects selected in Instance Security Dashboard. */
  projects: ProjectConnection;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades: Array<VulnerableProjectsByGrade>;
  /** Vulnerability scanners reported on the vulnerabilities from projects selected in Instance Security Dashboard. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity from projects selected in Instance Security Dashboard. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
};


export type InstanceSecurityDashboardClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasRemoteDevelopmentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  hasWorkspacesAgentConfig?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type InstanceSecurityDashboardProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type InstanceSecurityDashboardVulnerabilityGradesArgs = {
  letterGrade?: InputMaybe<VulnerabilityGrade>;
};


export type InstanceSecurityDashboardVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type InstanceSecurityDashboardVulnerabilitySeveritiesCountArgs = {
  capped?: InputMaybe<Scalars['Boolean']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};

/** An expression with an integer value. */
export type IntegerExpression = ExpressionInterface & {
  __typename?: 'IntegerExpression';
  /** Field the expression applies to. */
  field: Scalars['String']['output'];
  /** Operator of the expression. */
  operator: Scalars['String']['output'];
  /** Integer value of the expression. */
  value: Scalars['Int']['output'];
};

/** An integration to override the level settings of instance specific integrations. */
export type IntegrationExclusion = {
  __typename?: 'IntegrationExclusion';
  /** Group that has been excluded from the instance specific integration. */
  group?: Maybe<Group>;
  /** Project that has been excluded from the instance specific integration. */
  project?: Maybe<Project>;
};

/** The connection type for IntegrationExclusion. */
export type IntegrationExclusionConnection = {
  __typename?: 'IntegrationExclusionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IntegrationExclusionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IntegrationExclusion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IntegrationExclusionCreate */
export type IntegrationExclusionCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of groups to exclude up to a maximum of 100. */
  groupIds?: InputMaybe<Array<Scalars['GroupID']['input']>>;
  /** Type of integration to exclude. */
  integrationName: IntegrationType;
  /** IDs of projects to exclude up to a maximum of 100. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** Autogenerated return type of IntegrationExclusionCreate. */
export type IntegrationExclusionCreatePayload = {
  __typename?: 'IntegrationExclusionCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Integration exclusions created by the mutation. */
  exclusions?: Maybe<Array<IntegrationExclusion>>;
};

/** Autogenerated input type of IntegrationExclusionDelete */
export type IntegrationExclusionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of excluded groups. */
  groupIds?: InputMaybe<Array<Scalars['GroupID']['input']>>;
  /** Type of integration. */
  integrationName: IntegrationType;
  /** IDs of excluded projects. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** Autogenerated return type of IntegrationExclusionDelete. */
export type IntegrationExclusionDeletePayload = {
  __typename?: 'IntegrationExclusionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project no longer excluded due to the mutation. */
  exclusions?: Maybe<Array<IntegrationExclusion>>;
};

/** An edge in a connection. */
export type IntegrationExclusionEdge = {
  __typename?: 'IntegrationExclusionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IntegrationExclusion>;
};

/** Integration Names */
export type IntegrationType =
  /** Beyond Identity. */
  | 'BEYOND_IDENTITY';

/** Represents an issuable. */
export type Issuable = Epic | Issue | MergeRequest | WorkItem;

/** Describes an issuable resource link for incident issues */
export type IssuableResourceLink = {
  __typename?: 'IssuableResourceLink';
  /** ID of the Issuable resource link. */
  id: Scalars['IncidentManagementIssuableResourceLinkID']['output'];
  /** Incident of the resource link. */
  issue: Issue;
  /** Web Link to the resource. */
  link: Scalars['String']['output'];
  /** Optional text for the link. */
  linkText?: Maybe<Scalars['String']['output']>;
  /** Type of the resource link. */
  linkType: IssuableResourceLinkType;
};

/** The connection type for IssuableResourceLink. */
export type IssuableResourceLinkConnection = {
  __typename?: 'IssuableResourceLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssuableResourceLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssuableResourceLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IssuableResourceLinkCreate */
export type IssuableResourceLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Incident id to associate the resource link with. */
  id: Scalars['IssueID']['input'];
  /** Link of the resource. */
  link: Scalars['String']['input'];
  /** Link text of the resource. */
  linkText?: InputMaybe<Scalars['String']['input']>;
  /** Link type of the resource. */
  linkType?: InputMaybe<IssuableResourceLinkType>;
};

/** Autogenerated return type of IssuableResourceLinkCreate. */
export type IssuableResourceLinkCreatePayload = {
  __typename?: 'IssuableResourceLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** Autogenerated input type of IssuableResourceLinkDestroy */
export type IssuableResourceLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Issuable resource link ID to remove. */
  id: Scalars['IncidentManagementIssuableResourceLinkID']['input'];
};

/** Autogenerated return type of IssuableResourceLinkDestroy. */
export type IssuableResourceLinkDestroyPayload = {
  __typename?: 'IssuableResourceLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** An edge in a connection. */
export type IssuableResourceLinkEdge = {
  __typename?: 'IssuableResourceLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IssuableResourceLink>;
};

/** Issuable resource link type enum */
export type IssuableResourceLinkType =
  /** General link type */
  | 'general'
  /** Pagerduty link type */
  | 'pagerduty'
  /** Slack link type */
  | 'slack'
  /** Zoom link type */
  | 'zoom';

/** Fields to perform the search in */
export type IssuableSearchableField =
  /** Search in description field. */
  | 'DESCRIPTION'
  /** Search in title field. */
  | 'TITLE';

/** Incident severity */
export type IssuableSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** State of a GitLab issue or merge request */
export type IssuableState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** In open state. */
  | 'opened';

export type Issue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'Issue';
  /**
   * Alert associated to the issue. Deprecated in GitLab 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in GitLab 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean']['output'];
  /** Count of issues blocking the issue. */
  blockedByCount?: Maybe<Scalars['Int']['output']>;
  /** Issues blocking the issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues the issue is blocking. */
  blockingCount: Scalars['Int']['output'];
  /** Issue the issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean']['output'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time']['output'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Collection of design images associated with the issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int']['output'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled. Deprecated in GitLab 16.3: Use `emails_enabled`.
   * @deprecated Use `emails_enabled`. Deprecated in GitLab 16.3.
   */
  emailsDisabled: Scalars['Boolean']['output'];
  /** Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled. */
  emailsEnabled: Scalars['Boolean']['output'];
  /**
   * Epic to which the issue belongs. Deprecated in GitLab 17.5: Replaced by WorkItem type.
   * @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5.
   */
  epic?: Maybe<Epic>;
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /** Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated. */
  externalAuthor?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean']['output'];
  /**
   * Indicates if the issue has a parent work item. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  hasParent: Scalars['Boolean']['output'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /** Indicates the issue is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']['output']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']['output']>;
  /** ID of the issue. */
  id: Scalars['ID']['output'];
  /** Internal ID of the issue. */
  iid: Scalars['String']['output'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /**
   * Work items linked to the issue. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  linkedWorkItems?: Maybe<LinkedWorkItemTypeConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int']['output'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']['output']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId?: Maybe<Scalars['Int']['output']>;
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /** Merge requests related to the issue. This field can only be resolved for one issue in any single request. */
  relatedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Related vulnerabilities of the issue. */
  relatedVulnerabilities?: Maybe<VulnerabilityConnection>;
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']['output']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']['output']>;
  /** State of the issue. */
  state: IssueState;
  /**
   * Status of the issue. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  status?: Maybe<WorkItemStatus>;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean']['output'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int']['output'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Total time (in seconds) reported as spent on the issue. */
  totalTimeSpent: Scalars['Int']['output'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int']['output'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int']['output'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String']['output'];
  /** Web URL of the issue. */
  webUrl: Scalars['String']['output'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']['output']>;
};


export type IssueAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type IssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type IssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueIssuableResourceLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  incidentId: Scalars['IssueID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueLinkedWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WorkItemRelatedLinkType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};


export type IssueRelatedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueRelatedVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type IssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Issue. */
export type IssueConnection = {
  __typename?: 'IssueConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int']['output'];
};


/** The connection type for Issue. */
export type IssueConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Iteration ID wildcard values for issue creation */
export type IssueCreationIterationWildcardId =
  /** Current iteration. */
  | 'CURRENT';

/** An edge in a connection. */
export type IssueEdge = {
  __typename?: 'IssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Issue>;
};

/** Issue escalation status values */
export type IssueEscalationStatus =
  /** Someone is actively investigating the problem. */
  | 'ACKNOWLEDGED'
  /** No action will be taken. */
  | 'IGNORED'
  /** The problem has been addressed. */
  | 'RESOLVED'
  /** Investigation has not started. */
  | 'TRIGGERED';

/** Autogenerated input type of IssueLinkAlerts */
export type IssueLinkAlertsInput = {
  /** Alerts references to be linked to the incident. */
  alertReferences: Array<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueLinkAlerts. */
export type IssueLinkAlertsPayload = {
  __typename?: 'IssueLinkAlertsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueMove */
export type IssueMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Project to move the issue to. */
  targetProjectPath: Scalars['ID']['input'];
};

/** Autogenerated input type of IssueMoveList */
export type IssueMoveListInput = {
  /** Global ID of the board that the issue is in. */
  boardId: Scalars['BoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the board list that the issue will be moved from. */
  fromListId?: InputMaybe<Scalars['ID']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['ID']['input']>;
  /** Position of issue within the board list. Positions start at 0. Use -1 to move to the end of the list. */
  positionInList?: InputMaybe<Scalars['Int']['input']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** ID of the board list that the issue will be moved to. */
  toListId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of IssueMoveList. */
export type IssueMoveListPayload = {
  __typename?: 'IssueMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated return type of IssueMove. */
export type IssueMovePayload = {
  __typename?: 'IssueMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Check permissions for the current user on a issue */
export type IssuePermissions = {
  __typename?: 'IssuePermissions';
  /** If `true`, the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_issue_relation` on this resource */
  adminIssueRelation: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `clone_issue` on this resource */
  cloneIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `move_design` on this resource */
  moveDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `move_issue` on this resource */
  moveIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_issue` on this resource */
  readIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `reopen_issue` on this resource */
  reopenIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_design` on this resource */
  updateDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_issue` on this resource */
  updateIssue: Scalars['Boolean']['output'];
};

/** Autogenerated input type of IssueSetAssignees */
export type IssueSetAssigneesInput = {
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetAssignees. */
export type IssueSetAssigneesPayload = {
  __typename?: 'IssueSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetConfidential */
export type IssueSetConfidentialInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not to set the issue as a confidential. */
  confidential: Scalars['Boolean']['input'];
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetConfidential. */
export type IssueSetConfidentialPayload = {
  __typename?: 'IssueSetConfidentialPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetCrmContacts */
export type IssueSetCrmContactsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Customer relations contact IDs to set. Replaces existing contacts by default. */
  contactIds: Array<Scalars['CustomerRelationsContactID']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Changes the operation mode. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetCrmContacts. */
export type IssueSetCrmContactsPayload = {
  __typename?: 'IssueSetCrmContactsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetDueDate */
export type IssueSetDueDateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired due date for the issue. Due date is removed if null. */
  dueDate?: InputMaybe<Scalars['Time']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetDueDate. */
export type IssueSetDueDatePayload = {
  __typename?: 'IssueSetDueDatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEpic */
export type IssueSetEpicInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetEpic. */
export type IssueSetEpicPayload = {
  __typename?: 'IssueSetEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationPolicy */
export type IssueSetEscalationPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the escalation policy to assign to the issue. Policy will be removed if absent or set to null. */
  escalationPolicyId?: InputMaybe<Scalars['IncidentManagementEscalationPolicyID']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetEscalationPolicy. */
export type IssueSetEscalationPolicyPayload = {
  __typename?: 'IssueSetEscalationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationStatus */
export type IssueSetEscalationStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Set the escalation status. */
  status: IssueEscalationStatus;
};

/** Autogenerated return type of IssueSetEscalationStatus. */
export type IssueSetEscalationStatusPayload = {
  __typename?: 'IssueSetEscalationStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetIteration */
export type IssueSetIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /**
   * Iteration to assign to the issue.
   *
   */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetIteration. */
export type IssueSetIterationPayload = {
  __typename?: 'IssueSetIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetLocked */
export type IssueSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Whether or not to lock discussion on the issue. */
  locked: Scalars['Boolean']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueSetLocked. */
export type IssueSetLockedPayload = {
  __typename?: 'IssueSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSeverity */
export type IssueSetSeverityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Set the incident severity level. */
  severity: IssuableSeverity;
};

/** Autogenerated return type of IssueSetSeverity. */
export type IssueSetSeverityPayload = {
  __typename?: 'IssueSetSeverityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSubscription */
export type IssueSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean']['input'];
};

/** Autogenerated return type of IssueSetSubscription. */
export type IssueSetSubscriptionPayload = {
  __typename?: 'IssueSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetWeight */
export type IssueSetWeightInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** The desired weight for the issue. If set to null, weight is removed. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of IssueSetWeight. */
export type IssueSetWeightPayload = {
  __typename?: 'IssueSetWeightPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Values for sorting issues */
export type IssueSort =
  /** Blocking issues count by ascending order. */
  | 'BLOCKING_ISSUES_ASC'
  /** Blocking issues count by descending order. */
  | 'BLOCKING_ISSUES_DESC'
  /** Closed time by ascending order. */
  | 'CLOSED_AT_ASC'
  /** Closed time by descending order. */
  | 'CLOSED_AT_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Due date by ascending order. */
  | 'DUE_DATE_ASC'
  /** Due date by descending order. */
  | 'DUE_DATE_DESC'
  /** Status from triggered to resolved. */
  | 'ESCALATION_STATUS_ASC'
  /** Status from resolved to triggered. */
  | 'ESCALATION_STATUS_DESC'
  /** Issues with healthy issues first. */
  | 'HEALTH_STATUS_ASC'
  /** Issues with unhealthy issues first. */
  | 'HEALTH_STATUS_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** Number of upvotes (awarded "thumbs up" emoji) by ascending order. */
  | 'POPULARITY_ASC'
  /** Number of upvotes (awarded "thumbs up" emoji) by descending order. */
  | 'POPULARITY_DESC'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** Published issues shown last. */
  | 'PUBLISHED_ASC'
  /** Published issues shown first. */
  | 'PUBLISHED_DESC'
  /** Relative position by ascending order. */
  | 'RELATIVE_POSITION_ASC'
  /** Severity from less critical to more critical. */
  | 'SEVERITY_ASC'
  /** Severity from more critical to less critical. */
  | 'SEVERITY_DESC'
  /** Issues with earliest SLA due time shown first. */
  | 'SLA_DUE_AT_ASC'
  /** Issues with latest SLA due time shown first. */
  | 'SLA_DUE_AT_DESC'
  /** Status by ascending order. Introduced in GitLab 18.4: **Status**: Experiment. */
  | 'STATUS_ASC'
  /** Status by descending order. Introduced in GitLab 18.4: **Status**: Experiment. */
  | 'STATUS_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Weight by ascending order. */
  | 'WEIGHT_ASC'
  /** Weight by descending order. */
  | 'WEIGHT_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** State of a GitLab issue */
export type IssueState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** In open state. */
  | 'opened';

/** Values for issue state events */
export type IssueStateEvent =
  /** Closes the issue. */
  | 'CLOSE'
  /** Reopens the issue. */
  | 'REOPEN';

/** Represents total number of issues for the represented statuses */
export type IssueStatusCountsType = {
  __typename?: 'IssueStatusCountsType';
  /** Number of issues with status ALL for the project */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of issues with status CLOSED for the project */
  closed?: Maybe<Scalars['Int']['output']>;
  /** Number of issues with status OPENED for the project */
  opened?: Maybe<Scalars['Int']['output']>;
};

/** Issue type */
export type IssueType =
  /** Epic issue type. Available only when feature epics is available. Introduced in GitLab 16.7: **Status**: Experiment. */
  | 'EPIC'
  /** Incident issue type */
  | 'INCIDENT'
  /** Issue issue type */
  | 'ISSUE'
  /** Key Result issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in GitLab 15.7: **Status**: Experiment. */
  | 'KEY_RESULT'
  /** Objective issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in GitLab 15.6: **Status**: Experiment. */
  | 'OBJECTIVE'
  /** Requirement issue type */
  | 'REQUIREMENT'
  /** Task issue type */
  | 'TASK'
  /** Test Case issue type */
  | 'TEST_CASE'
  /** Ticket issue type */
  | 'TICKET';

/** Autogenerated input type of IssueUnlinkAlert */
export type IssueUnlinkAlertInput = {
  /** Global ID of the alert to unlink from the incident. */
  alertId: Scalars['AlertManagementAlertID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of IssueUnlinkAlert. */
export type IssueUnlinkAlertPayload = {
  __typename?: 'IssueUnlinkAlertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

export type ItemConsumerTargetInput = {
  /** Group in which to configure the item. */
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  /** Project in which to configure the item. */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
};

/** Represents an iteration object */
export type Iteration = TimeboxReportInterface & {
  __typename?: 'Iteration';
  /** Timestamp of iteration creation. */
  createdAt: Scalars['Time']['output'];
  /** Description of the iteration. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the iteration due date. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /** ID of the iteration. */
  id: Scalars['ID']['output'];
  /** Internal ID of the iteration. */
  iid: Scalars['String']['output'];
  /** Cadence of the iteration. */
  iterationCadence: IterationCadence;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Web path of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedPath?: Maybe<Scalars['String']['output']>;
  /** Web URL of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedUrl?: Maybe<Scalars['String']['output']>;
  /** Sequence number for the iteration when you sort the containing cadence's iterations by the start and end date. The earliest starting and ending iteration is assigned 1. */
  sequence: Scalars['Int']['output'];
  /** Timestamp of the iteration start date. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** State of the iteration. */
  state: IterationState;
  /** Title of the iteration. */
  title?: Maybe<Scalars['String']['output']>;
  /** Timestamp of last iteration update. */
  updatedAt: Scalars['Time']['output'];
  /** Web path of the iteration. */
  webPath: Scalars['String']['output'];
  /** Web URL of the iteration. */
  webUrl: Scalars['String']['output'];
};


/** Represents an iteration object */
export type IterationReportArgs = {
  fullPath?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an iteration cadence */
export type IterationCadence = {
  __typename?: 'IterationCadence';
  /** Whether the iteration cadence is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: Maybe<Scalars['String']['output']>;
  /** Duration in weeks of the iterations within the cadence. */
  durationInWeeks?: Maybe<Scalars['Int']['output']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID']['output'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: Maybe<Scalars['Int']['output']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver: Scalars['Boolean']['output'];
  /** Timestamp of the automation start date. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** Title of the iteration cadence. */
  title: Scalars['String']['output'];
};

/** The connection type for IterationCadence. */
export type IterationCadenceConnection = {
  __typename?: 'IterationCadenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationCadenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IterationCadence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IterationCadenceCreate */
export type IterationCadenceCreateInput = {
  /** Whether the iteration cadence is active. */
  active: Scalars['Boolean']['input'];
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Duration in weeks of the iterations within the cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']['input']>;
  /** Group where the iteration cadence is created. */
  groupPath: Scalars['ID']['input'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IterationCadenceCreate. */
export type IterationCadenceCreatePayload = {
  __typename?: 'IterationCadenceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceDestroy */
export type IterationCadenceDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID']['input'];
};

/** Autogenerated return type of IterationCadenceDestroy. */
export type IterationCadenceDestroyPayload = {
  __typename?: 'IterationCadenceDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group the iteration cadence belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationCadenceEdge = {
  __typename?: 'IterationCadenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceUpdate */
export type IterationCadenceUpdateInput = {
  /** Whether the iteration cadence is active. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Duration in weeks of the iterations within the cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']['input']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID']['input'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IterationCadenceUpdate. */
export type IterationCadenceUpdatePayload = {
  __typename?: 'IterationCadenceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** The connection type for Iteration. */
export type IterationConnection = {
  __typename?: 'IterationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Iteration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IterationDelete */
export type IterationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the iteration. */
  id: Scalars['IterationID']['input'];
};

/** Autogenerated return type of IterationDelete. */
export type IterationDeletePayload = {
  __typename?: 'IterationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Group the iteration belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationEdge = {
  __typename?: 'IterationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Iteration>;
};

/** Fields to perform the search in */
export type IterationSearchableField =
  /** Search in cadence_title field. */
  | 'CADENCE_TITLE'
  /** Search in title field. */
  | 'TITLE';

/** Iteration sort values */
export type IterationSort =
  /** Sort by cadence id in ascending and due date in ascending order. */
  | 'CADENCE_AND_DUE_DATE_ASC'
  /** Sort by cadence id in ascending and due date in descending order. */
  | 'CADENCE_AND_DUE_DATE_DESC';

/** State of a GitLab iteration */
export type IterationState =
  /** Any iteration. */
  | 'all'
  /** Closed iteration. */
  | 'closed'
  /** Current iteration. */
  | 'current'
  /** Open iteration. */
  | 'opened'
  /** Upcoming iteration. */
  | 'upcoming';

/** Iteration ID wildcard values */
export type IterationWildcardId =
  /** An iteration is assigned. */
  | 'ANY'
  /** Current iteration. */
  | 'CURRENT'
  /** No iteration is assigned. */
  | 'NONE';

export type JiraImport = {
  __typename?: 'JiraImport';
  /** Timestamp of when the Jira import was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Count of issues that failed to import. */
  failedToImportCount: Scalars['Int']['output'];
  /** Count of issues that were successfully imported. */
  importedIssuesCount: Scalars['Int']['output'];
  /** Project key for the imported Jira project. */
  jiraProjectKey: Scalars['String']['output'];
  /** Timestamp of when the Jira import was scheduled. */
  scheduledAt?: Maybe<Scalars['Time']['output']>;
  /** User that started the Jira import. */
  scheduledBy?: Maybe<UserCore>;
  /** Total count of issues that were attempted to import. */
  totalIssueCount: Scalars['Int']['output'];
};

/** The connection type for JiraImport. */
export type JiraImportConnection = {
  __typename?: 'JiraImportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraImportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraImport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraImportEdge = {
  __typename?: 'JiraImportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportStart */
export type JiraImportStartInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project key of the importer Jira project. */
  jiraProjectKey: Scalars['String']['input'];
  /** Project to import the Jira project into. */
  projectPath: Scalars['ID']['input'];
  /** Mapping of Jira to GitLab users. */
  usersMapping?: InputMaybe<Array<JiraUsersMappingInputType>>;
};

/** Autogenerated return type of JiraImportStart. */
export type JiraImportStartPayload = {
  __typename?: 'JiraImportStartPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Jira import data after mutation. */
  jiraImport?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportUsers */
export type JiraImportUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project to import the Jira users into. */
  projectPath: Scalars['ID']['input'];
  /** Index of the record the import should started at, default 0 (50 records returned). */
  startAt?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of JiraImportUsers. */
export type JiraImportUsersPayload = {
  __typename?: 'JiraImportUsersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Users returned from Jira, matched by email and name if possible. */
  jiraUsers?: Maybe<Array<JiraUser>>;
};

export type JiraProject = {
  __typename?: 'JiraProject';
  /** Key of the Jira project. */
  key: Scalars['String']['output'];
  /** Name of the Jira project. */
  name?: Maybe<Scalars['String']['output']>;
  /** ID of the Jira project. */
  projectId: Scalars['Int']['output'];
};

/** The connection type for JiraProject. */
export type JiraProjectConnection = {
  __typename?: 'JiraProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraProjectEdge = {
  __typename?: 'JiraProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraProject>;
};

export type JiraService = Service & {
  __typename?: 'JiraService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** List of all Jira projects fetched through Jira REST API. */
  projects?: Maybe<JiraProjectConnection>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']['output']>;
};


export type JiraServiceProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type JiraUser = {
  __typename?: 'JiraUser';
  /** ID of the matched GitLab user. */
  gitlabId?: Maybe<Scalars['Int']['output']>;
  /** Name of the matched GitLab user. */
  gitlabName?: Maybe<Scalars['String']['output']>;
  /** Username of the matched GitLab user. */
  gitlabUsername?: Maybe<Scalars['String']['output']>;
  /** Account ID of the Jira user. */
  jiraAccountId: Scalars['String']['output'];
  /** Display name of the Jira user. */
  jiraDisplayName: Scalars['String']['output'];
  /** Email of the Jira user, returned only for users with public emails. */
  jiraEmail?: Maybe<Scalars['String']['output']>;
};

export type JiraUsersMappingInputType = {
  /** ID of the GitLab user. */
  gitlabId?: InputMaybe<Scalars['Int']['input']>;
  /** Jira account ID of the user. */
  jiraAccountId: Scalars['String']['input'];
};

export type JobArtifactFileType =
  /** ACCESSIBILITY job artifact file type. */
  | 'ACCESSIBILITY'
  /** ANNOTATIONS job artifact file type. */
  | 'ANNOTATIONS'
  /** API FUZZING job artifact file type. */
  | 'API_FUZZING'
  /** ARCHIVE job artifact file type. */
  | 'ARCHIVE'
  /** BROWSER PERFORMANCE job artifact file type. */
  | 'BROWSER_PERFORMANCE'
  /** CLUSTER APPLICATIONS job artifact file type. */
  | 'CLUSTER_APPLICATIONS'
  /** CLUSTER IMAGE SCANNING job artifact file type. */
  | 'CLUSTER_IMAGE_SCANNING'
  /** COBERTURA job artifact file type. */
  | 'COBERTURA'
  /** CODE QUALITY job artifact file type. */
  | 'CODEQUALITY'
  /** CONTAINER SCANNING job artifact file type. */
  | 'CONTAINER_SCANNING'
  /** COVERAGE FUZZING job artifact file type. */
  | 'COVERAGE_FUZZING'
  /** CYCLONEDX job artifact file type. */
  | 'CYCLONEDX'
  /** DAST job artifact file type. */
  | 'DAST'
  /** DEPENDENCY SCANNING job artifact file type. */
  | 'DEPENDENCY_SCANNING'
  /** DOTENV job artifact file type. */
  | 'DOTENV'
  /** JACOCO job artifact file type. */
  | 'JACOCO'
  /** JUNIT job artifact file type. */
  | 'JUNIT'
  /** LICENSE SCANNING job artifact file type. */
  | 'LICENSE_SCANNING'
  /** LOAD PERFORMANCE job artifact file type. */
  | 'LOAD_PERFORMANCE'
  /** LSIF job artifact file type. */
  | 'LSIF'
  /** METADATA job artifact file type. */
  | 'METADATA'
  /** METRICS job artifact file type. */
  | 'METRICS'
  /** METRICS REFEREE job artifact file type. */
  | 'METRICS_REFEREE'
  /** NETWORK REFEREE job artifact file type. */
  | 'NETWORK_REFEREE'
  /** PERFORMANCE job artifact file type. */
  | 'PERFORMANCE'
  /** REPOSITORY XRAY job artifact file type. */
  | 'REPOSITORY_XRAY'
  /** REQUIREMENTS job artifact file type. */
  | 'REQUIREMENTS'
  /** REQUIREMENTS V2 job artifact file type. */
  | 'REQUIREMENTS_V2'
  /** SAST job artifact file type. */
  | 'SAST'
  /** SCIP job artifact file type. */
  | 'SCIP'
  /** SECRET DETECTION job artifact file type. */
  | 'SECRET_DETECTION'
  /** TERRAFORM job artifact file type. */
  | 'TERRAFORM'
  /** TRACE job artifact file type. */
  | 'TRACE';

/** Represents the Geo replication and verification state of a job_artifact. */
export type JobArtifactRegistry = {
  __typename?: 'JobArtifactRegistry';
  /** ID of the Job Artifact. */
  artifactId: Scalars['ID']['output'];
  /** Indicate if the checksums of the JobArtifactRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the JobArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the JobArtifactRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the JobArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the JobArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the JobArtifactRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the JobArtifactRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the JobArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the JobArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the JobArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the JobArtifactRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the JobArtifactRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the JobArtifactRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the JobArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the JobArtifactRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of JobArtifactRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the JobArtifactRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the JobArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for JobArtifactRegistry. */
export type JobArtifactRegistryConnection = {
  __typename?: 'JobArtifactRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for JobArtifactRegistry. */
export type JobArtifactRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type JobArtifactRegistryEdge = {
  __typename?: 'JobArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<JobArtifactRegistry>;
};

/** Autogenerated input type of JobArtifactsDestroy */
export type JobArtifactsDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID']['input'];
};

/** Autogenerated return type of JobArtifactsDestroy. */
export type JobArtifactsDestroyPayload = {
  __typename?: 'JobArtifactsDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Number of artifacts deleted. */
  destroyedArtifactsCount: Scalars['Int']['output'];
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Job with artifacts to be deleted. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobCancel */
export type JobCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID']['input'];
};

/** Autogenerated return type of JobCancel. */
export type JobCancelPayload = {
  __typename?: 'JobCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type JobNeedUnion = CiBuildNeed | CiJob;

/** The connection type for JobNeedUnion. */
export type JobNeedUnionConnection = {
  __typename?: 'JobNeedUnionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobNeedUnionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobNeedUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JobNeedUnionEdge = {
  __typename?: 'JobNeedUnionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<JobNeedUnion>;
};

export type JobPermissions = {
  __typename?: 'JobPermissions';
  /** If `true`, the user can perform `cancel_build` on this resource */
  cancelBuild: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_build` on this resource */
  readBuild: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_job_artifacts` on this resource */
  readJobArtifacts: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_build` on this resource */
  updateBuild: Scalars['Boolean']['output'];
};

/** Autogenerated input type of JobPlay */
export type JobPlayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the job to mutate. */
  id: Scalars['CiProcessableID']['input'];
  /** Variables to use when playing a manual job. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of JobPlay. */
export type JobPlayPayload = {
  __typename?: 'JobPlayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobRetry */
export type JobRetryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the job to mutate. */
  id: Scalars['CiProcessableID']['input'];
  /** Inputs to use when retrying the job. */
  inputs?: InputMaybe<Array<CiInputsInput>>;
  /** Variables to use when retrying a manual job. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of JobRetry. */
export type JobRetryPayload = {
  __typename?: 'JobRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobUnschedule */
export type JobUnscheduleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID']['input'];
};

/** Autogenerated return type of JobUnschedule. */
export type JobUnschedulePayload = {
  __typename?: 'JobUnschedulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type Kas = {
  __typename?: 'Kas';
  /** Indicates whether the Kubernetes agent server is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy. */
  externalK8sProxyUrl?: Maybe<Scalars['String']['output']>;
  /** URL used by the agents to communicate with the server. */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** KAS version. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Represents an SSH key. */
export type Key = Todoable & {
  __typename?: 'Key';
  /** Timestamp of when the key was created. */
  createdAt: Scalars['Time']['output'];
  /** Timestamp of when the key expires. It's null if it never expires. */
  expiresAt: Scalars['Time']['output'];
  /** ID of the key. */
  id: Scalars['ID']['output'];
  /** Public key of the key pair. */
  key: Scalars['String']['output'];
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** Title of the key. */
  title: Scalars['String']['output'];
  /** URL of the object. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Annotation to apply to associated Kubernetes objects of a workspace. */
export type KubernetesAnnotation = {
  __typename?: 'KubernetesAnnotation';
  /** Key of the annotation. */
  key: Scalars['String']['output'];
  /** Value of the annotation. */
  value: Scalars['String']['output'];
};

/** Label to apply to associated Kubernetes objects of a workspace. */
export type KubernetesLabel = {
  __typename?: 'KubernetesLabel';
  /** Key of the label. */
  key: Scalars['String']['output'];
  /** Value of the label. */
  value: Scalars['String']['output'];
};

export type Label = LabelInterface & {
  __typename?: 'Label';
  /** Indicates the label is archived. */
  archived: Scalars['Boolean']['output'];
  /** Background color of the label. */
  color: Scalars['String']['output'];
  /** When the label was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the label (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Global ID of the label. */
  id: Scalars['LabelID']['output'];
  /** Indicates this label is locked for merge requests that have been merged. */
  lockOnMerge: Scalars['Boolean']['output'];
  /** Text color of the label. */
  textColor: Scalars['String']['output'];
  /** Content of the label. */
  title: Scalars['String']['output'];
  /** When the label was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for Label. */
export type LabelConnection = {
  __typename?: 'LabelConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Label. */
export type LabelConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of LabelCreate */
export type LabelCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The color of the label given in 6-digit hex notation with leading '#' sign
   * (for example, `#FFAABB`) or one of the CSS color names.
   *
   */
  color?: InputMaybe<Scalars['String']['input']>;
  /** Description of the label. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Title of the label. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of LabelCreate. */
export type LabelCreatePayload = {
  __typename?: 'LabelCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Label after mutation. */
  label?: Maybe<Label>;
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

export type LabelInterface = {
  /** Background color of the label. */
  color: Scalars['String']['output'];
  /** When the label was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the label (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']['output']>;
  /** Text color of the label. */
  textColor: Scalars['String']['output'];
  /** Content of the label. */
  title: Scalars['String']['output'];
  /** When the label was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** List of fields where the provided searchTerm should be looked up */
export type LabelSearchFieldList =
  /** Search in the label description. */
  | 'DESCRIPTION'
  /** Search in the label title. */
  | 'TITLE';

/** Autogenerated input type of LabelUpdate */
export type LabelUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the label to update. */
  id: Scalars['LabelID']['input'];
};

/** Autogenerated return type of LabelUpdate. */
export type LabelUpdatePayload = {
  __typename?: 'LabelUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Label after mutation. */
  label?: Maybe<Label>;
};

/** Represents an instance-level LDAP link. */
export type LdapAdminRoleLink = {
  __typename?: 'LdapAdminRoleLink';
  /** Custom admin member role. */
  adminMemberRole: AdminMemberRole;
  /** Common Name (CN) of the LDAP group. */
  cn?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the role link was created. */
  createdAt: Scalars['Time']['output'];
  /** Search filter for the LDAP group. */
  filter?: Maybe<Scalars['String']['output']>;
  /** ID of the LDAP link. */
  id: Scalars['ID']['output'];
  /** Timestamp of the last successful sync. */
  lastSuccessfulSyncAt?: Maybe<Scalars['Time']['output']>;
  /** LDAP provider for the LDAP link. */
  provider: LdapProvider;
  /** Timestamp of when the last sync ended. */
  syncEndedAt?: Maybe<Scalars['Time']['output']>;
  /** Error message if the sync has failed. */
  syncError?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the last sync started. */
  syncStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the last sync. */
  syncStatus?: Maybe<LdapAdminRoleSyncStatus>;
};

/** The connection type for LdapAdminRoleLink. */
export type LdapAdminRoleLinkConnection = {
  __typename?: 'LdapAdminRoleLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LdapAdminRoleLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LdapAdminRoleLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of LdapAdminRoleLinkCreate */
export type LdapAdminRoleLinkCreateInput = {
  /** Global ID of the custom admin role to be assigned to a user. */
  adminMemberRoleId: Scalars['MemberRoleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Common Name (CN) of the LDAP group. */
  cn?: InputMaybe<Scalars['String']['input']>;
  /** Search filter for the LDAP group. */
  filter?: InputMaybe<Scalars['String']['input']>;
  /** LDAP provider for the LDAP link. */
  provider: Scalars['String']['input'];
};

/** Autogenerated return type of LdapAdminRoleLinkCreate. */
export type LdapAdminRoleLinkCreatePayload = {
  __typename?: 'LdapAdminRoleLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created instance-level LDAP link. */
  ldapAdminRoleLink?: Maybe<LdapAdminRoleLink>;
};

/** Autogenerated input type of LdapAdminRoleLinkDestroy */
export type LdapAdminRoleLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the instance-level LDAP link to delete. */
  id: Scalars['AuthzLdapAdminRoleLinkID']['input'];
};

/** Autogenerated return type of LdapAdminRoleLinkDestroy. */
export type LdapAdminRoleLinkDestroyPayload = {
  __typename?: 'LdapAdminRoleLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted instance-level LDAP link. */
  ldapAdminRoleLink?: Maybe<LdapAdminRoleLink>;
};

/** An edge in a connection. */
export type LdapAdminRoleLinkEdge = {
  __typename?: 'LdapAdminRoleLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LdapAdminRoleLink>;
};

/** All LDAP admin role sync statuses. */
export type LdapAdminRoleSyncStatus =
  /** A sync that is failed. */
  | 'FAILED'
  /** A sync that is never synced. */
  | 'NEVER_SYNCED'
  /** A sync that is queued. */
  | 'QUEUED'
  /** A sync that is running. */
  | 'RUNNING'
  /** A sync that is successful. */
  | 'SUCCESSFUL';

/** Represents a LDAP provider. */
export type LdapProvider = {
  __typename?: 'LdapProvider';
  /** ID of the LDAP provider. */
  id?: Maybe<Scalars['String']['output']>;
  /** Display name of the LDAP provider. */
  label?: Maybe<Scalars['String']['output']>;
};

/** Represents the Geo sync and verification state of an LFS object */
export type LfsObjectRegistry = {
  __typename?: 'LfsObjectRegistry';
  /** Indicate if the checksums of the LfsObjectRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the LfsObjectRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the LfsObjectRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the LfsObjectRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the LfsObjectRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the LFS object. */
  lfsObjectId: Scalars['ID']['output'];
  /** Indicate if the LfsObjectRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the LfsObjectRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the LfsObjectRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the LfsObjectRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the LfsObjectRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the LfsObjectRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the LfsObjectRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the LfsObjectRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the LfsObjectRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the LfsObjectRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of LfsObjectRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the LfsObjectRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the LfsObjectRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for LfsObjectRegistry. */
export type LfsObjectRegistryConnection = {
  __typename?: 'LfsObjectRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LfsObjectRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LfsObjectRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for LfsObjectRegistry. */
export type LfsObjectRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type LfsObjectRegistryEdge = {
  __typename?: 'LfsObjectRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LfsObjectRegistry>;
};

export type License = {
  __typename?: 'License';
  /** Name of the license. */
  name: Scalars['String']['output'];
  /** Policy dismissals associated with the license for the dependency. */
  policyViolations?: Maybe<Array<PolicyDismissal>>;
  /** Name of the SPDX identifier. */
  spdxIdentifier?: Maybe<Scalars['String']['output']>;
  /** License URL in relation to SPDX. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Represents an entry from the Cloud License history */
export type LicenseHistoryEntry = {
  __typename?: 'LicenseHistoryEntry';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']['output']>;
  /** Date when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']['output']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']['output']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']['output']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']['output']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID']['output'];
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']['output']>;
  /** Name of the subscription plan. */
  plan: Scalars['String']['output'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']['output']>;
  /** Type of the license. */
  type: Scalars['String']['output'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for LicenseHistoryEntry. */
export type LicenseHistoryEntryConnection = {
  __typename?: 'LicenseHistoryEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LicenseHistoryEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LicenseHistoryEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LicenseHistoryEntryEdge = {
  __typename?: 'LicenseHistoryEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LicenseHistoryEntry>;
};

/** Autogenerated input type of LifecycleAttachWorkItemType */
export type LifecycleAttachWorkItemTypeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the lifecycle to attach the work item type to. */
  lifecycleId: Scalars['WorkItemsStatusesLifecycleID']['input'];
  /** Namespace path where the lifecycle exists. */
  namespacePath: Scalars['ID']['input'];
  /** Status mappings from the old lifecycle to the new lifecycle. */
  statusMappings?: InputMaybe<Array<StatusMappingInput>>;
  /** Global ID of the work item type to attach to the lifecycle. */
  workItemTypeId: Scalars['WorkItemsTypeID']['input'];
};

/** Autogenerated return type of LifecycleAttachWorkItemType. */
export type LifecycleAttachWorkItemTypePayload = {
  __typename?: 'LifecycleAttachWorkItemTypePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Lifecycle after attaching the work item type. */
  lifecycle?: Maybe<WorkItemLifecycle>;
};

/** Autogenerated input type of LifecycleCreate */
export type LifecycleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Index of the default closed status in the statuses array. */
  defaultClosedStatusIndex: Scalars['Int']['input'];
  /** Index of the default duplicated status in the statuses array. */
  defaultDuplicateStatusIndex: Scalars['Int']['input'];
  /** Index of the default open status in the statuses array. */
  defaultOpenStatusIndex: Scalars['Int']['input'];
  /** Name of the lifecycle. */
  name: Scalars['String']['input'];
  /** Namespace path where the lifecycle will be created. */
  namespacePath: Scalars['ID']['input'];
  /** Statuses of the lifecycle. Can be existing (with id) or new (without id). */
  statuses: Array<WorkItemStatusInput>;
};

/** Autogenerated return type of LifecycleCreate. */
export type LifecycleCreatePayload = {
  __typename?: 'LifecycleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Lifecycle created. */
  lifecycle?: Maybe<WorkItemLifecycle>;
};

/** Autogenerated input type of LifecycleDelete */
export type LifecycleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the lifecycle to delete. */
  id: Scalars['WorkItemsStatusesLifecycleID']['input'];
  /** Namespace path where the lifecycle exists. */
  namespacePath: Scalars['ID']['input'];
};

/** Autogenerated return type of LifecycleDelete. */
export type LifecycleDeletePayload = {
  __typename?: 'LifecycleDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted lifecycle. */
  lifecycle?: Maybe<WorkItemLifecycle>;
};

/** Autogenerated input type of LifecycleUpdate */
export type LifecycleUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Index of the default closed status in the statuses array. */
  defaultClosedStatusIndex?: InputMaybe<Scalars['Int']['input']>;
  /** Index of the default duplicated status in the statuses array. */
  defaultDuplicateStatusIndex?: InputMaybe<Scalars['Int']['input']>;
  /** Index of the default open status in the statuses array. */
  defaultOpenStatusIndex?: InputMaybe<Scalars['Int']['input']>;
  /** Global ID of the lifecycle to be updated. */
  id: Scalars['WorkItemsStatusesLifecycleID']['input'];
  /** Name of the lifecycle. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Namespace path where the lifecycle exists. */
  namespacePath: Scalars['ID']['input'];
  /** Mappings for statuses being removed from the lifecycle. Maps old status to replacement status. */
  statusMappings?: InputMaybe<Array<StatusMappingInput>>;
  /** Statuses of the lifecycle. Can be existing (with id) or new (without id). */
  statuses?: InputMaybe<Array<WorkItemStatusInput>>;
};

/** Autogenerated return type of LifecycleUpdate. */
export type LifecycleUpdatePayload = {
  __typename?: 'LifecycleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Lifecycle updated. */
  lifecycle?: Maybe<WorkItemLifecycle>;
};

/** Autogenerated input type of LinkProjectComplianceViolationIssue */
export type LinkProjectComplianceViolationIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to be linked. */
  issueIid: Scalars['String']['input'];
  /** Full path of the project the issue belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Global ID of the project compliance violation. */
  violationId: Scalars['ComplianceManagementProjectsComplianceViolationID']['input'];
};

/** Autogenerated return type of LinkProjectComplianceViolationIssue. */
export type LinkProjectComplianceViolationIssuePayload = {
  __typename?: 'LinkProjectComplianceViolationIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated project compliance violation. */
  violation?: Maybe<ProjectComplianceViolation>;
};

export type LinkedWorkItemType = {
  __typename?: 'LinkedWorkItemType';
  /** Timestamp the link was created. */
  linkCreatedAt: Scalars['Time']['output'];
  /** Global ID of the link. */
  linkId: Scalars['WorkItemsRelatedWorkItemLinkID']['output'];
  /** Type of link. */
  linkType: Scalars['String']['output'];
  /** Timestamp the link was updated. */
  linkUpdatedAt: Scalars['Time']['output'];
  /** Linked work item. */
  workItem?: Maybe<WorkItem>;
  /** State of the linked work item. */
  workItemState: WorkItemState;
};

/** The connection type for LinkedWorkItemType. */
export type LinkedWorkItemTypeConnection = {
  __typename?: 'LinkedWorkItemTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LinkedWorkItemTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LinkedWorkItemType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LinkedWorkItemTypeEdge = {
  __typename?: 'LinkedWorkItemTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LinkedWorkItemType>;
};

/** List limit metric setting */
export type ListLimitMetric =
  /** Limit list by number and total weight of issues. */
  | 'all_metrics'
  /** Limit list by number of issues. */
  | 'issue_count'
  /** Limit list by total weight of issues. */
  | 'issue_weights';

export type Location = {
  __typename?: 'Location';
  /** Ancestors of the dependency. */
  ancestors?: Maybe<Array<AncestorType>>;
  /** HTTP URI path to view the input file in GitLab. */
  blobPath?: Maybe<Scalars['String']['output']>;
  /** Path, relative to the root of the repository, of the filewhich was analyzed to detect the dependency. */
  path?: Maybe<Scalars['String']['output']>;
  /** Is top level dependency. */
  topLevel?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents links to perform actions on the candidate */
export type MlCandidateLinks = {
  __typename?: 'MLCandidateLinks';
  /** Path to the artifact. */
  artifactPath?: Maybe<Scalars['String']['output']>;
  /** Path to the details page of the candidate. */
  showPath?: Maybe<Scalars['String']['output']>;
};

/** Represents links to perform actions on the model */
export type MlModelLinks = {
  __typename?: 'MLModelLinks';
  /** Path to the details page of the model. */
  showPath?: Maybe<Scalars['String']['output']>;
};

/** Represents links to perform actions on the model version */
export type MlModelVersionLinks = {
  __typename?: 'MLModelVersionLinks';
  /** File upload path for the machine learning model. */
  importPath?: Maybe<Scalars['String']['output']>;
  /** Path to the package of the model version. */
  packagePath?: Maybe<Scalars['String']['output']>;
  /** Path to the details page of the model version. */
  showPath?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MarkAsSpamSnippet */
export type MarkAsSpamSnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID']['input'];
};

/** Autogenerated return type of MarkAsSpamSnippet. */
export type MarkAsSpamSnippetPayload = {
  __typename?: 'MarkAsSpamSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

export type MarkdownPaths = {
  /** Supported paths for autocomplete sources for a given namespace. */
  autocompleteSourcesPath?: Maybe<Scalars['JSON']['output']>;
  /** Path for the markdown preview for given namespace. */
  markdownPreviewPath?: Maybe<Scalars['String']['output']>;
  /** Uploads path for a given namespace. */
  uploadsPath?: Maybe<Scalars['String']['output']>;
};


export type MarkdownPathsAutocompleteSourcesPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['String']['input']>;
};


export type MarkdownPathsMarkdownPreviewPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
};

/** Maven metadata */
export type MavenMetadata = {
  __typename?: 'MavenMetadata';
  /** App group of the Maven package. */
  appGroup: Scalars['String']['output'];
  /** App name of the Maven package. */
  appName: Scalars['String']['output'];
  /** App version of the Maven package. */
  appVersion?: Maybe<Scalars['String']['output']>;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the metadatum. */
  id: Scalars['PackagesMavenMetadatumID']['output'];
  /** Path of the Maven package. */
  path: Scalars['String']['output'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** Represents a Maven virtual registry */
export type MavenRegistry = RegistryInterface & {
  __typename?: 'MavenRegistry';
  /** Description of the virtual registry. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the virtual registry. */
  id: Scalars['ID']['output'];
  /** Name of the virtual registry. */
  name: Scalars['String']['output'];
  /** Timestamp of when the virtual registry was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for MavenRegistry. */
export type MavenRegistryConnection = {
  __typename?: 'MavenRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MavenRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MavenRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents Maven virtual registry details */
export type MavenRegistryDetails = RegistryInterface & {
  __typename?: 'MavenRegistryDetails';
  /** Description of the virtual registry. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the virtual registry. */
  id: Scalars['ID']['output'];
  /** Name of the virtual registry. */
  name: Scalars['String']['output'];
  /**
   * List of registry upstreams for the Maven virtual registry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  registryUpstreams: Array<MavenRegistryUpstreamWithUpstream>;
  /** Timestamp of when the virtual registry was updated. */
  updatedAt: Scalars['Time']['output'];
  /**
   * List of upstream registries for the Maven virtual registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  upstreams?: Maybe<Array<MavenUpstreamDetails>>;
};

/** An edge in a connection. */
export type MavenRegistryEdge = {
  __typename?: 'MavenRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MavenRegistry>;
};

/** Represents a Maven virtual registry upstream and its relationship to the registry. */
export type MavenRegistryUpstreamWithRegistry = {
  __typename?: 'MavenRegistryUpstreamWithRegistry';
  /**
   * ID of the registry upstream. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  id: Scalars['ID']['output'];
  /**
   * Position of the upstream registry in an ordered list. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  position: Scalars['Int']['output'];
  /**
   * Maven registry associated with the registry upstream. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  registry: MavenRegistry;
};

/** Represents a Maven virtual registry upstream and its relationship to the upstream. */
export type MavenRegistryUpstreamWithUpstream = {
  __typename?: 'MavenRegistryUpstreamWithUpstream';
  /**
   * ID of the registry upstream. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  id: Scalars['ID']['output'];
  /**
   * Position of the upstream registry in an ordered list. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  position: Scalars['Int']['output'];
  /**
   * Maven upstream associated with the registry upstream. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  upstream: MavenUpstream;
};

/** Represents a Maven upstream registry. */
export type MavenUpstream = {
  __typename?: 'MavenUpstream';
  /**
   * Time before the cache expires for the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  cacheValidityHours: Scalars['Int']['output'];
  /**
   * Description of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  id: Scalars['ID']['output'];
  /**
   * Time before the cache expires for Maven metadata. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  metadataCacheValidityHours: Scalars['Int']['output'];
  /**
   * Name of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  name: Scalars['String']['output'];
  /**
   * Number of registries using the upstream. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  registriesCount: Scalars['Int']['output'];
  /**
   * URL of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  url: Scalars['String']['output'];
  /**
   * Username to sign in to the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  username?: Maybe<Scalars['String']['output']>;
};

/** Represents a cache entry for a Maven upstream. */
export type MavenUpstreamCacheEntry = {
  __typename?: 'MavenUpstreamCacheEntry';
  /**
   * Content type of the cached file. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  contentType: Scalars['String']['output'];
  /**
   * Timestamp when the cache entry was created. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  createdAt: Scalars['Time']['output'];
  /**
   * Timestamp when the cache entry was last downloaded. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  downloadedAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Number of times the entry has been downloaded. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  downloadsCount: Scalars['Int']['output'];
  /**
   * MD5 hash of the cached file. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  fileMd5?: Maybe<Scalars['String']['output']>;
  /**
   * SHA1 hash of the cached file. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  fileSha1: Scalars['String']['output'];
  /**
   * ID of the cache entry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  id: Scalars['String']['output'];
  /**
   * Relative path of the cached entry. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  relativePath: Scalars['String']['output'];
  /**
   * Size of the cached file in bytes. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  size: Scalars['BigInt']['output'];
  /**
   * Timestamp when the cache entry was last updated. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  updatedAt: Scalars['Time']['output'];
  /**
   * Timestamp when the upstream was last checked. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  upstreamCheckedAt?: Maybe<Scalars['Time']['output']>;
  /**
   * ETag from the upstream source. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  upstreamEtag?: Maybe<Scalars['String']['output']>;
};

/** The connection type for MavenUpstreamCacheEntry. */
export type MavenUpstreamCacheEntryConnection = {
  __typename?: 'MavenUpstreamCacheEntryConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MavenUpstreamCacheEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MavenUpstreamCacheEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MavenUpstreamCacheEntry. */
export type MavenUpstreamCacheEntryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MavenUpstreamCacheEntryEdge = {
  __typename?: 'MavenUpstreamCacheEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MavenUpstreamCacheEntry>;
};

/** The connection type for MavenUpstream. */
export type MavenUpstreamConnection = {
  __typename?: 'MavenUpstreamConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MavenUpstreamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MavenUpstream>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MavenUpstream. */
export type MavenUpstreamConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MavenUpstreamCreate */
export type MavenUpstreamCreateInput = {
  /** Cache validity period. Defaults to 24 hours. */
  cacheValidityHours?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the upstream registry. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the upstream registry. */
  id: Scalars['VirtualRegistriesPackagesMavenRegistryID']['input'];
  /** Name of upstream registry. */
  name: Scalars['String']['input'];
  /** Password of the upstream registry. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** URL of the upstream registry. */
  url: Scalars['String']['input'];
  /** Username of the upstream registry. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of MavenUpstreamCreate. */
export type MavenUpstreamCreatePayload = {
  __typename?: 'MavenUpstreamCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Maven upstream after the mutation. */
  upstream?: Maybe<MavenUpstreamDetails>;
};

/** Represents Maven upstream registry details. */
export type MavenUpstreamDetails = {
  __typename?: 'MavenUpstreamDetails';
  /**
   * Represents cache entries for the upstream. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  cacheEntries?: Maybe<MavenUpstreamCacheEntryConnection>;
  /**
   * Time before the cache expires for the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  cacheValidityHours: Scalars['Int']['output'];
  /**
   * Description of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  id: Scalars['ID']['output'];
  /**
   * Time before the cache expires for Maven metadata. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  metadataCacheValidityHours: Scalars['Int']['output'];
  /**
   * Name of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  name: Scalars['String']['output'];
  /**
   * Number of registries using the upstream. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  registriesCount: Scalars['Int']['output'];
  /**
   * Represents the upstream registry for the upstream which contains the position data. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  registryUpstreams: Array<MavenRegistryUpstreamWithRegistry>;
  /**
   * URL of the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  url: Scalars['String']['output'];
  /**
   * Username to sign in to the upstream registry. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  username?: Maybe<Scalars['String']['output']>;
};


/** Represents Maven upstream registry details. */
export type MavenUpstreamDetailsCacheEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};

/** An edge in a connection. */
export type MavenUpstreamEdge = {
  __typename?: 'MavenUpstreamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MavenUpstream>;
};

/** Possible identifier types for a measurement */
export type MeasurementIdentifier =
  /** Group count. */
  | 'GROUPS'
  /** Issue count. */
  | 'ISSUES'
  /** Merge request count. */
  | 'MERGE_REQUESTS'
  /** Pipeline count. */
  | 'PIPELINES'
  /** Pipeline count with canceled status. */
  | 'PIPELINES_CANCELED'
  /** Pipeline count with failed status. */
  | 'PIPELINES_FAILED'
  /** Pipeline count with skipped status. */
  | 'PIPELINES_SKIPPED'
  /** Pipeline count with success status. */
  | 'PIPELINES_SUCCEEDED'
  /** Project count. */
  | 'PROJECTS'
  /** User count. */
  | 'USERS';

/** Access level of a group or project member */
export type MemberAccessLevel =
  /** The Developer role gives users access to contribute code while restricting sensitive administrative actions. */
  | 'DEVELOPER'
  /** The Guest role is for users who need visibility into a project or group but should not have the ability to make changes, such as external stakeholders. */
  | 'GUEST'
  /** The Maintainer role is primarily used for managing code reviews, approvals, and administrative settings for projects. This role can also manage project memberships. */
  | 'MAINTAINER'
  /** The Minimal Access role is for users who need the least amount of access into groups and projects. You can assign this role as a default, before giving a user another role with more permissions. */
  | 'MINIMAL_ACCESS'
  /** The Owner role is typically assigned to the individual or team responsible for managing and maintaining the group or creating the project. This role has the highest level of administrative control, and can manage all aspects of the group or project, including managing other Owners. */
  | 'OWNER'
  /** The Planner role is suitable for team members who need to manage projects and track work items but do not need to contribute code. */
  | 'PLANNER'
  /** The Reporter role is suitable for team members who need to stay informed about a project or group but do not actively contribute code. */
  | 'REPORTER';

/** Name of access levels of a group or project member */
export type MemberAccessLevelName =
  /** Developer access. */
  | 'DEVELOPER'
  /** Guest access. */
  | 'GUEST'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Owner access. */
  | 'OWNER'
  /** Planner access. */
  | 'PLANNER'
  /** Reporter access. */
  | 'REPORTER';

/** Represents a Member Approval queued for role promotion. */
export type MemberApproval = {
  __typename?: 'MemberApproval';
  /** Timestamp when the member approval was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Member associated with the member approval object. */
  member?: Maybe<MemberInterface>;
  /** ID of the member role. */
  memberRoleId?: Maybe<Scalars['ID']['output']>;
  /** New GitLab::Access level requested for the member. */
  newAccessLevel?: Maybe<AccessLevel>;
  /** Existing GitLab::Access level for the member. */
  oldAccessLevel?: Maybe<AccessLevel>;
  /** User who requested the member promotion. */
  requestedBy?: Maybe<UserCore>;
  /** User who reviewed the member promotion. */
  reviewedBy?: Maybe<UserCore>;
  /** Status for the member approval request (approved, denied, pending). */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the member approval was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member approval object. */
  user?: Maybe<UserCore>;
};

/** The connection type for MemberApproval. */
export type MemberApprovalConnection = {
  __typename?: 'MemberApprovalConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberApprovalEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberApproval>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MemberApproval. */
export type MemberApprovalConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MemberApprovalEdge = {
  __typename?: 'MemberApprovalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MemberApproval>;
};

/** Types of member approval status. */
export type MemberApprovalStatusType =
  /** Approved promotion request. */
  | 'APPROVED'
  /** Denied promotion request. */
  | 'DENIED'
  /** Pending promotion request. */
  | 'PENDING';

export type MemberInterface = {
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
};


export type MemberInterfaceMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

/** The connection type for MemberInterface. */
export type MemberInterfaceConnection = {
  __typename?: 'MemberInterfaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MemberInterfaceEdge = {
  __typename?: 'MemberInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MemberInterface>;
};

/** Represents a member role */
export type MemberRole = CustomRoleInterface & MemberRoleInterface & RoleInterface & {
  __typename?: 'MemberRole';
  /**
   * Base access level for the custom role. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  baseAccessLevel: AccessLevel;
  /** Timestamp of when the member role was created. */
  createdAt: Scalars['Time']['output'];
  /** Array of security policies dependent on the custom role. */
  dependentSecurityPolicies?: Maybe<Array<ApprovalPolicy>>;
  /** Role description. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * URL path to the role details webpage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  detailsPath?: Maybe<Scalars['String']['output']>;
  /**
   * Web UI path to edit the custom role. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  editPath: Scalars['String']['output'];
  /**
   * Array of all permissions enabled for the custom role. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  enabledPermissions: CustomizableStandardPermissionConnection;
  /** Role ID. */
  id: Scalars['ID']['output'];
  /**
   * Number of times the role has been directly assigned to a group or project member. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  membersCount?: Maybe<Scalars['Int']['output']>;
  /** Role name. */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Number of users who have been directly assigned the role in at least one group or project. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  usersCount?: Maybe<Scalars['Int']['output']>;
};


/** Represents a member role */
export type MemberRoleEnabledPermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MemberRoleAdminCreate */
export type MemberRoleAdminCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the member role. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the member role. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of all customizable admin permissions. */
  permissions?: InputMaybe<Array<MemberRoleAdminPermission>>;
};

/** Autogenerated return type of MemberRoleAdminCreate. */
export type MemberRoleAdminCreatePayload = {
  __typename?: 'MemberRoleAdminCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Member role. */
  memberRole?: Maybe<AdminMemberRole>;
};

/** Autogenerated input type of MemberRoleAdminDelete */
export type MemberRoleAdminDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the admin member role to delete. */
  id: Scalars['MemberRoleID']['input'];
};

/** Autogenerated return type of MemberRoleAdminDelete. */
export type MemberRoleAdminDeletePayload = {
  __typename?: 'MemberRoleAdminDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted admin member role. */
  memberRole?: Maybe<MemberRole>;
};

/** Member role admin permission */
export type MemberRoleAdminPermission =
  /** Read CI/CD details for runners and jobs in the Admin Area. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'READ_ADMIN_CICD'
  /** Read group details in the Admin Area. Introduced in GitLab 18.3: **Status**: Experiment. */
  | 'READ_ADMIN_GROUPS'
  /** Read system information such as background migrations, health checks, and Gitaly in the Admin Area. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'READ_ADMIN_MONITORING'
  /** Read project details in the Admin Area. Introduced in GitLab 18.3: **Status**: Experiment. */
  | 'READ_ADMIN_PROJECTS'
  /** Read subscription details in the Admin area. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'READ_ADMIN_SUBSCRIPTION'
  /** Read the user list and user details in the Admin area. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'READ_ADMIN_USERS';

/** Autogenerated input type of MemberRoleAdminUpdate */
export type MemberRoleAdminUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the member role. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the member role to mutate. */
  id: Scalars['MemberRoleID']['input'];
  /** Name of the member role. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of all customizable admin permissions. */
  permissions?: InputMaybe<Array<MemberRoleAdminPermission>>;
};

/** Autogenerated return type of MemberRoleAdminUpdate. */
export type MemberRoleAdminUpdatePayload = {
  __typename?: 'MemberRoleAdminUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Member role. */
  memberRole?: Maybe<AdminMemberRole>;
};

/** The connection type for MemberRole. */
export type MemberRoleConnection = {
  __typename?: 'MemberRoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberRoleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberRole>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of MemberRoleCreate */
export type MemberRoleCreateInput = {
  /** Base access level for the custom role. */
  baseAccessLevel: MemberRolesAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the member role. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Group the member role to mutate is in. Required for SaaS. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the member role. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of all customizable permissions. */
  permissions?: InputMaybe<Array<MemberRolePermission>>;
};

/** Autogenerated return type of MemberRoleCreate. */
export type MemberRoleCreatePayload = {
  __typename?: 'MemberRoleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Member role. */
  memberRole?: Maybe<MemberRole>;
};

/** Autogenerated input type of MemberRoleDelete */
export type MemberRoleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the member role to delete. */
  id: Scalars['MemberRoleID']['input'];
};

/** Autogenerated return type of MemberRoleDelete. */
export type MemberRoleDeletePayload = {
  __typename?: 'MemberRoleDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted member role. */
  memberRole?: Maybe<MemberRole>;
};

/** An edge in a connection. */
export type MemberRoleEdge = {
  __typename?: 'MemberRoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MemberRole>;
};

export type MemberRoleInterface = {
  /**
   * Number of times the role has been directly assigned to a group or project member. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  membersCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Number of users who have been directly assigned the role in at least one group or project. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  usersCount?: Maybe<Scalars['Int']['output']>;
};

/** Member role permission */
export type MemberRolePermission =
  /** Create, read, update, and delete CI/CD variables. */
  | 'ADMIN_CICD_VARIABLES'
  /** Create, read, update, and delete compliance frameworks. Users with this permission can also assign a compliance framework label to a project, and set the default framework of a group. */
  | 'ADMIN_COMPLIANCE_FRAMEWORK'
  /** Add or remove users in a group, and assign roles to users. When assigning a role, users with this custom permission must select a role that has the same or fewer permissions as the default role used as the base for their custom role. */
  | 'ADMIN_GROUP_MEMBER'
  /** Create, read, update, and delete integrations with external applications. */
  | 'ADMIN_INTEGRATIONS'
  /** Allows approval of merge requests. */
  | 'ADMIN_MERGE_REQUEST'
  /** Create, read, update, and delete protected branches for a project. */
  | 'ADMIN_PROTECTED_BRANCH'
  /** Create, read, update, and delete protected environments */
  | 'ADMIN_PROTECTED_ENVIRONMENTS'
  /** Configure push rules for repositories at the group or project level. */
  | 'ADMIN_PUSH_RULES'
  /** Create, view, edit, and delete group or project Runners. Includes configuring Runner settings. */
  | 'ADMIN_RUNNERS'
  /** Manage the security categories and attributes belonging to a top-level group. Also requires the `read_security_attribute` permission. */
  | 'ADMIN_SECURITY_ATTRIBUTES'
  /** Edit and manage security testing configurations and settings. */
  | 'ADMIN_SECURITY_TESTING'
  /** Execute terraform commands, lock/unlock terraform state files, and remove file versions. */
  | 'ADMIN_TERRAFORM_STATE'
  /** Edit the status, linked issue, and severity of a vulnerability object. Also requires the `read_vulnerability` permission. */
  | 'ADMIN_VULNERABILITY'
  /** Manage webhooks */
  | 'ADMIN_WEB_HOOK'
  /** Allows archiving of projects. */
  | 'ARCHIVE_PROJECT'
  /** Manage deploy tokens at the group or project level. */
  | 'MANAGE_DEPLOY_TOKENS'
  /** Create, read, update, and delete group access tokens. When creating a token, users with this custom permission must select a role for that token that has the same or fewer permissions as the default role used as the base for the custom role. */
  | 'MANAGE_GROUP_ACCESS_TOKENS'
  /** Configure merge request settings at the group or project level. Group actions include managing merge checks and approval settings. Project actions include managing MR configurations, approval rules and settings, and branch targets. In order to enable Suggested reviewers, the "Manage project access tokens" custom permission needs to be enabled. */
  | 'MANAGE_MERGE_REQUEST_SETTINGS'
  /** Create, read, update, and delete project access tokens. When creating a token, users with this custom permission must select a role for that token that has the same or fewer permissions as the default role used as the base for the custom role. */
  | 'MANAGE_PROJECT_ACCESS_TOKENS'
  /** Create, read, update, and delete protected tags. */
  | 'MANAGE_PROTECTED_TAGS'
  /** Allows linking security policy projects. */
  | 'MANAGE_SECURITY_POLICY_LINK'
  /** Read CI/CD details for runners and jobs in the Admin Area. */
  | 'READ_ADMIN_CICD'
  /** Read group details in the Admin Area. */
  | 'READ_ADMIN_GROUPS'
  /** Read system information such as background migrations, health checks, and Gitaly in the Admin Area. */
  | 'READ_ADMIN_MONITORING'
  /** Read project details in the Admin Area. */
  | 'READ_ADMIN_PROJECTS'
  /** Read subscription details in the Admin area. */
  | 'READ_ADMIN_SUBSCRIPTION'
  /** Read the user list and user details in the Admin area. */
  | 'READ_ADMIN_USERS'
  /** Allows read-only access to the source code in the user interface. Does not allow users to edit or download repository archives, clone or pull repositories, view source code in an IDE, or view merge requests for private projects. You can download individual files because read-only access inherently grants the ability to make a local copy of the file. */
  | 'READ_CODE'
  /** Read compliance capabilities including adherence, violations, and frameworks for groups and projects. */
  | 'READ_COMPLIANCE_DASHBOARD'
  /** Read CRM contact. */
  | 'READ_CRM_CONTACT'
  /** Allows read-only access to the dependencies and licenses. */
  | 'READ_DEPENDENCY'
  /** Allows read-only access to group or project runners, including the runner fleet dashboard. */
  | 'READ_RUNNERS'
  /** Allows read-only access to the security categories and attributes belonging to a top-level group. */
  | 'READ_SECURITY_ATTRIBUTE'
  /** Read security scan profiles. */
  | 'READ_SECURITY_SCAN_PROFILES'
  /** Read vulnerability reports and security dashboards. */
  | 'READ_VULNERABILITY'
  /** Ability to delete or restore a group. This ability does not allow deleting top-level groups. Review the Retention period settings to prevent accidental deletion. */
  | 'REMOVE_GROUP'
  /** Allows deletion of projects. */
  | 'REMOVE_PROJECT';

/** Member role standard permission */
export type MemberRoleStandardPermission =
  /** Create, read, update, and delete CI/CD variables. */
  | 'ADMIN_CICD_VARIABLES'
  /** Create, read, update, and delete compliance frameworks. Users with this permission can also assign a compliance framework label to a project, and set the default framework of a group. */
  | 'ADMIN_COMPLIANCE_FRAMEWORK'
  /** Add or remove users in a group, and assign roles to users. When assigning a role, users with this custom permission must select a role that has the same or fewer permissions as the default role used as the base for their custom role. */
  | 'ADMIN_GROUP_MEMBER'
  /** Create, read, update, and delete integrations with external applications. */
  | 'ADMIN_INTEGRATIONS'
  /** Allows approval of merge requests. */
  | 'ADMIN_MERGE_REQUEST'
  /** Create, read, update, and delete protected branches for a project. */
  | 'ADMIN_PROTECTED_BRANCH'
  /** Create, read, update, and delete protected environments */
  | 'ADMIN_PROTECTED_ENVIRONMENTS'
  /** Configure push rules for repositories at the group or project level. */
  | 'ADMIN_PUSH_RULES'
  /** Create, view, edit, and delete group or project Runners. Includes configuring Runner settings. */
  | 'ADMIN_RUNNERS'
  /** Manage the security categories and attributes belonging to a top-level group. Also requires the `read_security_attribute` permission. Introduced in GitLab 18.2: **Status**: Experiment. */
  | 'ADMIN_SECURITY_ATTRIBUTES'
  /** Edit and manage security testing configurations and settings. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'ADMIN_SECURITY_TESTING'
  /** Execute terraform commands, lock/unlock terraform state files, and remove file versions. */
  | 'ADMIN_TERRAFORM_STATE'
  /** Edit the status, linked issue, and severity of a vulnerability object. Also requires the `read_vulnerability` permission. */
  | 'ADMIN_VULNERABILITY'
  /** Manage webhooks */
  | 'ADMIN_WEB_HOOK'
  /** Allows archiving of projects. */
  | 'ARCHIVE_PROJECT'
  /** Manage deploy tokens at the group or project level. */
  | 'MANAGE_DEPLOY_TOKENS'
  /** Create, read, update, and delete group access tokens. When creating a token, users with this custom permission must select a role for that token that has the same or fewer permissions as the default role used as the base for the custom role. */
  | 'MANAGE_GROUP_ACCESS_TOKENS'
  /** Configure merge request settings at the group or project level. Group actions include managing merge checks and approval settings. Project actions include managing MR configurations, approval rules and settings, and branch targets. In order to enable Suggested reviewers, the "Manage project access tokens" custom permission needs to be enabled. */
  | 'MANAGE_MERGE_REQUEST_SETTINGS'
  /** Create, read, update, and delete project access tokens. When creating a token, users with this custom permission must select a role for that token that has the same or fewer permissions as the default role used as the base for the custom role. */
  | 'MANAGE_PROJECT_ACCESS_TOKENS'
  /** Create, read, update, and delete protected tags. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'MANAGE_PROTECTED_TAGS'
  /** Allows linking security policy projects. */
  | 'MANAGE_SECURITY_POLICY_LINK'
  /** Allows read-only access to the source code in the user interface. Does not allow users to edit or download repository archives, clone or pull repositories, view source code in an IDE, or view merge requests for private projects. You can download individual files because read-only access inherently grants the ability to make a local copy of the file. */
  | 'READ_CODE'
  /** Read compliance capabilities including adherence, violations, and frameworks for groups and projects. */
  | 'READ_COMPLIANCE_DASHBOARD'
  /** Read CRM contact. */
  | 'READ_CRM_CONTACT'
  /** Allows read-only access to the dependencies and licenses. */
  | 'READ_DEPENDENCY'
  /** Allows read-only access to group or project runners, including the runner fleet dashboard. */
  | 'READ_RUNNERS'
  /** Allows read-only access to the security categories and attributes belonging to a top-level group. Introduced in GitLab 18.6: **Status**: Experiment. */
  | 'READ_SECURITY_ATTRIBUTE'
  /** Read security scan profiles. */
  | 'READ_SECURITY_SCAN_PROFILES'
  /** Read vulnerability reports and security dashboards. */
  | 'READ_VULNERABILITY'
  /** Ability to delete or restore a group. This ability does not allow deleting top-level groups. Review the Retention period settings to prevent accidental deletion. */
  | 'REMOVE_GROUP'
  /** Allows deletion of projects. */
  | 'REMOVE_PROJECT';

/** Autogenerated input type of MemberRoleToUserAssign */
export type MemberRoleToUserAssignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Global ID of the custom role to be assigned to a user.
   *             Admin roles will be unassigned from the user if omitted or set as NULL.
   */
  memberRoleId?: InputMaybe<Scalars['MemberRoleID']['input']>;
  /** Global ID of the user to be assigned to a custom role. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of MemberRoleToUserAssign. */
export type MemberRoleToUserAssignPayload = {
  __typename?: 'MemberRoleToUserAssignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created user member role or nil if the relation was deleted. */
  userMemberRole?: Maybe<UserMemberRole>;
};

/** Autogenerated input type of MemberRoleUpdate */
export type MemberRoleUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the member role. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the member role to mutate. */
  id: Scalars['MemberRoleID']['input'];
  /** Name of the member role. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** List of all customizable permissions. */
  permissions?: InputMaybe<Array<MemberRolePermission>>;
};

/** Autogenerated return type of MemberRoleUpdate. */
export type MemberRoleUpdatePayload = {
  __typename?: 'MemberRoleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Member role. */
  memberRole?: Maybe<MemberRole>;
};

/** Access level of a group or project member */
export type MemberRolesAccessLevel =
  /** The Developer role gives users access to contribute code while restricting sensitive administrative actions. */
  | 'DEVELOPER'
  /** The Guest role is for users who need visibility into a project or group but should not have the ability to make changes, such as external stakeholders. */
  | 'GUEST'
  /** The Maintainer role is primarily used for managing code reviews, approvals, and administrative settings for projects. This role can also manage project memberships. */
  | 'MAINTAINER'
  /** The Minimal Access role is for users who need the least amount of access into groups and projects. You can assign this role as a default, before giving a user another role with more permissions. */
  | 'MINIMAL_ACCESS'
  /** The Planner role is suitable for team members who need to manage projects and track work items but do not need to contribute code. */
  | 'PLANNER'
  /** The Reporter role is suitable for team members who need to stay informed about a project or group but do not actively contribute code. */
  | 'REPORTER';

/** Values for ordering member roles by a specific field */
export type MemberRolesOrderBy =
  /** Ordered by creation time. */
  | 'CREATED_AT'
  /** Ordered by id. */
  | 'ID'
  /** Ordered by name. */
  | 'NAME';

/** Values for sorting members */
export type MemberSort =
  /** Access level ascending order. */
  | 'ACCESS_LEVEL_ASC'
  /** Access level descending order. */
  | 'ACCESS_LEVEL_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** User's full name ascending order. */
  | 'USER_FULL_NAME_ASC'
  /** User's full name descending order. */
  | 'USER_FULL_NAME_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Defines which user roles, users, or groups can merge into a protected branch. */
export type MergeAccessLevel = {
  __typename?: 'MergeAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int']['output'];
  /** Human readable representation for the access level. */
  accessLevelDescription: Scalars['String']['output'];
  /** Group associated with the access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with the access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for MergeAccessLevel. */
export type MergeAccessLevelConnection = {
  __typename?: 'MergeAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeAccessLevelEdge = {
  __typename?: 'MergeAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeAccessLevel>;
};

/** Defines which user roles, users, or groups can merge into a protected branch. */
export type MergeAccessLevelInput = {
  /** Access level allowed to perform action. */
  accessLevel?: InputMaybe<Scalars['Int']['input']>;
  /** Group associated with the access level. */
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  /** User associated with the access level. */
  userId?: InputMaybe<Scalars['UserID']['input']>;
};

export type MergeRequest = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'MergeRequest';
  /** Indicates if members of the target project can push to the fork. */
  allowCollaboration?: Maybe<Scalars['Boolean']['output']>;
  /** Allows assigning multiple users to a merge request. */
  allowsMultipleAssignees: Scalars['Boolean']['output'];
  /** Allows assigning multiple reviewers to a merge request. */
  allowsMultipleReviewers: Scalars['Boolean']['output'];
  /** Information relating to rules that must be satisfied to merge the merge request. */
  approvalState: MergeRequestApprovalState;
  /** Number of approvals left. */
  approvalsLeft?: Maybe<Scalars['Int']['output']>;
  /** Number of approvals required. */
  approvalsRequired?: Maybe<Scalars['Int']['output']>;
  /** Indicates if the merge request has all the required approvals. */
  approved: Scalars['Boolean']['output'];
  /** Users who approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** Assignees of the merge request. */
  assignees?: Maybe<MergeRequestAssigneeConnection>;
  /** User who created the merge request. */
  author?: Maybe<MergeRequestAuthor>;
  /** Indicates if auto merge is enabled for the merge request. */
  autoMergeEnabled: Scalars['Boolean']['output'];
  /** Selected auto merge strategy. */
  autoMergeStrategy?: Maybe<Scalars['String']['output']>;
  /** Array of available auto merge strategies. */
  availableAutoMergeStrategies?: Maybe<Array<Scalars['String']['output']>>;
  /** List of emoji reactions associated with the merge request. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /**
   * Merge requests that block another merge request from merging. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  blockingMergeRequests?: Maybe<BlockingMergeRequests>;
  /** Users that have requested changes to the merge request. */
  changeRequesters?: Maybe<UserCoreConnection>;
  /** Timestamp of when the merge request was closed, null if not closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** Code quality reports comparison reported on the merge request. */
  codequalityReportsComparer?: Maybe<CodequalityReportsComparer>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Number of commits in the merge request. */
  commitCount?: Maybe<Scalars['Int']['output']>;
  /** Merge request commits. */
  commits?: Maybe<CommitConnection>;
  /** Merge request commits excluding merge commits. */
  commitsWithoutMergeCommits?: Maybe<CommitConnection>;
  /** Users who have added commits to the merge request. */
  committers?: Maybe<UserCoreConnection>;
  /** Indicates if the merge request has conflicts. */
  conflicts: Scalars['Boolean']['output'];
  /** Timestamp of when the merge request was created. */
  createdAt: Scalars['Time']['output'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default merge commit message of the merge request. */
  defaultMergeCommitMessage?: Maybe<Scalars['String']['output']>;
  /** Default squash commit message of the merge request. */
  defaultSquashCommitMessage?: Maybe<Scalars['String']['output']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Detailed merge status of the merge request. */
  detailedMergeStatus?: Maybe<DetailedMergeStatus>;
  /** Diff head SHA of the merge request. */
  diffHeadSha?: Maybe<Scalars['String']['output']>;
  /** References of the base SHA, the head SHA, and the start SHA for the merge request. */
  diffRefs?: Maybe<DiffRefs>;
  /** Details about which files were changed in the merge request. */
  diffStats?: Maybe<Array<DiffStats>>;
  /** Summary of which files were changed in the merge request. */
  diffStatsSummary?: Maybe<DiffStatsSummary>;
  /** Indicates if comments on the merge request are locked to members only. */
  discussionLocked: Scalars['Boolean']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Indicates if the source branch is behind the target branch. */
  divergedFromTargetBranch: Scalars['Boolean']['output'];
  /** Number of downvotes for the merge request. */
  downvotes: Scalars['Int']['output'];
  /** Indicates if the merge request is a draft. */
  draft: Scalars['Boolean']['output'];
  /**
   * Vulnerability finding reports comparison reported on the merge request. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  findingReportsComparer?: Maybe<FindingReportsComparer>;
  /** Indicates if the project settings will lead to source branch deletion after merge. */
  forceRemoveSourceBranch?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if the merge request has CI. */
  hasCi: Scalars['Boolean']['output'];
  /** Indicates if the source branch has any security reports. */
  hasSecurityReports: Scalars['Boolean']['output'];
  /** Pipeline running on the branch HEAD of the merge request. */
  headPipeline?: Maybe<Pipeline>;
  /** Indicates the merge request is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** Human-readable time estimate of the merge request. */
  humanTimeEstimate?: Maybe<Scalars['String']['output']>;
  /** Human-readable total time reported as spent on the merge request. */
  humanTotalTimeSpent?: Maybe<Scalars['String']['output']>;
  /** ID of the merge request. */
  id: Scalars['ID']['output'];
  /** Internal ID of the merge request. */
  iid: Scalars['String']['output'];
  /** Commit SHA of the merge request if merge is in progress. */
  inProgressMergeCommitSha?: Maybe<Scalars['String']['output']>;
  /** Labels of the merge request. */
  labels?: Maybe<LabelConnection>;
  /** Date after which the merge request can be merged. */
  mergeAfter?: Maybe<Scalars['Time']['output']>;
  /** SHA of the merge request commit (set once merged). */
  mergeCommitSha?: Maybe<Scalars['String']['output']>;
  /** Error message due to a merge error. */
  mergeError?: Maybe<Scalars['String']['output']>;
  /** Indicates if a merge is currently occurring. */
  mergeOngoing: Scalars['Boolean']['output'];
  /**
   * Diff versions of a merge request. Introduced in GitLab 16.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.2.
   */
  mergeRequestDiffs?: Maybe<MergeRequestDiffConnection>;
  /**
   * Status of the merge request. Deprecated in GitLab 14.0: This was renamed.
   * @deprecated This was renamed. Please use `MergeRequest.mergeStatusEnum`. Deprecated in GitLab 14.0.
   */
  mergeStatus?: Maybe<Scalars['String']['output']>;
  /** Merge status of the merge request. */
  mergeStatusEnum?: Maybe<MergeStatus>;
  /**
   * Represents the merge request in a merge train. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  mergeTrainCar?: Maybe<MergeTrainCar>;
  /**
   * Zero-based position of the merge request in the merge train. Returns `null` if the merge request is not in a merge train. Deprecated in GitLab 17.4: Use `index` on `MergeTrains::CarType` instead.
   * @deprecated Use `index` on `MergeTrains::CarType` instead. Deprecated in GitLab 17.4.
   */
  mergeTrainIndex?: Maybe<Scalars['Int']['output']>;
  /**
   * Number of merge requests in the merge train. Deprecated in GitLab 17.4: Use `count` from `cars` connection on `MergeTrains::TrainType` instead.
   * @deprecated Use `count` from `cars` connection on `MergeTrains::TrainType` instead. Deprecated in GitLab 17.4.
   */
  mergeTrainsCount?: Maybe<Scalars['Int']['output']>;
  /** User who merged the merge request or set it to auto-merge. */
  mergeUser?: Maybe<UserCore>;
  /**
   * Indicates if the merge has been set to auto-merge. Deprecated in GitLab 17.11: This was renamed.
   * @deprecated This was renamed. Please use `MergeRequest.autoMergeEnabled`. Deprecated in GitLab 17.11.
   */
  mergeWhenPipelineSucceeds?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Status of all mergeability checks of the merge request. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  mergeabilityChecks: Array<MergeRequestMergeabilityCheck>;
  /** Indicates if the merge request is mergeable. */
  mergeable: Scalars['Boolean']['output'];
  /** Indicates if all discussions in the merge request have been resolved, allowing the merge request to be merged. */
  mergeableDiscussionsState?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp of when the merge request was merged, null if not merged. */
  mergedAt?: Maybe<Scalars['Time']['output']>;
  /** Milestone of the merge request. */
  milestone?: Maybe<Milestone>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Participants in the merge request. This includes the author, assignees, reviewers, and users mentioned in notes. */
  participants?: Maybe<MergeRequestParticipantConnection>;
  /** Pipeline creation requests for the merge request. */
  pipelineCreationRequests: Array<CiPipelineCreationRequest>;
  /** Pipelines for the merge request. Note: for performance reasons, no more than the most recent 500 pipelines will be returned. */
  pipelines?: Maybe<PipelineConnection>;
  /** Approval settings that are overridden by the policies for the merge request. */
  policiesOverridingApprovalSettings?: Maybe<Array<PolicyApprovalSettingsOverride>>;
  /**
   * List of bypass settings for security policies. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  policyBypassStatuses?: Maybe<Array<PolicyBypassStatus>>;
  /** Policy violations reported on the merge request.  */
  policyViolations?: Maybe<PolicyViolationDetails>;
  /** Timestamp of when the merge request was prepared. */
  preparedAt?: Maybe<Scalars['Time']['output']>;
  /** Alias for target_project. */
  project: Project;
  /** ID of the merge request project. */
  projectId: Scalars['Int']['output'];
  /** Rebase commit SHA of the merge request. */
  rebaseCommitSha?: Maybe<Scalars['String']['output']>;
  /** Indicates if there is a rebase currently in progress for the merge request. */
  rebaseInProgress: Scalars['Boolean']['output'];
  /** Internal reference of the merge request. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /** Number of user discussions that are resolvable in the merge request. */
  resolvableDiscussionsCount?: Maybe<Scalars['Int']['output']>;
  /** Number of user discussions that are resolved in the merge request. */
  resolvedDiscussionsCount?: Maybe<Scalars['Int']['output']>;
  /** Indicates if merge request was retargeted. */
  retargeted?: Maybe<Scalars['Boolean']['output']>;
  /** Users from whom a review has been requested. */
  reviewers?: Maybe<MergeRequestReviewerConnection>;
  /**
   * Indicates if the merge request is created by @GitLab-Security-Bot. Deprecated in GitLab 16.11: Security Auto Fix experiment feature was removed. It was always hidden behind `security_auto_fix` feature flag.
   * @deprecated Security Auto Fix experiment feature was removed. It was always hidden behind `security_auto_fix` feature flag. Deprecated in GitLab 16.11.
   */
  securityAutoFix?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if the target branch security reports are out of date. */
  securityReportsUpToDateOnTargetBranch: Scalars['Boolean']['output'];
  /** Indicates if the merge request will be rebased. */
  shouldBeRebased: Scalars['Boolean']['output'];
  /** Indicates if the source branch of the merge request will be deleted after merge. */
  shouldRemoveSourceBranch?: Maybe<Scalars['Boolean']['output']>;
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String']['output'];
  /** Indicates if the source branch of the merge request exists. */
  sourceBranchExists: Scalars['Boolean']['output'];
  /** Indicates if the source branch is protected. */
  sourceBranchProtected: Scalars['Boolean']['output'];
  /** Source project of the merge request. */
  sourceProject?: Maybe<Project>;
  /** ID of the merge request source project. */
  sourceProjectId?: Maybe<Scalars['Int']['output']>;
  /** Indicates if the merge request is set to be squashed when merged. [Project settings](https://docs.gitlab.com/user/project/merge_requests/squash_and_merge/#configure-squash-options-for-a-project) may override this value. Use `squash_on_merge` instead to take project squash options into account. */
  squash: Scalars['Boolean']['output'];
  /** Indicates if the merge request will be squashed when merged. */
  squashOnMerge: Scalars['Boolean']['output'];
  /** Indicates if `squashReadOnly` is enabled. */
  squashReadOnly: Scalars['Boolean']['output'];
  /** State of the merge request. */
  state: MergeRequestState;
  /** Indicates if the currently logged in user is subscribed to the merge request. */
  subscribed: Scalars['Boolean']['output'];
  /** Suggested reviewers for merge request. */
  suggestedReviewers?: Maybe<SuggestedReviewersType>;
  /** Indicates if the merge request supports locked labels. */
  supportsLockOnMerge: Scalars['Boolean']['output'];
  /** Target branch of the merge request. */
  targetBranch: Scalars['String']['output'];
  /** Indicates if the target branch of the merge request exists. */
  targetBranchExists: Scalars['Boolean']['output'];
  /** Path to the target branch of the merge request. */
  targetBranchPath?: Maybe<Scalars['String']['output']>;
  /** Target project of the merge request. */
  targetProject: Project;
  /** ID of the merge request target project. */
  targetProjectId: Scalars['Int']['output'];
  /** Completion status of tasks */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the merge request. */
  timeEstimate: Scalars['Int']['output'];
  /** Timelogs on the merge request. */
  timelogs: TimelogConnection;
  /** Title of the merge request. */
  title: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Total time (in seconds) reported as spent on the merge request. */
  totalTimeSpent: Scalars['Int']['output'];
  /** Timestamp of when the merge request was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Number of upvotes for the merge request. */
  upvotes: Scalars['Int']['output'];
  /** Number of user discussions in the merge request. */
  userDiscussionsCount?: Maybe<Scalars['Int']['output']>;
  /** User notes count of the merge request. */
  userNotesCount?: Maybe<Scalars['Int']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: MergeRequestPermissions;
  /** Web path of the merge request. */
  webPath: Scalars['String']['output'];
  /** Web URL of the merge request. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


export type MergeRequestApprovedByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestChangeRequestersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestCommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestCommitsWithoutMergeCommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestCommittersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type MergeRequestDiffStatsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


export type MergeRequestDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestFindingReportsComparerArgs = {
  reportType: ComparableSecurityReportType;
  scanMode?: InputMaybe<ScanModeEnum>;
};


export type MergeRequestLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestMergeRequestDiffsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestPipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type MergeRequestReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MergeRequestReviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type MergeRequestTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MergeRequestAccept */
export type MergeRequestAcceptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Custom merge commit message. */
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** HEAD SHA at the time when the merge was requested. */
  sha: Scalars['String']['input'];
  /** Should the source branch be removed. */
  shouldRemoveSourceBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Squash commits on the source branch before merge. */
  squash?: InputMaybe<Scalars['Boolean']['input']>;
  /** Custom squash commit message (if squash is true). */
  squashCommitMessage?: InputMaybe<Scalars['String']['input']>;
  /** How to merge the merge request. */
  strategy?: InputMaybe<MergeStrategyEnum>;
};

/** Autogenerated return type of MergeRequestAccept. */
export type MergeRequestAcceptPayload = {
  __typename?: 'MergeRequestAcceptPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Information relating to rules that must be satisfied to merge this merge request. */
export type MergeRequestApprovalState = {
  __typename?: 'MergeRequestApprovalState';
  /** Indicates if the merge request approval rules are overwritten for the merge request. */
  approvalRulesOverwritten?: Maybe<Scalars['Boolean']['output']>;
  /** List of approval rules that are associated with the merge request, but invalid. */
  invalidApproversRules?: Maybe<Array<ApprovalRule>>;
  /** List of approval rules associated with the merge request. */
  rules?: Maybe<Array<ApprovalRule>>;
  /** List of suggested approvers. */
  suggestedApprovers?: Maybe<UserCoreConnection>;
};


/** Information relating to rules that must be satisfied to merge this merge request. */
export type MergeRequestApprovalStateSuggestedApproversArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A user assigned to a merge request. */
export type MergeRequestAssignee = Todoable & User & {
  __typename?: 'MergeRequestAssignee';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Details of the user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneePersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** The connection type for MergeRequestAssignee. */
export type MergeRequestAssigneeConnection = {
  __typename?: 'MergeRequestAssigneeConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestAssigneeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestAssignee>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeRequestAssignee. */
export type MergeRequestAssigneeConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeRequestAssigneeEdge = {
  __typename?: 'MergeRequestAssigneeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestAssignee>;
};

/** The author of the merge request. */
export type MergeRequestAuthor = Todoable & User & {
  __typename?: 'MergeRequestAuthor';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Details of the user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** The author of the merge request. */
export type MergeRequestAuthorAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** The author of the merge request. */
export type MergeRequestAuthorEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** The author of the merge request. */
export type MergeRequestAuthorNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** The author of the merge request. */
export type MergeRequestAuthorProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** The author of the merge request. */
export type MergeRequestAuthorSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** The author of the merge request. */
export type MergeRequestAuthorStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** The author of the merge request. */
export type MergeRequestAuthorUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** Autogenerated input type of MergeRequestBypassSecurityPolicy */
export type MergeRequestBypassSecurityPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Reason for bypassing the security policy. */
  reason: Scalars['String']['input'];
  /** ID of the security policy to bypass. */
  securityPolicyIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of MergeRequestBypassSecurityPolicy. */
export type MergeRequestBypassSecurityPolicyPayload = {
  __typename?: 'MergeRequestBypassSecurityPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** The connection type for MergeRequest. */
export type MergeRequestConnection = {
  __typename?: 'MergeRequestConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total sum of time to merge, in seconds, for the collection of merge requests. */
  totalTimeToMerge?: Maybe<Scalars['Float']['output']>;
};


/** The connection type for MergeRequest. */
export type MergeRequestConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MergeRequestCreate */
export type MergeRequestCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Labels of the merge request. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Date after which the merge request can be merged. */
  mergeAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Project full path the merge request is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Indicates if the source branch of the merge request will be deleted after merge. */
  removeSourceBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String']['input'];
  /** Target branch of the merge request. */
  targetBranch: Scalars['String']['input'];
  /** Title of the merge request. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of MergeRequestCreate. */
export type MergeRequestCreatePayload = {
  __typename?: 'MergeRequestCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestDestroyRequestedChanges */
export type MergeRequestDestroyRequestedChangesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestDestroyRequestedChanges. */
export type MergeRequestDestroyRequestedChangesPayload = {
  __typename?: 'MergeRequestDestroyRequestedChangesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** A diff version of a merge request. */
export type MergeRequestDiff = {
  __typename?: 'MergeRequestDiff';
  /** Timestamp of when the diff was created. */
  createdAt: Scalars['Time']['output'];
  /** Timestamp of when the diff was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for MergeRequestDiff. */
export type MergeRequestDiffConnection = {
  __typename?: 'MergeRequestDiffConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestDiffEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestDiff>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestDiffEdge = {
  __typename?: 'MergeRequestDiffEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestDiff>;
};

/** Represents the Geo sync and verification state of a Merge Request diff */
export type MergeRequestDiffRegistry = {
  __typename?: 'MergeRequestDiffRegistry';
  /** Indicate if the checksums of the MergeRequestDiffRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the MergeRequestDiffRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the MergeRequestDiffRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the MergeRequestDiffRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the MergeRequestDiffRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Merge Request diff. */
  mergeRequestDiffId: Scalars['ID']['output'];
  /** Indicate if the MergeRequestDiffRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the MergeRequestDiffRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the MergeRequestDiffRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the MergeRequestDiffRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the MergeRequestDiffRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the MergeRequestDiffRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the MergeRequestDiffRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the MergeRequestDiffRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the MergeRequestDiffRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the MergeRequestDiffRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of MergeRequestDiffRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the MergeRequestDiffRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the MergeRequestDiffRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for MergeRequestDiffRegistry. */
export type MergeRequestDiffRegistryConnection = {
  __typename?: 'MergeRequestDiffRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestDiffRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestDiffRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeRequestDiffRegistry. */
export type MergeRequestDiffRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeRequestDiffRegistryEdge = {
  __typename?: 'MergeRequestDiffRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestDiffRegistry>;
};

/** An edge in a connection. */
export type MergeRequestEdge = {
  __typename?: 'MergeRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequest>;
};

/** Mergeability check of the merge request. */
export type MergeRequestMergeabilityCheck = {
  __typename?: 'MergeRequestMergeabilityCheck';
  /** Identifier of the mergeability check. */
  identifier: MergeabilityCheckIdentifier;
  /** Status of the mergeability check. */
  status: MergeabilityCheckStatus;
};

/** New state to apply to a merge request. */
export type MergeRequestNewState =
  /** Close the merge request if it is open. */
  | 'CLOSED'
  /** Open the merge request if it is closed. */
  | 'OPEN';

/** A user participating in a merge request. */
export type MergeRequestParticipant = Todoable & User & {
  __typename?: 'MergeRequestParticipant';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Details of the user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** The connection type for MergeRequestParticipant. */
export type MergeRequestParticipantConnection = {
  __typename?: 'MergeRequestParticipantConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestParticipantEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestParticipant>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeRequestParticipant. */
export type MergeRequestParticipantConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeRequestParticipantEdge = {
  __typename?: 'MergeRequestParticipantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestParticipant>;
};

/** Check permissions for the current user on a merge request */
export type MergeRequestPermissions = {
  __typename?: 'MergeRequestPermissions';
  /** If `true`, the user can perform `admin_merge_request` on this resource */
  adminMergeRequest: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `can_approve` on this resource */
  canApprove: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `can_merge` on this resource */
  canMerge: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `cherry_pick_on_current_merge_request` on this resource */
  cherryPickOnCurrentMergeRequest: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `push_to_source_branch` on this resource */
  pushToSourceBranch: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_source_branch` on this resource */
  removeSourceBranch: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `revert_on_current_merge_request` on this resource */
  revertOnCurrentMergeRequest: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_merge_request` on this resource */
  updateMergeRequest: Scalars['Boolean']['output'];
};

/** State of a review of a GitLab merge request. */
export type MergeRequestReviewState =
  /** Merge request reviewer has approved the changes. */
  | 'APPROVED'
  /** Merge request reviewer has requested changes. */
  | 'REQUESTED_CHANGES'
  /** Merge request reviewer has reviewed. */
  | 'REVIEWED'
  /** Merge request reviewer has started a review. */
  | 'REVIEW_STARTED'
  /** Merge request reviewer removed their approval of the changes. */
  | 'UNAPPROVED'
  /** Awaiting review from merge request reviewer. */
  | 'UNREVIEWED';

/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewer = Todoable & User & {
  __typename?: 'MergeRequestReviewer';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Details of the user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** The connection type for MergeRequestReviewer. */
export type MergeRequestReviewerConnection = {
  __typename?: 'MergeRequestReviewerConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeRequestReviewer. */
export type MergeRequestReviewerConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeRequestReviewerEdge = {
  __typename?: 'MergeRequestReviewerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestReviewer>;
};

/** Autogenerated input type of MergeRequestReviewerRereview */
export type MergeRequestReviewerRereviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /**
   * User ID for the user that has been requested for a new review.
   *
   */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of MergeRequestReviewerRereview. */
export type MergeRequestReviewerRereviewPayload = {
  __typename?: 'MergeRequestReviewerRereviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetAssignees */
export type MergeRequestSetAssigneesInput = {
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestSetAssignees. */
export type MergeRequestSetAssigneesPayload = {
  __typename?: 'MergeRequestSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetDraft */
export type MergeRequestSetDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether or not to set the merge request as a draft.
   *
   */
  draft: Scalars['Boolean']['input'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestSetDraft. */
export type MergeRequestSetDraftPayload = {
  __typename?: 'MergeRequestSetDraftPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLabels */
export type MergeRequestSetLabelsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /**
   * Label IDs to set. Replaces existing labels by default.
   *
   */
  labelIds: Array<Scalars['LabelID']['input']>;
  /**
   * Changes the operation mode. Defaults to REPLACE.
   *
   */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestSetLabels. */
export type MergeRequestSetLabelsPayload = {
  __typename?: 'MergeRequestSetLabelsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLocked */
export type MergeRequestSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /**
   * Whether or not to lock the merge request.
   *
   */
  locked: Scalars['Boolean']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestSetLocked. */
export type MergeRequestSetLockedPayload = {
  __typename?: 'MergeRequestSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetMilestone */
export type MergeRequestSetMilestoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /**
   * Milestone to assign to the merge request.
   *
   */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeRequestSetMilestone. */
export type MergeRequestSetMilestonePayload = {
  __typename?: 'MergeRequestSetMilestonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetReviewers */
export type MergeRequestSetReviewersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Usernames of reviewers to assign. Replaces existing reviewers by default. */
  reviewerUsernames: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of MergeRequestSetReviewers. */
export type MergeRequestSetReviewersPayload = {
  __typename?: 'MergeRequestSetReviewersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetSubscription */
export type MergeRequestSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean']['input'];
};

/** Autogenerated return type of MergeRequestSetSubscription. */
export type MergeRequestSetSubscriptionPayload = {
  __typename?: 'MergeRequestSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Values for sorting merge requests */
export type MergeRequestSort =
  /** Closed time by ascending order. */
  | 'CLOSED_AT_ASC'
  /** Closed time by descending order. */
  | 'CLOSED_AT_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Merge time by ascending order. */
  | 'MERGED_AT_ASC'
  /** Merge time by descending order. */
  | 'MERGED_AT_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** Number of upvotes (awarded "thumbs up" emoji) by ascending order. */
  | 'POPULARITY_ASC'
  /** Number of upvotes (awarded "thumbs up" emoji) by descending order. */
  | 'POPULARITY_DESC'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** State of a GitLab merge request */
export type MergeRequestState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** Merge request has been merged. */
  | 'merged'
  /** Opened merge request. */
  | 'opened';

/** Autogenerated input type of MergeRequestUpdateApprovalRule */
export type MergeRequestUpdateApprovalRuleInput = {
  /** ID of an approval rule. */
  approvalRuleId: Scalars['Int']['input'];
  /** Number of required approvals for a given rule. */
  approvalsRequired: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of groups as approvers. */
  groupIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Name of the approval rule. */
  name: Scalars['String']['input'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Whether hidden groups should be removed. */
  removeHiddenGroups?: InputMaybe<Scalars['Boolean']['input']>;
  /** IDs of users as approvers. */
  userIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of MergeRequestUpdateApprovalRule. */
export type MergeRequestUpdateApprovalRulePayload = {
  __typename?: 'MergeRequestUpdateApprovalRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestUpdate */
export type MergeRequestUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']['input']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String']['input'];
  /** Date after which the merge request can be merged. */
  mergeAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Override all requested changes. Can only be set by users who have permissionto merge this merge request. */
  overrideRequestedChanges?: InputMaybe<Scalars['Boolean']['input']>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Indicates if the source branch of the merge request will be deleted after merge. */
  removeSourceBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Action to perform to change the state. */
  state?: InputMaybe<MergeRequestNewState>;
  /** Target branch of the merge request. */
  targetBranch?: InputMaybe<Scalars['String']['input']>;
  /** Estimated time to complete the merge request. Use `null` or `0` to remove the current estimate. */
  timeEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Title of the merge request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of MergeRequestUpdate. */
export type MergeRequestUpdatePayload = {
  __typename?: 'MergeRequestUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Values for merge request dashboard list type */
export type MergeRequestsDashboardListType =
  /** Action based list rendering. */
  | 'ACTION_BASED'
  /** Role based list rendering. */
  | 'ROLE_BASED';

export type MergeRequestsResolverNegatedParams = {
  /** Filters merge requests to exclude any that are approved by usernames in the given array. */
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters merge requests to exclude any that are assigned to the usernames in the given array. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters merge requests to exclude any that are authored by the given user. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filters merge requests to exclude any that have the labels provided in the given array. */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters merge requests to those not in the given milestone. */
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filters merge requests to those without the given reaction from the authenticated user. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Filters merge requests to those without the given release tag. */
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  /** Filters merge requests to those not reviewed by the given user. */
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filters merge requests to exclude the source branch names provided in the given array. */
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters merge requests to exclude the target branch names provided in the given array. */
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Representation of whether a GitLab merge request can be merged. */
export type MergeStatus =
  /** There are conflicts between the source and target branches. */
  | 'CANNOT_BE_MERGED'
  /** Currently unchecked. The previous state was `CANNOT_BE_MERGED`. */
  | 'CANNOT_BE_MERGED_RECHECK'
  /** There are no conflicts between the source and target branches. */
  | 'CAN_BE_MERGED'
  /** Currently checking for mergeability. */
  | 'CHECKING'
  /** Merge status has not been checked. */
  | 'UNCHECKED';

export type MergeStrategyEnum =
  /** Use the add_to_merge_train_when_checks_pass merge strategy. */
  | 'ADD_TO_MERGE_TRAIN_WHEN_CHECKS_PASS'
  /** Use the merge_train merge strategy. */
  | 'MERGE_TRAIN'
  /** Use the merge_when_checks_pass merge strategy. */
  | 'MERGE_WHEN_CHECKS_PASS';

/** Represents a set of cars/merge_requests queued for merging */
export type MergeTrain = {
  __typename?: 'MergeTrain';
  /**
   * Cars queued in the train. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  cars: MergeTrainCarConnection;
  /** Target branch of the car's merge request. */
  targetBranch: Scalars['String']['output'];
};


/** Represents a set of cars/merge_requests queued for merging */
export type MergeTrainCarsArgs = {
  activityStatus?: MergeTrainStatus;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** MergeTrainCar represents an attempt to merge a merge requestusing merge trains. */
export type MergeTrainCar = {
  __typename?: 'MergeTrainCar';
  /** Timestamp of when the car was created. */
  createdAt: Scalars['Time']['output'];
  /** Duration of the car. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** Global ID of the car. */
  id: Scalars['MergeTrainsCarID']['output'];
  /** Zero-based position of the car in the merge train. Returns `null` if the car is not active in a merge train. */
  index?: Maybe<Scalars['Int']['output']>;
  /** Merge request the car contains. */
  mergeRequest: MergeRequest;
  /** Timestamp of when the car was merged. */
  mergedAt?: Maybe<Scalars['Time']['output']>;
  /** Pipeline of the car. */
  pipeline?: Maybe<Pipeline>;
  /** Status of the car. */
  status: CarStatus;
  /** Target branch of the car's merge request. */
  targetBranch: Scalars['String']['output'];
  /** Project the car's MR targets. */
  targetProject: Project;
  /** Timestamp of when the car was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Creator of the car (user who added the merge request to the train). */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: CarPermissions;
};

/** The connection type for MergeTrainCar. */
export type MergeTrainCarConnection = {
  __typename?: 'MergeTrainCarConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeTrainCarEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeTrainCar>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeTrainCar. */
export type MergeTrainCarConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeTrainCarEdge = {
  __typename?: 'MergeTrainCarEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeTrainCar>;
};

/** The connection type for MergeTrain. */
export type MergeTrainConnection = {
  __typename?: 'MergeTrainConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeTrainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeTrain>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MergeTrain. */
export type MergeTrainConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MergeTrainEdge = {
  __typename?: 'MergeTrainEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeTrain>;
};

export type MergeTrainStatus =
  /** Active merge train. */
  | 'ACTIVE'
  /** Completed merge train. */
  | 'COMPLETED';

/** Autogenerated input type of MergeTrainsDeleteCar */
export type MergeTrainsDeleteCarInput = {
  /** Global ID of the car. */
  carId: Scalars['MergeTrainsCarID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of MergeTrainsDeleteCar. */
export type MergeTrainsDeleteCarPayload = {
  __typename?: 'MergeTrainsDeleteCarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Representation of mergeability check identifier. */
export type MergeabilityCheckIdentifier =
  /** Checks whether CI has passed */
  | 'CI_MUST_PASS'
  /** Checks source branch exists and contains commits. */
  | 'COMMITS_STATUS'
  /** Checks whether the merge request has a conflict */
  | 'CONFLICT'
  /** Checks whether the merge request has open discussions */
  | 'DISCUSSIONS_NOT_RESOLVED'
  /** Checks whether the merge request is draft */
  | 'DRAFT_STATUS'
  /** Checks whether the title or description references a Jira issue. */
  | 'JIRA_ASSOCIATION_MISSING'
  /** Checks whether the merge request contains locked LFS files that are locked by users other than the merge request author */
  | 'LOCKED_LFS_FILES'
  /** Checks whether the merge request contains locked paths */
  | 'LOCKED_PATHS'
  /** Checks whether the merge request is blocked */
  | 'MERGE_REQUEST_BLOCKED'
  /** Checks whether the merge is blocked due to a scheduled merge time */
  | 'MERGE_TIME'
  /** Checks whether the merge request needs to be rebased */
  | 'NEED_REBASE'
  /** Checks whether the merge request is approved */
  | 'NOT_APPROVED'
  /** Checks whether the merge request is open */
  | 'NOT_OPEN'
  /** Checks whether the merge request has changes requested */
  | 'REQUESTED_CHANGES'
  /** Checks whether the security policies are satisfied */
  | 'SECURITY_POLICY_VIOLATIONS'
  /** Checks whether the external status checks pass */
  | 'STATUS_CHECKS_MUST_PASS'
  /** Checks whether the title matches the expected regex */
  | 'TITLE_REGEX';

/** Representation of whether a mergeability check passed, checking, failed or is inactive. */
export type MergeabilityCheckStatus =
  /** Mergeability check is being checked. */
  | 'CHECKING'
  /** Mergeability check has failed. The merge request cannot be merged. */
  | 'FAILED'
  /** Mergeability check is disabled via settings. */
  | 'INACTIVE'
  /** Mergeability check has passed. */
  | 'SUCCESS'
  /** Mergeability check has passed with a warning. */
  | 'WARNING';

export type Metadata = {
  __typename?: 'Metadata';
  /** Enterprise edition. */
  enterprise: Scalars['Boolean']['output'];
  /**
   * Feature flags for the GitLab instance. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  featureFlags: Array<GitlabInstanceFeatureFlag>;
  /** Metadata about KAS. */
  kas: Kas;
  /** Revision. */
  revision: Scalars['String']['output'];
  /** Version. */
  version: Scalars['String']['output'];
};


export type MetadataFeatureFlagsArgs = {
  names: Array<Scalars['String']['input']>;
};

/** Represents a metric image upload */
export type MetricImage = {
  __typename?: 'MetricImage';
  /** File name of the metric image. */
  fileName?: Maybe<Scalars['String']['output']>;
  /** File path of the metric image. */
  filePath?: Maybe<Scalars['String']['output']>;
  /** ID of the metric upload. */
  id: Scalars['ID']['output'];
  /** Internal ID of the metric upload. */
  iid: Scalars['String']['output'];
  /** URL of the metric source. */
  url: Scalars['String']['output'];
};

export type MetricsDashboardAnnotation = {
  __typename?: 'MetricsDashboardAnnotation';
  /** Description of the annotation. */
  description?: Maybe<Scalars['String']['output']>;
  /** Timestamp marking end of annotated time span. */
  endingAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the annotation. */
  id: Scalars['ID']['output'];
  /** ID of a dashboard panel to which the annotation should be scoped. */
  panelId?: Maybe<Scalars['String']['output']>;
  /** Timestamp marking start of annotated time span. */
  startingAt?: Maybe<Scalars['Time']['output']>;
};

/** Represents a milestone */
export type Milestone = TimeboxReportInterface & {
  __typename?: 'Milestone';
  /** Timestamp of milestone creation. */
  createdAt: Scalars['Time']['output'];
  /** Description of the milestone. */
  description?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the milestone due date. */
  dueDate?: Maybe<Scalars['Time']['output']>;
  /** Expired state of the milestone (a milestone is expired when the due date is past the current date). Defaults to `false` when due date has not been set. */
  expired: Scalars['Boolean']['output'];
  /** Group of the milestone. */
  group?: Maybe<Group>;
  /** Indicates if milestone is at group level. */
  groupMilestone: Scalars['Boolean']['output'];
  /** ID of the milestone. */
  id: Scalars['ID']['output'];
  /** Internal ID of the milestone. */
  iid: Scalars['ID']['output'];
  /** Project of the milestone. */
  project?: Maybe<Project>;
  /** Indicates if milestone is at project level. */
  projectMilestone: Scalars['Boolean']['output'];
  /** Releases associated with the milestone. */
  releases?: Maybe<ReleaseConnection>;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Timestamp of the milestone start date. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** State of the milestone. */
  state: MilestoneStateEnum;
  /** Milestone statistics. */
  stats?: Maybe<MilestoneStats>;
  /** Indicates if milestone is at subgroup level. */
  subgroupMilestone: Scalars['Boolean']['output'];
  /** Title of the milestone. */
  title: Scalars['String']['output'];
  /** Upcoming state of the milestone (a milestone is upcoming when the start date is in the future). Defaults to `false` when start date has not been set. */
  upcoming: Scalars['Boolean']['output'];
  /** Timestamp of last milestone update. */
  updatedAt: Scalars['Time']['output'];
  /** Web path of the milestone. */
  webPath: Scalars['String']['output'];
};


/** Represents a milestone */
export type MilestoneReleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a milestone */
export type MilestoneReportArgs = {
  fullPath?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  __typename?: 'MilestoneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MilestoneEdge = {
  __typename?: 'MilestoneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Milestone>;
};

/** Values for sorting milestones */
export type MilestoneSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Milestone due date by ascending order. */
  | 'DUE_DATE_ASC'
  /** Milestone due date by descending order. */
  | 'DUE_DATE_DESC'
  /** Group milestones in the order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in ascending order. */
  | 'EXPIRED_LAST_DUE_DATE_ASC'
  /** Group milestones in the order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in descending order. */
  | 'EXPIRED_LAST_DUE_DATE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Current state of milestone */
export type MilestoneStateEnum =
  /** Milestone is currently active. */
  | 'active'
  /** Milestone is closed. */
  | 'closed';

/** Contains statistics about a milestone */
export type MilestoneStats = {
  __typename?: 'MilestoneStats';
  /** Number of closed issues associated with the milestone. */
  closedIssuesCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of issues associated with the milestone. */
  totalIssuesCount?: Maybe<Scalars['Int']['output']>;
};

/** Milestone ID wildcard values */
export type MilestoneWildcardId =
  /** Milestone is assigned. */
  | 'ANY'
  /** No milestone is assigned. */
  | 'NONE'
  /** Milestone assigned is open and started (overlaps current date). This differs from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues). */
  | 'STARTED'
  /** Milestone assigned starts in the future (start date > today). This differs from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues). */
  | 'UPCOMING';

/** Candidate for a model version in the model registry */
export type MlCandidate = {
  __typename?: 'MlCandidate';
  /** Map of links to perform actions on the candidate. */
  _links: MlCandidateLinks;
  /** CI information about the job that created the candidate. */
  ciJob?: Maybe<CiJob>;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** User that created the candidate. */
  creator?: Maybe<UserCore>;
  /** MLflow uuid for the candidate. */
  eid: Scalars['String']['output'];
  /** ID of the candidate. */
  id: Scalars['MlCandidateID']['output'];
  /** IID of the candidate scoped to project. */
  iid: Scalars['Int']['output'];
  /** Metadata entries for the candidate. */
  metadata: MlCandidateMetadataConnection;
  /** Metrics for the candidate. */
  metrics: MlCandidateMetricConnection;
  /** Name of the candidate. */
  name?: Maybe<Scalars['String']['output']>;
  /** Parameters for the candidate. */
  params: MlCandidateParamConnection;
  /** Candidate status. */
  status?: Maybe<Scalars['String']['output']>;
};


/** Candidate for a model version in the model registry */
export type MlCandidateMetadataArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Candidate for a model version in the model registry */
export type MlCandidateMetricsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Candidate for a model version in the model registry */
export type MlCandidateParamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for MlCandidate. */
export type MlCandidateConnection = {
  __typename?: 'MlCandidateConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlCandidateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlCandidate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlCandidate. */
export type MlCandidateConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MlCandidateEdge = {
  __typename?: 'MlCandidateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlCandidate>;
};

/** Metadata for a candidate in the model registry */
export type MlCandidateMetadata = {
  __typename?: 'MlCandidateMetadata';
  /** ID of the metadata. */
  id: Scalars['MlCandidateMetadataID']['output'];
  /** Name of the metadata entry. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value set for the metadata entry. */
  value: Scalars['String']['output'];
};

/** The connection type for MlCandidateMetadata. */
export type MlCandidateMetadataConnection = {
  __typename?: 'MlCandidateMetadataConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlCandidateMetadataEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlCandidateMetadata>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlCandidateMetadata. */
export type MlCandidateMetadataConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MlCandidateMetadataEdge = {
  __typename?: 'MlCandidateMetadataEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlCandidateMetadata>;
};

/** Metric for a candidate in the model registry */
export type MlCandidateMetric = {
  __typename?: 'MlCandidateMetric';
  /** ID of the metric. */
  id: Scalars['MlCandidateMetricID']['output'];
  /** Name of the metric. */
  name?: Maybe<Scalars['String']['output']>;
  /** Step at which the metric was measured. */
  step: Scalars['Int']['output'];
  /** Value set for the metric. */
  value: Scalars['Float']['output'];
};

/** The connection type for MlCandidateMetric. */
export type MlCandidateMetricConnection = {
  __typename?: 'MlCandidateMetricConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlCandidateMetricEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlCandidateMetric>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlCandidateMetric. */
export type MlCandidateMetricConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MlCandidateMetricEdge = {
  __typename?: 'MlCandidateMetricEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlCandidateMetric>;
};

/** Parameter for a candidate in the model registry */
export type MlCandidateParam = {
  __typename?: 'MlCandidateParam';
  /** ID of the parameter. */
  id: Scalars['MlCandidateParamID']['output'];
  /** Name of the parameter. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value set for the parameter. */
  value: Scalars['String']['output'];
};

/** The connection type for MlCandidateParam. */
export type MlCandidateParamConnection = {
  __typename?: 'MlCandidateParamConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlCandidateParamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlCandidateParam>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlCandidateParam. */
export type MlCandidateParamConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MlCandidateParamEdge = {
  __typename?: 'MlCandidateParamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlCandidateParam>;
};

/** Machine learning experiment in model experiments */
export type MlExperiment = {
  __typename?: 'MlExperiment';
  /** Number of candidates in the experiment. */
  candidateCount: Scalars['Int']['output'];
  /** Candidates of the experiment. */
  candidates?: Maybe<MlCandidateConnection>;
  /** Timestamp of when the experiment was created. */
  createdAt: Scalars['Time']['output'];
  /** User who created the experiment. */
  creator?: Maybe<UserCore>;
  /** ID of the experiment. */
  id: Scalars['MlExperimentID']['output'];
  /** ID of the model. */
  modelId?: Maybe<Scalars['MlModelID']['output']>;
  /** Name of the experiment. */
  name: Scalars['String']['output'];
  /** Web URL of the experiment. */
  path: Scalars['String']['output'];
  /** Timestamp of when the experiment was updated. */
  updatedAt: Scalars['Time']['output'];
};


/** Machine learning experiment in model experiments */
export type MlExperimentCandidatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for MlExperiment. */
export type MlExperimentConnection = {
  __typename?: 'MlExperimentConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlExperimentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlExperiment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlExperiment. */
export type MlExperimentConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type MlExperimentEdge = {
  __typename?: 'MlExperimentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlExperiment>;
};

/** Machine learning model in the model registry */
export type MlModel = {
  __typename?: 'MlModel';
  /** Map of links to perform actions on the model. */
  _links: MlModelLinks;
  /** User that created the model. */
  author?: Maybe<UserCore>;
  /** Count of candidates in the model. */
  candidateCount?: Maybe<Scalars['Int']['output']>;
  /** Version candidates of the model. */
  candidates?: Maybe<MlCandidateConnection>;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Path to default experiment page for the model. */
  defaultExperimentPath?: Maybe<Scalars['String']['output']>;
  /** Description of the model. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** ID of the model. */
  id: Scalars['MlModelID']['output'];
  /** Latest version of the model. */
  latestVersion?: Maybe<MlModelVersion>;
  /** Name of the model. */
  name: Scalars['String']['output'];
  /** Version of the model. */
  version?: Maybe<MlModelVersion>;
  /** Count of versions in the model. */
  versionCount?: Maybe<Scalars['Int']['output']>;
  /** Versions of the model. */
  versions?: Maybe<MlModelVersionConnection>;
};


/** Machine learning model in the model registry */
export type MlModelCandidatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Machine learning model in the model registry */
export type MlModelVersionArgs = {
  modelVersionId?: InputMaybe<Scalars['MlModelVersionID']['input']>;
};


/** Machine learning model in the model registry */
export type MlModelVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MlModelVersionsOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for MlModel. */
export type MlModelConnection = {
  __typename?: 'MlModelConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlModelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlModel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlModel. */
export type MlModelConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MlModelCreate */
export type MlModelCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the model. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the model. */
  name: Scalars['String']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MlModelCreate. */
export type MlModelCreatePayload = {
  __typename?: 'MlModelCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model after mutation. */
  model?: Maybe<MlModel>;
};

/** Autogenerated input type of MlModelDelete */
export type MlModelDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the model to be deleted. */
  id: Scalars['MlModelID']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MlModelDelete. */
export type MlModelDeletePayload = {
  __typename?: 'MlModelDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model after mutation. */
  model?: Maybe<MlModel>;
};

/** Autogenerated input type of MlModelDestroy */
export type MlModelDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the model to be deleted. */
  id: Scalars['MlModelID']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MlModelDestroy. */
export type MlModelDestroyPayload = {
  __typename?: 'MlModelDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model deletion result message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Model after mutation. */
  model?: Maybe<MlModel>;
};

/** An edge in a connection. */
export type MlModelEdge = {
  __typename?: 'MlModelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlModel>;
};

/** Autogenerated input type of MlModelEdit */
export type MlModelEditInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the model. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Id of the model. */
  modelId?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the model. */
  name: Scalars['String']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of MlModelEdit. */
export type MlModelEditPayload = {
  __typename?: 'MlModelEditPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model after mutation. */
  model?: Maybe<MlModel>;
};

/** Version of a machine learning model */
export type MlModelVersion = {
  __typename?: 'MlModelVersion';
  /** Map of links to perform actions on the model version. */
  _links: MlModelVersionLinks;
  /** Number of files in the package. */
  artifactsCount?: Maybe<Scalars['Int']['output']>;
  /** User that created the model version. */
  author?: Maybe<UserCore>;
  /** Metrics, params and metadata for the model version. */
  candidate: MlCandidate;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Description of the version. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** ID of the model version. */
  id: Scalars['MlModelVersionID']['output'];
  /** Package for model version artifacts. */
  packageId: Scalars['PackagesPackageID']['output'];
  /** Name of the version. */
  version: Scalars['String']['output'];
};

/** The connection type for MlModelVersion. */
export type MlModelVersionConnection = {
  __typename?: 'MlModelVersionConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MlModelVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MlModelVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for MlModelVersion. */
export type MlModelVersionConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of MlModelVersionCreate */
export type MlModelVersionCreateInput = {
  /** Global ID of a candidate to promote optionally. */
  candidateId?: InputMaybe<Scalars['MlCandidateID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the model version. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the model the version belongs to. */
  modelId: Scalars['MlModelID']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Model version. */
  version?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of MlModelVersionCreate. */
export type MlModelVersionCreatePayload = {
  __typename?: 'MlModelVersionCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model after mutation. */
  modelVersion?: Maybe<MlModelVersion>;
};

/** Autogenerated input type of MlModelVersionDelete */
export type MlModelVersionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the model version to be deleted. */
  id: Scalars['MlModelVersionID']['input'];
};

/** Autogenerated return type of MlModelVersionDelete. */
export type MlModelVersionDeletePayload = {
  __typename?: 'MlModelVersionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted model version. */
  modelVersion?: Maybe<MlModelVersion>;
};

/** An edge in a connection. */
export type MlModelVersionEdge = {
  __typename?: 'MlModelVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MlModelVersion>;
};

/** Autogenerated input type of MlModelVersionEdit */
export type MlModelVersionEditInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the model version. */
  description: Scalars['String']['input'];
  /** Global ID of the model the version belongs to. */
  modelId: Scalars['MlModelID']['input'];
  /** Project the model to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Model version. */
  version: Scalars['String']['input'];
};

/** Autogenerated return type of MlModelVersionEdit. */
export type MlModelVersionEditPayload = {
  __typename?: 'MlModelVersionEditPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Model after mutation. */
  modelVersion?: Maybe<MlModelVersion>;
};

/** Field names for ordering machine learning model versions */
export type MlModelVersionsOrderBy =
  /** Ordered by creation time. */
  | 'CREATED_AT'
  /** Ordered by id. */
  | 'ID'
  /** Ordered by name. */
  | 'VERSION';

/** Values for ordering machine learning models by a specific field */
export type MlModelsOrderBy =
  /** Ordered by creation time. */
  | 'CREATED_AT'
  /** Ordered by id. */
  | 'ID'
  /** Ordered by name. */
  | 'NAME'
  /** Ordered by update time. */
  | 'UPDATED_AT';

/** The position to which the adjacent object should be moved */
export type MoveType =
  /** Adjacent object is moved after the object that is being moved. */
  | 'after'
  /** Adjacent object is moved before the object that is being moved. */
  | 'before';

export type Mutation = {
  __typename?: 'Mutation';
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.10. */
  achievementsAward?: Maybe<AchievementsAwardPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.8. */
  achievementsCreate?: Maybe<AchievementsCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.11. */
  achievementsDelete?: Maybe<AchievementsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.10. */
  achievementsRevoke?: Maybe<AchievementsRevokePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.11. */
  achievementsUpdate?: Maybe<AchievementsUpdatePayload>;
  addProjectToSecurityDashboard?: Maybe<AddProjectToSecurityDashboardPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.0. */
  adminRolesLdapSync?: Maybe<AdminRolesLdapSyncPayload>;
  adminSidekiqQueuesDeleteJobs?: Maybe<AdminSidekiqQueuesDeleteJobsPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.11. */
  aiAction?: Maybe<AiActionPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.8. */
  aiAgentCreate?: Maybe<AiAgentCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  aiAgentDestroy?: Maybe<AiAgentDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  aiAgentUpdate?: Maybe<AiAgentUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  aiCatalogAgentCreate?: Maybe<AiCatalogAgentCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  aiCatalogAgentDelete?: Maybe<AiCatalogAgentDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogAgentUpdate?: Maybe<AiCatalogAgentUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogFlowCreate?: Maybe<AiCatalogFlowCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogFlowDelete?: Maybe<AiCatalogFlowDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogFlowUpdate?: Maybe<AiCatalogFlowUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogItemConsumerCreate?: Maybe<AiCatalogItemConsumerCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogItemConsumerDelete?: Maybe<AiCatalogItemConsumerDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiCatalogItemConsumerUpdate?: Maybe<AiCatalogItemConsumerUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.7. */
  aiCatalogItemReport?: Maybe<AiCatalogItemReportPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.5. */
  aiCatalogThirdPartyFlowCreate?: Maybe<AiCatalogThirdPartyFlowCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.5. */
  aiCatalogThirdPartyFlowDelete?: Maybe<AiCatalogThirdPartyFlowDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.5. */
  aiCatalogThirdPartyFlowUpdate?: Maybe<AiCatalogThirdPartyFlowUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  aiDuoWorkflowCreate?: Maybe<AiDuoWorkflowCreatePayload>;
  /**
   * Updates or creates settings for AI features. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  aiFeatureSettingUpdate?: Maybe<AiFeatureSettingUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiFlowTriggerCreate?: Maybe<AiFlowTriggerCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiFlowTriggerDelete?: Maybe<AiFlowTriggerDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  aiFlowTriggerUpdate?: Maybe<AiFlowTriggerUpdatePayload>;
  /**
   * Updates or creates settings for AI features for a namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  aiModelSelectionNamespaceUpdate?: Maybe<AiModelSelectionNamespaceUpdatePayload>;
  /**
   * Checks if the AI Gateway can establish a connection with the given model configuration. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  aiSelfHostedModelConnectionCheck?: Maybe<AiSelfHostedModelConnectionCheckPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.1. */
  aiSelfHostedModelCreate?: Maybe<AiSelfHostedModelCreatePayload>;
  /**
   * Deletes a self-hosted model. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  aiSelfHostedModelDelete?: Maybe<AiSelfHostedModelDeletePayload>;
  /**
   * Updates a self-hosted model. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  aiSelfHostedModelUpdate?: Maybe<AiSelfHostedModelUpdatePayload>;
  alertSetAssignees?: Maybe<AlertSetAssigneesPayload>;
  alertTodoCreate?: Maybe<AlertTodoCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  approvalProjectRuleDelete?: Maybe<ApprovalProjectRuleDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  approvalProjectRuleUpdate?: Maybe<ApprovalProjectRuleUpdatePayload>;
  approveDeployment?: Maybe<ApproveDeploymentPayload>;
  artifactDestroy?: Maybe<ArtifactDestroyPayload>;
  auditEventsAmazonS3ConfigurationCreate?: Maybe<AuditEventsAmazonS3ConfigurationCreatePayload>;
  auditEventsAmazonS3ConfigurationDelete?: Maybe<AuditEventsAmazonS3ConfigurationDeletePayload>;
  auditEventsAmazonS3ConfigurationUpdate?: Maybe<AuditEventsAmazonS3ConfigurationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsGroupDestinationEventsAdd?: Maybe<AuditEventsGroupDestinationEventsAddPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsGroupDestinationEventsDelete?: Maybe<AuditEventsGroupDestinationEventsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsGroupDestinationNamespaceFilterCreate?: Maybe<AuditEventsGroupDestinationNamespaceFilterCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsGroupDestinationNamespaceFilterDelete?: Maybe<AuditEventsGroupDestinationNamespaceFilterDeletePayload>;
  auditEventsInstanceAmazonS3ConfigurationCreate?: Maybe<AuditEventsInstanceAmazonS3ConfigurationCreatePayload>;
  auditEventsInstanceAmazonS3ConfigurationDelete?: Maybe<AuditEventsInstanceAmazonS3ConfigurationDeletePayload>;
  auditEventsInstanceAmazonS3ConfigurationUpdate?: Maybe<AuditEventsInstanceAmazonS3ConfigurationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsInstanceDestinationEventsAdd?: Maybe<AuditEventsInstanceDestinationEventsAddPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  auditEventsInstanceDestinationEventsDelete?: Maybe<AuditEventsInstanceDestinationEventsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  auditEventsInstanceDestinationNamespaceFilterCreate?: Maybe<AuditEventsInstanceDestinationNamespaceFilterCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  auditEventsInstanceDestinationNamespaceFilterDelete?: Maybe<AuditEventsInstanceDestinationNamespaceFilterDeletePayload>;
  auditEventsStreamingDestinationEventsAdd?: Maybe<AuditEventsStreamingDestinationEventsAddPayload>;
  auditEventsStreamingDestinationEventsRemove?: Maybe<AuditEventsStreamingDestinationEventsRemovePayload>;
  auditEventsStreamingDestinationInstanceEventsAdd?: Maybe<AuditEventsStreamingDestinationInstanceEventsAddPayload>;
  auditEventsStreamingDestinationInstanceEventsRemove?: Maybe<AuditEventsStreamingDestinationInstanceEventsRemovePayload>;
  auditEventsStreamingHeadersCreate?: Maybe<AuditEventsStreamingHeadersCreatePayload>;
  auditEventsStreamingHeadersDestroy?: Maybe<AuditEventsStreamingHeadersDestroyPayload>;
  auditEventsStreamingHeadersUpdate?: Maybe<AuditEventsStreamingHeadersUpdatePayload>;
  auditEventsStreamingHttpNamespaceFiltersAdd?: Maybe<AuditEventsStreamingHttpNamespaceFiltersAddPayload>;
  auditEventsStreamingHttpNamespaceFiltersDelete?: Maybe<AuditEventsStreamingHttpNamespaceFiltersDeletePayload>;
  auditEventsStreamingInstanceHeadersCreate?: Maybe<AuditEventsStreamingInstanceHeadersCreatePayload>;
  auditEventsStreamingInstanceHeadersDestroy?: Maybe<AuditEventsStreamingInstanceHeadersDestroyPayload>;
  auditEventsStreamingInstanceHeadersUpdate?: Maybe<AuditEventsStreamingInstanceHeadersUpdatePayload>;
  awardEmojiAdd?: Maybe<AwardEmojiAddPayload>;
  awardEmojiRemove?: Maybe<AwardEmojiRemovePayload>;
  awardEmojiToggle?: Maybe<AwardEmojiTogglePayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  boardEpicCreate?: Maybe<BoardEpicCreatePayload>;
  boardListCreate?: Maybe<BoardListCreatePayload>;
  boardListUpdateLimitMetrics?: Maybe<BoardListUpdateLimitMetricsPayload>;
  branchDelete?: Maybe<BranchDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  branchRuleApprovalProjectRuleCreate?: Maybe<BranchRuleApprovalProjectRuleCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.7. */
  branchRuleCreate?: Maybe<BranchRuleCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.9. */
  branchRuleDelete?: Maybe<BranchRuleDeletePayload>;
  /**
   * Create a new external status check from a branch rule Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  branchRuleExternalStatusCheckCreate?: Maybe<BranchRuleExternalStatusCheckCreatePayload>;
  /**
   * Destroy an external status check from a branch rule Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  branchRuleExternalStatusCheckDestroy?: Maybe<BranchRuleExternalStatusCheckDestroyPayload>;
  /**
   * Update an external status check from a branch rule Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  branchRuleExternalStatusCheckUpdate?: Maybe<BranchRuleExternalStatusCheckUpdatePayload>;
  /**
   * Delete a squash option for a branch rule Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  branchRuleSquashOptionDelete?: Maybe<BranchRuleSquashOptionDeletePayload>;
  /**
   * Update a squash option for a branch rule Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  branchRuleSquashOptionUpdate?: Maybe<BranchRuleSquashOptionUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.7. */
  branchRuleUpdate?: Maybe<BranchRuleUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.10. */
  bulkDestroyJobArtifacts?: Maybe<BulkDestroyJobArtifactsPayload>;
  /** **Status**: Beta */
  bulkEnableDevopsAdoptionNamespaces?: Maybe<BulkEnableDevopsAdoptionNamespacesPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.3. */
  bulkRunnerDelete?: Maybe<BulkRunnerDeletePayload>;
  bulkUpdateSecurityAttributes?: Maybe<BulkUpdateSecurityAttributesPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.11. */
  catalogResourcesCreate?: Maybe<CatalogResourcesCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.6. */
  catalogResourcesDestroy?: Maybe<CatalogResourcesDestroyPayload>;
  ciJobTokenScopeAddGroupOrProject?: Maybe<CiJobTokenScopeAddGroupOrProjectPayload>;
  ciJobTokenScopeAddProject?: Maybe<CiJobTokenScopeAddProjectPayload>;
  ciJobTokenScopeRemoveGroup?: Maybe<CiJobTokenScopeRemoveGroupPayload>;
  ciJobTokenScopeRemoveProject?: Maybe<CiJobTokenScopeRemoveProjectPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.6. */
  ciJobTokenScopeUpdatePolicies?: Maybe<CiJobTokenScopeUpdatePoliciesPayload>;
  /**
   * Linted and processed contents of a CI config.
   * Should not be requested more than once per request.
   *
   */
  ciLint?: Maybe<CiLintPayload>;
  clusterAgentDelete?: Maybe<ClusterAgentDeletePayload>;
  clusterAgentTokenCreate?: Maybe<ClusterAgentTokenCreatePayload>;
  clusterAgentTokenRevoke?: Maybe<ClusterAgentTokenRevokePayload>;
  clusterAgentUrlConfigurationCreate?: Maybe<ClusterAgentUrlConfigurationCreatePayload>;
  clusterAgentUrlConfigurationDelete?: Maybe<ClusterAgentUrlConfigurationDeletePayload>;
  commitCreate?: Maybe<CommitCreatePayload>;
  /**
   * Configure container scanning for a project by adding it to a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a merge request are part of the response.
   *
   */
  configureContainerScanning?: Maybe<ConfigureContainerScanningPayload>;
  /**
   * Configure Dependency Scanning for a project by enabling Dependency Scanning in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   *
   */
  configureDependencyScanning?: Maybe<ConfigureDependencyScanningPayload>;
  /**
   * Configure SAST for a project by enabling SAST in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   *
   */
  configureSast?: Maybe<ConfigureSastPayload>;
  /**
   * Enable SAST IaC for a project in a new or
   * modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a merge request are a part of the
   * response.
   *
   */
  configureSastIac?: Maybe<ConfigureSastIacPayload>;
  /**
   * Configure Secret Detection for a project by enabling Secret Detection
   * in a new or modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a Merge Request are a part of the
   * response.
   *
   */
  configureSecretDetection?: Maybe<ConfigureSecretDetectionPayload>;
  corpusCreate?: Maybe<CorpusCreatePayload>;
  createAlertIssue?: Maybe<CreateAlertIssuePayload>;
  /** @deprecated Underlying feature was removed in 16.0. Deprecated in GitLab 16.0. */
  createAnnotation?: Maybe<CreateAnnotationPayload>;
  createBoard?: Maybe<CreateBoardPayload>;
  createBranch?: Maybe<CreateBranchPayload>;
  createClusterAgent?: Maybe<CreateClusterAgentPayload>;
  createComplianceFramework?: Maybe<CreateComplianceFrameworkPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.6. */
  createComplianceRequirement?: Maybe<CreateComplianceRequirementPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  createComplianceRequirementsControl?: Maybe<CreateComplianceRequirementsControlPayload>;
  /** Creates a repository protection rule to restrict access to a project's container registry. */
  createContainerProtectionRepositoryRule?: Maybe<CreateContainerProtectionRepositoryRulePayload>;
  /**
   * Creates a protection rule to control which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  createContainerProtectionTagRule?: Maybe<CreateContainerProtectionTagRulePayload>;
  /**
   * Creates a custom dashboard in an organization. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  createCustomDashboard?: Maybe<CreateCustomDashboardPayload>;
  createCustomEmoji?: Maybe<CreateCustomEmojiPayload>;
  createDiffNote?: Maybe<CreateDiffNotePayload>;
  createDiscussion?: Maybe<CreateDiscussionPayload>;
  /** @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5. */
  createEpic?: Maybe<CreateEpicPayload>;
  createImageDiffNote?: Maybe<CreateImageDiffNotePayload>;
  createIssue?: Maybe<CreateIssuePayload>;
  /** @deprecated Use iterationCreate. Deprecated in GitLab 14.0. */
  createIteration?: Maybe<CreateIterationPayload>;
  /**
   * Creates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   *
   */
  createNote?: Maybe<CreateNotePayload>;
  /** Creates a protection rule to restrict access to project packages. */
  createPackagesProtectionRule?: Maybe<CreatePackagesProtectionRulePayload>;
  createRequirement?: Maybe<CreateRequirementPayload>;
  createSnippet?: Maybe<CreateSnippetPayload>;
  createTestCase?: Maybe<CreateTestCasePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  customFieldArchive?: Maybe<CustomFieldArchivePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.6. */
  customFieldCreate?: Maybe<CustomFieldCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  customFieldUnarchive?: Maybe<CustomFieldUnarchivePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.6. */
  customFieldUpdate?: Maybe<CustomFieldUpdatePayload>;
  customerRelationsContactCreate?: Maybe<CustomerRelationsContactCreatePayload>;
  customerRelationsContactUpdate?: Maybe<CustomerRelationsContactUpdatePayload>;
  customerRelationsOrganizationCreate?: Maybe<CustomerRelationsOrganizationCreatePayload>;
  customerRelationsOrganizationUpdate?: Maybe<CustomerRelationsOrganizationUpdatePayload>;
  dastOnDemandScanCreate?: Maybe<DastOnDemandScanCreatePayload>;
  dastProfileCreate?: Maybe<DastProfileCreatePayload>;
  dastProfileDelete?: Maybe<DastProfileDeletePayload>;
  dastProfileRun?: Maybe<DastProfileRunPayload>;
  dastProfileUpdate?: Maybe<DastProfileUpdatePayload>;
  dastScannerProfileCreate?: Maybe<DastScannerProfileCreatePayload>;
  dastScannerProfileDelete?: Maybe<DastScannerProfileDeletePayload>;
  dastScannerProfileUpdate?: Maybe<DastScannerProfileUpdatePayload>;
  dastSiteProfileCreate?: Maybe<DastSiteProfileCreatePayload>;
  dastSiteProfileDelete?: Maybe<DastSiteProfileDeletePayload>;
  dastSiteProfileUpdate?: Maybe<DastSiteProfileUpdatePayload>;
  dastSiteTokenCreate?: Maybe<DastSiteTokenCreatePayload>;
  dastSiteValidationCreate?: Maybe<DastSiteValidationCreatePayload>;
  dastSiteValidationRevoke?: Maybe<DastSiteValidationRevokePayload>;
  /** @deprecated Underlying feature was removed in 16.0. Deprecated in GitLab 16.0. */
  deleteAnnotation?: Maybe<DeleteAnnotationPayload>;
  /** Deletes a container repository protection rule. */
  deleteContainerProtectionRepositoryRule?: Maybe<DeleteContainerProtectionRepositoryRulePayload>;
  /**
   * Deletes a protection rule that controls which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  deleteContainerProtectionTagRule?: Maybe<DeleteContainerProtectionTagRulePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  deleteConversationThread?: Maybe<DeleteConversationThreadPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  deleteDuoWorkflowsWorkflow?: Maybe<DeleteDuoWorkflowsWorkflowPayload>;
  /** Deletes a protection rule for packages. */
  deletePackagesProtectionRule?: Maybe<DeletePackagesProtectionRulePayload>;
  /**
   * Deletes a Pages deployment. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  deletePagesDeployment?: Maybe<DeletePagesDeploymentPayload>;
  designManagementDelete?: Maybe<DesignManagementDeletePayload>;
  designManagementMove?: Maybe<DesignManagementMovePayload>;
  designManagementUpdate?: Maybe<DesignManagementUpdatePayload>;
  designManagementUpload?: Maybe<DesignManagementUploadPayload>;
  destroyBoard?: Maybe<DestroyBoardPayload>;
  destroyBoardList?: Maybe<DestroyBoardListPayload>;
  destroyComplianceFramework?: Maybe<DestroyComplianceFrameworkPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.7. */
  destroyComplianceRequirement?: Maybe<DestroyComplianceRequirementPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  destroyComplianceRequirementsControl?: Maybe<DestroyComplianceRequirementsControlPayload>;
  destroyContainerRepository?: Maybe<DestroyContainerRepositoryPayload>;
  destroyContainerRepositoryTags?: Maybe<DestroyContainerRepositoryTagsPayload>;
  destroyCustomEmoji?: Maybe<DestroyCustomEmojiPayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  destroyEpicBoard?: Maybe<DestroyEpicBoardPayload>;
  destroyNote?: Maybe<DestroyNotePayload>;
  destroyPackage?: Maybe<DestroyPackagePayload>;
  destroyPackageFile?: Maybe<DestroyPackageFilePayload>;
  destroyPackageFiles?: Maybe<DestroyPackageFilesPayload>;
  destroyPackages?: Maybe<DestroyPackagesPayload>;
  destroySnippet?: Maybe<DestroySnippetPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.4. */
  devfileValidate?: Maybe<DevfileValidatePayload>;
  /** **Status**: Beta */
  disableDevopsAdoptionNamespace?: Maybe<DisableDevopsAdoptionNamespacePayload>;
  /** Toggles the resolved state of a discussion */
  discussionToggleResolve?: Maybe<DiscussionToggleResolvePayload>;
  /**
   * Dismisses policy violations linked to a merge request Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  dismissPolicyViolations?: Maybe<DismissPolicyViolationsPayload>;
  /**
   * Updates GitLab Duo settings. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  duoSettingsUpdate?: Maybe<DuoSettingsUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  duoUserFeedback?: Maybe<DuoUserFeedbackPayload>;
  /**
   * A mutation that does not perform any changes.
   *
   * This is expected to be used for testing of endpoints, to verify
   * that a user has mutation access.
   *
   */
  echoCreate?: Maybe<EchoCreatePayload>;
  /** **Status**: Beta */
  enableDevopsAdoptionNamespace?: Maybe<EnableDevopsAdoptionNamespacePayload>;
  /** Create an environment. */
  environmentCreate?: Maybe<EnvironmentCreatePayload>;
  /** Delete an environment. */
  environmentDelete?: Maybe<EnvironmentDeletePayload>;
  /** Stop an environment. */
  environmentStop?: Maybe<EnvironmentStopPayload>;
  /** Update an environment. */
  environmentUpdate?: Maybe<EnvironmentUpdatePayload>;
  /** **Deprecated** This endpoint is planned to be removed along with certificate-based clusters. [See this epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information. */
  environmentsCanaryIngressUpdate?: Maybe<EnvironmentsCanaryIngressUpdatePayload>;
  /** @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5. */
  epicAddIssue?: Maybe<EpicAddIssuePayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  epicBoardCreate?: Maybe<EpicBoardCreatePayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  epicBoardListCreate?: Maybe<EpicBoardListCreatePayload>;
  /**
   * Destroys an epic board list. Deprecated in GitLab 17.5: Replaced by WorkItem type.
   * @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5.
   */
  epicBoardListDestroy?: Maybe<EpicBoardListDestroyPayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  epicBoardUpdate?: Maybe<EpicBoardUpdatePayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  epicMoveList?: Maybe<EpicMoveListPayload>;
  /** @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5. */
  epicSetSubscription?: Maybe<EpicSetSubscriptionPayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  epicTreeReorder?: Maybe<EpicTreeReorderPayload>;
  escalationPolicyCreate?: Maybe<EscalationPolicyCreatePayload>;
  escalationPolicyDestroy?: Maybe<EscalationPolicyDestroyPayload>;
  escalationPolicyUpdate?: Maybe<EscalationPolicyUpdatePayload>;
  exportRequirements?: Maybe<ExportRequirementsPayload>;
  externalAuditEventDestinationCreate?: Maybe<ExternalAuditEventDestinationCreatePayload>;
  externalAuditEventDestinationDestroy?: Maybe<ExternalAuditEventDestinationDestroyPayload>;
  externalAuditEventDestinationUpdate?: Maybe<ExternalAuditEventDestinationUpdatePayload>;
  /**
   * Mutates multiple Geo registries for a given registry class. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  geoRegistriesBulkUpdate?: Maybe<GeoRegistriesBulkUpdatePayload>;
  /**
   * Mutates a Geo registry. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  geoRegistriesUpdate?: Maybe<GeoRegistriesUpdatePayload>;
  gitlabSubscriptionActivate?: Maybe<GitlabSubscriptionActivatePayload>;
  googleCloudLoggingConfigurationCreate?: Maybe<GoogleCloudLoggingConfigurationCreatePayload>;
  googleCloudLoggingConfigurationDestroy?: Maybe<GoogleCloudLoggingConfigurationDestroyPayload>;
  googleCloudLoggingConfigurationUpdate?: Maybe<GoogleCloudLoggingConfigurationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  groupAuditEventStreamingDestinationsCreate?: Maybe<GroupAuditEventStreamingDestinationsCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  groupAuditEventStreamingDestinationsDelete?: Maybe<GroupAuditEventStreamingDestinationsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  groupAuditEventStreamingDestinationsUpdate?: Maybe<GroupAuditEventStreamingDestinationsUpdatePayload>;
  groupMemberBulkUpdate?: Maybe<GroupMemberBulkUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.4. */
  groupMembersExport?: Maybe<GroupMembersExportPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  groupSavedReplyCreate?: Maybe<GroupSavedReplyCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  groupSavedReplyDestroy?: Maybe<GroupSavedReplyDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  groupSavedReplyUpdate?: Maybe<GroupSavedReplyUpdatePayload>;
  groupSecretsManagerDeprovision?: Maybe<GroupSecretsManagerDeprovisionPayload>;
  groupSecretsManagerInitialize?: Maybe<GroupSecretsManagerInitializePayload>;
  groupSecretsPermissionDelete?: Maybe<GroupSecretsPermissionDeletePayload>;
  groupSecretsPermissionUpdate?: Maybe<GroupSecretsPermissionUpdatePayload>;
  groupUpdate?: Maybe<GroupUpdatePayload>;
  httpIntegrationCreate?: Maybe<HttpIntegrationCreatePayload>;
  httpIntegrationDestroy?: Maybe<HttpIntegrationDestroyPayload>;
  httpIntegrationResetToken?: Maybe<HttpIntegrationResetTokenPayload>;
  httpIntegrationUpdate?: Maybe<HttpIntegrationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  importSourceUserCancelReassignment?: Maybe<ImportSourceUserCancelReassignmentPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.6. */
  importSourceUserKeepAllAsPlaceholder?: Maybe<ImportSourceUserKeepAllAsPlaceholderPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  importSourceUserKeepAsPlaceholder?: Maybe<ImportSourceUserKeepAsPlaceholderPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  importSourceUserReassign?: Maybe<ImportSourceUserReassignPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  importSourceUserResendNotification?: Maybe<ImportSourceUserResendNotificationPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.4. */
  importSourceUserUndoKeepAsPlaceholder?: Maybe<ImportSourceUserUndoKeepAsPlaceholderPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  instanceAuditEventStreamingDestinationsCreate?: Maybe<InstanceAuditEventStreamingDestinationsCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  instanceAuditEventStreamingDestinationsDelete?: Maybe<InstanceAuditEventStreamingDestinationsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  instanceAuditEventStreamingDestinationsUpdate?: Maybe<InstanceAuditEventStreamingDestinationsUpdatePayload>;
  instanceExternalAuditEventDestinationCreate?: Maybe<InstanceExternalAuditEventDestinationCreatePayload>;
  instanceExternalAuditEventDestinationDestroy?: Maybe<InstanceExternalAuditEventDestinationDestroyPayload>;
  instanceExternalAuditEventDestinationUpdate?: Maybe<InstanceExternalAuditEventDestinationUpdatePayload>;
  instanceGoogleCloudLoggingConfigurationCreate?: Maybe<InstanceGoogleCloudLoggingConfigurationCreatePayload>;
  instanceGoogleCloudLoggingConfigurationDestroy?: Maybe<InstanceGoogleCloudLoggingConfigurationDestroyPayload>;
  instanceGoogleCloudLoggingConfigurationUpdate?: Maybe<InstanceGoogleCloudLoggingConfigurationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  integrationExclusionCreate?: Maybe<IntegrationExclusionCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  integrationExclusionDelete?: Maybe<IntegrationExclusionDeletePayload>;
  issuableResourceLinkCreate?: Maybe<IssuableResourceLinkCreatePayload>;
  issuableResourceLinkDestroy?: Maybe<IssuableResourceLinkDestroyPayload>;
  issueLinkAlerts?: Maybe<IssueLinkAlertsPayload>;
  issueMove?: Maybe<IssueMovePayload>;
  issueMoveList?: Maybe<IssueMoveListPayload>;
  issueSetAssignees?: Maybe<IssueSetAssigneesPayload>;
  issueSetConfidential?: Maybe<IssueSetConfidentialPayload>;
  issueSetCrmContacts?: Maybe<IssueSetCrmContactsPayload>;
  issueSetDueDate?: Maybe<IssueSetDueDatePayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  issueSetEpic?: Maybe<IssueSetEpicPayload>;
  issueSetEscalationPolicy?: Maybe<IssueSetEscalationPolicyPayload>;
  issueSetEscalationStatus?: Maybe<IssueSetEscalationStatusPayload>;
  issueSetIteration?: Maybe<IssueSetIterationPayload>;
  issueSetLocked?: Maybe<IssueSetLockedPayload>;
  issueSetSeverity?: Maybe<IssueSetSeverityPayload>;
  issueSetSubscription?: Maybe<IssueSetSubscriptionPayload>;
  issueSetWeight?: Maybe<IssueSetWeightPayload>;
  issueUnlinkAlert?: Maybe<IssueUnlinkAlertPayload>;
  iterationCadenceCreate?: Maybe<IterationCadenceCreatePayload>;
  iterationCadenceDestroy?: Maybe<IterationCadenceDestroyPayload>;
  iterationCadenceUpdate?: Maybe<IterationCadenceUpdatePayload>;
  iterationCreate?: Maybe<IterationCreatePayload>;
  iterationDelete?: Maybe<IterationDeletePayload>;
  jiraImportStart?: Maybe<JiraImportStartPayload>;
  jiraImportUsers?: Maybe<JiraImportUsersPayload>;
  jobArtifactsDestroy?: Maybe<JobArtifactsDestroyPayload>;
  jobCancel?: Maybe<JobCancelPayload>;
  jobPlay?: Maybe<JobPlayPayload>;
  jobRetry?: Maybe<JobRetryPayload>;
  jobUnschedule?: Maybe<JobUnschedulePayload>;
  labelCreate?: Maybe<LabelCreatePayload>;
  labelUpdate?: Maybe<LabelUpdatePayload>;
  /**
   * Creates an instance-level custom admin role LDAP link Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  ldapAdminRoleLinkCreate?: Maybe<LdapAdminRoleLinkCreatePayload>;
  /**
   * Destroys an instance-level custom admin role LDAP link Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  ldapAdminRoleLinkDestroy?: Maybe<LdapAdminRoleLinkDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.4. */
  lifecycleAttachWorkItemType?: Maybe<LifecycleAttachWorkItemTypePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.4. */
  lifecycleCreate?: Maybe<LifecycleCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.4. */
  lifecycleDelete?: Maybe<LifecycleDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  lifecycleUpdate?: Maybe<LifecycleUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  linkProjectComplianceViolationIssue?: Maybe<LinkProjectComplianceViolationIssuePayload>;
  markAsSpamSnippet?: Maybe<MarkAsSpamSnippetPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  mavenUpstreamCreate?: Maybe<MavenUpstreamCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.7. */
  memberRoleAdminCreate?: Maybe<MemberRoleAdminCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.10. */
  memberRoleAdminDelete?: Maybe<MemberRoleAdminDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.10. */
  memberRoleAdminUpdate?: Maybe<MemberRoleAdminUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.5. */
  memberRoleCreate?: Maybe<MemberRoleCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.7. */
  memberRoleDelete?: Maybe<MemberRoleDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.7. */
  memberRoleToUserAssign?: Maybe<MemberRoleToUserAssignPayload>;
  memberRoleUpdate?: Maybe<MemberRoleUpdatePayload>;
  /**
   * Accepts a merge request.
   * When accepted, the source branch will be scheduled to merge into the target branch, either
   * immediately if possible, or using one of the automatic merge strategies.
   *
   * [In GitLab 16.5](https://gitlab.com/gitlab-org/gitlab/-/issues/421510), the merging happens asynchronously.
   * This results in `mergeRequest` and `state` not updating after a mutation request,
   * because the merging may not have happened yet.
   *
   */
  mergeRequestAccept?: Maybe<MergeRequestAcceptPayload>;
  /**
   * Bypasses security policies for a merge request. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  mergeRequestBypassSecurityPolicy?: Maybe<MergeRequestBypassSecurityPolicyPayload>;
  mergeRequestCreate?: Maybe<MergeRequestCreatePayload>;
  mergeRequestDestroyRequestedChanges?: Maybe<MergeRequestDestroyRequestedChangesPayload>;
  mergeRequestReviewerRereview?: Maybe<MergeRequestReviewerRereviewPayload>;
  mergeRequestSetAssignees?: Maybe<MergeRequestSetAssigneesPayload>;
  mergeRequestSetDraft?: Maybe<MergeRequestSetDraftPayload>;
  mergeRequestSetLabels?: Maybe<MergeRequestSetLabelsPayload>;
  mergeRequestSetLocked?: Maybe<MergeRequestSetLockedPayload>;
  mergeRequestSetMilestone?: Maybe<MergeRequestSetMilestonePayload>;
  mergeRequestSetReviewers?: Maybe<MergeRequestSetReviewersPayload>;
  mergeRequestSetSubscription?: Maybe<MergeRequestSetSubscriptionPayload>;
  /** Update attributes of a merge request */
  mergeRequestUpdate?: Maybe<MergeRequestUpdatePayload>;
  mergeRequestUpdateApprovalRule?: Maybe<MergeRequestUpdateApprovalRulePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  mergeTrainsDeleteCar?: Maybe<MergeTrainsDeleteCarPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.8. */
  mlModelCreate?: Maybe<MlModelCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  mlModelDelete?: Maybe<MlModelDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.10. */
  mlModelDestroy?: Maybe<MlModelDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.3. */
  mlModelEdit?: Maybe<MlModelEditPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.1. */
  mlModelVersionCreate?: Maybe<MlModelVersionCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  mlModelVersionDelete?: Maybe<MlModelVersionDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.4. */
  mlModelVersionEdit?: Maybe<MlModelVersionEditPayload>;
  namespaceBanDestroy?: Maybe<NamespaceBanDestroyPayload>;
  namespaceCiCdSettingsUpdate?: Maybe<NamespaceCiCdSettingsUpdatePayload>;
  namespaceCreateRemoteDevelopmentClusterAgentMapping?: Maybe<NamespaceCreateRemoteDevelopmentClusterAgentMappingPayload>;
  namespaceDeleteRemoteDevelopmentClusterAgentMapping?: Maybe<NamespaceDeleteRemoteDevelopmentClusterAgentMappingPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  namespaceSettingsUpdate?: Maybe<NamespaceSettingsUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  namespacesRegenerateNewWorkItemEmailAddress?: Maybe<NamespacesRegenerateNewWorkItemEmailAddressPayload>;
  /** Convert a standard comment to a resolvable thread. */
  noteConvertToThread?: Maybe<NoteConvertToThreadPayload>;
  oncallRotationCreate?: Maybe<OncallRotationCreatePayload>;
  oncallRotationDestroy?: Maybe<OncallRotationDestroyPayload>;
  oncallRotationUpdate?: Maybe<OncallRotationUpdatePayload>;
  oncallScheduleCreate?: Maybe<OncallScheduleCreatePayload>;
  oncallScheduleDestroy?: Maybe<OncallScheduleDestroyPayload>;
  oncallScheduleUpdate?: Maybe<OncallScheduleUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.6. */
  organizationCreate?: Maybe<OrganizationCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.11. */
  organizationCreateClusterAgentMapping?: Maybe<OrganizationCreateClusterAgentMappingPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.11. */
  organizationDeleteClusterAgentMapping?: Maybe<OrganizationDeleteClusterAgentMappingPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.7. */
  organizationUpdate?: Maybe<OrganizationUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.5. */
  organizationUserUpdate?: Maybe<OrganizationUserUpdatePayload>;
  pagesMarkOnboardingComplete?: Maybe<PagesMarkOnboardingCompletePayload>;
  /**
   * Creates a personal access token for the current user. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  personalAccessTokenCreate?: Maybe<PersonalAccessTokenCreatePayload>;
  /**
   * Revokes a specified personal access token. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  personalAccessTokenRevoke?: Maybe<PersonalAccessTokenRevokePayload>;
  /**
   * Rotate a specified personal access token. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  personalAccessTokenRotate?: Maybe<PersonalAccessTokenRotatePayload>;
  pipelineCancel?: Maybe<PipelineCancelPayload>;
  pipelineCreate?: Maybe<PipelineCreatePayload>;
  pipelineDestroy?: Maybe<PipelineDestroyPayload>;
  pipelineRetry?: Maybe<PipelineRetryPayload>;
  pipelineScheduleCreate?: Maybe<PipelineScheduleCreatePayload>;
  pipelineScheduleDelete?: Maybe<PipelineScheduleDeletePayload>;
  pipelineSchedulePlay?: Maybe<PipelineSchedulePlayPayload>;
  pipelineScheduleTakeOwnership?: Maybe<PipelineScheduleTakeOwnershipPayload>;
  pipelineScheduleUpdate?: Maybe<PipelineScheduleUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.3. */
  pipelineTriggerCreate?: Maybe<PipelineTriggerCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.3. */
  pipelineTriggerDelete?: Maybe<PipelineTriggerDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.3. */
  pipelineTriggerUpdate?: Maybe<PipelineTriggerUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.2. */
  processUserBillablePromotionRequest?: Maybe<ProcessUserBillablePromotionRequestPayload>;
  productAnalyticsProjectSettingsUpdate?: Maybe<ProductAnalyticsProjectSettingsUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.1. */
  projectBlobsRemove?: Maybe<ProjectBlobsRemovePayload>;
  projectCiCdSettingsUpdate?: Maybe<ProjectCiCdSettingsUpdatePayload>;
  projectInitializeProductAnalytics?: Maybe<ProjectInitializeProductAnalyticsPayload>;
  /** Updates multiple members of a project. To use this mutation, you must have at least the Maintainer role. */
  projectMemberBulkUpdate?: Maybe<ProjectMemberBulkUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  projectSavedReplyCreate?: Maybe<ProjectSavedReplyCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  projectSavedReplyDestroy?: Maybe<ProjectSavedReplyDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.11. */
  projectSavedReplyUpdate?: Maybe<ProjectSavedReplyUpdatePayload>;
  projectSecretCreate?: Maybe<ProjectSecretCreatePayload>;
  projectSecretDelete?: Maybe<ProjectSecretDeletePayload>;
  projectSecretUpdate?: Maybe<ProjectSecretUpdatePayload>;
  projectSecretsManagerDeprovision?: Maybe<ProjectSecretsManagerDeprovisionPayload>;
  projectSecretsManagerInitialize?: Maybe<ProjectSecretsManagerInitializePayload>;
  projectSecretsPermissionDelete?: Maybe<ProjectSecretsPermissionDeletePayload>;
  projectSecretsPermissionUpdate?: Maybe<ProjectSecretsPermissionUpdatePayload>;
  projectSecurityExclusionCreate?: Maybe<ProjectSecurityExclusionCreatePayload>;
  projectSecurityExclusionDelete?: Maybe<ProjectSecurityExclusionDeletePayload>;
  projectSecurityExclusionUpdate?: Maybe<ProjectSecurityExclusionUpdatePayload>;
  /**
   * Assign (or unset) a compliance framework to a project. This mutation raises an error if the project has more than one compliance framework associated with it. Deprecated in GitLab 17.11: Use mutation ProjectUpdateComplianceFrameworks instead of this.
   * @deprecated Use mutation ProjectUpdateComplianceFrameworks instead of this. Deprecated in GitLab 17.11.
   */
  projectSetComplianceFramework?: Maybe<ProjectSetComplianceFrameworkPayload>;
  /**
   * Enable or disable continuous vulnerability scanning for the given project. Deprecated in GitLab 17.3: CVS has been enabled permanently. See [this epic](https://gitlab.com/groups/gitlab-org/-/epics/11474) for more information.
   * @deprecated CVS has been enabled permanently. See [this epic](https://gitlab.com/groups/gitlab-org/-/epics/11474) for more information. Deprecated in GitLab 17.3.
   */
  projectSetContinuousVulnerabilityScanning?: Maybe<ProjectSetContinuousVulnerabilityScanningPayload>;
  projectSetLocked?: Maybe<ProjectSetLockedPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.9. */
  projectSettingsUpdate?: Maybe<ProjectSettingsUpdatePayload>;
  projectSubscriptionCreate?: Maybe<ProjectSubscriptionCreatePayload>;
  projectSubscriptionDelete?: Maybe<ProjectSubscriptionDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.9. */
  projectSyncFork?: Maybe<ProjectSyncForkPayload>;
  projectTargetBranchRuleCreate?: Maybe<ProjectTargetBranchRuleCreatePayload>;
  projectTargetBranchRuleDestroy?: Maybe<ProjectTargetBranchRuleDestroyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.1. */
  projectTextReplace?: Maybe<ProjectTextReplacePayload>;
  /** Update compliance frameworks for a project. */
  projectUpdateComplianceFrameworks?: Maybe<ProjectUpdateComplianceFrameworksPayload>;
  /** @deprecated Use HttpIntegrationCreate. Deprecated in GitLab 18.2. */
  prometheusIntegrationCreate?: Maybe<PrometheusIntegrationCreatePayload>;
  /** @deprecated Use HttpIntegrationResetToken. Deprecated in GitLab 18.2. */
  prometheusIntegrationResetToken?: Maybe<PrometheusIntegrationResetTokenPayload>;
  /** @deprecated Use HttpIntegrationUpdate. Deprecated in GitLab 18.2. */
  prometheusIntegrationUpdate?: Maybe<PrometheusIntegrationUpdatePayload>;
  /** @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5. */
  promoteToEpic?: Maybe<PromoteToEpicPayload>;
  refreshFindingTokenStatus?: Maybe<RefreshFindingTokenStatusPayload>;
  refreshSecurityFindingTokenStatus?: Maybe<RefreshSecurityFindingTokenStatusPayload>;
  refreshStandardsAdherenceChecks?: Maybe<RefreshStandardsAdherenceChecksPayload>;
  refreshVulnerabilityFindingTokenStatus?: Maybe<RefreshVulnerabilityFindingTokenStatusPayload>;
  releaseAssetLinkCreate?: Maybe<ReleaseAssetLinkCreatePayload>;
  releaseAssetLinkDelete?: Maybe<ReleaseAssetLinkDeletePayload>;
  releaseAssetLinkUpdate?: Maybe<ReleaseAssetLinkUpdatePayload>;
  releaseCreate?: Maybe<ReleaseCreatePayload>;
  releaseDelete?: Maybe<ReleaseDeletePayload>;
  releaseUpdate?: Maybe<ReleaseUpdatePayload>;
  removeProjectFromSecurityDashboard?: Maybe<RemoveProjectFromSecurityDashboardPayload>;
  /** Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`) */
  repositionImageDiffNote?: Maybe<RepositionImageDiffNotePayload>;
  /**
   * Restores a Pages deployment that has been scheduled for deletion. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  restorePagesDeployment?: Maybe<RestorePagesDeploymentPayload>;
  /**
   * Triggers a resynchronization of security policies linked to the given project or group (`full_path`) Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  resyncSecurityPolicies?: Maybe<ResyncSecurityPoliciesPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  runnerAssignToProject?: Maybe<RunnerAssignToProjectPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.11. */
  runnerBulkPause?: Maybe<RunnerBulkPausePayload>;
  runnerCacheClear?: Maybe<RunnerCacheClearPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.10. */
  runnerCreate?: Maybe<RunnerCreatePayload>;
  runnerDelete?: Maybe<RunnerDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  runnerUnassignFromProject?: Maybe<RunnerUnassignFromProjectPayload>;
  runnerUpdate?: Maybe<RunnerUpdatePayload>;
  runnersExportUsage?: Maybe<RunnersExportUsagePayload>;
  /** @deprecated Underlying feature was deprecated in 15.6 and will be removed in 18.0. Deprecated in GitLab 17.7. */
  runnersRegistrationTokenReset?: Maybe<RunnersRegistrationTokenResetPayload>;
  safeDisablePipelineVariables?: Maybe<SafeDisablePipelineVariablesPayload>;
  savedReplyCreate?: Maybe<SavedReplyCreatePayload>;
  savedReplyDestroy?: Maybe<SavedReplyDestroyPayload>;
  savedReplyUpdate?: Maybe<SavedReplyUpdatePayload>;
  /** Commits the `policy_yaml` content to the assigned security policy project for the given project (`full_path`) */
  scanExecutionPolicyCommit?: Maybe<ScanExecutionPolicyCommitPayload>;
  secretPermissionDelete?: Maybe<SecretPermissionDeletePayload>;
  secretPermissionUpdate?: Maybe<SecretPermissionUpdatePayload>;
  securityAttributeCreate?: Maybe<SecurityAttributeCreatePayload>;
  securityAttributeDestroy?: Maybe<SecurityAttributeDestroyPayload>;
  securityAttributeProjectUpdate?: Maybe<SecurityAttributeProjectUpdatePayload>;
  securityAttributeUpdate?: Maybe<SecurityAttributeUpdatePayload>;
  securityCategoryCreate?: Maybe<SecurityCategoryCreatePayload>;
  securityCategoryDestroy?: Maybe<SecurityCategoryDestroyPayload>;
  securityCategoryUpdate?: Maybe<SecurityCategoryUpdatePayload>;
  securityFindingCreateIssue?: Maybe<SecurityFindingCreateIssuePayload>;
  securityFindingCreateMergeRequest?: Maybe<SecurityFindingCreateMergeRequestPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.5. */
  securityFindingCreateVulnerability?: Maybe<SecurityFindingCreateVulnerabilityPayload>;
  securityFindingDismiss?: Maybe<SecurityFindingDismissPayload>;
  securityFindingExternalIssueLinkCreate?: Maybe<SecurityFindingExternalIssueLinkCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.7. */
  securityFindingJiraIssueFormUrlCreate?: Maybe<SecurityFindingJiraIssueFormUrlCreatePayload>;
  securityFindingRevertToDetected?: Maybe<SecurityFindingRevertToDetectedPayload>;
  securityFindingSeverityOverride?: Maybe<SecurityFindingSeverityOverridePayload>;
  /** Assigns the specified project(`security_policy_project_id`) as security policy project for the given project(`full_path`). If the project already has a security policy project, this reassigns the project's security policy project with the given `security_policy_project_id` */
  securityPolicyProjectAssign?: Maybe<SecurityPolicyProjectAssignPayload>;
  /** Creates and assigns a security policy project for the given project or group (`full_path`) */
  securityPolicyProjectCreate?: Maybe<SecurityPolicyProjectCreatePayload>;
  /**
   * Creates and assigns a security policy project for the given project or group (`full_path`) async Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  securityPolicyProjectCreateAsync?: Maybe<SecurityPolicyProjectCreateAsyncPayload>;
  /** Unassigns the security policy project for the given project (`full_path`). */
  securityPolicyProjectUnassign?: Maybe<SecurityPolicyProjectUnassignPayload>;
  securityTrainingUpdate?: Maybe<SecurityTrainingUpdatePayload>;
  /**
   * Enable/disable container scanning for registry for the given project.
   *
   */
  setContainerScanningForRegistry?: Maybe<SetContainerScanningForRegistryPayload>;
  /** Enable or disable Secret Push Protection for a group. */
  setGroupSecretPushProtection?: Maybe<SetGroupSecretPushProtectionPayload>;
  /** Enable or disable Validity Checks for a group. */
  setGroupValidityChecks?: Maybe<SetGroupValidityChecksPayload>;
  /**
   * Set the license information source for a given project.
   *
   */
  setLicenseConfigurationSource?: Maybe<SetLicenseConfigurationSourcePayload>;
  setPagesForceHttps?: Maybe<SetPagesForceHttpsPayload>;
  setPagesUseUniqueDomain?: Maybe<SetPagesUseUniqueDomainPayload>;
  /**
   * Enable/disable secret push protection for the given project.
   *
   */
  setPreReceiveSecretDetection?: Maybe<SetPreReceiveSecretDetectionPayload>;
  /**
   * Enable/disable secret push protection for the given project.
   *
   */
  setSecretPushProtection?: Maybe<SetSecretPushProtectionPayload>;
  /**
   * Enable/disable secret detection validity checks for the given project.
   *
   */
  setValidityChecks?: Maybe<SetValidityChecksPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.7. */
  starProject?: Maybe<StarProjectPayload>;
  tagCreate?: Maybe<TagCreatePayload>;
  tagDelete?: Maybe<TagDeletePayload>;
  terraformStateDelete?: Maybe<TerraformStateDeletePayload>;
  terraformStateLock?: Maybe<TerraformStateLockPayload>;
  terraformStateUnlock?: Maybe<TerraformStateUnlockPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.6. */
  timelineEventCreate?: Maybe<TimelineEventCreatePayload>;
  timelineEventDestroy?: Maybe<TimelineEventDestroyPayload>;
  timelineEventPromoteFromNote?: Maybe<TimelineEventPromoteFromNotePayload>;
  timelineEventTagCreate?: Maybe<TimelineEventTagCreatePayload>;
  timelineEventUpdate?: Maybe<TimelineEventUpdatePayload>;
  timelogCreate?: Maybe<TimelogCreatePayload>;
  timelogDelete?: Maybe<TimelogDeletePayload>;
  todoCreate?: Maybe<TodoCreatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.11. */
  todoDeleteAllDone?: Maybe<TodoDeleteAllDonePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.11. */
  todoDeleteMany?: Maybe<TodoDeleteManyPayload>;
  todoMarkDone?: Maybe<TodoMarkDonePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  todoResolveMany?: Maybe<TodoResolveManyPayload>;
  todoRestore?: Maybe<TodoRestorePayload>;
  todoRestoreMany?: Maybe<TodoRestoreManyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.4. */
  todoSnooze?: Maybe<TodoSnoozePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  todoSnoozeMany?: Maybe<TodoSnoozeManyPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.4. */
  todoUnSnooze?: Maybe<TodoUnSnoozePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  todoUnsnoozeMany?: Maybe<TodoUnsnoozeManyPayload>;
  todosMarkAllDone?: Maybe<TodosMarkAllDonePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.3. */
  unlinkProjectComplianceViolationIssue?: Maybe<UnlinkProjectComplianceViolationIssuePayload>;
  updateAlertStatus?: Maybe<UpdateAlertStatusPayload>;
  updateBoard?: Maybe<UpdateBoardPayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  updateBoardEpicUserPreferences?: Maybe<UpdateBoardEpicUserPreferencesPayload>;
  updateBoardList?: Maybe<UpdateBoardListPayload>;
  updateComplianceFramework?: Maybe<UpdateComplianceFrameworkPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.7. */
  updateComplianceRequirement?: Maybe<UpdateComplianceRequirementPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  updateComplianceRequirementsControl?: Maybe<UpdateComplianceRequirementsControlPayload>;
  updateContainerExpirationPolicy?: Maybe<UpdateContainerExpirationPolicyPayload>;
  /** Updates a container repository protection rule that controls who can modify container images based on user roles. */
  updateContainerProtectionRepositoryRule?: Maybe<UpdateContainerProtectionRepositoryRulePayload>;
  /**
   * Updates a protection rule that controls which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  updateContainerProtectionTagRule?: Maybe<UpdateContainerProtectionTagRulePayload>;
  /** These settings can be adjusted only by the group Owner. */
  updateDependencyProxyImageTtlGroupPolicy?: Maybe<UpdateDependencyProxyImageTtlGroupPolicyPayload>;
  /**
   * Updates or creates dependency proxy for packages settings.
   * Requires the packages and dependency proxy to be enabled in the config.
   * Requires the packages feature to be enabled at the project level.
   */
  updateDependencyProxyPackagesSettings?: Maybe<UpdateDependencyProxyPackagesSettingsPayload>;
  /** These settings can be adjusted only by the group Owner. */
  updateDependencyProxySettings?: Maybe<UpdateDependencyProxySettingsPayload>;
  /** @deprecated Replaced by `WorkItem` type. For more information, see [migration guide](https://docs.gitlab.com/api/graphql/epic_work_items_api_migration_guide/). Deprecated in GitLab 17.5. */
  updateEpic?: Maybe<UpdateEpicPayload>;
  /** @deprecated Replaced by WorkItem type. Deprecated in GitLab 17.5. */
  updateEpicBoardList?: Maybe<UpdateEpicBoardListPayload>;
  /**
   * Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   *
   *
   */
  updateImageDiffNote?: Maybe<UpdateImageDiffNotePayload>;
  updateIssue?: Maybe<UpdateIssuePayload>;
  updateIteration?: Maybe<UpdateIterationPayload>;
  /** These settings can be adjusted only by the group Owner. */
  updateNamespacePackageSettings?: Maybe<UpdateNamespacePackageSettingsPayload>;
  /**
   * Updates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   *
   */
  updateNote?: Maybe<UpdateNotePayload>;
  updatePackagesCleanupPolicy?: Maybe<UpdatePackagesCleanupPolicyPayload>;
  /** Updates a package protection rule to restrict access to project packages. You can prevent users without certain permissions from altering packages. */
  updatePackagesProtectionRule?: Maybe<UpdatePackagesProtectionRulePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  updateProjectComplianceViolation?: Maybe<UpdateProjectComplianceViolationPayload>;
  updateRequirement?: Maybe<UpdateRequirementPayload>;
  updateSnippet?: Maybe<UpdateSnippetPayload>;
  /**
   * Updates or creates virtual registries settings for a root group. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  updateVirtualRegistriesSetting?: Maybe<UpdateVirtualRegistriesSettingPayload>;
  /** Deletes an upload. */
  uploadDelete?: Maybe<UploadDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.5. */
  userAchievementPrioritiesUpdate?: Maybe<UserAchievementPrioritiesUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.1. */
  userAchievementsDelete?: Maybe<UserAchievementsDeletePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.3. */
  userAchievementsUpdate?: Maybe<UserAchievementsUpdatePayload>;
  userAddOnAssignmentBulkCreate?: Maybe<UserAddOnAssignmentBulkCreatePayload>;
  userAddOnAssignmentBulkRemove?: Maybe<UserAddOnAssignmentBulkRemovePayload>;
  userAddOnAssignmentCreate?: Maybe<UserAddOnAssignmentCreatePayload>;
  userAddOnAssignmentRemove?: Maybe<UserAddOnAssignmentRemovePayload>;
  userCalloutCreate?: Maybe<UserCalloutCreatePayload>;
  userGroupCalloutCreate?: Maybe<UserGroupCalloutCreatePayload>;
  userPreferencesUpdate?: Maybe<UserPreferencesUpdatePayload>;
  userSetNamespaceCommitEmail?: Maybe<UserSetNamespaceCommitEmailPayload>;
  /**
   * Creates a value stream. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  valueStreamCreate?: Maybe<ValueStreamCreatePayload>;
  /**
   * Destroy a value stream. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  valueStreamDestroy?: Maybe<ValueStreamDestroyPayload>;
  /**
   * Updates a value stream. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  valueStreamUpdate?: Maybe<ValueStreamUpdatePayload>;
  /** Create a verified namespace and mark all child catalog resources with the passed verification level info. */
  verifiedNamespaceCreate?: Maybe<VerifiedNamespaceCreatePayload>;
  /**
   * Create or update virtual registries cleanup policy for a root group. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  virtualRegistriesCleanupPolicyUpsert?: Maybe<VirtualRegistriesCleanupPolicyUpsertPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.10. */
  vulnerabilitiesArchive?: Maybe<VulnerabilitiesArchivePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.9. */
  vulnerabilitiesCreateIssue?: Maybe<VulnerabilitiesCreateIssuePayload>;
  vulnerabilitiesDismiss?: Maybe<VulnerabilitiesDismissPayload>;
  /** Remove all Vulnerabilities and related information from a given project. [Introduced](https://gitlab.com/gitlab-org/gitlab/-/issues/412602) in GitLab 16.7 */
  vulnerabilitiesRemoveAllFromProject?: Maybe<VulnerabilitiesRemoveAllFromProjectPayload>;
  vulnerabilitiesSeverityOverride?: Maybe<VulnerabilitiesSeverityOverridePayload>;
  vulnerabilityConfirm?: Maybe<VulnerabilityConfirmPayload>;
  vulnerabilityCreate?: Maybe<VulnerabilityCreatePayload>;
  vulnerabilityDismiss?: Maybe<VulnerabilityDismissPayload>;
  /**
   * Dismiss a vulnerability false positive flag Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  vulnerabilityDismissFalsePositiveFlag?: Maybe<VulnerabilityDismissFalsePositiveFlagPayload>;
  vulnerabilityExternalIssueLinkCreate?: Maybe<VulnerabilityExternalIssueLinkCreatePayload>;
  vulnerabilityExternalIssueLinkDestroy?: Maybe<VulnerabilityExternalIssueLinkDestroyPayload>;
  vulnerabilityIssueLinkCreate?: Maybe<VulnerabilityIssueLinkCreatePayload>;
  /**
   * Link a merge request to a vulnerability Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  vulnerabilityLinkMergeRequest?: Maybe<VulnerabilityLinkMergeRequestPayload>;
  vulnerabilityResolve?: Maybe<VulnerabilityResolvePayload>;
  vulnerabilityRevertToDetected?: Maybe<VulnerabilityRevertToDetectedPayload>;
  /**
   * Unlink a merge request from a vulnerability Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  vulnerabilityUnlinkMergeRequest?: Maybe<VulnerabilityUnlinkMergeRequestPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.1. */
  wikiPageSubscribe?: Maybe<WikiPageSubscribePayload>;
  /**
   * Adds a closing merge request to a work item Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  workItemAddClosingMergeRequest?: Maybe<WorkItemAddClosingMergeRequestPayload>;
  /**
   * Add linked items to the work item. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  workItemAddLinkedItems?: Maybe<WorkItemAddLinkedItemsPayload>;
  /**
   * Moves work items between projects or groups. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  workItemBulkMove?: Maybe<WorkItemBulkMovePayload>;
  /**
   * Allows updating several properties for a set of work items. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  workItemBulkUpdate?: Maybe<WorkItemBulkUpdatePayload>;
  /**
   * Converts the work item to a new type Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  workItemConvert?: Maybe<WorkItemConvertPayload>;
  /**
   * Creates a work item. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItemCreate?: Maybe<WorkItemCreatePayload>;
  /**
   * Creates a work item from a task in another work item's description. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItemCreateFromTask?: Maybe<WorkItemCreateFromTaskPayload>;
  /**
   * Deletes a work item. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItemDelete?: Maybe<WorkItemDeletePayload>;
  /** @deprecated Use WorkItemsCsvExport. Deprecated in GitLab 18.0. */
  workItemExport?: Maybe<WorkItemExportPayload>;
  /**
   * Adds children to a given work item's hierarchy by Global ID. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  workItemHierarchyAddChildrenItems?: Maybe<WorkItemHierarchyAddChildrenItemsPayload>;
  /**
   * Remove items linked to the work item. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  workItemRemoveLinkedItems?: Maybe<WorkItemRemoveLinkedItemsPayload>;
  /**
   * Creates a saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewCreate?: Maybe<WorkItemSavedViewCreatePayload>;
  /**
   * Deletes a saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewDelete?: Maybe<WorkItemSavedViewDeletePayload>;
  /**
   * Reorders a saved view for the current user. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewReorder?: Maybe<WorkItemSavedViewReorderPayload>;
  /**
   * Subscribes the current user to a saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewSubscribe?: Maybe<WorkItemSavedViewSubscribePayload>;
  /**
   * Unsubscribes the current user to a saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewUnsubscribe?: Maybe<WorkItemSavedViewUnsubscribePayload>;
  /**
   * Updates a saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItemSavedViewUpdate?: Maybe<WorkItemSavedViewUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 16.3. */
  workItemSubscribe?: Maybe<WorkItemSubscribePayload>;
  /**
   * Updates a work item by Global ID. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItemUpdate?: Maybe<WorkItemUpdatePayload>;
  /**
   * Create or Update user preferences for a work item type and namespace. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  workItemUserPreferenceUpdate?: Maybe<WorkItemUserPreferenceUpdatePayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 15.10. */
  workItemsCsvExport?: Maybe<WorkItemsCsvExportPayload>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 18.2. */
  workItemsCsvImport?: Maybe<WorkItemsCsvImportPayload>;
  /**
   * Reorder a work item in the hierarchy tree. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  workItemsHierarchyReorder?: Maybe<WorkItemsHierarchyReorderPayload>;
  /**
   * Reorders a work item. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  workItemsReorder?: Maybe<WorkItemsReorderPayload>;
  workspaceCreate?: Maybe<WorkspaceCreatePayload>;
  workspaceUpdate?: Maybe<WorkspaceUpdatePayload>;
};


export type MutationAchievementsAwardArgs = {
  input: AchievementsAwardInput;
};


export type MutationAchievementsCreateArgs = {
  input: AchievementsCreateInput;
};


export type MutationAchievementsDeleteArgs = {
  input: AchievementsDeleteInput;
};


export type MutationAchievementsRevokeArgs = {
  input: AchievementsRevokeInput;
};


export type MutationAchievementsUpdateArgs = {
  input: AchievementsUpdateInput;
};


export type MutationAddProjectToSecurityDashboardArgs = {
  input: AddProjectToSecurityDashboardInput;
};


export type MutationAdminRolesLdapSyncArgs = {
  input: AdminRolesLdapSyncInput;
};


export type MutationAdminSidekiqQueuesDeleteJobsArgs = {
  input: AdminSidekiqQueuesDeleteJobsInput;
};


export type MutationAiActionArgs = {
  input: AiActionInput;
};


export type MutationAiAgentCreateArgs = {
  input: AiAgentCreateInput;
};


export type MutationAiAgentDestroyArgs = {
  input: AiAgentDestroyInput;
};


export type MutationAiAgentUpdateArgs = {
  input: AiAgentUpdateInput;
};


export type MutationAiCatalogAgentCreateArgs = {
  input: AiCatalogAgentCreateInput;
};


export type MutationAiCatalogAgentDeleteArgs = {
  input: AiCatalogAgentDeleteInput;
};


export type MutationAiCatalogAgentUpdateArgs = {
  input: AiCatalogAgentUpdateInput;
};


export type MutationAiCatalogFlowCreateArgs = {
  input: AiCatalogFlowCreateInput;
};


export type MutationAiCatalogFlowDeleteArgs = {
  input: AiCatalogFlowDeleteInput;
};


export type MutationAiCatalogFlowUpdateArgs = {
  input: AiCatalogFlowUpdateInput;
};


export type MutationAiCatalogItemConsumerCreateArgs = {
  input: AiCatalogItemConsumerCreateInput;
};


export type MutationAiCatalogItemConsumerDeleteArgs = {
  input: AiCatalogItemConsumerDeleteInput;
};


export type MutationAiCatalogItemConsumerUpdateArgs = {
  input: AiCatalogItemConsumerUpdateInput;
};


export type MutationAiCatalogItemReportArgs = {
  input: AiCatalogItemReportInput;
};


export type MutationAiCatalogThirdPartyFlowCreateArgs = {
  input: AiCatalogThirdPartyFlowCreateInput;
};


export type MutationAiCatalogThirdPartyFlowDeleteArgs = {
  input: AiCatalogThirdPartyFlowDeleteInput;
};


export type MutationAiCatalogThirdPartyFlowUpdateArgs = {
  input: AiCatalogThirdPartyFlowUpdateInput;
};


export type MutationAiDuoWorkflowCreateArgs = {
  input: AiDuoWorkflowCreateInput;
};


export type MutationAiFeatureSettingUpdateArgs = {
  input: AiFeatureSettingUpdateInput;
};


export type MutationAiFlowTriggerCreateArgs = {
  input: AiFlowTriggerCreateInput;
};


export type MutationAiFlowTriggerDeleteArgs = {
  input: AiFlowTriggerDeleteInput;
};


export type MutationAiFlowTriggerUpdateArgs = {
  input: AiFlowTriggerUpdateInput;
};


export type MutationAiModelSelectionNamespaceUpdateArgs = {
  input: AiModelSelectionNamespaceUpdateInput;
};


export type MutationAiSelfHostedModelConnectionCheckArgs = {
  input: AiSelfHostedModelConnectionCheckInput;
};


export type MutationAiSelfHostedModelCreateArgs = {
  input: AiSelfHostedModelCreateInput;
};


export type MutationAiSelfHostedModelDeleteArgs = {
  input: AiSelfHostedModelDeleteInput;
};


export type MutationAiSelfHostedModelUpdateArgs = {
  input: AiSelfHostedModelUpdateInput;
};


export type MutationAlertSetAssigneesArgs = {
  input: AlertSetAssigneesInput;
};


export type MutationAlertTodoCreateArgs = {
  input: AlertTodoCreateInput;
};


export type MutationApprovalProjectRuleDeleteArgs = {
  input: ApprovalProjectRuleDeleteInput;
};


export type MutationApprovalProjectRuleUpdateArgs = {
  input: ApprovalProjectRuleUpdateInput;
};


export type MutationApproveDeploymentArgs = {
  input: ApproveDeploymentInput;
};


export type MutationArtifactDestroyArgs = {
  input: ArtifactDestroyInput;
};


export type MutationAuditEventsAmazonS3ConfigurationCreateArgs = {
  input: AuditEventsAmazonS3ConfigurationCreateInput;
};


export type MutationAuditEventsAmazonS3ConfigurationDeleteArgs = {
  input: AuditEventsAmazonS3ConfigurationDeleteInput;
};


export type MutationAuditEventsAmazonS3ConfigurationUpdateArgs = {
  input: AuditEventsAmazonS3ConfigurationUpdateInput;
};


export type MutationAuditEventsGroupDestinationEventsAddArgs = {
  input: AuditEventsGroupDestinationEventsAddInput;
};


export type MutationAuditEventsGroupDestinationEventsDeleteArgs = {
  input: AuditEventsGroupDestinationEventsDeleteInput;
};


export type MutationAuditEventsGroupDestinationNamespaceFilterCreateArgs = {
  input: AuditEventsGroupDestinationNamespaceFilterCreateInput;
};


export type MutationAuditEventsGroupDestinationNamespaceFilterDeleteArgs = {
  input: AuditEventsGroupDestinationNamespaceFilterDeleteInput;
};


export type MutationAuditEventsInstanceAmazonS3ConfigurationCreateArgs = {
  input: AuditEventsInstanceAmazonS3ConfigurationCreateInput;
};


export type MutationAuditEventsInstanceAmazonS3ConfigurationDeleteArgs = {
  input: AuditEventsInstanceAmazonS3ConfigurationDeleteInput;
};


export type MutationAuditEventsInstanceAmazonS3ConfigurationUpdateArgs = {
  input: AuditEventsInstanceAmazonS3ConfigurationUpdateInput;
};


export type MutationAuditEventsInstanceDestinationEventsAddArgs = {
  input: AuditEventsInstanceDestinationEventsAddInput;
};


export type MutationAuditEventsInstanceDestinationEventsDeleteArgs = {
  input: AuditEventsInstanceDestinationEventsDeleteInput;
};


export type MutationAuditEventsInstanceDestinationNamespaceFilterCreateArgs = {
  input: AuditEventsInstanceDestinationNamespaceFilterCreateInput;
};


export type MutationAuditEventsInstanceDestinationNamespaceFilterDeleteArgs = {
  input: AuditEventsInstanceDestinationNamespaceFilterDeleteInput;
};


export type MutationAuditEventsStreamingDestinationEventsAddArgs = {
  input: AuditEventsStreamingDestinationEventsAddInput;
};


export type MutationAuditEventsStreamingDestinationEventsRemoveArgs = {
  input: AuditEventsStreamingDestinationEventsRemoveInput;
};


export type MutationAuditEventsStreamingDestinationInstanceEventsAddArgs = {
  input: AuditEventsStreamingDestinationInstanceEventsAddInput;
};


export type MutationAuditEventsStreamingDestinationInstanceEventsRemoveArgs = {
  input: AuditEventsStreamingDestinationInstanceEventsRemoveInput;
};


export type MutationAuditEventsStreamingHeadersCreateArgs = {
  input: AuditEventsStreamingHeadersCreateInput;
};


export type MutationAuditEventsStreamingHeadersDestroyArgs = {
  input: AuditEventsStreamingHeadersDestroyInput;
};


export type MutationAuditEventsStreamingHeadersUpdateArgs = {
  input: AuditEventsStreamingHeadersUpdateInput;
};


export type MutationAuditEventsStreamingHttpNamespaceFiltersAddArgs = {
  input: AuditEventsStreamingHttpNamespaceFiltersAddInput;
};


export type MutationAuditEventsStreamingHttpNamespaceFiltersDeleteArgs = {
  input: AuditEventsStreamingHttpNamespaceFiltersDeleteInput;
};


export type MutationAuditEventsStreamingInstanceHeadersCreateArgs = {
  input: AuditEventsStreamingInstanceHeadersCreateInput;
};


export type MutationAuditEventsStreamingInstanceHeadersDestroyArgs = {
  input: AuditEventsStreamingInstanceHeadersDestroyInput;
};


export type MutationAuditEventsStreamingInstanceHeadersUpdateArgs = {
  input: AuditEventsStreamingInstanceHeadersUpdateInput;
};


export type MutationAwardEmojiAddArgs = {
  input: AwardEmojiAddInput;
};


export type MutationAwardEmojiRemoveArgs = {
  input: AwardEmojiRemoveInput;
};


export type MutationAwardEmojiToggleArgs = {
  input: AwardEmojiToggleInput;
};


export type MutationBoardEpicCreateArgs = {
  input: BoardEpicCreateInput;
};


export type MutationBoardListCreateArgs = {
  input: BoardListCreateInput;
};


export type MutationBoardListUpdateLimitMetricsArgs = {
  input: BoardListUpdateLimitMetricsInput;
};


export type MutationBranchDeleteArgs = {
  input: BranchDeleteInput;
};


export type MutationBranchRuleApprovalProjectRuleCreateArgs = {
  input: BranchRuleApprovalProjectRuleCreateInput;
};


export type MutationBranchRuleCreateArgs = {
  input: BranchRuleCreateInput;
};


export type MutationBranchRuleDeleteArgs = {
  input: BranchRuleDeleteInput;
};


export type MutationBranchRuleExternalStatusCheckCreateArgs = {
  input: BranchRuleExternalStatusCheckCreateInput;
};


export type MutationBranchRuleExternalStatusCheckDestroyArgs = {
  input: BranchRuleExternalStatusCheckDestroyInput;
};


export type MutationBranchRuleExternalStatusCheckUpdateArgs = {
  input: BranchRuleExternalStatusCheckUpdateInput;
};


export type MutationBranchRuleSquashOptionDeleteArgs = {
  input: BranchRuleSquashOptionDeleteInput;
};


export type MutationBranchRuleSquashOptionUpdateArgs = {
  input: BranchRuleSquashOptionUpdateInput;
};


export type MutationBranchRuleUpdateArgs = {
  input: BranchRuleUpdateInput;
};


export type MutationBulkDestroyJobArtifactsArgs = {
  input: BulkDestroyJobArtifactsInput;
};


export type MutationBulkEnableDevopsAdoptionNamespacesArgs = {
  input: BulkEnableDevopsAdoptionNamespacesInput;
};


export type MutationBulkRunnerDeleteArgs = {
  input: BulkRunnerDeleteInput;
};


export type MutationBulkUpdateSecurityAttributesArgs = {
  input: BulkUpdateSecurityAttributesInput;
};


export type MutationCatalogResourcesCreateArgs = {
  input: CatalogResourcesCreateInput;
};


export type MutationCatalogResourcesDestroyArgs = {
  input: CatalogResourcesDestroyInput;
};


export type MutationCiJobTokenScopeAddGroupOrProjectArgs = {
  input: CiJobTokenScopeAddGroupOrProjectInput;
};


export type MutationCiJobTokenScopeAddProjectArgs = {
  input: CiJobTokenScopeAddProjectInput;
};


export type MutationCiJobTokenScopeRemoveGroupArgs = {
  input: CiJobTokenScopeRemoveGroupInput;
};


export type MutationCiJobTokenScopeRemoveProjectArgs = {
  input: CiJobTokenScopeRemoveProjectInput;
};


export type MutationCiJobTokenScopeUpdatePoliciesArgs = {
  input: CiJobTokenScopeUpdatePoliciesInput;
};


export type MutationCiLintArgs = {
  input: CiLintInput;
};


export type MutationClusterAgentDeleteArgs = {
  input: ClusterAgentDeleteInput;
};


export type MutationClusterAgentTokenCreateArgs = {
  input: ClusterAgentTokenCreateInput;
};


export type MutationClusterAgentTokenRevokeArgs = {
  input: ClusterAgentTokenRevokeInput;
};


export type MutationClusterAgentUrlConfigurationCreateArgs = {
  input: ClusterAgentUrlConfigurationCreateInput;
};


export type MutationClusterAgentUrlConfigurationDeleteArgs = {
  input: ClusterAgentUrlConfigurationDeleteInput;
};


export type MutationCommitCreateArgs = {
  input: CommitCreateInput;
};


export type MutationConfigureContainerScanningArgs = {
  input: ConfigureContainerScanningInput;
};


export type MutationConfigureDependencyScanningArgs = {
  input: ConfigureDependencyScanningInput;
};


export type MutationConfigureSastArgs = {
  input: ConfigureSastInput;
};


export type MutationConfigureSastIacArgs = {
  input: ConfigureSastIacInput;
};


export type MutationConfigureSecretDetectionArgs = {
  input: ConfigureSecretDetectionInput;
};


export type MutationCorpusCreateArgs = {
  input: CorpusCreateInput;
};


export type MutationCreateAlertIssueArgs = {
  input: CreateAlertIssueInput;
};


export type MutationCreateAnnotationArgs = {
  input: CreateAnnotationInput;
};


export type MutationCreateBoardArgs = {
  input: CreateBoardInput;
};


export type MutationCreateBranchArgs = {
  input: CreateBranchInput;
};


export type MutationCreateClusterAgentArgs = {
  input: CreateClusterAgentInput;
};


export type MutationCreateComplianceFrameworkArgs = {
  input: CreateComplianceFrameworkInput;
};


export type MutationCreateComplianceRequirementArgs = {
  input: CreateComplianceRequirementInput;
};


export type MutationCreateComplianceRequirementsControlArgs = {
  input: CreateComplianceRequirementsControlInput;
};


export type MutationCreateContainerProtectionRepositoryRuleArgs = {
  input: CreateContainerProtectionRepositoryRuleInput;
};


export type MutationCreateContainerProtectionTagRuleArgs = {
  input: CreateContainerProtectionTagRuleInput;
};


export type MutationCreateCustomDashboardArgs = {
  input: CreateCustomDashboardInput;
};


export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};


export type MutationCreateDiffNoteArgs = {
  input: CreateDiffNoteInput;
};


export type MutationCreateDiscussionArgs = {
  input: CreateDiscussionInput;
};


export type MutationCreateEpicArgs = {
  input: CreateEpicInput;
};


export type MutationCreateImageDiffNoteArgs = {
  input: CreateImageDiffNoteInput;
};


export type MutationCreateIssueArgs = {
  input: CreateIssueInput;
};


export type MutationCreateIterationArgs = {
  input: CreateIterationInput;
};


export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


export type MutationCreatePackagesProtectionRuleArgs = {
  input: CreatePackagesProtectionRuleInput;
};


export type MutationCreateRequirementArgs = {
  input: CreateRequirementInput;
};


export type MutationCreateSnippetArgs = {
  input: CreateSnippetInput;
};


export type MutationCreateTestCaseArgs = {
  input: CreateTestCaseInput;
};


export type MutationCustomFieldArchiveArgs = {
  input: CustomFieldArchiveInput;
};


export type MutationCustomFieldCreateArgs = {
  input: CustomFieldCreateInput;
};


export type MutationCustomFieldUnarchiveArgs = {
  input: CustomFieldUnarchiveInput;
};


export type MutationCustomFieldUpdateArgs = {
  input: CustomFieldUpdateInput;
};


export type MutationCustomerRelationsContactCreateArgs = {
  input: CustomerRelationsContactCreateInput;
};


export type MutationCustomerRelationsContactUpdateArgs = {
  input: CustomerRelationsContactUpdateInput;
};


export type MutationCustomerRelationsOrganizationCreateArgs = {
  input: CustomerRelationsOrganizationCreateInput;
};


export type MutationCustomerRelationsOrganizationUpdateArgs = {
  input: CustomerRelationsOrganizationUpdateInput;
};


export type MutationDastOnDemandScanCreateArgs = {
  input: DastOnDemandScanCreateInput;
};


export type MutationDastProfileCreateArgs = {
  input: DastProfileCreateInput;
};


export type MutationDastProfileDeleteArgs = {
  input: DastProfileDeleteInput;
};


export type MutationDastProfileRunArgs = {
  input: DastProfileRunInput;
};


export type MutationDastProfileUpdateArgs = {
  input: DastProfileUpdateInput;
};


export type MutationDastScannerProfileCreateArgs = {
  input: DastScannerProfileCreateInput;
};


export type MutationDastScannerProfileDeleteArgs = {
  input: DastScannerProfileDeleteInput;
};


export type MutationDastScannerProfileUpdateArgs = {
  input: DastScannerProfileUpdateInput;
};


export type MutationDastSiteProfileCreateArgs = {
  input: DastSiteProfileCreateInput;
};


export type MutationDastSiteProfileDeleteArgs = {
  input: DastSiteProfileDeleteInput;
};


export type MutationDastSiteProfileUpdateArgs = {
  input: DastSiteProfileUpdateInput;
};


export type MutationDastSiteTokenCreateArgs = {
  input: DastSiteTokenCreateInput;
};


export type MutationDastSiteValidationCreateArgs = {
  input: DastSiteValidationCreateInput;
};


export type MutationDastSiteValidationRevokeArgs = {
  input: DastSiteValidationRevokeInput;
};


export type MutationDeleteAnnotationArgs = {
  input: DeleteAnnotationInput;
};


export type MutationDeleteContainerProtectionRepositoryRuleArgs = {
  input: DeleteContainerProtectionRepositoryRuleInput;
};


export type MutationDeleteContainerProtectionTagRuleArgs = {
  input: DeleteContainerProtectionTagRuleInput;
};


export type MutationDeleteConversationThreadArgs = {
  input: DeleteConversationThreadInput;
};


export type MutationDeleteDuoWorkflowsWorkflowArgs = {
  input: DeleteDuoWorkflowsWorkflowInput;
};


export type MutationDeletePackagesProtectionRuleArgs = {
  input: DeletePackagesProtectionRuleInput;
};


export type MutationDeletePagesDeploymentArgs = {
  input: DeletePagesDeploymentInput;
};


export type MutationDesignManagementDeleteArgs = {
  input: DesignManagementDeleteInput;
};


export type MutationDesignManagementMoveArgs = {
  input: DesignManagementMoveInput;
};


export type MutationDesignManagementUpdateArgs = {
  input: DesignManagementUpdateInput;
};


export type MutationDesignManagementUploadArgs = {
  input: DesignManagementUploadInput;
};


export type MutationDestroyBoardArgs = {
  input: DestroyBoardInput;
};


export type MutationDestroyBoardListArgs = {
  input: DestroyBoardListInput;
};


export type MutationDestroyComplianceFrameworkArgs = {
  input: DestroyComplianceFrameworkInput;
};


export type MutationDestroyComplianceRequirementArgs = {
  input: DestroyComplianceRequirementInput;
};


export type MutationDestroyComplianceRequirementsControlArgs = {
  input: DestroyComplianceRequirementsControlInput;
};


export type MutationDestroyContainerRepositoryArgs = {
  input: DestroyContainerRepositoryInput;
};


export type MutationDestroyContainerRepositoryTagsArgs = {
  input: DestroyContainerRepositoryTagsInput;
};


export type MutationDestroyCustomEmojiArgs = {
  input: DestroyCustomEmojiInput;
};


export type MutationDestroyEpicBoardArgs = {
  input: DestroyEpicBoardInput;
};


export type MutationDestroyNoteArgs = {
  input: DestroyNoteInput;
};


export type MutationDestroyPackageArgs = {
  input: DestroyPackageInput;
};


export type MutationDestroyPackageFileArgs = {
  input: DestroyPackageFileInput;
};


export type MutationDestroyPackageFilesArgs = {
  input: DestroyPackageFilesInput;
};


export type MutationDestroyPackagesArgs = {
  input: DestroyPackagesInput;
};


export type MutationDestroySnippetArgs = {
  input: DestroySnippetInput;
};


export type MutationDevfileValidateArgs = {
  input: DevfileValidateInput;
};


export type MutationDisableDevopsAdoptionNamespaceArgs = {
  input: DisableDevopsAdoptionNamespaceInput;
};


export type MutationDiscussionToggleResolveArgs = {
  input: DiscussionToggleResolveInput;
};


export type MutationDismissPolicyViolationsArgs = {
  input: DismissPolicyViolationsInput;
};


export type MutationDuoSettingsUpdateArgs = {
  input: DuoSettingsUpdateInput;
};


export type MutationDuoUserFeedbackArgs = {
  input: DuoUserFeedbackInput;
};


export type MutationEchoCreateArgs = {
  input: EchoCreateInput;
};


export type MutationEnableDevopsAdoptionNamespaceArgs = {
  input: EnableDevopsAdoptionNamespaceInput;
};


export type MutationEnvironmentCreateArgs = {
  input: EnvironmentCreateInput;
};


export type MutationEnvironmentDeleteArgs = {
  input: EnvironmentDeleteInput;
};


export type MutationEnvironmentStopArgs = {
  input: EnvironmentStopInput;
};


export type MutationEnvironmentUpdateArgs = {
  input: EnvironmentUpdateInput;
};


export type MutationEnvironmentsCanaryIngressUpdateArgs = {
  input: EnvironmentsCanaryIngressUpdateInput;
};


export type MutationEpicAddIssueArgs = {
  input: EpicAddIssueInput;
};


export type MutationEpicBoardCreateArgs = {
  input: EpicBoardCreateInput;
};


export type MutationEpicBoardListCreateArgs = {
  input: EpicBoardListCreateInput;
};


export type MutationEpicBoardListDestroyArgs = {
  input: EpicBoardListDestroyInput;
};


export type MutationEpicBoardUpdateArgs = {
  input: EpicBoardUpdateInput;
};


export type MutationEpicMoveListArgs = {
  input: EpicMoveListInput;
};


export type MutationEpicSetSubscriptionArgs = {
  input: EpicSetSubscriptionInput;
};


export type MutationEpicTreeReorderArgs = {
  input: EpicTreeReorderInput;
};


export type MutationEscalationPolicyCreateArgs = {
  input: EscalationPolicyCreateInput;
};


export type MutationEscalationPolicyDestroyArgs = {
  input: EscalationPolicyDestroyInput;
};


export type MutationEscalationPolicyUpdateArgs = {
  input: EscalationPolicyUpdateInput;
};


export type MutationExportRequirementsArgs = {
  input: ExportRequirementsInput;
};


export type MutationExternalAuditEventDestinationCreateArgs = {
  input: ExternalAuditEventDestinationCreateInput;
};


export type MutationExternalAuditEventDestinationDestroyArgs = {
  input: ExternalAuditEventDestinationDestroyInput;
};


export type MutationExternalAuditEventDestinationUpdateArgs = {
  input: ExternalAuditEventDestinationUpdateInput;
};


export type MutationGeoRegistriesBulkUpdateArgs = {
  input: GeoRegistriesBulkUpdateInput;
};


export type MutationGeoRegistriesUpdateArgs = {
  input: GeoRegistriesUpdateInput;
};


export type MutationGitlabSubscriptionActivateArgs = {
  input: GitlabSubscriptionActivateInput;
};


export type MutationGoogleCloudLoggingConfigurationCreateArgs = {
  input: GoogleCloudLoggingConfigurationCreateInput;
};


export type MutationGoogleCloudLoggingConfigurationDestroyArgs = {
  input: GoogleCloudLoggingConfigurationDestroyInput;
};


export type MutationGoogleCloudLoggingConfigurationUpdateArgs = {
  input: GoogleCloudLoggingConfigurationUpdateInput;
};


export type MutationGroupAuditEventStreamingDestinationsCreateArgs = {
  input: GroupAuditEventStreamingDestinationsCreateInput;
};


export type MutationGroupAuditEventStreamingDestinationsDeleteArgs = {
  input: GroupAuditEventStreamingDestinationsDeleteInput;
};


export type MutationGroupAuditEventStreamingDestinationsUpdateArgs = {
  input: GroupAuditEventStreamingDestinationsUpdateInput;
};


export type MutationGroupMemberBulkUpdateArgs = {
  input: GroupMemberBulkUpdateInput;
};


export type MutationGroupMembersExportArgs = {
  input: GroupMembersExportInput;
};


export type MutationGroupSavedReplyCreateArgs = {
  input: GroupSavedReplyCreateInput;
};


export type MutationGroupSavedReplyDestroyArgs = {
  input: GroupSavedReplyDestroyInput;
};


export type MutationGroupSavedReplyUpdateArgs = {
  input: GroupSavedReplyUpdateInput;
};


export type MutationGroupSecretsManagerDeprovisionArgs = {
  input: GroupSecretsManagerDeprovisionInput;
};


export type MutationGroupSecretsManagerInitializeArgs = {
  input: GroupSecretsManagerInitializeInput;
};


export type MutationGroupSecretsPermissionDeleteArgs = {
  input: GroupSecretsPermissionDeleteInput;
};


export type MutationGroupSecretsPermissionUpdateArgs = {
  input: GroupSecretsPermissionUpdateInput;
};


export type MutationGroupUpdateArgs = {
  input: GroupUpdateInput;
};


export type MutationHttpIntegrationCreateArgs = {
  input: HttpIntegrationCreateInput;
};


export type MutationHttpIntegrationDestroyArgs = {
  input: HttpIntegrationDestroyInput;
};


export type MutationHttpIntegrationResetTokenArgs = {
  input: HttpIntegrationResetTokenInput;
};


export type MutationHttpIntegrationUpdateArgs = {
  input: HttpIntegrationUpdateInput;
};


export type MutationImportSourceUserCancelReassignmentArgs = {
  input: ImportSourceUserCancelReassignmentInput;
};


export type MutationImportSourceUserKeepAllAsPlaceholderArgs = {
  input: ImportSourceUserKeepAllAsPlaceholderInput;
};


export type MutationImportSourceUserKeepAsPlaceholderArgs = {
  input: ImportSourceUserKeepAsPlaceholderInput;
};


export type MutationImportSourceUserReassignArgs = {
  input: ImportSourceUserReassignInput;
};


export type MutationImportSourceUserResendNotificationArgs = {
  input: ImportSourceUserResendNotificationInput;
};


export type MutationImportSourceUserUndoKeepAsPlaceholderArgs = {
  input: ImportSourceUserUndoKeepAsPlaceholderInput;
};


export type MutationInstanceAuditEventStreamingDestinationsCreateArgs = {
  input: InstanceAuditEventStreamingDestinationsCreateInput;
};


export type MutationInstanceAuditEventStreamingDestinationsDeleteArgs = {
  input: InstanceAuditEventStreamingDestinationsDeleteInput;
};


export type MutationInstanceAuditEventStreamingDestinationsUpdateArgs = {
  input: InstanceAuditEventStreamingDestinationsUpdateInput;
};


export type MutationInstanceExternalAuditEventDestinationCreateArgs = {
  input: InstanceExternalAuditEventDestinationCreateInput;
};


export type MutationInstanceExternalAuditEventDestinationDestroyArgs = {
  input: InstanceExternalAuditEventDestinationDestroyInput;
};


export type MutationInstanceExternalAuditEventDestinationUpdateArgs = {
  input: InstanceExternalAuditEventDestinationUpdateInput;
};


export type MutationInstanceGoogleCloudLoggingConfigurationCreateArgs = {
  input: InstanceGoogleCloudLoggingConfigurationCreateInput;
};


export type MutationInstanceGoogleCloudLoggingConfigurationDestroyArgs = {
  input: InstanceGoogleCloudLoggingConfigurationDestroyInput;
};


export type MutationInstanceGoogleCloudLoggingConfigurationUpdateArgs = {
  input: InstanceGoogleCloudLoggingConfigurationUpdateInput;
};


export type MutationIntegrationExclusionCreateArgs = {
  input: IntegrationExclusionCreateInput;
};


export type MutationIntegrationExclusionDeleteArgs = {
  input: IntegrationExclusionDeleteInput;
};


export type MutationIssuableResourceLinkCreateArgs = {
  input: IssuableResourceLinkCreateInput;
};


export type MutationIssuableResourceLinkDestroyArgs = {
  input: IssuableResourceLinkDestroyInput;
};


export type MutationIssueLinkAlertsArgs = {
  input: IssueLinkAlertsInput;
};


export type MutationIssueMoveArgs = {
  input: IssueMoveInput;
};


export type MutationIssueMoveListArgs = {
  input: IssueMoveListInput;
};


export type MutationIssueSetAssigneesArgs = {
  input: IssueSetAssigneesInput;
};


export type MutationIssueSetConfidentialArgs = {
  input: IssueSetConfidentialInput;
};


export type MutationIssueSetCrmContactsArgs = {
  input: IssueSetCrmContactsInput;
};


export type MutationIssueSetDueDateArgs = {
  input: IssueSetDueDateInput;
};


export type MutationIssueSetEpicArgs = {
  input: IssueSetEpicInput;
};


export type MutationIssueSetEscalationPolicyArgs = {
  input: IssueSetEscalationPolicyInput;
};


export type MutationIssueSetEscalationStatusArgs = {
  input: IssueSetEscalationStatusInput;
};


export type MutationIssueSetIterationArgs = {
  input: IssueSetIterationInput;
};


export type MutationIssueSetLockedArgs = {
  input: IssueSetLockedInput;
};


export type MutationIssueSetSeverityArgs = {
  input: IssueSetSeverityInput;
};


export type MutationIssueSetSubscriptionArgs = {
  input: IssueSetSubscriptionInput;
};


export type MutationIssueSetWeightArgs = {
  input: IssueSetWeightInput;
};


export type MutationIssueUnlinkAlertArgs = {
  input: IssueUnlinkAlertInput;
};


export type MutationIterationCadenceCreateArgs = {
  input: IterationCadenceCreateInput;
};


export type MutationIterationCadenceDestroyArgs = {
  input: IterationCadenceDestroyInput;
};


export type MutationIterationCadenceUpdateArgs = {
  input: IterationCadenceUpdateInput;
};


export type MutationIterationCreateArgs = {
  input: IterationCreateInput;
};


export type MutationIterationDeleteArgs = {
  input: IterationDeleteInput;
};


export type MutationJiraImportStartArgs = {
  input: JiraImportStartInput;
};


export type MutationJiraImportUsersArgs = {
  input: JiraImportUsersInput;
};


export type MutationJobArtifactsDestroyArgs = {
  input: JobArtifactsDestroyInput;
};


export type MutationJobCancelArgs = {
  input: JobCancelInput;
};


export type MutationJobPlayArgs = {
  input: JobPlayInput;
};


export type MutationJobRetryArgs = {
  input: JobRetryInput;
};


export type MutationJobUnscheduleArgs = {
  input: JobUnscheduleInput;
};


export type MutationLabelCreateArgs = {
  input: LabelCreateInput;
};


export type MutationLabelUpdateArgs = {
  input: LabelUpdateInput;
};


export type MutationLdapAdminRoleLinkCreateArgs = {
  input: LdapAdminRoleLinkCreateInput;
};


export type MutationLdapAdminRoleLinkDestroyArgs = {
  input: LdapAdminRoleLinkDestroyInput;
};


export type MutationLifecycleAttachWorkItemTypeArgs = {
  input: LifecycleAttachWorkItemTypeInput;
};


export type MutationLifecycleCreateArgs = {
  input: LifecycleCreateInput;
};


export type MutationLifecycleDeleteArgs = {
  input: LifecycleDeleteInput;
};


export type MutationLifecycleUpdateArgs = {
  input: LifecycleUpdateInput;
};


export type MutationLinkProjectComplianceViolationIssueArgs = {
  input: LinkProjectComplianceViolationIssueInput;
};


export type MutationMarkAsSpamSnippetArgs = {
  input: MarkAsSpamSnippetInput;
};


export type MutationMavenUpstreamCreateArgs = {
  input: MavenUpstreamCreateInput;
};


export type MutationMemberRoleAdminCreateArgs = {
  input: MemberRoleAdminCreateInput;
};


export type MutationMemberRoleAdminDeleteArgs = {
  input: MemberRoleAdminDeleteInput;
};


export type MutationMemberRoleAdminUpdateArgs = {
  input: MemberRoleAdminUpdateInput;
};


export type MutationMemberRoleCreateArgs = {
  input: MemberRoleCreateInput;
};


export type MutationMemberRoleDeleteArgs = {
  input: MemberRoleDeleteInput;
};


export type MutationMemberRoleToUserAssignArgs = {
  input: MemberRoleToUserAssignInput;
};


export type MutationMemberRoleUpdateArgs = {
  input: MemberRoleUpdateInput;
};


export type MutationMergeRequestAcceptArgs = {
  input: MergeRequestAcceptInput;
};


export type MutationMergeRequestBypassSecurityPolicyArgs = {
  input: MergeRequestBypassSecurityPolicyInput;
};


export type MutationMergeRequestCreateArgs = {
  input: MergeRequestCreateInput;
};


export type MutationMergeRequestDestroyRequestedChangesArgs = {
  input: MergeRequestDestroyRequestedChangesInput;
};


export type MutationMergeRequestReviewerRereviewArgs = {
  input: MergeRequestReviewerRereviewInput;
};


export type MutationMergeRequestSetAssigneesArgs = {
  input: MergeRequestSetAssigneesInput;
};


export type MutationMergeRequestSetDraftArgs = {
  input: MergeRequestSetDraftInput;
};


export type MutationMergeRequestSetLabelsArgs = {
  input: MergeRequestSetLabelsInput;
};


export type MutationMergeRequestSetLockedArgs = {
  input: MergeRequestSetLockedInput;
};


export type MutationMergeRequestSetMilestoneArgs = {
  input: MergeRequestSetMilestoneInput;
};


export type MutationMergeRequestSetReviewersArgs = {
  input: MergeRequestSetReviewersInput;
};


export type MutationMergeRequestSetSubscriptionArgs = {
  input: MergeRequestSetSubscriptionInput;
};


export type MutationMergeRequestUpdateArgs = {
  input: MergeRequestUpdateInput;
};


export type MutationMergeRequestUpdateApprovalRuleArgs = {
  input: MergeRequestUpdateApprovalRuleInput;
};


export type MutationMergeTrainsDeleteCarArgs = {
  input: MergeTrainsDeleteCarInput;
};


export type MutationMlModelCreateArgs = {
  input: MlModelCreateInput;
};


export type MutationMlModelDeleteArgs = {
  input: MlModelDeleteInput;
};


export type MutationMlModelDestroyArgs = {
  input: MlModelDestroyInput;
};


export type MutationMlModelEditArgs = {
  input: MlModelEditInput;
};


export type MutationMlModelVersionCreateArgs = {
  input: MlModelVersionCreateInput;
};


export type MutationMlModelVersionDeleteArgs = {
  input: MlModelVersionDeleteInput;
};


export type MutationMlModelVersionEditArgs = {
  input: MlModelVersionEditInput;
};


export type MutationNamespaceBanDestroyArgs = {
  input: NamespaceBanDestroyInput;
};


export type MutationNamespaceCiCdSettingsUpdateArgs = {
  input: NamespaceCiCdSettingsUpdateInput;
};


export type MutationNamespaceCreateRemoteDevelopmentClusterAgentMappingArgs = {
  input: NamespaceCreateRemoteDevelopmentClusterAgentMappingInput;
};


export type MutationNamespaceDeleteRemoteDevelopmentClusterAgentMappingArgs = {
  input: NamespaceDeleteRemoteDevelopmentClusterAgentMappingInput;
};


export type MutationNamespaceSettingsUpdateArgs = {
  input: NamespaceSettingsUpdateInput;
};


export type MutationNamespacesRegenerateNewWorkItemEmailAddressArgs = {
  input: NamespacesRegenerateNewWorkItemEmailAddressInput;
};


export type MutationNoteConvertToThreadArgs = {
  input: NoteConvertToThreadInput;
};


export type MutationOncallRotationCreateArgs = {
  input: OncallRotationCreateInput;
};


export type MutationOncallRotationDestroyArgs = {
  input: OncallRotationDestroyInput;
};


export type MutationOncallRotationUpdateArgs = {
  input: OncallRotationUpdateInput;
};


export type MutationOncallScheduleCreateArgs = {
  input: OncallScheduleCreateInput;
};


export type MutationOncallScheduleDestroyArgs = {
  input: OncallScheduleDestroyInput;
};


export type MutationOncallScheduleUpdateArgs = {
  input: OncallScheduleUpdateInput;
};


export type MutationOrganizationCreateArgs = {
  input: OrganizationCreateInput;
};


export type MutationOrganizationCreateClusterAgentMappingArgs = {
  input: OrganizationCreateClusterAgentMappingInput;
};


export type MutationOrganizationDeleteClusterAgentMappingArgs = {
  input: OrganizationDeleteClusterAgentMappingInput;
};


export type MutationOrganizationUpdateArgs = {
  input: OrganizationUpdateInput;
};


export type MutationOrganizationUserUpdateArgs = {
  input: OrganizationUserUpdateInput;
};


export type MutationPagesMarkOnboardingCompleteArgs = {
  input: PagesMarkOnboardingCompleteInput;
};


export type MutationPersonalAccessTokenCreateArgs = {
  input: PersonalAccessTokenCreateInput;
};


export type MutationPersonalAccessTokenRevokeArgs = {
  input: PersonalAccessTokenRevokeInput;
};


export type MutationPersonalAccessTokenRotateArgs = {
  input: PersonalAccessTokenRotateInput;
};


export type MutationPipelineCancelArgs = {
  input: PipelineCancelInput;
};


export type MutationPipelineCreateArgs = {
  input: PipelineCreateInput;
};


export type MutationPipelineDestroyArgs = {
  input: PipelineDestroyInput;
};


export type MutationPipelineRetryArgs = {
  input: PipelineRetryInput;
};


export type MutationPipelineScheduleCreateArgs = {
  input: PipelineScheduleCreateInput;
};


export type MutationPipelineScheduleDeleteArgs = {
  input: PipelineScheduleDeleteInput;
};


export type MutationPipelineSchedulePlayArgs = {
  input: PipelineSchedulePlayInput;
};


export type MutationPipelineScheduleTakeOwnershipArgs = {
  input: PipelineScheduleTakeOwnershipInput;
};


export type MutationPipelineScheduleUpdateArgs = {
  input: PipelineScheduleUpdateInput;
};


export type MutationPipelineTriggerCreateArgs = {
  input: PipelineTriggerCreateInput;
};


export type MutationPipelineTriggerDeleteArgs = {
  input: PipelineTriggerDeleteInput;
};


export type MutationPipelineTriggerUpdateArgs = {
  input: PipelineTriggerUpdateInput;
};


export type MutationProcessUserBillablePromotionRequestArgs = {
  input: ProcessUserBillablePromotionRequestInput;
};


export type MutationProductAnalyticsProjectSettingsUpdateArgs = {
  input: ProductAnalyticsProjectSettingsUpdateInput;
};


export type MutationProjectBlobsRemoveArgs = {
  input: ProjectBlobsRemoveInput;
};


export type MutationProjectCiCdSettingsUpdateArgs = {
  input: ProjectCiCdSettingsUpdateInput;
};


export type MutationProjectInitializeProductAnalyticsArgs = {
  input: ProjectInitializeProductAnalyticsInput;
};


export type MutationProjectMemberBulkUpdateArgs = {
  input: ProjectMemberBulkUpdateInput;
};


export type MutationProjectSavedReplyCreateArgs = {
  input: ProjectSavedReplyCreateInput;
};


export type MutationProjectSavedReplyDestroyArgs = {
  input: ProjectSavedReplyDestroyInput;
};


export type MutationProjectSavedReplyUpdateArgs = {
  input: ProjectSavedReplyUpdateInput;
};


export type MutationProjectSecretCreateArgs = {
  input: ProjectSecretCreateInput;
};


export type MutationProjectSecretDeleteArgs = {
  input: ProjectSecretDeleteInput;
};


export type MutationProjectSecretUpdateArgs = {
  input: ProjectSecretUpdateInput;
};


export type MutationProjectSecretsManagerDeprovisionArgs = {
  input: ProjectSecretsManagerDeprovisionInput;
};


export type MutationProjectSecretsManagerInitializeArgs = {
  input: ProjectSecretsManagerInitializeInput;
};


export type MutationProjectSecretsPermissionDeleteArgs = {
  input: ProjectSecretsPermissionDeleteInput;
};


export type MutationProjectSecretsPermissionUpdateArgs = {
  input: ProjectSecretsPermissionUpdateInput;
};


export type MutationProjectSecurityExclusionCreateArgs = {
  input: ProjectSecurityExclusionCreateInput;
};


export type MutationProjectSecurityExclusionDeleteArgs = {
  input: ProjectSecurityExclusionDeleteInput;
};


export type MutationProjectSecurityExclusionUpdateArgs = {
  input: ProjectSecurityExclusionUpdateInput;
};


export type MutationProjectSetComplianceFrameworkArgs = {
  input: ProjectSetComplianceFrameworkInput;
};


export type MutationProjectSetContinuousVulnerabilityScanningArgs = {
  input: ProjectSetContinuousVulnerabilityScanningInput;
};


export type MutationProjectSetLockedArgs = {
  input: ProjectSetLockedInput;
};


export type MutationProjectSettingsUpdateArgs = {
  input: ProjectSettingsUpdateInput;
};


export type MutationProjectSubscriptionCreateArgs = {
  input: ProjectSubscriptionCreateInput;
};


export type MutationProjectSubscriptionDeleteArgs = {
  input: ProjectSubscriptionDeleteInput;
};


export type MutationProjectSyncForkArgs = {
  input: ProjectSyncForkInput;
};


export type MutationProjectTargetBranchRuleCreateArgs = {
  input: ProjectTargetBranchRuleCreateInput;
};


export type MutationProjectTargetBranchRuleDestroyArgs = {
  input: ProjectTargetBranchRuleDestroyInput;
};


export type MutationProjectTextReplaceArgs = {
  input: ProjectTextReplaceInput;
};


export type MutationProjectUpdateComplianceFrameworksArgs = {
  input: ProjectUpdateComplianceFrameworksInput;
};


export type MutationPrometheusIntegrationCreateArgs = {
  input: PrometheusIntegrationCreateInput;
};


export type MutationPrometheusIntegrationResetTokenArgs = {
  input: PrometheusIntegrationResetTokenInput;
};


export type MutationPrometheusIntegrationUpdateArgs = {
  input: PrometheusIntegrationUpdateInput;
};


export type MutationPromoteToEpicArgs = {
  input: PromoteToEpicInput;
};


export type MutationRefreshFindingTokenStatusArgs = {
  input: RefreshFindingTokenStatusInput;
};


export type MutationRefreshSecurityFindingTokenStatusArgs = {
  input: RefreshSecurityFindingTokenStatusInput;
};


export type MutationRefreshStandardsAdherenceChecksArgs = {
  input: RefreshStandardsAdherenceChecksInput;
};


export type MutationRefreshVulnerabilityFindingTokenStatusArgs = {
  input: RefreshVulnerabilityFindingTokenStatusInput;
};


export type MutationReleaseAssetLinkCreateArgs = {
  input: ReleaseAssetLinkCreateInput;
};


export type MutationReleaseAssetLinkDeleteArgs = {
  input: ReleaseAssetLinkDeleteInput;
};


export type MutationReleaseAssetLinkUpdateArgs = {
  input: ReleaseAssetLinkUpdateInput;
};


export type MutationReleaseCreateArgs = {
  input: ReleaseCreateInput;
};


export type MutationReleaseDeleteArgs = {
  input: ReleaseDeleteInput;
};


export type MutationReleaseUpdateArgs = {
  input: ReleaseUpdateInput;
};


export type MutationRemoveProjectFromSecurityDashboardArgs = {
  input: RemoveProjectFromSecurityDashboardInput;
};


export type MutationRepositionImageDiffNoteArgs = {
  input: RepositionImageDiffNoteInput;
};


export type MutationRestorePagesDeploymentArgs = {
  input: RestorePagesDeploymentInput;
};


export type MutationResyncSecurityPoliciesArgs = {
  input: ResyncSecurityPoliciesInput;
};


export type MutationRunnerAssignToProjectArgs = {
  input: RunnerAssignToProjectInput;
};


export type MutationRunnerBulkPauseArgs = {
  input: RunnerBulkPauseInput;
};


export type MutationRunnerCacheClearArgs = {
  input: RunnerCacheClearInput;
};


export type MutationRunnerCreateArgs = {
  input: RunnerCreateInput;
};


export type MutationRunnerDeleteArgs = {
  input: RunnerDeleteInput;
};


export type MutationRunnerUnassignFromProjectArgs = {
  input: RunnerUnassignFromProjectInput;
};


export type MutationRunnerUpdateArgs = {
  input: RunnerUpdateInput;
};


export type MutationRunnersExportUsageArgs = {
  input: RunnersExportUsageInput;
};


export type MutationRunnersRegistrationTokenResetArgs = {
  input: RunnersRegistrationTokenResetInput;
};


export type MutationSafeDisablePipelineVariablesArgs = {
  input: SafeDisablePipelineVariablesInput;
};


export type MutationSavedReplyCreateArgs = {
  input: SavedReplyCreateInput;
};


export type MutationSavedReplyDestroyArgs = {
  input: SavedReplyDestroyInput;
};


export type MutationSavedReplyUpdateArgs = {
  input: SavedReplyUpdateInput;
};


export type MutationScanExecutionPolicyCommitArgs = {
  input: ScanExecutionPolicyCommitInput;
};


export type MutationSecretPermissionDeleteArgs = {
  input: SecretPermissionDeleteInput;
};


export type MutationSecretPermissionUpdateArgs = {
  input: SecretPermissionUpdateInput;
};


export type MutationSecurityAttributeCreateArgs = {
  input: SecurityAttributeCreateInput;
};


export type MutationSecurityAttributeDestroyArgs = {
  input: SecurityAttributeDestroyInput;
};


export type MutationSecurityAttributeProjectUpdateArgs = {
  input: SecurityAttributeProjectUpdateInput;
};


export type MutationSecurityAttributeUpdateArgs = {
  input: SecurityAttributeUpdateInput;
};


export type MutationSecurityCategoryCreateArgs = {
  input: SecurityCategoryCreateInput;
};


export type MutationSecurityCategoryDestroyArgs = {
  input: SecurityCategoryDestroyInput;
};


export type MutationSecurityCategoryUpdateArgs = {
  input: SecurityCategoryUpdateInput;
};


export type MutationSecurityFindingCreateIssueArgs = {
  input: SecurityFindingCreateIssueInput;
};


export type MutationSecurityFindingCreateMergeRequestArgs = {
  input: SecurityFindingCreateMergeRequestInput;
};


export type MutationSecurityFindingCreateVulnerabilityArgs = {
  input: SecurityFindingCreateVulnerabilityInput;
};


export type MutationSecurityFindingDismissArgs = {
  input: SecurityFindingDismissInput;
};


export type MutationSecurityFindingExternalIssueLinkCreateArgs = {
  input: SecurityFindingExternalIssueLinkCreateInput;
};


export type MutationSecurityFindingJiraIssueFormUrlCreateArgs = {
  input: SecurityFindingJiraIssueFormUrlCreateInput;
};


export type MutationSecurityFindingRevertToDetectedArgs = {
  input: SecurityFindingRevertToDetectedInput;
};


export type MutationSecurityFindingSeverityOverrideArgs = {
  input: SecurityFindingSeverityOverrideInput;
};


export type MutationSecurityPolicyProjectAssignArgs = {
  input: SecurityPolicyProjectAssignInput;
};


export type MutationSecurityPolicyProjectCreateArgs = {
  input: SecurityPolicyProjectCreateInput;
};


export type MutationSecurityPolicyProjectCreateAsyncArgs = {
  input: SecurityPolicyProjectCreateAsyncInput;
};


export type MutationSecurityPolicyProjectUnassignArgs = {
  input: SecurityPolicyProjectUnassignInput;
};


export type MutationSecurityTrainingUpdateArgs = {
  input: SecurityTrainingUpdateInput;
};


export type MutationSetContainerScanningForRegistryArgs = {
  input: SetContainerScanningForRegistryInput;
};


export type MutationSetGroupSecretPushProtectionArgs = {
  input: SetGroupSecretPushProtectionInput;
};


export type MutationSetGroupValidityChecksArgs = {
  input: SetGroupValidityChecksInput;
};


export type MutationSetLicenseConfigurationSourceArgs = {
  input: SetLicenseConfigurationSourceInput;
};


export type MutationSetPagesForceHttpsArgs = {
  input: SetPagesForceHttpsInput;
};


export type MutationSetPagesUseUniqueDomainArgs = {
  input: SetPagesUseUniqueDomainInput;
};


export type MutationSetPreReceiveSecretDetectionArgs = {
  input: SetPreReceiveSecretDetectionInput;
};


export type MutationSetSecretPushProtectionArgs = {
  input: SetSecretPushProtectionInput;
};


export type MutationSetValidityChecksArgs = {
  input: SetValidityChecksInput;
};


export type MutationStarProjectArgs = {
  input: StarProjectInput;
};


export type MutationTagCreateArgs = {
  input: TagCreateInput;
};


export type MutationTagDeleteArgs = {
  input: TagDeleteInput;
};


export type MutationTerraformStateDeleteArgs = {
  input: TerraformStateDeleteInput;
};


export type MutationTerraformStateLockArgs = {
  input: TerraformStateLockInput;
};


export type MutationTerraformStateUnlockArgs = {
  input: TerraformStateUnlockInput;
};


export type MutationTimelineEventCreateArgs = {
  input: TimelineEventCreateInput;
};


export type MutationTimelineEventDestroyArgs = {
  input: TimelineEventDestroyInput;
};


export type MutationTimelineEventPromoteFromNoteArgs = {
  input: TimelineEventPromoteFromNoteInput;
};


export type MutationTimelineEventTagCreateArgs = {
  input: TimelineEventTagCreateInput;
};


export type MutationTimelineEventUpdateArgs = {
  input: TimelineEventUpdateInput;
};


export type MutationTimelogCreateArgs = {
  input: TimelogCreateInput;
};


export type MutationTimelogDeleteArgs = {
  input: TimelogDeleteInput;
};


export type MutationTodoCreateArgs = {
  input: TodoCreateInput;
};


export type MutationTodoDeleteAllDoneArgs = {
  input: TodoDeleteAllDoneInput;
};


export type MutationTodoDeleteManyArgs = {
  input: TodoDeleteManyInput;
};


export type MutationTodoMarkDoneArgs = {
  input: TodoMarkDoneInput;
};


export type MutationTodoResolveManyArgs = {
  input: TodoResolveManyInput;
};


export type MutationTodoRestoreArgs = {
  input: TodoRestoreInput;
};


export type MutationTodoRestoreManyArgs = {
  input: TodoRestoreManyInput;
};


export type MutationTodoSnoozeArgs = {
  input: TodoSnoozeInput;
};


export type MutationTodoSnoozeManyArgs = {
  input: TodoSnoozeManyInput;
};


export type MutationTodoUnSnoozeArgs = {
  input: TodoUnSnoozeInput;
};


export type MutationTodoUnsnoozeManyArgs = {
  input: TodoUnsnoozeManyInput;
};


export type MutationTodosMarkAllDoneArgs = {
  input: TodosMarkAllDoneInput;
};


export type MutationUnlinkProjectComplianceViolationIssueArgs = {
  input: UnlinkProjectComplianceViolationIssueInput;
};


export type MutationUpdateAlertStatusArgs = {
  input: UpdateAlertStatusInput;
};


export type MutationUpdateBoardArgs = {
  input: UpdateBoardInput;
};


export type MutationUpdateBoardEpicUserPreferencesArgs = {
  input: UpdateBoardEpicUserPreferencesInput;
};


export type MutationUpdateBoardListArgs = {
  input: UpdateBoardListInput;
};


export type MutationUpdateComplianceFrameworkArgs = {
  input: UpdateComplianceFrameworkInput;
};


export type MutationUpdateComplianceRequirementArgs = {
  input: UpdateComplianceRequirementInput;
};


export type MutationUpdateComplianceRequirementsControlArgs = {
  input: UpdateComplianceRequirementsControlInput;
};


export type MutationUpdateContainerExpirationPolicyArgs = {
  input: UpdateContainerExpirationPolicyInput;
};


export type MutationUpdateContainerProtectionRepositoryRuleArgs = {
  input: UpdateContainerProtectionRepositoryRuleInput;
};


export type MutationUpdateContainerProtectionTagRuleArgs = {
  input: UpdateContainerProtectionTagRuleInput;
};


export type MutationUpdateDependencyProxyImageTtlGroupPolicyArgs = {
  input: UpdateDependencyProxyImageTtlGroupPolicyInput;
};


export type MutationUpdateDependencyProxyPackagesSettingsArgs = {
  input: UpdateDependencyProxyPackagesSettingsInput;
};


export type MutationUpdateDependencyProxySettingsArgs = {
  input: UpdateDependencyProxySettingsInput;
};


export type MutationUpdateEpicArgs = {
  input: UpdateEpicInput;
};


export type MutationUpdateEpicBoardListArgs = {
  input: UpdateEpicBoardListInput;
};


export type MutationUpdateImageDiffNoteArgs = {
  input: UpdateImageDiffNoteInput;
};


export type MutationUpdateIssueArgs = {
  input: UpdateIssueInput;
};


export type MutationUpdateIterationArgs = {
  input: UpdateIterationInput;
};


export type MutationUpdateNamespacePackageSettingsArgs = {
  input: UpdateNamespacePackageSettingsInput;
};


export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


export type MutationUpdatePackagesCleanupPolicyArgs = {
  input: UpdatePackagesCleanupPolicyInput;
};


export type MutationUpdatePackagesProtectionRuleArgs = {
  input: UpdatePackagesProtectionRuleInput;
};


export type MutationUpdateProjectComplianceViolationArgs = {
  input: UpdateProjectComplianceViolationInput;
};


export type MutationUpdateRequirementArgs = {
  input: UpdateRequirementInput;
};


export type MutationUpdateSnippetArgs = {
  input: UpdateSnippetInput;
};


export type MutationUpdateVirtualRegistriesSettingArgs = {
  input: UpdateVirtualRegistriesSettingInput;
};


export type MutationUploadDeleteArgs = {
  input: UploadDeleteInput;
};


export type MutationUserAchievementPrioritiesUpdateArgs = {
  input: UserAchievementPrioritiesUpdateInput;
};


export type MutationUserAchievementsDeleteArgs = {
  input: UserAchievementsDeleteInput;
};


export type MutationUserAchievementsUpdateArgs = {
  input: UserAchievementsUpdateInput;
};


export type MutationUserAddOnAssignmentBulkCreateArgs = {
  input: UserAddOnAssignmentBulkCreateInput;
};


export type MutationUserAddOnAssignmentBulkRemoveArgs = {
  input: UserAddOnAssignmentBulkRemoveInput;
};


export type MutationUserAddOnAssignmentCreateArgs = {
  input: UserAddOnAssignmentCreateInput;
};


export type MutationUserAddOnAssignmentRemoveArgs = {
  input: UserAddOnAssignmentRemoveInput;
};


export type MutationUserCalloutCreateArgs = {
  input: UserCalloutCreateInput;
};


export type MutationUserGroupCalloutCreateArgs = {
  input: UserGroupCalloutCreateInput;
};


export type MutationUserPreferencesUpdateArgs = {
  input: UserPreferencesUpdateInput;
};


export type MutationUserSetNamespaceCommitEmailArgs = {
  input: UserSetNamespaceCommitEmailInput;
};


export type MutationValueStreamCreateArgs = {
  input: ValueStreamCreateInput;
};


export type MutationValueStreamDestroyArgs = {
  input: ValueStreamDestroyInput;
};


export type MutationValueStreamUpdateArgs = {
  input: ValueStreamUpdateInput;
};


export type MutationVerifiedNamespaceCreateArgs = {
  input: VerifiedNamespaceCreateInput;
};


export type MutationVirtualRegistriesCleanupPolicyUpsertArgs = {
  input: VirtualRegistriesCleanupPolicyUpsertInput;
};


export type MutationVulnerabilitiesArchiveArgs = {
  input: VulnerabilitiesArchiveInput;
};


export type MutationVulnerabilitiesCreateIssueArgs = {
  input: VulnerabilitiesCreateIssueInput;
};


export type MutationVulnerabilitiesDismissArgs = {
  input: VulnerabilitiesDismissInput;
};


export type MutationVulnerabilitiesRemoveAllFromProjectArgs = {
  input: VulnerabilitiesRemoveAllFromProjectInput;
};


export type MutationVulnerabilitiesSeverityOverrideArgs = {
  input: VulnerabilitiesSeverityOverrideInput;
};


export type MutationVulnerabilityConfirmArgs = {
  input: VulnerabilityConfirmInput;
};


export type MutationVulnerabilityCreateArgs = {
  input: VulnerabilityCreateInput;
};


export type MutationVulnerabilityDismissArgs = {
  input: VulnerabilityDismissInput;
};


export type MutationVulnerabilityDismissFalsePositiveFlagArgs = {
  input: VulnerabilityDismissFalsePositiveFlagInput;
};


export type MutationVulnerabilityExternalIssueLinkCreateArgs = {
  input: VulnerabilityExternalIssueLinkCreateInput;
};


export type MutationVulnerabilityExternalIssueLinkDestroyArgs = {
  input: VulnerabilityExternalIssueLinkDestroyInput;
};


export type MutationVulnerabilityIssueLinkCreateArgs = {
  input: VulnerabilityIssueLinkCreateInput;
};


export type MutationVulnerabilityLinkMergeRequestArgs = {
  input: VulnerabilityLinkMergeRequestInput;
};


export type MutationVulnerabilityResolveArgs = {
  input: VulnerabilityResolveInput;
};


export type MutationVulnerabilityRevertToDetectedArgs = {
  input: VulnerabilityRevertToDetectedInput;
};


export type MutationVulnerabilityUnlinkMergeRequestArgs = {
  input: VulnerabilityUnlinkMergeRequestInput;
};


export type MutationWikiPageSubscribeArgs = {
  input: WikiPageSubscribeInput;
};


export type MutationWorkItemAddClosingMergeRequestArgs = {
  input: WorkItemAddClosingMergeRequestInput;
};


export type MutationWorkItemAddLinkedItemsArgs = {
  input: WorkItemAddLinkedItemsInput;
};


export type MutationWorkItemBulkMoveArgs = {
  input: WorkItemBulkMoveInput;
};


export type MutationWorkItemBulkUpdateArgs = {
  input: WorkItemBulkUpdateInput;
};


export type MutationWorkItemConvertArgs = {
  input: WorkItemConvertInput;
};


export type MutationWorkItemCreateArgs = {
  input: WorkItemCreateInput;
};


export type MutationWorkItemCreateFromTaskArgs = {
  input: WorkItemCreateFromTaskInput;
};


export type MutationWorkItemDeleteArgs = {
  input: WorkItemDeleteInput;
};


export type MutationWorkItemExportArgs = {
  input: WorkItemExportInput;
};


export type MutationWorkItemHierarchyAddChildrenItemsArgs = {
  input: WorkItemHierarchyAddChildrenItemsInput;
};


export type MutationWorkItemRemoveLinkedItemsArgs = {
  input: WorkItemRemoveLinkedItemsInput;
};


export type MutationWorkItemSavedViewCreateArgs = {
  input: WorkItemSavedViewCreateInput;
};


export type MutationWorkItemSavedViewDeleteArgs = {
  input: WorkItemSavedViewDeleteInput;
};


export type MutationWorkItemSavedViewReorderArgs = {
  input: WorkItemSavedViewReorderInput;
};


export type MutationWorkItemSavedViewSubscribeArgs = {
  input: WorkItemSavedViewSubscribeInput;
};


export type MutationWorkItemSavedViewUnsubscribeArgs = {
  input: WorkItemSavedViewUnsubscribeInput;
};


export type MutationWorkItemSavedViewUpdateArgs = {
  input: WorkItemSavedViewUpdateInput;
};


export type MutationWorkItemSubscribeArgs = {
  input: WorkItemSubscribeInput;
};


export type MutationWorkItemUpdateArgs = {
  input: WorkItemUpdateInput;
};


export type MutationWorkItemUserPreferenceUpdateArgs = {
  input: WorkItemUserPreferenceUpdateInput;
};


export type MutationWorkItemsCsvExportArgs = {
  input: WorkItemsCsvExportInput;
};


export type MutationWorkItemsCsvImportArgs = {
  input: WorkItemsCsvImportInput;
};


export type MutationWorkItemsHierarchyReorderArgs = {
  input: WorkItemsHierarchyReorderInput;
};


export type MutationWorkItemsReorderArgs = {
  input: WorkItemsReorderInput;
};


export type MutationWorkspaceCreateArgs = {
  input: WorkspaceCreateInput;
};


export type MutationWorkspaceUpdateArgs = {
  input: WorkspaceUpdateInput;
};

/** Different toggles for changing mutator behavior */
export type MutationOperationMode =
  /** Performs an append operation. */
  | 'APPEND'
  /** Performs a removal operation. */
  | 'REMOVE'
  /** Performs a replace operation. */
  | 'REPLACE';

export type Namespace = Todoable & {
  __typename?: 'Namespace';
  /**
   * Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in GitLab 15.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.8.
   */
  achievements?: Maybe<AchievementConnection>;
  /**
   * Path for the namespace's achievements. Returns `null` if the namespace is not a group, or the `achievements` feature flag is disabled. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  achievementsPath?: Maybe<Scalars['String']['output']>;
  /** Size limit for repositories in the namespace in bytes. This limit only applies to namespaces under Project limit enforcement. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']['output']>;
  /** The actual storage size limit (in bytes) based on the enforcement type of either repository or namespace. This limit is agnostic of enforcement type. */
  actualSizeLimit?: Maybe<Scalars['Float']['output']>;
  /**
   * Users in the namespace hierarchy that add ons are applicable for. This only applies to root namespaces. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  addOnEligibleUsers?: Maybe<AddOnUserConnection>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']['output']>;
  /**
   * AI settings for the namespace. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  aiSettings?: Maybe<AiNamespaceSettings>;
  /** Approval Policies of the project */
  approvalPolicies?: Maybe<ApprovalPolicyConnection>;
  /**
   * Features available on the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  availableFeatures: NamespaceAvailableFeatures;
  /** URL to avatar image file of the namespace. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Namespace CI/CD settings for the namespace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  ciCdSettings?: Maybe<CiCdSettings>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Includes at least one project where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement. */
  containsLockedProjects?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean']['output'];
  /**
   * Custom fields configured for the namespace. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  customFields?: Maybe<CustomFieldConnection>;
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /**
   * Indicates whether the namespace is designated to centrally manage security policies. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  designatedAsCsp: Scalars['Boolean']['output'];
  /** Full name of the namespace. */
  fullName: Scalars['String']['output'];
  /** Full path of the namespace. */
  fullPath: Scalars['ID']['output'];
  /** ID of the namespace. */
  id: Scalars['ID']['output'];
  /**
   * Import source users of the namespace. This field can only be resolved for one namespace in any single request. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  importSourceUsers?: Maybe<ImportSourceUserConnection>;
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Licensed features available on the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  licensedFeatures: NamespaceAvailableFeatures;
  /**
   * Lifecycle templates available to the namespace. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  lifecycleTemplates?: Maybe<Array<WorkItemLifecycle>>;
  /**
   * Lifecycles of work items available to the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  lifecycles?: Maybe<WorkItemLifecycleConnection>;
  /**
   * Namespace relevant paths to create links on the UI. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  linkPaths?: Maybe<NamespacesLinkPaths>;
  /**
   * Namespace relevant paths to create markdown links on the UI. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  markdownPaths?: Maybe<MarkdownPaths>;
  /**
   * Indicates if merge requests are enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  mergeRequestsEnabled: Scalars['Boolean']['output'];
  /**
   * Metadata information for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  metadata?: Maybe<NamespaceMetadata>;
  /** Name of the namespace. */
  name: Scalars['String']['output'];
  /** Namespace settings for the namespace. */
  namespaceSettings?: Maybe<NamespaceSettings>;
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** List of the namespaces's Pages Deployments. */
  pagesDeployments?: Maybe<PagesDeploymentConnection>;
  /** Path of the namespace. */
  path: Scalars['String']['output'];
  /** Pipeline Execution Policies of the namespace. */
  pipelineExecutionPolicies?: Maybe<PipelineExecutionPolicyConnection>;
  /** Pipeline Execution Schedule Policies of the namespace. */
  pipelineExecutionSchedulePolicies?: Maybe<PipelineExecutionSchedulePolicyConnection>;
  /**
   * Subscription plan associated with the namespace. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  plan?: Maybe<NamespacePlan>;
  /**
   * Number of product analytics events namespace is permitted to store per cycle. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  productAnalyticsStoredEventsLimit?: Maybe<Scalars['Int']['output']>;
  /** Projects within this namespace. Returns projects from the parent group if namespace is project. */
  projects: ProjectConnection;
  /**
   * Cluster agents in the namespace with remote development capabilities Deprecated in GitLab 17.8: Use `workspacesClusterAgents`.
   * @deprecated Use `workspacesClusterAgents`. Deprecated in GitLab 17.8.
   */
  remoteDevelopmentClusterAgents?: Maybe<ClusterAgentConnection>;
  /** Number of projects in the root namespace where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement. */
  repositorySizeExcessProjectCount?: Maybe<Scalars['Int']['output']>;
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /**
   * Saved views associated with the namespace. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  savedViews?: Maybe<WorkItemSavedViewTypeConnection>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /**
   * Scan Result Policies of the project Deprecated in GitLab 16.9: Use `approvalPolicies`.
   * @deprecated Use `approvalPolicies`. Deprecated in GitLab 16.9.
   */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /**
   * List of security policies configured for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  securityPolicies?: Maybe<SecurityPolicyTypeConnection>;
  /** Security policy project assigned to the namespace. */
  securityPolicyProject?: Maybe<Project>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /**
   * Data needed to render the sidebar for the namespace. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  sidebar?: Maybe<NamespaceSidebar>;
  /**
   * Statuses of work items available to the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  statuses?: Maybe<WorkItemStatusConnection>;
  /** The storage limit (in bytes) included with the root namespace plan. This limit only applies to namespaces under namespace limit enforcement. */
  storageSizeLimit?: Maybe<Scalars['Float']['output']>;
  /**
   * Maximum number of subscribed saved views allowed on the namespace. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  subscribedSavedViewLimit: Scalars['Int']['output'];
  /**
   * Find subscription history records. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  subscriptionHistory?: Maybe<GitlabSubscriptionHistoryConnection>;
  /**
   * Timelog categories for the namespace. Introduced in GitLab 15.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']['output']>;
  /** Total excess repository size of all projects in the root namespace in bytes. This only applies to namespaces under Project limit enforcement. */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: NamespacePermissions;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']['output']>;
  /**
   * Vulnerability Management Policies of the project. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  vulnerabilityManagementPolicies?: Maybe<VulnerabilityManagementPolicyConnection>;
  /** URL of the namespace. */
  webUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Find a work item by IID directly associated with the namespace (project or group) Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  workItem?: Maybe<WorkItem>;
  /**
   * Work item description templates available to the namespace. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  workItemDescriptionTemplates?: Maybe<WorkItemDescriptionTemplateConnection>;
  /**
   * Counts of work items by state for the namespace (project or group). Returns `null` for user namespaces. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  workItemStateCounts?: Maybe<WorkItemStateCountsType>;
  /**
   * Work item types available to the namespace. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
  /**
   * Work items that belong to the namespace (project or group). Returns `null` for user namespaces. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  workItems?: Maybe<WorkItemConnection>;
  /**
   * List of available widgets for the given work items. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  workItemsWidgets?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Cluster agents in the namespace with workspaces capabilities Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  workspacesClusterAgents?: Maybe<ClusterAgentConnection>;
};


export type NamespaceAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['AchievementsAchievementID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceAddOnEligibleUsersArgs = {
  addOnPurchaseIds: Array<Scalars['GitlabSubscriptionsAddOnPurchaseID']['input']>;
  addOnType: GitlabSubscriptionsAddOnType;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignedSeat?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GitlabSubscriptionsUserSort>;
};


export type NamespaceApprovalPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  ids?: InputMaybe<Array<Scalars['ComplianceManagementFrameworkID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ComplianceFrameworkSort>;
};


export type NamespaceCustomFieldsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  fieldType?: InputMaybe<CustomFieldType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['WorkItemsTypeID']['input']>;
};


export type NamespaceImportSourceUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<SourceUserSort>;
  statuses?: InputMaybe<Array<ImportSourceUserStatus>>;
};


export type NamespaceLifecyclesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespacePagesDeploymentsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Sort>;
  versioned?: InputMaybe<Scalars['Boolean']['input']>;
};


export type NamespacePipelineExecutionPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespacePipelineExecutionSchedulePoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  complianceFrameworkFilters?: InputMaybe<ComplianceFrameworkFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  sbomComponentId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withNamespaceDomainPages?: InputMaybe<Scalars['Boolean']['input']>;
};


export type NamespaceRemoteDevelopmentClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: NamespaceClusterAgentFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceSavedViewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['WorkItemsSavedViewsSavedViewID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemsSavedViewsSort>;
  subscribedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type NamespaceScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceSecurityPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  type?: InputMaybe<PolicyType>;
};


export type NamespaceStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceSubscriptionHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceVulnerabilityManagementPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceWorkItemArgs = {
  iid: Scalars['String']['input'];
};


export type NamespaceWorkItemDescriptionTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NamespaceWorkItemStateCountsArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type NamespaceWorkItemTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<IssueType>;
};


export type NamespaceWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  timeframe?: InputMaybe<Timeframe>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type NamespaceWorkItemsWidgetsArgs = {
  ids: Array<Scalars['WorkItemsTypeID']['input']>;
  union?: Scalars['Boolean']['input'];
};


export type NamespaceWorkspacesClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: NamespaceClusterAgentFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type NamespaceAvailableFeatures = {
  __typename?: 'NamespaceAvailableFeatures';
  /**
   * Whether blocked issues are enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  hasBlockedIssuesFeature: Scalars['Boolean']['output'];
  /**
   * Whether custom fields are enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  hasCustomFieldsFeature: Scalars['Boolean']['output'];
  /**
   * Whether design management is enabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  hasDesignManagementFeature: Scalars['Boolean']['output'];
  /**
   * Whether Duo remote flows are enabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  hasDuoRemoteFlowsFeature: Scalars['Boolean']['output'];
  /**
   * Whether epics are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasEpicsFeature: Scalars['Boolean']['output'];
  /**
   * Whether group bulk edit is enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  hasGroupBulkEditFeature: Scalars['Boolean']['output'];
  /**
   * Whether issuable health status is enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasIssuableHealthStatusFeature: Scalars['Boolean']['output'];
  /**
   * Whether issue date filter is enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasIssueDateFilterFeature: Scalars['Boolean']['output'];
  /**
   * Whether issue weights are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasIssueWeightsFeature: Scalars['Boolean']['output'];
  /**
   * Whether iterations are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasIterationsFeature: Scalars['Boolean']['output'];
  /**
   * Whether linked items epics are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasLinkedItemsEpicsFeature: Scalars['Boolean']['output'];
  /**
   * Whether OKRs are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasOkrsFeature: Scalars['Boolean']['output'];
  /**
   * Whether quality management is enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasQualityManagementFeature: Scalars['Boolean']['output'];
  /**
   * Whether scoped labels are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasScopedLabelsFeature: Scalars['Boolean']['output'];
  /**
   * Whether subepics are enabled for the namespace. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  hasSubepicsFeature: Scalars['Boolean']['output'];
  /**
   * Whether work item planning view is enabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  hasWorkItemPlanningViewFeature: Scalars['Boolean']['output'];
  /**
   * Whether work item statuses are enabled for the namespace. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  hasWorkItemStatusFeature: Scalars['Boolean']['output'];
  /**
   * Whether work item saved views are enabled for the namespace. Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  hasWorkItemsSavedViewsFeature: Scalars['Boolean']['output'];
};

export type NamespaceBan = {
  __typename?: 'NamespaceBan';
  /** Global ID of the namespace ban. */
  id: Scalars['GlobalID']['output'];
  /** Root namespace to which the ban applies. */
  namespace: Namespace;
  /** User to which the namespace ban applies. */
  user: UserCore;
};

/** Autogenerated input type of NamespaceBanDestroy */
export type NamespaceBanDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the namespace ban to remove. */
  id: Scalars['NamespacesNamespaceBanID']['input'];
};

/** Autogenerated return type of NamespaceBanDestroy. */
export type NamespaceBanDestroyPayload = {
  __typename?: 'NamespaceBanDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace Ban. */
  namespaceBan?: Maybe<NamespaceBan>;
};

export type NamespaceCiCdSetting = {
  __typename?: 'NamespaceCiCdSetting';
  /** Indicates if stale runners directly belonging to the namespace should be periodically pruned. */
  allowStaleRunnerPruning?: Maybe<Scalars['Boolean']['output']>;
  /** Namespace the CI/CD settings belong to. */
  namespace?: Maybe<Namespace>;
};

/** Autogenerated input type of NamespaceCiCdSettingsUpdate */
export type NamespaceCiCdSettingsUpdateInput = {
  /** Indicates if stale runners directly belonging to the namespace should be periodically pruned. */
  allowStaleRunnerPruning?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the namespace the settings belong to. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of NamespaceCiCdSettingsUpdate. */
export type NamespaceCiCdSettingsUpdatePayload = {
  __typename?: 'NamespaceCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: NamespaceCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Possible filter types for remote development cluster agents in a namespace */
export type NamespaceClusterAgentFilter =
  /** All cluster agents in the namespace that can be used for hosting worksapces. */
  | 'ALL'
  /** Cluster agents in the namespace that can be used for hosting workspaces. */
  | 'AVAILABLE'
  /** Cluster agents that are directly mapped to the given namespace. */
  | 'DIRECTLY_MAPPED'
  /** Cluster agents within a namespace that are not directly mapped to it. */
  | 'UNMAPPED';

/** Represents a namespace-cluster-agent mapping. */
export type NamespaceClusterAgentMapping = {
  __typename?: 'NamespaceClusterAgentMapping';
  /** Global ID of the cluster agent. */
  clusterAgentId: Scalars['ClustersAgentID']['output'];
  /** Timestamp when the namespace-cluster-agent mapping was created. */
  createdAt: Scalars['Time']['output'];
  /** Global ID of the creator. */
  creatorId: Scalars['UserID']['output'];
  /** Global ID of the namespace-cluster-agent mapping. */
  id: Scalars['RemoteDevelopmentNamespaceClusterAgentMappingID']['output'];
  /** Global ID of the namespace. */
  namespaceId: Scalars['NamespaceID']['output'];
  /** Timestamp when the namespace-cluster-agent mapping was last updated. */
  updatedAt: Scalars['Time']['output'];
};

export type NamespaceCommitEmail = {
  __typename?: 'NamespaceCommitEmail';
  /** Timestamp the namespace commit email was created. */
  createdAt: Scalars['Time']['output'];
  /** Email. */
  email: Email;
  /** Internal ID of the namespace commit email. */
  id: Scalars['ID']['output'];
  /** Namespace. */
  namespace: Namespace;
  /** Timestamp the namespace commit email was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for NamespaceCommitEmail. */
export type NamespaceCommitEmailConnection = {
  __typename?: 'NamespaceCommitEmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NamespaceCommitEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NamespaceCommitEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NamespaceCommitEmailEdge = {
  __typename?: 'NamespaceCommitEmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NamespaceCommitEmail>;
};

/** The connection type for Namespace. */
export type NamespaceConnection = {
  __typename?: 'NamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Namespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of NamespaceCreateRemoteDevelopmentClusterAgentMapping */
export type NamespaceCreateRemoteDevelopmentClusterAgentMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** GlobalID of the cluster agent to be associated with the namespace. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** GlobalID of the namespace to be associated with the cluster agent. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of NamespaceCreateRemoteDevelopmentClusterAgentMapping. */
export type NamespaceCreateRemoteDevelopmentClusterAgentMappingPayload = {
  __typename?: 'NamespaceCreateRemoteDevelopmentClusterAgentMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * Created namespace cluster agent mapping. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  namespaceClusterAgentMapping?: Maybe<NamespaceClusterAgentMapping>;
};

/** Autogenerated input type of NamespaceDeleteRemoteDevelopmentClusterAgentMapping */
export type NamespaceDeleteRemoteDevelopmentClusterAgentMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** GlobalID of the cluster agent to be un-associated from the namespace. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** GlobalID of the namespace to be un-associated from the cluster agent. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of NamespaceDeleteRemoteDevelopmentClusterAgentMapping. */
export type NamespaceDeleteRemoteDevelopmentClusterAgentMappingPayload = {
  __typename?: 'NamespaceDeleteRemoteDevelopmentClusterAgentMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * Created namespace cluster agent mapping. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  namespaceClusterAgentMapping?: Maybe<NamespaceClusterAgentMapping>;
};

/** An edge in a connection. */
export type NamespaceEdge = {
  __typename?: 'NamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Namespace>;
};

export type NamespaceMetadata = {
  /**
   * ID of the group. Returns null for user namespaces. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupId?: Maybe<Scalars['String']['output']>;
  /**
   * User preference for initial sort order. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  initialSort?: Maybe<Scalars['String']['output']>;
  /**
   * Whether issue repositioning is disabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isIssueRepositioningDisabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Maximum allowed attachment size (humanized). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  maxAttachmentSize?: Maybe<Scalars['String']['output']>;
  /**
   * Whether to show the new work item link. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  showNewWorkItem?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Time tracking limit to hours setting. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  timeTrackingLimitToHours?: Maybe<Scalars['Boolean']['output']>;
};

export type NamespacePermissions = {
  __typename?: 'NamespacePermissions';
  /** If `true`, the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_label` on this resource */
  adminLabel: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_project` on this resource */
  adminProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `bulk_admin_epic` on this resource */
  bulkAdminEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_epic` on this resource */
  createEpic: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_projects` on this resource */
  createProjects: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_work_item` on this resource */
  createWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `generate_description` on this resource */
  generateDescription: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `import_issues` on this resource */
  importIssues: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `import_work_items` on this resource */
  importWorkItems: Scalars['Boolean']['output'];
  /** If `true`, the user can read CRM contacts. */
  readCrmContact: Scalars['Boolean']['output'];
  /** If `true`, the user can read CRM organizations. */
  readCrmOrganization: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_namespace` on this resource */
  readNamespace: Scalars['Boolean']['output'];
  /** If `true`, the user can set work item metadata for new work items. */
  setNewWorkItemMetadata: Scalars['Boolean']['output'];
};

/** Represents a subscription plan. */
export type NamespacePlan = {
  __typename?: 'NamespacePlan';
  /** True if plan is paid. */
  isPaid?: Maybe<Scalars['Boolean']['output']>;
  /** Name of the plan. */
  name?: Maybe<Scalars['String']['output']>;
  /** Title of the plan. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Values for sorting projects */
export type NamespaceProjectSort =
  /** Sort by latest activity, descending order. */
  | 'ACTIVITY_DESC'
  /** Sort by total build artifact size, ascending order. */
  | 'BUILD_ARTIFACTS_SIZE_ASC'
  /** Sort by total build artifact size, descending order. */
  | 'BUILD_ARTIFACTS_SIZE_DESC'
  /** Sort by total container registry size, ascending order. */
  | 'CONTAINER_REGISTRY_SIZE_ASC'
  /** Sort by total container registry size, descending order. */
  | 'CONTAINER_REGISTRY_SIZE_DESC'
  /** Sort by excess repository storage size, descending order. */
  | 'EXCESS_REPO_STORAGE_SIZE_DESC'
  /** Sort by full path, ascending order. */
  | 'FULL_PATH_ASC'
  /** Sort by full path, descending order. */
  | 'FULL_PATH_DESC'
  /** Sort by total LFS object size, ascending order. */
  | 'LFS_OBJECTS_SIZE_ASC'
  /** Sort by total LFS object size, descending order. */
  | 'LFS_OBJECTS_SIZE_DESC'
  /** Sort by total package size, ascending order. */
  | 'PACKAGES_SIZE_ASC'
  /** Sort by total package size, descending order. */
  | 'PACKAGES_SIZE_DESC'
  /** Sort by path, ascending order. */
  | 'PATH_ASC'
  /** Sort by path, descending order. */
  | 'PATH_DESC'
  /** Sort by total repository size, ascending order. */
  | 'REPOSITORY_SIZE_ASC'
  /** Sort by total repository size, descending order. */
  | 'REPOSITORY_SIZE_DESC'
  /** Most similar to the search query. */
  | 'SIMILARITY'
  /** Sort by total snippet size, ascending order. */
  | 'SNIPPETS_SIZE_ASC'
  /** Sort by total snippet size, descending order. */
  | 'SNIPPETS_SIZE_DESC'
  /** Sort by total storage size, ascending order. */
  | 'STORAGE_SIZE_ASC'
  /** Sort by total storage size, descending order. */
  | 'STORAGE_SIZE_DESC'
  /** Sort by total wiki size, ascending order. */
  | 'WIKI_SIZE_ASC'
  /** Sort by total wiki size, descending order. */
  | 'WIKI_SIZE_DESC';

export type NamespaceProjectStatistics = {
  __typename?: 'NamespaceProjectStatistics';
  /** Build artifacts size of the project in bytes. */
  buildArtifactsSize?: Maybe<Scalars['Float']['output']>;
  /** Large File Storage (LFS) object size of the project in bytes. */
  lfsObjectsSize?: Maybe<Scalars['Float']['output']>;
  /** Packages size of the project in bytes. */
  packagesSize?: Maybe<Scalars['Float']['output']>;
  /** CI/CD Pipeline artifacts size in bytes. */
  pipelineArtifactsSize?: Maybe<Scalars['Float']['output']>;
  /** Repository size of the project in bytes. */
  repositorySize?: Maybe<Scalars['Float']['output']>;
  /** Snippets size of the project in bytes. */
  snippetsSize?: Maybe<Scalars['Float']['output']>;
  /** Storage size of the project in bytes. */
  storageSize?: Maybe<Scalars['Float']['output']>;
  /** Uploads size of the project in bytes. */
  uploadsSize?: Maybe<Scalars['Float']['output']>;
  /** Wiki size of the project in bytes. */
  wikiSize?: Maybe<Scalars['Float']['output']>;
};

/** Settings for the namespace */
export type NamespaceSettings = {
  __typename?: 'NamespaceSettings';
  /** OAuth provider required for step-up authentication. */
  stepUpAuthRequiredOauthProvider?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of NamespaceSettingsUpdate */
export type NamespaceSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the namespace the settings belong to. */
  fullPath: Scalars['ID']['input'];
  /** Indicates the default minimum role required to override pipeline variables in the namespace. */
  pipelineVariablesDefaultRole?: InputMaybe<PipelineVariablesDefaultRoleType>;
};

/** Autogenerated return type of NamespaceSettingsUpdate. */
export type NamespaceSettingsUpdatePayload = {
  __typename?: 'NamespaceSettingsUpdatePayload';
  /** Namespace CI/CD settings after mutation. */
  ciCdSettings: CiCdSettings;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type NamespaceSidebar = {
  __typename?: 'NamespaceSidebar';
  /** Number of open epics of the namespace. */
  openEpicsCount?: Maybe<Scalars['Int']['output']>;
  /** Number of open issues of the namespace. */
  openIssuesCount?: Maybe<Scalars['Int']['output']>;
  /** Number of open merge requests of the namespace. */
  openMergeRequestsCount?: Maybe<Scalars['Int']['output']>;
};

/** Represents either a namespace or a reference to a deleted namespace */
export type NamespaceUnion = CiDeletedNamespace | Namespace;

export type NamespacesLinkPaths = {
  /**
   * Path for autocomplete award emojis. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  autocompleteAwardEmojisPath?: Maybe<Scalars['String']['output']>;
  /**
   * Calendar path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  calendarPath?: Maybe<Scalars['String']['output']>;
  /** Namespace contribution guide path. */
  contributionGuidePath?: Maybe<Scalars['String']['output']>;
  /** Help page path for emails. */
  emailsHelpPagePath?: Maybe<Scalars['String']['output']>;
  /** Namespace epics_list. */
  epicsList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the epics list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  epicsListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace group_issues. */
  groupIssues?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the group. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues_list. */
  issuesList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the issues list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  issuesListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues settings path. */
  issuesSettings?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_fetch. */
  labelsFetch?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_manage. */
  labelsManage?: Maybe<Scalars['String']['output']>;
  /** Help page path for Markdown. */
  markdownHelpPath?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the namespace (project.namespace.full_path or group full_path). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  namespaceFullPath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_comment_template_paths. */
  newCommentTemplate?: Maybe<Array<CommentTemplatePath>>;
  /**
   * Path to create a new issue. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newIssuePath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_project. */
  newProject?: Maybe<Scalars['String']['output']>;
  /**
   * New trial path for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newTrialPath?: Maybe<Scalars['String']['output']>;
  /** Help page path for quick actions. */
  quickActionsHelpPath?: Maybe<Scalars['String']['output']>;
  /** Namespace register_path. */
  register?: Maybe<Scalars['String']['output']>;
  /** Namespace report_abuse. */
  reportAbuse?: Maybe<Scalars['String']['output']>;
  /**
   * RSS path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rssPath?: Maybe<Scalars['String']['output']>;
  /** Namespace sign_in_path. */
  signIn?: Maybe<Scalars['String']['output']>;
  /**
   * User email for export CSV. Returns `null` for user namespaces. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  userExportEmail?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of NamespacesRegenerateNewWorkItemEmailAddress */
export type NamespacesRegenerateNewWorkItemEmailAddressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the namespace to regenerate the new work item email address for. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of NamespacesRegenerateNewWorkItemEmailAddress. */
export type NamespacesRegenerateNewWorkItemEmailAddressPayload = {
  __typename?: 'NamespacesRegenerateNewWorkItemEmailAddressPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace after regenerating the new work item email address. */
  namespace?: Maybe<Namespace>;
};

export type NegatedBoardIssueInput = {
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /**
   * Health status not applied to the issue.
   *                     Includes issues where health status is not set.
   */
  healthStatusFilter?: InputMaybe<HealthStatus>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']['input']>>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<NegatedIterationWildcardId>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']['input']>;
};

export type NegatedComplianceFrameworkFilters = {
  /** ID of the compliance framework. */
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** IDs of the compliance framework. */
  ids?: InputMaybe<Array<Scalars['ComplianceManagementFrameworkID']['input']>>;
};

export type NegatedEpicBoardIssueInput = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
};

export type NegatedEpicFilterInput = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
};

export type NegatedIssueFilterInput = {
  /** ID of a user not assigned to the issues. */
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  /** Usernames of users not assigned to the issue. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Username of a user who didn't author the issue. */
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID of an epic not associated with the issues. */
  epicId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Health status not applied to the issue.
   *                     Includes issues where health status is not set.
   */
  healthStatusFilter?: InputMaybe<Array<HealthStatus>>;
  /** List of IIDs of issues to exclude. For example, `[1, 2]`. */
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of iteration Global IDs not applied to the issue. */
  iterationId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by negated iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Labels not applied to the issue. */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Milestone not applied to the issue. */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by negated milestone wildcard values. */
  milestoneWildcardId?: InputMaybe<NegatedMilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Release tag not associated with the issue's milestone. Ignored when parent is a group. */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters out issues by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Weight not applied to the issue. */
  weight?: InputMaybe<Scalars['String']['input']>;
};

/** Negated Iteration ID wildcard values */
export type NegatedIterationWildcardId =
  /** Current iteration. */
  | 'CURRENT';

/** Negated Milestone ID wildcard values */
export type NegatedMilestoneWildcardId =
  /** Milestone assigned is open and yet to be started (start date > today). */
  | 'STARTED'
  /** Milestone assigned is open but starts in the past (start date <= today). This differs from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues). */
  | 'UPCOMING';

export type NegatedValueStreamAnalyticsIssuableFilterInput = {
  /** Usernames of users not assigned to the issue or merge request. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Username of a user who didn't author the issue or merge request. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** ID of an epic not associated with the issues.         Using the filter is not supported for stages based on merge requests. */
  epicId?: InputMaybe<Scalars['ID']['input']>;
  /** List of iteration Global IDs not applied to the issue.         Using the filter is not supported for stages based on merge requests. */
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  /** Labels not applied to the issue or merge request. */
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Milestone not applied to the issue or merge request. */
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Weight not applied to the issue.         Using the filter is not supported for stages based on merge requests. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type NegatedWorkItemFilterInput = {
  /** Usernames of users not assigned to the work item (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Username of a user who didn't author the work item (maximum is 100 usernames). */
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Health status not applied to the work items.
   *                     Includes work items where health status is not set.
   */
  healthStatusFilter?: InputMaybe<Array<HealthStatus>>;
  /** List of iteration Global IDs not applied to the work items (maximum is 100 IDs). */
  iterationId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by negated iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Labels not applied to the work item (maximum is 100 labels). */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Milestone not applied to the work item (maximum is 100 milestones). */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by negated milestone wildcard values. */
  milestoneWildcardId?: InputMaybe<NegatedMilestoneWildcardId>;
  /** Filter by reaction emoji not applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Release tag not associated with the work items's milestone (maximum is 100 tags). Ignored when parent is a group . */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter out work items by the given types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Weight not applied to the work items. */
  weight?: InputMaybe<Scalars['String']['input']>;
};

/** Describes where code is deployed for a project organized by folder. */
export type NestedEnvironment = {
  __typename?: 'NestedEnvironment';
  /** Latest environment in the folder. */
  environment?: Maybe<Environment>;
  /** Human-readable name of the environment. */
  name: Scalars['String']['output'];
  /** Number of environments nested in the folder. */
  size: Scalars['Int']['output'];
};

/** The connection type for NestedEnvironment. */
export type NestedEnvironmentConnection = {
  __typename?: 'NestedEnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NestedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NestedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NestedEnvironmentEdge = {
  __typename?: 'NestedEnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NestedEnvironment>;
};

export type NetworkPolicyEgress = {
  __typename?: 'NetworkPolicyEgress';
  /** IP range to allow traffic from. */
  allow: Scalars['String']['output'];
  /** List of IP ranges to exclude from the `allow` range. */
  except?: Maybe<Array<Scalars['String']['output']>>;
};

export type Note = BaseNoteInterface & ResolvableInterface & {
  __typename?: 'Note';
  /** User who wrote the note. */
  author?: Maybe<UserCore>;
  /** Indicates whether the note author is a contributor. */
  authorIsContributor?: Maybe<Scalars['Boolean']['output']>;
  /** List of emoji reactions associated with the note. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Content of the note. */
  body: Scalars['String']['output'];
  /** First line of the note content. */
  bodyFirstLineHtml: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of the content of the note. */
  bodyHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the note creation. */
  createdAt: Scalars['Time']['output'];
  /** Discussion the note is a part of. */
  discussion?: Maybe<Discussion>;
  /** Email address of non-GitLab user adding the note. For guests, the email address is obfuscated. */
  externalAuthor?: Maybe<Scalars['String']['output']>;
  /** ID of the note. */
  id: Scalars['NoteID']['output'];
  /** Indicates whether the note was imported. */
  imported?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if the note is internal. */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when note was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']['output']>;
  /** User who last edited the note. */
  lastEditedBy?: Maybe<UserCore>;
  /** Max access level of the note author in the project. */
  maxAccessLevelOfAuthor?: Maybe<Scalars['String']['output']>;
  /** Position of the note on a diff. */
  position?: Maybe<DiffPosition>;
  /** Project associated with the note. */
  project?: Maybe<Project>;
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean']['output'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean']['output'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether the note was created by the system or by a user. */
  system: Scalars['Boolean']['output'];
  /** Name of the icon corresponding to a system note. */
  systemNoteIconName?: Maybe<Scalars['String']['output']>;
  /** Metadata for the given note if it is a system note. */
  systemNoteMetadata?: Maybe<SystemNoteMetadata>;
  /** Timestamp of the note's last activity. */
  updatedAt: Scalars['Time']['output'];
  /** URL to view the note in the Web UI. */
  url?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: NotePermissions;
};


export type NoteAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Note>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Note. */
export type NoteConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of NoteConvertToThread */
export type NoteConvertToThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Note to convert. */
  id: Scalars['NoteID']['input'];
};

/** Autogenerated return type of NoteConvertToThread. */
export type NoteConvertToThreadPayload = {
  __typename?: 'NoteConvertToThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

export type NotePermissions = {
  __typename?: 'NotePermissions';
  /** If `true`, the user can perform `admin_note` on this resource */
  adminNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_note` on this resource */
  readNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `reposition_note` on this resource */
  repositionNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `resolve_note` on this resource */
  resolveNote: Scalars['Boolean']['output'];
};

export type NoteableInterface = {
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** All notes on this noteable. */
  notes: NoteConnection;
};


export type NoteableInterfaceCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NoteableInterfaceDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type NoteableInterfaceNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an object that supports notes. */
export type NoteableType = Design | Issue | MergeRequest;

/** Work item notes collection type. */
export type NotesFilterType =
  /** Show all activity */
  | 'ALL_NOTES'
  /** Show history only */
  | 'ONLY_ACTIVITY'
  /** Show comments only */
  | 'ONLY_COMMENTS';

/** Nuget dependency link metadata */
export type NugetDependencyLinkMetadata = {
  __typename?: 'NugetDependencyLinkMetadata';
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetDependencyLinkMetadatumID']['output'];
  /** Target framework of the dependency link package. */
  targetFramework: Scalars['String']['output'];
};

/** Nuget metadata */
export type NugetMetadata = {
  __typename?: 'NugetMetadata';
  /** Icon URL of the Nuget package. */
  iconUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetMetadatumID']['output'];
  /** License URL of the Nuget package. */
  licenseUrl?: Maybe<Scalars['String']['output']>;
  /** Project URL of the Nuget package. */
  projectUrl?: Maybe<Scalars['String']['output']>;
};

/** ObservabilityLog represents a connection between an issue and a log entry */
export type ObservabilityLog = {
  __typename?: 'ObservabilityLog';
  /** Log fingerprint of the log. */
  fingerprint: Scalars['String']['output'];
  /** Issue associated with the log. */
  issue: Issue;
  /** Service name of the log. */
  serviceName: Scalars['String']['output'];
  /** Severity number of the log. */
  severityNumber: Scalars['Int']['output'];
  /** Timestamp of the log. */
  timestamp: Scalars['ISO8601DateTime']['output'];
  /** Trace identifier of the log. */
  traceIdentifier: Scalars['String']['output'];
};

/** The connection type for ObservabilityLog. */
export type ObservabilityLogConnection = {
  __typename?: 'ObservabilityLogConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ObservabilityLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ObservabilityLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ObservabilityLog. */
export type ObservabilityLogConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ObservabilityLogEdge = {
  __typename?: 'ObservabilityLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ObservabilityLog>;
};

/** ObservabilityMetric represents a connection between an issue and a metric */
export type ObservabilityMetric = {
  __typename?: 'ObservabilityMetric';
  /** Issues that the metric is attributed to. */
  issue?: Maybe<Issue>;
  /** Name of the metric. */
  name: Scalars['String']['output'];
  /** OpenTelemetry metric type of the metric. */
  type: Scalars['String']['output'];
};

/** The connection type for ObservabilityMetric. */
export type ObservabilityMetricConnection = {
  __typename?: 'ObservabilityMetricConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ObservabilityMetricEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ObservabilityMetric>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ObservabilityMetric. */
export type ObservabilityMetricConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ObservabilityMetricEdge = {
  __typename?: 'ObservabilityMetricEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ObservabilityMetric>;
};

/** ObservabilityTrace represents a connection between an issue and a trace */
export type ObservabilityTrace = {
  __typename?: 'ObservabilityTrace';
  /** Issue associated with the trace. */
  issue: Issue;
  /** Identifier of the trace. */
  traceIdentifier: Scalars['String']['output'];
};

/** The connection type for ObservabilityTrace. */
export type ObservabilityTraceConnection = {
  __typename?: 'ObservabilityTraceConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ObservabilityTraceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ObservabilityTrace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ObservabilityTrace. */
export type ObservabilityTraceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ObservabilityTraceEdge = {
  __typename?: 'ObservabilityTraceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ObservabilityTrace>;
};

/** The rotation participant and color palette */
export type OncallParticipantType = {
  __typename?: 'OncallParticipantType';
  /** Color palette to assign to the on-call user. For example "blue". */
  colorPalette?: Maybe<Scalars['String']['output']>;
  /** Color weight to assign to for the on-call user, for example "500". Max 4 chars. For easy identification of the user. */
  colorWeight?: Maybe<Scalars['String']['output']>;
  /** ID of the on-call participant. */
  id: Scalars['IncidentManagementOncallParticipantID']['output'];
  /** User who is participating. */
  user: UserCore;
};

/** The connection type for OncallParticipantType. */
export type OncallParticipantTypeConnection = {
  __typename?: 'OncallParticipantTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OncallParticipantTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OncallParticipantType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OncallParticipantTypeEdge = {
  __typename?: 'OncallParticipantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OncallParticipantType>;
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodInputType = {
  /** End of the rotation active period in 24 hour format. For example, "18:30". */
  endTime: Scalars['String']['input'];
  /** Start of the rotation active period in 24 hour format. For example, "18:30". */
  startTime: Scalars['String']['input'];
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodType = {
  __typename?: 'OncallRotationActivePeriodType';
  /** End of the rotation active period. */
  endTime?: Maybe<Scalars['String']['output']>;
  /** Start of the rotation active period. */
  startTime?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of OncallRotationCreate */
export type OncallRotationCreateInput = {
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** Name of the on-call rotation. */
  name: Scalars['String']['input'];
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants: Array<OncallUserInputType>;
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID']['input'];
  /** Rotation length of the on-call rotation. */
  rotationLength: OncallRotationLengthInputType;
  /** IID of the on-call schedule to create the on-call rotation in. */
  scheduleIid: Scalars['String']['input'];
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt: OncallRotationDateInputType;
};

/** Autogenerated return type of OncallRotationCreate. */
export type OncallRotationCreatePayload = {
  __typename?: 'OncallRotationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Date input type for on-call rotation */
export type OncallRotationDateInputType = {
  /** Date component of the date in YYYY-MM-DD format. */
  date: Scalars['String']['input'];
  /** Time component of the date in 24hr HH:MM format. */
  time: Scalars['String']['input'];
};

/** Autogenerated input type of OncallRotationDestroy */
export type OncallRotationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the on-call rotation to remove. */
  id: Scalars['IncidentManagementOncallRotationID']['input'];
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID']['input'];
  /** IID of the on-call schedule to the on-call rotation belongs to. */
  scheduleIid: Scalars['String']['input'];
};

/** Autogenerated return type of OncallRotationDestroy. */
export type OncallRotationDestroyPayload = {
  __typename?: 'OncallRotationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** The rotation length of the on-call rotation */
export type OncallRotationLengthInputType = {
  /** Rotation length of the on-call rotation. */
  length: Scalars['Int']['input'];
  /** Unit of the rotation length of the on-call rotation. */
  unit: OncallRotationUnitEnum;
};

/** Rotation length unit of an on-call rotation */
export type OncallRotationUnitEnum =
  /** Days */
  | 'DAYS'
  /** Hours */
  | 'HOURS'
  /** Weeks */
  | 'WEEKS';

/** Autogenerated input type of OncallRotationUpdate */
export type OncallRotationUpdateInput = {
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementOncallRotationID']['input'];
  /** Name of the on-call rotation. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants?: InputMaybe<Array<OncallUserInputType>>;
  /** Rotation length of the on-call rotation. */
  rotationLength?: InputMaybe<OncallRotationLengthInputType>;
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt?: InputMaybe<OncallRotationDateInputType>;
};

/** Autogenerated return type of OncallRotationUpdate. */
export type OncallRotationUpdatePayload = {
  __typename?: 'OncallRotationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Autogenerated input type of OncallScheduleCreate */
export type OncallScheduleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name of the on-call schedule. */
  name: Scalars['String']['input'];
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID']['input'];
  /** Timezone of the on-call schedule. */
  timezone: Scalars['String']['input'];
};

/** Autogenerated return type of OncallScheduleCreate. */
export type OncallScheduleCreatePayload = {
  __typename?: 'OncallScheduleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleDestroy */
export type OncallScheduleDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** On-call schedule internal ID to remove. */
  iid: Scalars['String']['input'];
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of OncallScheduleDestroy. */
export type OncallScheduleDestroyPayload = {
  __typename?: 'OncallScheduleDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleUpdate */
export type OncallScheduleUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** On-call schedule internal ID to update. */
  iid: Scalars['String']['input'];
  /** Name of the on-call schedule. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Project to update the on-call schedule in. */
  projectPath: Scalars['ID']['input'];
  /** Timezone of the on-call schedule. */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of OncallScheduleUpdate. */
export type OncallScheduleUpdatePayload = {
  __typename?: 'OncallScheduleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** The rotation user and color palette */
export type OncallUserInputType = {
  /** Value of DataVisualizationColorEnum. The color from the palette to assign to the on-call user. */
  colorPalette?: InputMaybe<DataVisualizationColorEnum>;
  /** Color weight to assign to for the on-call user. To view on-call schedules in GitLab, do not provide a value below 500. A value between 500 and 950 ensures sufficient contrast. */
  colorWeight?: InputMaybe<DataVisualizationWeightEnum>;
  /** Username of the user to participate in the on-call rotation. For example, `"user_one"`. */
  username: Scalars['String']['input'];
};

/** Enum defining the type of OpenTelemetry metric */
export type OpenTelemetryMetricType =
  /** Exponential Histogram Type type. */
  | 'EXPONENTIAL_HISTOGRAM_TYPE'
  /** Gauge Type type. */
  | 'GAUGE_TYPE'
  /** Histogram Type type. */
  | 'HISTOGRAM_TYPE'
  /** Sum Type type. */
  | 'SUM_TYPE';

export type OrchestrationPolicy = {
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

export type Organization = {
  __typename?: 'Organization';
  /**
   * Avatar URL of the organization. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Description of the organization. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * GitLab Flavored Markdown rendering of `description` Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /**
   * Groups within this organization that the user has access to. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  groups: GroupConnection;
  /**
   * ID of the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  id: Scalars['ID']['output'];
  /**
   * Name of the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  name: Scalars['String']['output'];
  /**
   * Users with access to the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  organizationUsers: OrganizationUserConnection;
  /**
   * Path of the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  path: Scalars['String']['output'];
  /**
   * Projects within this organization that the user has access to. Introduced in GitLab 16.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.8.
   */
  projects: ProjectConnection;
  /**
   * Root path in the context of the organization. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  rootPath: Scalars['String']['output'];
  /**
   * Web URL of the organization. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  webUrl: Scalars['String']['output'];
  /**
   * Cluster agents in the organization with workspaces capabilities Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  workspacesClusterAgents?: Maybe<ClusterAgentConnection>;
};


export type OrganizationGroupsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  ownedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  parentPath?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topLevelOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrganizationOrganizationUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type OrganizationProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  aimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  archived?: InputMaybe<ProjectArchived>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fullPaths?: InputMaybe<Array<Scalars['String']['input']>>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRepositoryCheckFailed?: InputMaybe<Scalars['Boolean']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  membership?: InputMaybe<Scalars['Boolean']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  personal?: InputMaybe<Scalars['Boolean']['input']>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topics?: InputMaybe<Array<Scalars['String']['input']>>;
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrganizationWorkspacesClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: OrganizationClusterAgentFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Possible filter types for remote development cluster agents in an organization */
export type OrganizationClusterAgentFilter =
  /** All cluster agents in the organization that can be used for hosting workspaces. */
  | 'ALL'
  /** Cluster agents that are directly mapped to the given organization. */
  | 'DIRECTLY_MAPPED';

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename?: 'OrganizationConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Organization. */
export type OrganizationConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of OrganizationCreateClusterAgentMapping */
export type OrganizationCreateClusterAgentMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** GlobalID of the cluster agent to be associated with the organization. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** GlobalID of the organization to be associated with the cluster agent. */
  organizationId: Scalars['OrganizationsOrganizationID']['input'];
};

/** Autogenerated return type of OrganizationCreateClusterAgentMapping. */
export type OrganizationCreateClusterAgentMappingPayload = {
  __typename?: 'OrganizationCreateClusterAgentMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of OrganizationCreate */
export type OrganizationCreateInput = {
  /** Avatar for the organization. */
  avatar?: InputMaybe<Scalars['Upload']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the organization. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the organization. */
  name: Scalars['String']['input'];
  /** Path for the organization. */
  path: Scalars['String']['input'];
};

/** Autogenerated return type of OrganizationCreate. */
export type OrganizationCreatePayload = {
  __typename?: 'OrganizationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Organization after mutation. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of OrganizationDeleteClusterAgentMapping */
export type OrganizationDeleteClusterAgentMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** GlobalID of the cluster agent to be dissociated with the organization. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** GlobalID of the organization to be dissociated with the cluster agent. */
  organizationId: Scalars['OrganizationsOrganizationID']['input'];
};

/** Autogenerated return type of OrganizationDeleteClusterAgentMapping. */
export type OrganizationDeleteClusterAgentMappingPayload = {
  __typename?: 'OrganizationDeleteClusterAgentMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** Default list view for organization groups and projects. */
export type OrganizationGroupProjectDisplay =
  /** Display organization groups list. Introduced in GitLab 17.2: **Status**: Experiment. */
  | 'GROUPS'
  /** Display organization projects list. Introduced in GitLab 17.2: **Status**: Experiment. */
  | 'PROJECTS';

/** Values for sorting organization groups and projects. */
export type OrganizationGroupProjectSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Name ascending order. Introduced in GitLab 17.2: **Status**: Experiment. */
  | 'NAME_ASC'
  /** Name descending order. Introduced in GitLab 17.2: **Status**: Experiment. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Values for sorting organizations */
export type OrganizationSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Default Rate in ascending order. */
  | 'DEFAULT_RATE_ASC'
  /** Default Rate in descending order. */
  | 'DEFAULT_RATE_DESC'
  /** Description in ascending order. */
  | 'DESCRIPTION_ASC'
  /** Description in descending order. */
  | 'DESCRIPTION_DESC'
  /** Name in ascending order. */
  | 'NAME_ASC'
  /** Name in descending order. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Represents the total number of organizations for the represented states. */
export type OrganizationStateCounts = {
  __typename?: 'OrganizationStateCounts';
  /** Number of organizations with state `ACTIVE` */
  active?: Maybe<Scalars['Int']['output']>;
  /** Number of organizations with state `ALL` */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of organizations with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of OrganizationUpdate */
export type OrganizationUpdateInput = {
  /** Avatar for the organization. */
  avatar?: InputMaybe<Scalars['Upload']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the organization. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to mutate. */
  id: Scalars['OrganizationsOrganizationID']['input'];
  /** Name for the organization. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Path for the organization. */
  path?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of OrganizationUpdate. */
export type OrganizationUpdatePayload = {
  __typename?: 'OrganizationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Organization after mutation. */
  organization?: Maybe<Organization>;
};

/** A user with access to the organization. */
export type OrganizationUser = {
  __typename?: 'OrganizationUser';
  /**
   * Access level of the user in the organization. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  accessLevel: OrganizationUserAccess;
  /**
   * Badges describing the user within the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  badges?: Maybe<Array<OrganizationUserBadge>>;
  /**
   * ID of the organization user. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  id: Scalars['ID']['output'];
  /**
   * Whether the user is the last owner of the organization. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  isLastOwner: Scalars['Boolean']['output'];
  /**
   * User that is associated with the organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: OrganizationUserPermissions;
};

/** Represents the access level of a relationship between a User and Organization that it is related to */
export type OrganizationUserAccess = {
  __typename?: 'OrganizationUserAccess';
  /**
   * Integer representation of access level. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  integerValue?: Maybe<Scalars['Int']['output']>;
  /**
   * String representation of access level. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  stringValue?: Maybe<OrganizationUserAccessLevel>;
};

/** Access level of an organization user */
export type OrganizationUserAccessLevel =
  /** Guest access. Introduced in GitLab 16.11: **Status**: Experiment. */
  | 'DEFAULT'
  /** Owner access. Introduced in GitLab 16.11: **Status**: Experiment. */
  | 'OWNER';

/** An organization user badge. */
export type OrganizationUserBadge = {
  __typename?: 'OrganizationUserBadge';
  /** Badge text. */
  text: Scalars['String']['output'];
  /** Badge variant. */
  variant: Scalars['String']['output'];
};

/** The connection type for OrganizationUser. */
export type OrganizationUserConnection = {
  __typename?: 'OrganizationUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OrganizationUserEdge = {
  __typename?: 'OrganizationUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationUser>;
};

export type OrganizationUserPermissions = {
  __typename?: 'OrganizationUserPermissions';
  /** If `true`, the user can perform `admin_organization` on this resource */
  adminOrganization: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `delete_user` on this resource */
  deleteUser: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_user` on this resource */
  removeUser: Scalars['Boolean']['output'];
};

/** Autogenerated input type of OrganizationUserUpdate */
export type OrganizationUserUpdateInput = {
  /** Access level to update the organization user to. */
  accessLevel: OrganizationUserAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization user to mutate. */
  id: Scalars['OrganizationsOrganizationUserID']['input'];
};

/** Autogenerated return type of OrganizationUserUpdate. */
export type OrganizationUserUpdatePayload = {
  __typename?: 'OrganizationUserUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /**
   * Organization user after mutation. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  organizationUser?: Maybe<OrganizationUser>;
};

/** Represents a package with pipelines in the package registry */
export type Package = {
  __typename?: 'Package';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID']['output'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String']['output'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /**
   *               Pipelines that built the package. Max page size 20.
   *
   */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Whether any matching package protection rule exists for the package. */
  protectionRuleExists: Scalars['Boolean']['output'];
  /** Package status. */
  status: PackageStatus;
  /** Status message. */
  statusMessage?: Maybe<Scalars['String']['output']>;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: PackagePermissions;
  /** Version string. */
  version?: Maybe<Scalars['String']['output']>;
};


/** Represents a package with pipelines in the package registry */
export type PackagePipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a package with pipelines in the package registry */
export type PackageTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a package in the package registry */
export type PackageBase = {
  __typename?: 'PackageBase';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID']['output'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String']['output'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Project where the package is stored. */
  project: Project;
  /** Whether any matching package protection rule exists for the package. */
  protectionRuleExists: Scalars['Boolean']['output'];
  /** Package status. */
  status: PackageStatus;
  /** Status message. */
  statusMessage?: Maybe<Scalars['String']['output']>;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: PackagePermissions;
  /** Version string. */
  version?: Maybe<Scalars['String']['output']>;
};


/** Represents a package in the package registry */
export type PackageBaseTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PackageBase. */
export type PackageBaseConnection = {
  __typename?: 'PackageBaseConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageBaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageBase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PackageBase. */
export type PackageBaseConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PackageBaseEdge = {
  __typename?: 'PackageBaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageBase>;
};

/** Represents a composer JSON file */
export type PackageComposerJsonType = {
  __typename?: 'PackageComposerJsonType';
  /** License set in the Composer JSON file. */
  license?: Maybe<Scalars['String']['output']>;
  /** Name set in the Composer JSON file. */
  name?: Maybe<Scalars['String']['output']>;
  /** Type set in the Composer JSON file. */
  type?: Maybe<Scalars['String']['output']>;
  /** Version set in the Composer JSON file. */
  version?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Package. */
export type PackageConnection = {
  __typename?: 'PackageConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Package. */
export type PackageConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a package dependency. */
export type PackageDependency = {
  __typename?: 'PackageDependency';
  /** ID of the dependency. */
  id: Scalars['PackagesDependencyID']['output'];
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Version pattern of the dependency. */
  versionPattern: Scalars['String']['output'];
};

/** Represents a package dependency link */
export type PackageDependencyLink = {
  __typename?: 'PackageDependencyLink';
  /** Dependency. */
  dependency?: Maybe<PackageDependency>;
  /** Dependency type. */
  dependencyType: PackageDependencyType;
  /** ID of the dependency link. */
  id: Scalars['PackagesDependencyLinkID']['output'];
  /** Dependency link metadata. */
  metadata?: Maybe<DependencyLinkMetadata>;
};

/** The connection type for PackageDependencyLink. */
export type PackageDependencyLinkConnection = {
  __typename?: 'PackageDependencyLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageDependencyLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageDependencyLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageDependencyLinkEdge = {
  __typename?: 'PackageDependencyLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageDependencyLink>;
};

export type PackageDependencyType =
  /** bundleDependencies dependency type */
  | 'BUNDLE_DEPENDENCIES'
  /** dependencies dependency type */
  | 'DEPENDENCIES'
  /** devDependencies dependency type */
  | 'DEV_DEPENDENCIES'
  /** peerDependencies dependency type */
  | 'PEER_DEPENDENCIES';

/** Represents a package details in the Package Registry */
export type PackageDetailsType = {
  __typename?: 'PackageDetailsType';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Url of the Composer setup endpoint. */
  composerConfigRepositoryUrl?: Maybe<Scalars['String']['output']>;
  /** Url of the Composer endpoint. */
  composerUrl?: Maybe<Scalars['String']['output']>;
  /** Url of the Conan project endpoint. */
  conanUrl?: Maybe<Scalars['String']['output']>;
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Dependency link. */
  dependencyLinks?: Maybe<PackageDependencyLinkConnection>;
  /** ID of the package. */
  id: Scalars['PackagesPackageID']['output'];
  /** Last time that a file of the package was downloaded. */
  lastDownloadedAt?: Maybe<Scalars['Time']['output']>;
  /** Url of the Maven project endpoint. */
  mavenUrl?: Maybe<Scalars['String']['output']>;
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String']['output'];
  /** Url of the NPM project endpoint. */
  npmUrl?: Maybe<Scalars['String']['output']>;
  /** Url of the Nuget project endpoint. */
  nugetUrl?: Maybe<Scalars['String']['output']>;
  /** Package files. */
  packageFiles?: Maybe<PackageFileConnection>;
  /** Package type. */
  packageType: PackageTypeEnum;
  /**
   *               Pipelines that built the package. Max page size 20.
   *
   */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Whether any matching package protection rule exists for the package. */
  protectionRuleExists: Scalars['Boolean']['output'];
  /** Indicates if there is public access to the package. */
  publicPackage?: Maybe<Scalars['Boolean']['output']>;
  /** Url of the PyPi project setup endpoint. */
  pypiSetupUrl?: Maybe<Scalars['String']['output']>;
  /** Url of the PyPi project endpoint. */
  pypiUrl?: Maybe<Scalars['String']['output']>;
  /** Package status. */
  status: PackageStatus;
  /** Status message. */
  statusMessage?: Maybe<Scalars['String']['output']>;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: PackagePermissions;
  /** Version string. */
  version?: Maybe<Scalars['String']['output']>;
  /** Other versions of the package. */
  versions?: Maybe<PackageBaseConnection>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeDependencyLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePackageFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PackageEdge = {
  __typename?: 'PackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Package>;
};

/** Represents a package file */
export type PackageFile = {
  __typename?: 'PackageFile';
  /** Created date. */
  createdAt: Scalars['Time']['output'];
  /** Download path of the package file. */
  downloadPath: Scalars['String']['output'];
  /** Md5 of the package file. */
  fileMd5?: Maybe<Scalars['String']['output']>;
  /** File metadata. */
  fileMetadata?: Maybe<PackageFileMetadata>;
  /** Name of the package file. */
  fileName: Scalars['String']['output'];
  /** Sha1 of the package file. */
  fileSha1?: Maybe<Scalars['String']['output']>;
  /** Sha256 of the package file. */
  fileSha256?: Maybe<Scalars['String']['output']>;
  /** ID of the file. */
  id: Scalars['PackagesPackageFileID']['output'];
  /** Size of the package file. */
  size: Scalars['String']['output'];
  /** Updated date. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for PackageFile. */
export type PackageFileConnection = {
  __typename?: 'PackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageFileEdge = {
  __typename?: 'PackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFile>;
};

/** Represents metadata associated with a Package file */
export type PackageFileMetadata = {
  /** Date of creation. */
  createdAt: Scalars['Time']['output'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time']['output'];
};

/** Represents the Geo sync and verification state of a package file */
export type PackageFileRegistry = {
  __typename?: 'PackageFileRegistry';
  /** Indicate if the checksums of the PackageFileRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the PackageFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PackageFileRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the PackageFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the PackageFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the PackageFileRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PackageFileRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the PackageFile. */
  packageFileId: Scalars['ID']['output'];
  /** Timestamp after which the PackageFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the PackageFileRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the PackageFileRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the PackageFileRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the PackageFileRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the PackageFileRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the PackageFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the PackageFileRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of PackageFileRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the PackageFileRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the PackageFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for PackageFileRegistry. */
export type PackageFileRegistryConnection = {
  __typename?: 'PackageFileRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PackageFileRegistry. */
export type PackageFileRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PackageFileRegistryEdge = {
  __typename?: 'PackageFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFileRegistry>;
};

/** Values for sorting group packages */
export type PackageGroupSort =
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC'
  /** Ordered by project path in ascending order. */
  | 'PROJECT_PATH_ASC'
  /** Ordered by project path in descending order. */
  | 'PROJECT_PATH_DESC'
  /** Ordered by type in ascending order. */
  | 'TYPE_ASC'
  /** Ordered by type in descending order. */
  | 'TYPE_DESC'
  /** Ordered by version in ascending order. */
  | 'VERSION_ASC'
  /** Ordered by version in descending order. */
  | 'VERSION_DESC';

/** Represents a Helm dependency */
export type PackageHelmDependencyType = {
  __typename?: 'PackageHelmDependencyType';
  /** Alias of the dependency. */
  alias?: Maybe<Scalars['String']['output']>;
  /** Condition of the dependency. */
  condition?: Maybe<Scalars['String']['output']>;
  /** Indicates the dependency is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Import-values of the dependency. */
  importValues?: Maybe<Array<Scalars['JSON']['output']>>;
  /** Name of the dependency. */
  name?: Maybe<Scalars['String']['output']>;
  /** Repository of the dependency. */
  repository?: Maybe<Scalars['String']['output']>;
  /** Tags of the dependency. */
  tags?: Maybe<Array<Scalars['String']['output']>>;
  /** Version of the dependency. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Represents a Helm maintainer */
export type PackageHelmMaintainerType = {
  __typename?: 'PackageHelmMaintainerType';
  /** Email of the maintainer. */
  email?: Maybe<Scalars['String']['output']>;
  /** Name of the maintainer. */
  name?: Maybe<Scalars['String']['output']>;
  /** URL of the maintainer. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Represents the contents of a Helm Chart.yml file */
export type PackageHelmMetadataType = {
  __typename?: 'PackageHelmMetadataType';
  /** Annotations for the chart. */
  annotations?: Maybe<Scalars['JSON']['output']>;
  /** API version of the chart. */
  apiVersion: Scalars['String']['output'];
  /** App version of the chart. */
  appVersion?: Maybe<Scalars['String']['output']>;
  /** Condition for the chart. */
  condition?: Maybe<Scalars['String']['output']>;
  /** Dependencies of the chart. */
  dependencies?: Maybe<Array<PackageHelmDependencyType>>;
  /** Indicates if the chart is deprecated. */
  deprecated?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the chart. */
  description?: Maybe<Scalars['String']['output']>;
  /** URL of the home page. */
  home?: Maybe<Scalars['String']['output']>;
  /** URL to an SVG or PNG image for the chart. */
  icon?: Maybe<Scalars['String']['output']>;
  /** Keywords for the chart. */
  keywords?: Maybe<Array<Scalars['String']['output']>>;
  /** Kubernetes versions for the chart. */
  kubeVersion?: Maybe<Scalars['String']['output']>;
  /** Maintainers of the chart. */
  maintainers?: Maybe<Array<PackageHelmMaintainerType>>;
  /** Name of the chart. */
  name: Scalars['String']['output'];
  /** URLs of the source code for the chart. */
  sources?: Maybe<Array<Scalars['String']['output']>>;
  /** Tags for the chart. */
  tags?: Maybe<Scalars['String']['output']>;
  /** Type of the chart. */
  type?: Maybe<Scalars['String']['output']>;
  /** Version of the chart. */
  version: Scalars['String']['output'];
};

/** Represents links to perform actions on the package */
export type PackageLinks = {
  __typename?: 'PackageLinks';
  /** Path to the package details page. */
  webPath?: Maybe<Scalars['String']['output']>;
};

/** Values for package manager */
export type PackageManager =
  /** Package manager: apk. */
  | 'APK'
  /** Package manager: bundler. */
  | 'BUNDLER'
  /** Package manager: cargo. */
  | 'CARGO'
  /** Package manager: composer. */
  | 'COMPOSER'
  /** Package manager: conan. */
  | 'CONAN'
  /** Package manager: conda. */
  | 'CONDA'
  /** Package manager: go. */
  | 'GO'
  /** Package manager: gradle. */
  | 'GRADLE'
  /** Package manager: maven. */
  | 'MAVEN'
  /** Package manager: npm. */
  | 'NPM'
  /** Package manager: nuget. */
  | 'NUGET'
  /** Package manager: pip. */
  | 'PIP'
  /** Package manager: pipenv. */
  | 'PIPENV'
  /** Package manager: pnpm. */
  | 'PNPM'
  /** Package manager: poetry. */
  | 'POETRY'
  /** Package manager: pub. */
  | 'PUB'
  /** Package manager: sbt. */
  | 'SBT'
  /** Package manager: setuptools. */
  | 'SETUPTOOLS'
  /** Package manager: yarn. */
  | 'YARN';

/** Represents metadata associated with a Package */
export type PackageMetadata = ComposerMetadata | ConanMetadata | MavenMetadata | NugetMetadata | PypiMetadata | TerraformModuleMetadata;

export type PackagePermissions = {
  __typename?: 'PackagePermissions';
  /** If `true`, the user can perform `destroy_package` on this resource */
  destroyPackage: Scalars['Boolean']['output'];
};

/** Namespace-level Package Registry settings */
export type PackageSettings = {
  __typename?: 'PackageSettings';
  /** Indicates whether audit events are created when publishing or deleting a package in the namespace (Premium and Ultimate only). */
  auditEventsEnabled: Scalars['Boolean']['output'];
  /** When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  genericDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Indicates whether duplicate generic packages are allowed for the namespace. */
  genericDuplicatesAllowed: Scalars['Boolean']['output'];
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding: Scalars['Boolean']['output'];
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding: Scalars['Boolean']['output'];
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding: Scalars['Boolean']['output'];
  /** When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  mavenDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Indicates whether duplicate Maven packages are allowed for the namespace. */
  mavenDuplicatesAllowed: Scalars['Boolean']['output'];
  /** Indicates whether Maven package forwarding is allowed for the namespace. */
  mavenPackageRequestsForwarding?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether Maven package forwarding settings are locked by a parent namespace. */
  mavenPackageRequestsForwardingLocked: Scalars['Boolean']['output'];
  /** Indicates whether npm package forwarding is allowed for the namespace. */
  npmPackageRequestsForwarding?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether npm package forwarding settings are locked by a parent namespace. */
  npmPackageRequestsForwardingLocked: Scalars['Boolean']['output'];
  /** When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect.  */
  nugetDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Indicates whether duplicate NuGet packages are allowed for the namespace. */
  nugetDuplicatesAllowed: Scalars['Boolean']['output'];
  /** Indicates whether the NuGet symbol server is enabled for the namespace. */
  nugetSymbolServerEnabled: Scalars['Boolean']['output'];
  /** Indicates whether PyPI package forwarding is allowed for the namespace. */
  pypiPackageRequestsForwarding?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether PyPI package forwarding settings are locked by a parent namespace. */
  pypiPackageRequestsForwardingLocked: Scalars['Boolean']['output'];
  /** When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  terraformModuleDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']['output']>;
  /** Indicates whether duplicate Terraform packages are allowed for the namespace. */
  terraformModuleDuplicatesAllowed: Scalars['Boolean']['output'];
};

/** Values for sorting package */
export type PackageSort =
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC'
  /** Ordered by type in ascending order. */
  | 'TYPE_ASC'
  /** Ordered by type in descending order. */
  | 'TYPE_DESC'
  /** Ordered by version in ascending order. */
  | 'VERSION_ASC'
  /** Ordered by version in descending order. */
  | 'VERSION_DESC';

export type PackageStatus =
  /** Packages with a default status */
  | 'DEFAULT'
  /** Packages with a deprecated status */
  | 'DEPRECATED'
  /** Packages with a error status */
  | 'ERROR'
  /** Packages with a hidden status */
  | 'HIDDEN'
  /** Packages with a pending_destruction status */
  | 'PENDING_DESTRUCTION'
  /** Packages with a processing status */
  | 'PROCESSING';

/** Represents a package tag */
export type PackageTag = {
  __typename?: 'PackageTag';
  /** Created date. */
  createdAt: Scalars['Time']['output'];
  /** ID of the tag. */
  id: Scalars['ID']['output'];
  /** Name of the tag. */
  name: Scalars['String']['output'];
  /** Updated date. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for PackageTag. */
export type PackageTagConnection = {
  __typename?: 'PackageTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageTagEdge = {
  __typename?: 'PackageTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageTag>;
};

export type PackageTypeEnum =
  /** Packages from the Cargo package manager */
  | 'CARGO'
  /** Packages from the Composer package manager */
  | 'COMPOSER'
  /** Packages from the Conan package manager */
  | 'CONAN'
  /** Packages from the Debian package manager */
  | 'DEBIAN'
  /** Packages from the Generic package manager */
  | 'GENERIC'
  /** Packages from the Golang package manager */
  | 'GOLANG'
  /** Packages from the Helm package manager */
  | 'HELM'
  /** Packages from the Maven package manager */
  | 'MAVEN'
  /** Packages from the Ml_model package manager */
  | 'ML_MODEL'
  /** Packages from the npm package manager */
  | 'NPM'
  /** Packages from the Nuget package manager */
  | 'NUGET'
  /** Packages from the PyPI package manager */
  | 'PYPI'
  /** Packages from the Rpm package manager */
  | 'RPM'
  /** Packages from the Rubygems package manager */
  | 'RUBYGEMS'
  /** Packages from the Terraform Module package manager */
  | 'TERRAFORM_MODULE';

export type PackagesCleanupKeepDuplicatedPackageFilesEnum =
  /** Value to keep all package files */
  | 'ALL_PACKAGE_FILES'
  /** Value to keep 50 package files */
  | 'FIFTY_PACKAGE_FILES'
  /** Value to keep 40 package files */
  | 'FORTY_PACKAGE_FILES'
  /** Value to keep 1 package files */
  | 'ONE_PACKAGE_FILE'
  /** Value to keep 10 package files */
  | 'TEN_PACKAGE_FILES'
  /** Value to keep 30 package files */
  | 'THIRTY_PACKAGE_FILES'
  /** Value to keep 20 package files */
  | 'TWENTY_PACKAGE_FILES';

/** A packages cleanup policy designed to keep only packages and packages assets that matter most */
export type PackagesCleanupPolicy = {
  __typename?: 'PackagesCleanupPolicy';
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum;
  /** Next time that the packages cleanup policy will be executed. */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
};

/** Represents the Geo replication and verification state of a packages_nuget_symbol */
export type PackagesNugetSymbolRegistry = {
  __typename?: 'PackagesNugetSymbolRegistry';
  /** Indicate if the checksums of the PackagesNugetSymbolRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the PackagesNugetSymbolRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PackagesNugetSymbolRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the PackagesNugetSymbolRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the PackagesNugetSymbolRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the PackagesNugetSymbolRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PackagesNugetSymbolRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the Packages::Nuget::Symbol. */
  packagesNugetSymbolId: Scalars['ID']['output'];
  /** Timestamp after which the PackagesNugetSymbolRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the PackagesNugetSymbolRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the PackagesNugetSymbolRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the PackagesNugetSymbolRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the PackagesNugetSymbolRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the PackagesNugetSymbolRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the PackagesNugetSymbolRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the PackagesNugetSymbolRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of PackagesNugetSymbolRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the PackagesNugetSymbolRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the PackagesNugetSymbolRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for PackagesNugetSymbolRegistry. */
export type PackagesNugetSymbolRegistryConnection = {
  __typename?: 'PackagesNugetSymbolRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagesNugetSymbolRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackagesNugetSymbolRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PackagesNugetSymbolRegistry. */
export type PackagesNugetSymbolRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PackagesNugetSymbolRegistryEdge = {
  __typename?: 'PackagesNugetSymbolRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagesNugetSymbolRegistry>;
};

/** A packages protection rule designed to protect packages from being pushed by users with a certain access level. */
export type PackagesProtectionRule = {
  __typename?: 'PackagesProtectionRule';
  /** Global ID of the package protection rule. */
  id: Scalars['PackagesProtectionRuleID']['output'];
  /**
   * Minimum GitLab access required to delete packages from the package registry. Valid values include `OWNER` or `ADMIN`. If the value is `nil`, the default minimum access level is `MAINTAINER`. Available only when feature flag `packages_protected_packages_delete` is enabled. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  minimumAccessLevelForDelete?: Maybe<PackagesProtectionRuleAccessLevelForDelete>;
  /** Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: Maybe<PackagesProtectionRuleAccessLevel>;
  /** Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed. */
  packageNamePattern: Scalars['String']['output'];
  /** Package type protected by the protection rule. For example, `NPM`, `PYPI`. */
  packageType: PackagesProtectionRulePackageType;
};

/** Access level of a package protection rule resource */
export type PackagesProtectionRuleAccessLevel =
  /** Admin access. */
  | 'ADMIN'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Owner access. */
  | 'OWNER';

/** Access level for the deletion of a package protection rule resource. */
export type PackagesProtectionRuleAccessLevelForDelete =
  /** Admin access. Available only when feature flag `packages_protected_packages_delete` is enabled. */
  | 'ADMIN'
  /** Owner access. Available only when feature flag `packages_protected_packages_delete` is enabled. */
  | 'OWNER';

/** The connection type for PackagesProtectionRule. */
export type PackagesProtectionRuleConnection = {
  __typename?: 'PackagesProtectionRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagesProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackagesProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackagesProtectionRuleEdge = {
  __typename?: 'PackagesProtectionRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagesProtectionRule>;
};

/** Package type of a package protection rule resource */
export type PackagesProtectionRulePackageType =
  /** Packages of the Conan format. */
  | 'CONAN'
  /** Packages of the Generic format. */
  | 'GENERIC'
  /** Packages of the Helm format. */
  | 'HELM'
  /** Packages of the Maven format. */
  | 'MAVEN'
  /** Packages of the npm format. */
  | 'NPM'
  /** Packages of the NuGet format. */
  | 'NUGET'
  /** Packages of the PyPI format. */
  | 'PYPI';

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** Represents a pages deployment. */
export type PagesDeployment = {
  __typename?: 'PagesDeployment';
  /** Whether the deployment is currently active. */
  active: Scalars['Boolean']['output'];
  /** ID of the CI build that created the deployment. */
  ciBuildId?: Maybe<Scalars['ID']['output']>;
  /** Time the deployment was created. */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Time the deployment was deleted. */
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Time the deployment will expire. */
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Number of files that were published with the deployment. */
  fileCount?: Maybe<Scalars['Int']['output']>;
  /** ID of the Pages Deployment. */
  id: Scalars['ID']['output'];
  /** URL path Prefix that points to the deployment. */
  pathPrefix?: Maybe<Scalars['String']['output']>;
  /** Project the deployment belongs to. */
  project: Project;
  /** Path within the build assets that functions as the root directory for Pages sites. */
  rootDirectory?: Maybe<Scalars['String']['output']>;
  /** Size of the storage used. */
  size?: Maybe<Scalars['Int']['output']>;
  /** Time the deployment was last updated. */
  updatedAt: Scalars['ISO8601DateTime']['output'];
  /** Publicly accessible URL of the deployment. */
  url: Scalars['String']['output'];
};

/** The connection type for PagesDeployment. */
export type PagesDeploymentConnection = {
  __typename?: 'PagesDeploymentConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PagesDeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PagesDeployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PagesDeployment. */
export type PagesDeploymentConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PagesDeploymentEdge = {
  __typename?: 'PagesDeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PagesDeployment>;
};

/** Represents the Geo replication and verification state of a pages_deployment */
export type PagesDeploymentRegistry = {
  __typename?: 'PagesDeploymentRegistry';
  /** Indicate if the checksums of the PagesDeploymentRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the PagesDeploymentRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PagesDeploymentRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the PagesDeploymentRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the PagesDeploymentRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the PagesDeploymentRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PagesDeploymentRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the Pages Deployment. */
  pagesDeploymentId: Scalars['ID']['output'];
  /** Timestamp after which the PagesDeploymentRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the PagesDeploymentRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the PagesDeploymentRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the PagesDeploymentRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the PagesDeploymentRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the PagesDeploymentRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the PagesDeploymentRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the PagesDeploymentRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of PagesDeploymentRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the PagesDeploymentRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the PagesDeploymentRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for PagesDeploymentRegistry. */
export type PagesDeploymentRegistryConnection = {
  __typename?: 'PagesDeploymentRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PagesDeploymentRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PagesDeploymentRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PagesDeploymentRegistry. */
export type PagesDeploymentRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PagesDeploymentRegistryEdge = {
  __typename?: 'PagesDeploymentRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PagesDeploymentRegistry>;
};

/** Autogenerated input type of PagesMarkOnboardingComplete */
export type PagesMarkOnboardingCompleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of PagesMarkOnboardingComplete. */
export type PagesMarkOnboardingCompletePayload = {
  __typename?: 'PagesMarkOnboardingCompletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Indicates the new onboarding_complete state of the project's Pages metadata. */
  onboardingComplete: Scalars['Boolean']['output'];
};

/** Represents a file or directory in the project repository that has been locked. */
export type PathLock = {
  __typename?: 'PathLock';
  /** ID of the path lock. */
  id: Scalars['PathLockID']['output'];
  /** Locked path. */
  path?: Maybe<Scalars['String']['output']>;
  /** User that has locked the path. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: PathLockPermissions;
};

/** The connection type for PathLock. */
export type PathLockConnection = {
  __typename?: 'PathLockConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PathLockEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PathLock>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PathLockEdge = {
  __typename?: 'PathLockEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PathLock>;
};

export type PathLockPermissions = {
  __typename?: 'PathLockPermissions';
  /** If `true`, the user can perform `destroy_path_lock` on this resource */
  destroyPathLock: Scalars['Boolean']['output'];
};

/** Represents a Pending Group Membership */
export type PendingGroupMember = MemberInterface & PendingMemberInterface & {
  __typename?: 'PendingGroupMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Whether the pending member has been approved. */
  approved?: Maybe<Scalars['Boolean']['output']>;
  /** URL to avatar image file of the pending member. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Email address of the pending member. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Whether the pending member has been invited. */
  invited?: Maybe<Scalars['Boolean']['output']>;
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Name of the pending member. */
  name?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Username of the pending member. */
  username?: Maybe<Scalars['String']['output']>;
  /** Web URL of the pending member. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** Represents a Pending Group Membership */
export type PendingGroupMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

export type PendingMemberInterface = {
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Whether the pending member has been approved. */
  approved?: Maybe<Scalars['Boolean']['output']>;
  /** URL to avatar image file of the pending member. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Email address of the pending member. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Whether the pending member has been invited. */
  invited?: Maybe<Scalars['Boolean']['output']>;
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Name of the pending member. */
  name?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Username of the pending member. */
  username?: Maybe<Scalars['String']['output']>;
  /** Web URL of the pending member. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


export type PendingMemberInterfaceMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

/** The connection type for PendingMemberInterface. */
export type PendingMemberInterfaceConnection = {
  __typename?: 'PendingMemberInterfaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PendingMemberInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PendingMemberInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PendingMemberInterfaceEdge = {
  __typename?: 'PendingMemberInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PendingMemberInterface>;
};

/** Represents a Pending Project Membership */
export type PendingProjectMember = MemberInterface & PendingMemberInterface & {
  __typename?: 'PendingProjectMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Whether the pending member has been approved. */
  approved?: Maybe<Scalars['Boolean']['output']>;
  /** URL to avatar image file of the pending member. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Email address of the pending member. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Whether the pending member has been invited. */
  invited?: Maybe<Scalars['Boolean']['output']>;
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Name of the pending member. */
  name?: Maybe<Scalars['String']['output']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Username of the pending member. */
  username?: Maybe<Scalars['String']['output']>;
  /** Web URL of the pending member. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** Represents a Pending Project Membership */
export type PendingProjectMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

/** Type of resource that the permission can be applied to. */
export type PermissionBoundary =
  /** Group. */
  | 'GROUP'
  /** Instance. */
  | 'INSTANCE'
  /** Project. */
  | 'PROJECT'
  /** User. */
  | 'USER';

/** Personal access token. */
export type PersonalAccessToken = {
  __typename?: 'PersonalAccessToken';
  /** Whether the personal access token is active. */
  active: Scalars['Boolean']['output'];
  /** Timestamp of when the personal access token was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the personal access token. */
  description?: Maybe<Scalars['String']['output']>;
  /** Date of when the personal access token expires. */
  expiresAt?: Maybe<Scalars['Date']['output']>;
  /** Whether the personal access token is granular. */
  granular: Scalars['Boolean']['output'];
  /** ID of the personal access token. */
  id: Scalars['ID']['output'];
  /** Timestamp of when the personal access token was last used. */
  lastUsedAt?: Maybe<Scalars['Time']['output']>;
  /** IP addresses where the personal access token was recently used. */
  lastUsedIps: Array<Scalars['String']['output']>;
  /** Name of the personal access token. */
  name: Scalars['String']['output'];
  /** Whether the personal access token has been revoked. */
  revoked: Scalars['Boolean']['output'];
  /** List of scopes applied to a personal access token. */
  scopes: Array<PersonalAccessTokenScope>;
};

/** The connection type for PersonalAccessToken. */
export type PersonalAccessTokenConnection = {
  __typename?: 'PersonalAccessTokenConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PersonalAccessTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PersonalAccessToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PersonalAccessToken. */
export type PersonalAccessTokenConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of PersonalAccessTokenCreate */
export type PersonalAccessTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the token. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date of the token. */
  expiresAt?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** List of granular scopes to assign to the token. */
  granularScopes: Array<GranularScopeInput>;
  /** Name of the token. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of PersonalAccessTokenCreate. */
export type PersonalAccessTokenCreatePayload = {
  __typename?: 'PersonalAccessTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created personal access token. */
  token?: Maybe<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type PersonalAccessTokenEdge = {
  __typename?: 'PersonalAccessTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PersonalAccessToken>;
};

/** Autogenerated input type of PersonalAccessTokenRevoke */
export type PersonalAccessTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the personal access token that will be revoked. */
  id: Scalars['PersonalAccessTokenID']['input'];
};

/** Autogenerated return type of PersonalAccessTokenRevoke. */
export type PersonalAccessTokenRevokePayload = {
  __typename?: 'PersonalAccessTokenRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of PersonalAccessTokenRotate */
export type PersonalAccessTokenRotateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the personal access token that will be rotated. */
  id: Scalars['PersonalAccessTokenID']['input'];
};

/** Autogenerated return type of PersonalAccessTokenRotate. */
export type PersonalAccessTokenRotatePayload = {
  __typename?: 'PersonalAccessTokenRotatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created personal access token. */
  token?: Maybe<Scalars['String']['output']>;
};

/** Scope applied to a personal access token. */
export type PersonalAccessTokenScope = AccessTokenGranularScope | AccessTokenLegacyScope;

export type Pipeline = PipelineInterface & {
  __typename?: 'Pipeline';
  /** Indicates if the pipeline is active. */
  active: Scalars['Boolean']['output'];
  /** Base SHA of the source branch. */
  beforeSha?: Maybe<Scalars['String']['output']>;
  /** Specifies if a pipeline can be canceled. */
  cancelable: Scalars['Boolean']['output'];
  /** If the pipeline is a child or not. */
  child: Scalars['Boolean']['output'];
  /** Code Quality report summary for a pipeline. */
  codeQualityReportSummary?: Maybe<CodeQualityReportSummary>;
  /** Code Quality degradations reported on the pipeline. */
  codeQualityReports?: Maybe<CodeQualityDegradationConnection>;
  /** Git commit of the pipeline. */
  commit?: Maybe<Commit>;
  /** Path to the commit that triggered the pipeline. */
  commitPath?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the pipeline's commit. */
  committedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if a pipeline is complete. */
  complete: Scalars['Boolean']['output'];
  /** Total minutes consumed by the pipeline. */
  computeMinutes?: Maybe<Scalars['Float']['output']>;
  /** Configuration source of the pipeline (UNKNOWN_SOURCE, REPOSITORY_SOURCE, AUTO_DEVOPS_SOURCE, WEBIDE_SOURCE, REMOTE_SOURCE, EXTERNAL_PROJECT_SOURCE, BRIDGE_SOURCE, PARAMETER_SOURCE, COMPLIANCE_SOURCE, SECURITY_POLICIES_DEFAULT_SOURCE, PIPELINE_EXECUTION_POLICY_FORCED) */
  configSource?: Maybe<PipelineConfigSourceEnum>;
  /** Coverage percentage. */
  coverage?: Maybe<Scalars['Float']['output']>;
  /** Timestamp of the pipeline's creation. */
  createdAt: Scalars['Time']['output'];
  /** DAST profile associated with the pipeline. */
  dastProfile?: Maybe<DastProfile>;
  /** Detailed status of the pipeline. */
  detailedStatus: DetailedStatus;
  /** Pipelines the pipeline will trigger. */
  downstream?: Maybe<PipelineConnection>;
  /** Duration of the pipeline in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  /**
   * Partial scans present in the pipeline and its descendents for each report type Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  enabledPartialSecurityScans: EnabledSecurityScans;
  /**
   * Security scans present in the pipeline and its descendents for each report type Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  enabledSecurityScans: EnabledSecurityScans;
  /** Pipeline error messages. */
  errorMessages?: Maybe<PipelineMessageConnection>;
  /** Number of failed jobs in the pipeline, including trigger jobs and external jobs. */
  failedJobsCount: Scalars['Int']['output'];
  /** Reason why the pipeline failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the pipeline's completion. */
  finishedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the pipeline has manual actions. */
  hasManualActions: Scalars['Boolean']['output'];
  /** Indicates if the pipeline has scheduled actions. */
  hasScheduledActions: Scalars['Boolean']['output'];
  /** ID of the pipeline. */
  id: Scalars['ID']['output'];
  /** Internal ID of the pipeline. */
  iid: Scalars['String']['output'];
  /** Specific job in the pipeline, either by name or ID. */
  job?: Maybe<CiJob>;
  /** Job artifacts of the pipeline. */
  jobArtifacts?: Maybe<Array<CiJobArtifact>>;
  /** Jobs belonging to the pipeline. */
  jobs?: Maybe<CiJobConnection>;
  /** If the pipeline is the latest one or not. */
  latest: Scalars['Boolean']['output'];
  /** CI/CD variables added to a manual pipeline. */
  manualVariables?: Maybe<PipelineManualVariableConnection>;
  /** MR which the Pipeline is attached to. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Event type of the pipeline associated with a merge request. */
  mergeRequestEventType?: Maybe<PipelineMergeRequestEventType>;
  /** Name of the pipeline. */
  name?: Maybe<Scalars['String']['output']>;
  /** Relative path to the pipeline's page. */
  path?: Maybe<Scalars['String']['output']>;
  /** Project the pipeline belongs to. */
  project?: Maybe<Project>;
  /** How long the pipeline was queued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']['output']>;
  /** Reference to the branch from which the pipeline was triggered. */
  ref?: Maybe<Scalars['String']['output']>;
  /** Reference path to the branch from which the pipeline was triggered. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Reference text from the presenter. */
  refText: Scalars['String']['output'];
  /** Specifies if a pipeline's jobs can be retried. */
  retryable: Scalars['Boolean']['output'];
  /** Vulnerability finding reported on the pipeline. */
  securityReportFinding?: Maybe<PipelineSecurityReportFinding>;
  /** Vulnerability findings reported on the pipeline. By default all the states except dismissed are included in the response. */
  securityReportFindings?: Maybe<PipelineSecurityReportFindingConnection>;
  /** Vulnerability and scanned resource counts for each security scanner of the pipeline. */
  securityReportSummary?: Maybe<SecurityReportSummary>;
  /** SHA of the pipeline's commit. */
  sha?: Maybe<Scalars['String']['output']>;
  /** Source of the pipeline. */
  source?: Maybe<Scalars['String']['output']>;
  /** Job where pipeline was triggered from. */
  sourceJob?: Maybe<CiJob>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiStageConnection>;
  /** Timestamp when the pipeline was started. */
  startedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the pipeline (CREATED, WAITING_FOR_RESOURCE, PREPARING, WAITING_FOR_CALLBACK, PENDING, RUNNING, FAILED, SUCCESS, CANCELED, CANCELING, SKIPPED, MANUAL, SCHEDULED) */
  status: PipelineStatusEnum;
  /** If the pipeline is stuck. */
  stuck: Scalars['Boolean']['output'];
  /** Summary of the test report generated by the pipeline. */
  testReportSummary: TestReportSummary;
  /** A specific test suite in a pipeline test report. */
  testSuite?: Maybe<TestSuite>;
  /** Total number of jobs in the pipeline. */
  totalJobs: Scalars['Int']['output'];
  /** If the pipeline was created by a Trigger request. */
  trigger: Scalars['Boolean']['output'];
  /** Path that triggered the pipeline. */
  triggeredByPath?: Maybe<Scalars['String']['output']>;
  /** If the user can troubleshoot jobs of a pipeline. */
  troubleshootJobWithAi: Scalars['Boolean']['output'];
  /** Type of the pipeline. */
  type: Scalars['String']['output'];
  /** Timestamp of the pipeline's last activity. */
  updatedAt: Scalars['Time']['output'];
  /** Pipeline that triggered the pipeline. */
  upstream?: Maybe<Pipeline>;
  /** Pipeline user. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: PipelinePermissions;
  /** Indicates if the pipeline has jobs with `needs` dependencies. */
  usesNeeds?: Maybe<Scalars['Boolean']['output']>;
  /** Pipeline warning messages. */
  warningMessages?: Maybe<PipelineMessageConnection>;
  /** Indicates if a pipeline has warnings. */
  warnings: Scalars['Boolean']['output'];
  /** Pipeline YAML errors. */
  yamlErrorMessages?: Maybe<Scalars['String']['output']>;
  /** If the pipeline has YAML errors. */
  yamlErrors: Scalars['Boolean']['output'];
};


export type PipelineCodeQualityReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PipelineDownstreamArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PipelineErrorMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PipelineJobArgs = {
  id?: InputMaybe<Scalars['JobID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type PipelineJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jobKind?: InputMaybe<CiJobKind>;
  last?: InputMaybe<Scalars['Int']['input']>;
  retried?: InputMaybe<Scalars['Boolean']['input']>;
  securityReportTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
  whenExecuted?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type PipelineManualVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PipelineSecurityReportFindingArgs = {
  uuid: Scalars['String']['input'];
};


export type PipelineSecurityReportFindingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reportType?: InputMaybe<Array<Scalars['String']['input']>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  severity?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<PipelineSecurityReportFindingSort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type PipelineShaArgs = {
  format?: InputMaybe<ShaFormat>;
};


export type PipelineStagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PipelineTestSuiteArgs = {
  buildIds: Array<Scalars['ID']['input']>;
};


export type PipelineWarningMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PipelineAnalytics = {
  __typename?: 'PipelineAnalytics';
  /**
   * Pipeline analytics for the specified filter. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  aggregate?: Maybe<PipelineAnalyticsPeriod>;
  /** Labels for the monthly pipeline count. Only available for projects. */
  monthPipelinesLabels?: Maybe<Array<Scalars['String']['output']>>;
  /** Total monthly successful pipeline count. Only available for projects. */
  monthPipelinesSuccessful?: Maybe<Array<Scalars['Int']['output']>>;
  /** Total monthly pipeline count. Only available for projects. */
  monthPipelinesTotals?: Maybe<Array<Scalars['Int']['output']>>;
  /** Pipeline times labels. Only available for projects. */
  pipelineTimesLabels?: Maybe<Array<Scalars['String']['output']>>;
  /** Pipeline times. Only available for projects. */
  pipelineTimesValues?: Maybe<Array<Scalars['Int']['output']>>;
  /**
   * Pipeline analytics shown over time based on the specified filter. Data is aggregated in UTC, with adaptive resolution: hourly for 7-day windows or less, daily for longer periods. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  timeSeries?: Maybe<Array<PipelineAnalyticsPeriod>>;
  /** Labels for the weekly pipeline count. Only available for projects. */
  weekPipelinesLabels?: Maybe<Array<Scalars['String']['output']>>;
  /** Total weekly successful pipeline count. Only available for projects. */
  weekPipelinesSuccessful?: Maybe<Array<Scalars['Int']['output']>>;
  /** Total weekly pipeline count. Only available for projects. */
  weekPipelinesTotals?: Maybe<Array<Scalars['Int']['output']>>;
  /** Labels for the yearly pipeline count. Only available for projects. */
  yearPipelinesLabels?: Maybe<Array<Scalars['String']['output']>>;
  /** Total yearly successful pipeline count. Only available for projects. */
  yearPipelinesSuccessful?: Maybe<Array<Scalars['Int']['output']>>;
  /** Total yearly pipeline count. Only available for projects. */
  yearPipelinesTotals?: Maybe<Array<Scalars['Int']['output']>>;
};


export type PipelineAnalyticsTimeSeriesArgs = {
  period: AnalyticsAggregationPeriod;
};

export type PipelineAnalyticsJobStatus =
  /** Jobs with any status. */
  | 'ANY'
  /** Job that failed. */
  | 'FAILED'
  /** Job that was canceled or skipped. */
  | 'OTHER'
  /** Job that succeeded. */
  | 'SUCCESS';

export type PipelineAnalyticsPeriod = {
  __typename?: 'PipelineAnalyticsPeriod';
  /**
   * Pipeline count, optionally filtered by status. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  count?: Maybe<Scalars['BigInt']['output']>;
  /**
   * Pipeline duration statistics. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  durationStatistics?: Maybe<CiDurationStatistics>;
  /**
   * Data point label (UTC time). Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  label?: Maybe<Scalars['Date']['output']>;
};


export type PipelineAnalyticsPeriodCountArgs = {
  status?: PipelineAnalyticsJobStatus;
};

/** Represents the Geo sync and verification state of a pipeline artifact */
export type PipelineArtifactRegistry = {
  __typename?: 'PipelineArtifactRegistry';
  /** Indicate if the checksums of the PipelineArtifactRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the PipelineArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PipelineArtifactRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the PipelineArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the PipelineArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the PipelineArtifactRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the PipelineArtifactRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the pipeline artifact. */
  pipelineArtifactId: Scalars['ID']['output'];
  /** Timestamp after which the PipelineArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the PipelineArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the PipelineArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the PipelineArtifactRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the PipelineArtifactRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the PipelineArtifactRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the PipelineArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the PipelineArtifactRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of PipelineArtifactRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the PipelineArtifactRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the PipelineArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for PipelineArtifactRegistry. */
export type PipelineArtifactRegistryConnection = {
  __typename?: 'PipelineArtifactRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PipelineArtifactRegistry. */
export type PipelineArtifactRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PipelineArtifactRegistryEdge = {
  __typename?: 'PipelineArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineArtifactRegistry>;
};

/** Autogenerated input type of PipelineCancel */
export type PipelineCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID']['input'];
};

/** Autogenerated return type of PipelineCancel. */
export type PipelineCancelPayload = {
  __typename?: 'PipelineCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Pipeline after mutation. */
  pipeline?: Maybe<Pipeline>;
};

export type PipelineConfigSourceEnum =
  /** Auto DevOps source. */
  | 'AUTO_DEVOPS_SOURCE'
  /** Bridge source. */
  | 'BRIDGE_SOURCE'
  /** Compliance source. */
  | 'COMPLIANCE_SOURCE'
  /** External project source. */
  | 'EXTERNAL_PROJECT_SOURCE'
  /** Parameter source. */
  | 'PARAMETER_SOURCE'
  /** Pipeline execution policy forced. */
  | 'PIPELINE_EXECUTION_POLICY_FORCED'
  /** Remote source. */
  | 'REMOTE_SOURCE'
  /** Repository source. */
  | 'REPOSITORY_SOURCE'
  /** Security policies default source. */
  | 'SECURITY_POLICIES_DEFAULT_SOURCE'
  /** Unknown source. */
  | 'UNKNOWN_SOURCE'
  /** Webide source. */
  | 'WEBIDE_SOURCE';

/** The connection type for Pipeline. */
export type PipelineConnection = {
  __typename?: 'PipelineConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Pipeline>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Pipeline. */
export type PipelineConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents pipeline counts for the project */
export type PipelineCounts = {
  __typename?: 'PipelineCounts';
  /** Total number of pipelines for the project. */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of pipelines with scope FINISHED for the project */
  finished?: Maybe<Scalars['Int']['output']>;
  /** Number of pipelines with scope PENDING for the project */
  pending?: Maybe<Scalars['Int']['output']>;
  /** Number of pipelines with scope RUNNING for the project */
  running?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of PipelineCreate */
export type PipelineCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project that is triggering the pipeline. */
  projectPath: Scalars['ID']['input'];
  /** Ref on which to run the pipeline. */
  ref: Scalars['String']['input'];
  /** Variables for the pipeline. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of PipelineCreate. */
export type PipelineCreatePayload = {
  __typename?: 'PipelineCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Pipeline created after mutation. Null if `async: true`. */
  pipeline?: Maybe<Pipeline>;
  /**
   * ID for checking the pipeline creation status. Null if `async: false`. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  requestId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of PipelineDestroy */
export type PipelineDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID']['input'];
};

/** Autogenerated return type of PipelineDestroy. */
export type PipelineDestroyPayload = {
  __typename?: 'PipelineDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type PipelineEdge = {
  __typename?: 'PipelineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Pipeline>;
};

/** Represents the pipeline execution policy */
export type PipelineExecutionPolicy = OrchestrationPolicy & {
  __typename?: 'PipelineExecutionPolicy';
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Path to the policy file in the project. */
  policyBlobFilePath: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Warnings associated with the policy. */
  warnings: Array<Scalars['String']['output']>;
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** Represents policy fields related to the pipeline execution policy. */
export type PipelineExecutionPolicyAttributesType = {
  __typename?: 'PipelineExecutionPolicyAttributesType';
  /** Path to the policy file in the project. */
  policyBlobFilePath: Scalars['String']['output'];
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Warnings associated with the policy. */
  warnings: Array<Scalars['String']['output']>;
};

/** The connection type for PipelineExecutionPolicy. */
export type PipelineExecutionPolicyConnection = {
  __typename?: 'PipelineExecutionPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineExecutionPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineExecutionPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineExecutionPolicyEdge = {
  __typename?: 'PipelineExecutionPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineExecutionPolicy>;
};

/** Represents the pipeline execution schedule policy */
export type PipelineExecutionSchedulePolicy = OrchestrationPolicy & {
  __typename?: 'PipelineExecutionSchedulePolicy';
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Path to the policy file in the project. */
  policyBlobFilePath: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Warnings associated with the policy. */
  warnings: Array<Scalars['String']['output']>;
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** The connection type for PipelineExecutionSchedulePolicy. */
export type PipelineExecutionSchedulePolicyConnection = {
  __typename?: 'PipelineExecutionSchedulePolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineExecutionSchedulePolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineExecutionSchedulePolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineExecutionSchedulePolicyEdge = {
  __typename?: 'PipelineExecutionSchedulePolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineExecutionSchedulePolicy>;
};

/** Represents policy fields related to the pipeline execution scheduled policy. */
export type PipelineExecutionScheduledPolicyAttributesType = {
  __typename?: 'PipelineExecutionScheduledPolicyAttributesType';
  /** Path to the policy file in the project. */
  policyBlobFilePath: Scalars['String']['output'];
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Warnings associated with the policy. */
  warnings: Array<Scalars['String']['output']>;
};

export type PipelineInterface = {
  /** ID of the pipeline. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Internal ID of the pipeline. */
  iid?: Maybe<Scalars['String']['output']>;
  /** Relative path to the pipeline's page. */
  path?: Maybe<Scalars['String']['output']>;
  /** Project the pipeline belongs to. */
  project?: Maybe<ProjectInterface>;
  /** Pipeline user. */
  user?: Maybe<UserCore>;
};

/** CI/CD variables added to a manual pipeline. */
export type PipelineManualVariable = {
  __typename?: 'PipelineManualVariable';
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
};

/** The connection type for PipelineManualVariable. */
export type PipelineManualVariableConnection = {
  __typename?: 'PipelineManualVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineManualVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineManualVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineManualVariableEdge = {
  __typename?: 'PipelineManualVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineManualVariable>;
};

/** Event type of the pipeline associated with a merge request */
export type PipelineMergeRequestEventType =
  /** Pipeline run on the changes in the merge request source branch. */
  | 'DETACHED'
  /** Pipeline run on the changes from the source branch combined with the target branch. */
  | 'MERGED_RESULT'
  /** Pipeline ran as part of a merge train. */
  | 'MERGE_TRAIN';

export type PipelineMessage = {
  __typename?: 'PipelineMessage';
  /** Content of the pipeline message. */
  content: Scalars['String']['output'];
  /** ID of the pipeline message. */
  id: Scalars['ID']['output'];
};

/** The connection type for PipelineMessage. */
export type PipelineMessageConnection = {
  __typename?: 'PipelineMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineMessageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineMessage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineMessageEdge = {
  __typename?: 'PipelineMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineMessage>;
};

export type PipelineMinimalAccess = PipelineInterface & {
  __typename?: 'PipelineMinimalAccess';
  /** ID of the pipeline. */
  id: Scalars['ID']['output'];
  /** Internal ID of the pipeline. */
  iid?: Maybe<Scalars['String']['output']>;
  /** Relative path to the pipeline's page. */
  path?: Maybe<Scalars['String']['output']>;
  /** Project the pipeline belongs to. */
  project?: Maybe<ProjectInterface>;
  /** Pipeline user. */
  user?: Maybe<UserCore>;
};

export type PipelinePermissions = {
  __typename?: 'PipelinePermissions';
  /** If `true`, the user can perform `admin_pipeline` on this resource */
  adminPipeline: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `cancel_pipeline` on this resource */
  cancelPipeline: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_pipeline` on this resource */
  destroyPipeline: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_pipeline` on this resource */
  updatePipeline: Scalars['Boolean']['output'];
};

/** Autogenerated input type of PipelineRetry */
export type PipelineRetryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID']['input'];
};

/** Autogenerated return type of PipelineRetry. */
export type PipelineRetryPayload = {
  __typename?: 'PipelineRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Pipeline after mutation. */
  pipeline?: Maybe<Pipeline>;
};

/** Represents a pipeline schedule */
export type PipelineSchedule = {
  __typename?: 'PipelineSchedule';
  /** Indicates if the pipeline schedule is active. */
  active: Scalars['Boolean']['output'];
  /** Timestamp of when the pipeline schedule was created. */
  createdAt: Scalars['Time']['output'];
  /** Cron notation for the schedule. */
  cron: Scalars['String']['output'];
  /** Timezone for the pipeline schedule. */
  cronTimezone: Scalars['String']['output'];
  /** Description of the pipeline schedule. */
  description?: Maybe<Scalars['String']['output']>;
  /** Edit path of the pipeline schedule. */
  editPath?: Maybe<Scalars['String']['output']>;
  /** Indicates if a pipelines schedule belongs to a tag. */
  forTag: Scalars['Boolean']['output'];
  /** ID of the pipeline schedule. */
  id: Scalars['ID']['output'];
  /**
   * Inputs configured for the pipeline schedule. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  inputs?: Maybe<CiInputsFieldConnection>;
  /** Last pipeline object. */
  lastPipeline?: Maybe<Pipeline>;
  /** Time when the next pipeline will run. */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
  /** Owner of the pipeline schedule. */
  owner?: Maybe<UserCore>;
  /** Project of the pipeline schedule. */
  project?: Maybe<Project>;
  /** Time when the next pipeline will run. */
  realNextRun?: Maybe<Scalars['Time']['output']>;
  /** Ref of the pipeline schedule. */
  ref?: Maybe<Scalars['String']['output']>;
  /** Git ref for the pipeline schedule. */
  refForDisplay?: Maybe<Scalars['String']['output']>;
  /** Path to the ref that triggered the pipeline. */
  refPath?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the pipeline schedule was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: PipelineSchedulePermissions;
  /** Pipeline schedule variables. */
  variables?: Maybe<PipelineScheduleVariableConnection>;
};


/** Represents a pipeline schedule */
export type PipelineScheduleInputsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a pipeline schedule */
export type PipelineScheduleVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PipelineSchedule. */
export type PipelineScheduleConnection = {
  __typename?: 'PipelineScheduleConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PipelineSchedule. */
export type PipelineScheduleConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of PipelineScheduleCreate */
export type PipelineScheduleCreateInput = {
  /** Indicates if the pipeline schedule should be active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Cron expression of the pipeline schedule. */
  cron: Scalars['String']['input'];
  /**
   *                     Cron time zone supported by `ActiveSupport::TimeZone`.
   *                     For example: `Pacific Time (US & Canada)` (default: `UTC`).
   *
   */
  cronTimezone?: InputMaybe<Scalars['String']['input']>;
  /** Description of the pipeline schedule. */
  description: Scalars['String']['input'];
  /** Full path of the project the pipeline schedule is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Ref of the pipeline schedule. */
  ref: Scalars['String']['input'];
  /** Variables for the pipeline schedule. */
  variables?: InputMaybe<Array<PipelineScheduleVariableInput>>;
};

/** Autogenerated return type of PipelineScheduleCreate. */
export type PipelineScheduleCreatePayload = {
  __typename?: 'PipelineScheduleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created pipeline schedule. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

/** Autogenerated input type of PipelineScheduleDelete */
export type PipelineScheduleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID']['input'];
};

/** Autogenerated return type of PipelineScheduleDelete. */
export type PipelineScheduleDeletePayload = {
  __typename?: 'PipelineScheduleDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type PipelineScheduleEdge = {
  __typename?: 'PipelineScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSchedule>;
};

export type PipelineSchedulePermissions = {
  __typename?: 'PipelineSchedulePermissions';
  /** If `true`, the user can perform `admin_pipeline_schedule` on this resource */
  adminPipelineSchedule: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `play_pipeline_schedule` on this resource */
  playPipelineSchedule: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `take_ownership_pipeline_schedule` on this resource Deprecated in GitLab 15.9: Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule.
   * @deprecated Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule. Deprecated in GitLab 15.9.
   */
  takeOwnershipPipelineSchedule: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_pipeline_schedule` on this resource */
  updatePipelineSchedule: Scalars['Boolean']['output'];
};

/** Autogenerated input type of PipelineSchedulePlay */
export type PipelineSchedulePlayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID']['input'];
};

/** Autogenerated return type of PipelineSchedulePlay. */
export type PipelineSchedulePlayPayload = {
  __typename?: 'PipelineSchedulePlayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Pipeline schedule after mutation. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

/** Values for sorting pipeline schedules. */
export type PipelineScheduleSort =
  /** Sort pipeline schedules by created date in ascending order. */
  | 'CREATED_AT_ASC'
  /** Sort pipeline schedules by created date in descending order. */
  | 'CREATED_AT_DESC'
  /** Sort pipeline schedules by description in ascending order. */
  | 'DESCRIPTION_ASC'
  /** Sort pipeline schedules by description in descending order. */
  | 'DESCRIPTION_DESC'
  /** Sort pipeline schedules by ID in ascending order. */
  | 'ID_ASC'
  /** Sort pipeline schedules by ID in descending order. */
  | 'ID_DESC'
  /** Sort pipeline schedules by next run in ascending order. */
  | 'NEXT_RUN_AT_ASC'
  /** Sort pipeline schedules by next run in descending order. */
  | 'NEXT_RUN_AT_DESC'
  /** Sort pipeline schedules by target in ascending order. */
  | 'REF_ASC'
  /** Sort pipeline schedules by target in descending order. */
  | 'REF_DESC'
  /** Sort pipeline schedules by updated date in ascending order. */
  | 'UPDATED_AT_ASC'
  /** Sort pipeline schedules by updated date in descending order. */
  | 'UPDATED_AT_DESC';

export type PipelineScheduleStatus =
  /** Active pipeline schedules. */
  | 'ACTIVE'
  /** Inactive pipeline schedules. */
  | 'INACTIVE';

/** Autogenerated input type of PipelineScheduleTakeOwnership */
export type PipelineScheduleTakeOwnershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID']['input'];
};

/** Autogenerated return type of PipelineScheduleTakeOwnership. */
export type PipelineScheduleTakeOwnershipPayload = {
  __typename?: 'PipelineScheduleTakeOwnershipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated pipeline schedule ownership. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

/** Autogenerated input type of PipelineScheduleUpdate */
export type PipelineScheduleUpdateInput = {
  /** Indicates if the pipeline schedule should be active or not. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Cron expression of the pipeline schedule. */
  cron?: InputMaybe<Scalars['String']['input']>;
  /**
   *                     Cron time zone supported by `ActiveSupport::TimeZone`.
   *                     For example: `Pacific Time (US & Canada)` (default: `UTC`).
   *
   */
  cronTimezone?: InputMaybe<Scalars['String']['input']>;
  /** Description of the pipeline schedule. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID']['input'];
  /** Ref of the pipeline schedule. */
  ref?: InputMaybe<Scalars['String']['input']>;
  /** Variables for the pipeline schedule. */
  variables?: InputMaybe<Array<PipelineScheduleVariableInput>>;
};

/** Autogenerated return type of PipelineScheduleUpdate. */
export type PipelineScheduleUpdatePayload = {
  __typename?: 'PipelineScheduleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated pipeline schedule. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

export type PipelineScheduleVariable = CiVariable & {
  __typename?: 'PipelineScheduleVariable';
  /** ID of the variable. */
  id: Scalars['ID']['output'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']['output']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for PipelineScheduleVariable. */
export type PipelineScheduleVariableConnection = {
  __typename?: 'PipelineScheduleVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineScheduleVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineScheduleVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineScheduleVariableEdge = {
  __typename?: 'PipelineScheduleVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineScheduleVariable>;
};

/** Attributes for the pipeline schedule variable. */
export type PipelineScheduleVariableInput = {
  /** Boolean option to destroy the variable. */
  destroy?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the variable to mutate. */
  id?: InputMaybe<Scalars['CiPipelineScheduleVariableID']['input']>;
  /** Name of the variable. */
  key: Scalars['String']['input'];
  /** Value of the variable. */
  value: Scalars['String']['input'];
  /** Type of the variable. */
  variableType: CiVariableType;
};

export type PipelineScopeEnum =
  /** Branches. */
  | 'BRANCHES'
  /** Pipeline has completed. */
  | 'FINISHED'
  /** Pipeline has not started running yet. */
  | 'PENDING'
  /** Pipeline is running. */
  | 'RUNNING'
  /** Tags. */
  | 'TAGS';

/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFinding = {
  __typename?: 'PipelineSecurityReportFinding';
  /** Indicates whether the type of finding can be resolved with AI. */
  aiResolutionAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the specific finding can be resolved with AI. */
  aiResolutionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** List of assets associated with the vulnerability. */
  assets?: Maybe<Array<AssetType>>;
  /** Description of the vulnerability finding. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Details of the security finding. */
  details: Array<VulnerabilityDetail>;
  /** Reason for the dismissal of the security report finding. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** Time of the dismissal of the security report finding. */
  dismissedAt?: Maybe<Scalars['Time']['output']>;
  /** User who dismissed the security report finding. */
  dismissedBy?: Maybe<UserCore>;
  /** Evidence for the vulnerability. */
  evidence?: Maybe<VulnerabilityEvidence>;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']['output']>;
  /** Status of the secret token associated with this finding. */
  findingTokenStatus?: Maybe<VulnerabilityFindingTokenStatus>;
  /** Identifiers of the vulnerability finding. */
  identifiers: Array<VulnerabilityIdentifier>;
  /** List of issue links related to the vulnerability. */
  issueLinks?: Maybe<VulnerabilityIssueLinkConnection>;
  /** List of links associated with the vulnerability. */
  links?: Maybe<Array<VulnerabilityLink>>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Severity of the vulnerability finding before any overrides. */
  originalSeverity?: Maybe<VulnerabilitySeverity>;
  /** Project on which the vulnerability finding was found. */
  project?: Maybe<Project>;
  /** Remediations of the security report finding. */
  remediations?: Maybe<Array<VulnerabilityRemediationType>>;
  /** Type of the security report that found the vulnerability finding. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability finding. */
  severity?: Maybe<VulnerabilitySeverity>;
  /** List of severity changes for the vulnerability finding. */
  severityOverrides?: Maybe<SeverityOverrideConnection>;
  /** Solution for resolving the security report finding. */
  solution?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `solution` */
  solutionHtml?: Maybe<Scalars['String']['output']>;
  /** Finding status. */
  state?: Maybe<VulnerabilityState>;
  /** Comment for the state of the security report finding. */
  stateComment?: Maybe<Scalars['String']['output']>;
  /** Title of the vulnerability finding. */
  title?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the resource */
  userPermissions: PipelineSecurityReportFindingPermissions;
  /** UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier. */
  uuid?: Maybe<Scalars['String']['output']>;
  /** Vulnerability related to the security report finding. */
  vulnerability?: Maybe<Vulnerability>;
};


/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFindingIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFindingSeverityOverridesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PipelineSecurityReportFinding. */
export type PipelineSecurityReportFindingConnection = {
  __typename?: 'PipelineSecurityReportFindingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineSecurityReportFindingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSecurityReportFinding>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineSecurityReportFindingEdge = {
  __typename?: 'PipelineSecurityReportFindingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSecurityReportFinding>;
};

/** Check permissions for the current user on a vulnerability finding. */
export type PipelineSecurityReportFindingPermissions = {
  __typename?: 'PipelineSecurityReportFindingPermissions';
  /** If `true`, the user can perform `admin_vulnerability` on this resource */
  adminVulnerability: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_issue` on this resource */
  createIssue: Scalars['Boolean']['output'];
};

/** Pipeline security report finding sort values */
export type PipelineSecurityReportFindingSort =
  /** Severity in ascending order. */
  | 'severity_asc'
  /** Severity in descending order. */
  | 'severity_desc';

export type PipelineStatusEnum =
  /** Pipeline was canceled before completion. */
  | 'CANCELED'
  /** Pipeline is in the process of canceling. */
  | 'CANCELING'
  /** Pipeline has been created. */
  | 'CREATED'
  /** At least one stage of the pipeline failed. */
  | 'FAILED'
  /** Pipeline needs to be manually started. */
  | 'MANUAL'
  /** Pipeline has not started running yet. */
  | 'PENDING'
  /** Pipeline is preparing to run. */
  | 'PREPARING'
  /** Pipeline is running. */
  | 'RUNNING'
  /** Pipeline is scheduled to run. */
  | 'SCHEDULED'
  /** Pipeline was skipped. */
  | 'SKIPPED'
  /** Pipeline completed successfully. */
  | 'SUCCESS'
  /** Pipeline is waiting for an external action. */
  | 'WAITING_FOR_CALLBACK'
  /** A resource (for example, a runner) that the pipeline requires to run is unavailable. */
  | 'WAITING_FOR_RESOURCE';

export type PipelineTrigger = {
  __typename?: 'PipelineTrigger';
  /** Indicates if the pipeline trigger token has access to the project. */
  canAccessProject: Scalars['Boolean']['output'];
  /** Description of the pipeline trigger token. */
  description?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the pipeline trigger token expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the token is exposed. */
  hasTokenExposed: Scalars['Boolean']['output'];
  /** ID of the pipeline trigger token. */
  id: Scalars['ID']['output'];
  /** Timestamp of the last usage of the pipeline trigger token. */
  lastUsed?: Maybe<Scalars['Time']['output']>;
  /** Owner of the pipeline trigger token. */
  owner: UserCore;
  /** Value of the pipeline trigger token. */
  token: Scalars['String']['output'];
};

/** The connection type for PipelineTrigger. */
export type PipelineTriggerConnection = {
  __typename?: 'PipelineTriggerConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineTriggerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineTrigger>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for PipelineTrigger. */
export type PipelineTriggerConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of PipelineTriggerCreate */
export type PipelineTriggerCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the pipeline trigger token. */
  description: Scalars['String']['input'];
  /** Timestamp of when the pipeline trigger token expires. */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  /** Full path of the project that the pipeline trigger token to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineTriggerCreate. */
export type PipelineTriggerCreatePayload = {
  __typename?: 'PipelineTriggerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mutated pipeline trigger token. */
  pipelineTrigger?: Maybe<PipelineTrigger>;
};

/** Autogenerated input type of PipelineTriggerDelete */
export type PipelineTriggerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pipeline trigger token to delete. */
  id: Scalars['CiTriggerID']['input'];
};

/** Autogenerated return type of PipelineTriggerDelete. */
export type PipelineTriggerDeletePayload = {
  __typename?: 'PipelineTriggerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type PipelineTriggerEdge = {
  __typename?: 'PipelineTriggerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineTrigger>;
};

/** Autogenerated input type of PipelineTriggerUpdate */
export type PipelineTriggerUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the pipeline trigger token. */
  description: Scalars['String']['input'];
  /** ID of the pipeline trigger token to update. */
  id: Scalars['CiTriggerID']['input'];
};

/** Autogenerated return type of PipelineTriggerUpdate. */
export type PipelineTriggerUpdatePayload = {
  __typename?: 'PipelineTriggerUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mutated pipeline trigger token. */
  pipelineTrigger?: Maybe<PipelineTrigger>;
};

/** Pipeline variables minimum override roles. */
export type PipelineVariablesDefaultRoleType =
  /** Developer */
  | 'DEVELOPER'
  /** Maintainer */
  | 'MAINTAINER'
  /** No one allowed */
  | 'NO_ONE_ALLOWED'
  /** Owner */
  | 'OWNER';

/** Security policy state synchronization update. Returns `null` if the `security_policy_sync_propagation_tracking` feature flag is disabled. */
export type PoliciesSyncUpdated = {
  __typename?: 'PoliciesSyncUpdated';
  /** IDs of failed projects. */
  failedProjects?: Maybe<Array<Scalars['String']['output']>>;
  /** Whether security policies are currently being synchronized. */
  inProgress?: Maybe<Scalars['Boolean']['output']>;
  /** Percentage of merge requests synced. */
  mergeRequestsProgress?: Maybe<Scalars['Float']['output']>;
  /** Total number of merge requests synced. */
  mergeRequestsTotal?: Maybe<Scalars['Int']['output']>;
  /** Percentage of projects synced. */
  projectsProgress?: Maybe<Scalars['Float']['output']>;
  /** Total number of projects synced. */
  projectsTotal?: Maybe<Scalars['Int']['output']>;
};

/** Represents policy violation for `any_merge_request` report_type */
export type PolicyAnyMergeRequestViolation = {
  __typename?: 'PolicyAnyMergeRequestViolation';
  /** List of unsigned commits causing the violation. If policy targets any commits, it returns `true`. */
  commits?: Maybe<Scalars['JSON']['output']>;
  /** Represents the policy name. */
  name: Scalars['String']['output'];
};

export type PolicyApprovalGroup = {
  __typename?: 'PolicyApprovalGroup';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Full path of the namespace. */
  fullPath: Scalars['ID']['output'];
  /** ID of the namespace. */
  id: Scalars['ID']['output'];
  /** Web URL of the group. */
  webUrl: Scalars['String']['output'];
};

/** Represents the approval settings of merge request overridden by a policy. */
export type PolicyApprovalSettingsOverride = {
  __typename?: 'PolicyApprovalSettingsOverride';
  /**
   * Path to edit the policy. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  editPath?: Maybe<Scalars['String']['output']>;
  /**
   * Policy name. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  name?: Maybe<Scalars['String']['output']>;
  /** Overridden project approval settings. */
  settings: Scalars['JSON']['output'];
};

/** Multiple approvers action */
export type PolicyApproversType = {
  __typename?: 'PolicyApproversType';
  /** All potential approvers of the group type, including groups inaccessible to the user. */
  allGroups?: Maybe<Array<PolicyApprovalGroup>>;
  /** Approvers of the custom role type. Users belonging to these role(s) alone will be approvers. */
  customRoles?: Maybe<Array<MemberRole>>;
  /** Approvers of the role type. Users belonging to these role(s) alone will be approvers. */
  roles?: Maybe<Array<MemberAccessLevelName>>;
  /** Approvers of the user type. */
  users?: Maybe<Array<UserCore>>;
};

/** Represents specific policy types. Its fields depend on the policy type. */
export type PolicyAttributesUnion = ApprovalPolicyAttributesType | PipelineExecutionPolicyAttributesType | PipelineExecutionScheduledPolicyAttributesType | ScanExecutionPolicyAttributesType | VulnerabilityManagementPolicyAttributesType;

/** Represents bypass status of a merge request for a security policy */
export type PolicyBypassStatus = {
  __typename?: 'PolicyBypassStatus';
  /** Indicates if bypass is allowed for the policy. */
  allowBypass: Scalars['Boolean']['output'];
  /** Indicates if the policy has been bypassed. */
  bypassed: Scalars['Boolean']['output'];
  /** ID of the security policy. */
  id: Scalars['ID']['output'];
  /** Name of the security policy. */
  name: Scalars['String']['output'];
};

/** Represents the source and target pipelines used for comparison in the policy evaluation. */
export type PolicyComparisonPipeline = {
  __typename?: 'PolicyComparisonPipeline';
  /** Represents the report_type for which the pipeline IDs were evaluated. */
  reportType: ApprovalReportType;
  /** Represents the list of pipeline GIDs for the source branch. */
  source?: Maybe<Array<Scalars['CiPipelineID']['output']>>;
  /** Represents the list of pipeline GIDs for the target branch. */
  target?: Maybe<Array<Scalars['CiPipelineID']['output']>>;
};

/** Represents a policy dismissal for a security finding or license occurrence */
export type PolicyDismissal = {
  __typename?: 'PolicyDismissal';
  /** ID of the policy dismissal. */
  id: Scalars['ID']['output'];
  /** Security policy associated with the dismissal. */
  securityPolicy?: Maybe<SecurityPolicy>;
};

export type PolicyEnforcementType =
  /** Represents an enforced policy type. */
  | 'ENFORCE'
  /** Represents a warn mode policy type. */
  | 'WARN';

/** Represents an error that can occur during policy evaluation. */
export type PolicyError = {
  __typename?: 'PolicyError';
  /** Represents the error-specific data. */
  data?: Maybe<Scalars['JSON']['output']>;
  /** Represents error code. */
  error: PolicyViolationErrorType;
  /** Represents the error message. */
  message: Scalars['String']['output'];
  /** Represents the report type. */
  reportType: ApprovalReportType;
};

/** Represents policy violation for `license_scanning` report_type */
export type PolicyLicenseScanningViolation = {
  __typename?: 'PolicyLicenseScanningViolation';
  /** List of dependencies using the violated license. */
  dependencies: Array<Scalars['String']['output']>;
  /** License name. */
  license: Scalars['String']['output'];
  /** URL of the license. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Response of security policy creation. */
export type PolicyProjectCreated = {
  __typename?: 'PolicyProjectCreated';
  /**
   * Error messages in case status is :error. Deprecated in GitLab 17.5: Use errors instead.
   * @deprecated Use errors instead. Deprecated in GitLab 17.5.
   */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Error messages in case status is :error. */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Security Policy Project that was created. */
  project?: Maybe<Project>;
  /** Status of the creation of the security policy project. */
  status?: Maybe<PolicyProjectCreatedStatus>;
};

/** Types of security policy project created status. */
export type PolicyProjectCreatedStatus =
  /** Creating the security policy project faild. */
  | 'ERROR'
  /** Creating the security policy project was successful. */
  | 'SUCCESS';

/** Represents policy violation for `scan_finding` report_type */
export type PolicyScanFindingViolation = {
  __typename?: 'PolicyScanFindingViolation';
  /** Location of the finding determined by the scanner. */
  location?: Maybe<Scalars['JSON']['output']>;
  /** Represents the name of the finding. */
  name?: Maybe<Scalars['String']['output']>;
  /** Represents the URL path to the finding. */
  path?: Maybe<Scalars['String']['output']>;
  /** Represents the report type. */
  reportType: VulnerabilityReportType;
  /** Severity of the finding. */
  severity?: Maybe<VulnerabilitySeverity>;
};

export type PolicyScope = {
  __typename?: 'PolicyScope';
  /** Compliance Frameworks linked to the policy. */
  complianceFrameworks: ComplianceFrameworkConnection;
  /** Groups to which the policy should not be applied. */
  excludingGroups: GroupConnection;
  /** Boolean indicating whether personal projects are excluded from the policy. */
  excludingPersonalProjects: Scalars['Boolean']['output'];
  /** Projects to which the policy should not be applied. */
  excludingProjects: ProjectConnection;
  /** Groups to which the policy should be applied. */
  includingGroups: GroupConnection;
  /** Projects to which the policy should be applied. */
  includingProjects: ProjectConnection;
};


export type PolicyScopeComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PolicyScopeExcludingGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PolicyScopeExcludingProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PolicyScopeIncludingGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type PolicyScopeIncludingProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Lists the status of a virtual registry cleanup policy */
export type PolicyStatus =
  /** Cleanup policy status failed. */
  | 'FAILED'
  /** Cleanup policy status running. */
  | 'RUNNING'
  /** Cleanup policy status scheduled. */
  | 'SCHEDULED';

export type PolicyType =
  /** Approval policy. */
  | 'APPROVAL_POLICY'
  /** Pipeline execution policy. */
  | 'PIPELINE_EXECUTION_POLICY'
  /** Pipeline execution schedule policy. */
  | 'PIPELINE_EXECUTION_SCHEDULE_POLICY'
  /** Scan execution policy. */
  | 'SCAN_EXECUTION_POLICY'
  /** Vulnerability management policy. */
  | 'VULNERABILITY_MANAGEMENT_POLICY';

/** Represents the details of merge request approval policy violations. */
export type PolicyViolationDetails = {
  __typename?: 'PolicyViolationDetails';
  /** Represents the violations of `any_merge_request` rules. */
  anyMergeRequest: Array<PolicyAnyMergeRequestViolation>;
  /** Represents the pipelines used for comparison in the policy evaluation. */
  comparisonPipelines: Array<PolicyComparisonPipeline>;
  /** Represents the policy errors. */
  errors: Array<PolicyError>;
  /** Represents the violations of `license_scanning` rules. */
  licenseScanning: Array<PolicyLicenseScanningViolation>;
  /** Represents the newly detected violations of `scan_finding` rules. */
  newScanFinding: Array<PolicyScanFindingViolation>;
  /** Information about policies that were violated. */
  policies: Array<PolicyViolationInfo>;
  /** Represents the violations of `scan_finding` rules for previously existing vulnerabilities. */
  previousScanFinding: Array<PolicyScanFindingViolation>;
  /** Total count of violations. */
  violationsCount: Scalars['Int']['output'];
};

export type PolicyViolationErrorType =
  /** Represents error which occurs when pipeline is misconfigured and does not include necessary artifacts to evaluate a policy. */
  | 'ARTIFACTS_MISSING'
  /** Represents mismatch between the scans of the source and target pipelines. */
  | 'SCAN_REMOVED'
  /** Represents unknown error. */
  | 'UNKNOWN';

/** Represents generic policy violation information. */
export type PolicyViolationInfo = {
  __typename?: 'PolicyViolationInfo';
  /** Represents if a warn mode policy violation was dismissed. */
  dismissed: Scalars['Boolean']['output'];
  /** Represents the enforcement type of the violated policy. */
  enforcementType: PolicyEnforcementType;
  /** Represents the name of the violated policy. */
  name: Scalars['String']['output'];
  /** Represents the report type. */
  reportType: ApprovalReportType;
  /** Represents the violated security policy id. */
  securityPolicyId?: Maybe<Scalars['ID']['output']>;
  /** Represents the status of the violated policy. */
  status?: Maybe<PolicyViolationStatus>;
};

export type PolicyViolationStatus =
  /** Represents a failed policy violation. */
  | 'FAILED'
  /** Represents a running policy violation. */
  | 'RUNNING'
  /** Represents a policy violation warning. */
  | 'WARNING';

export type PolicyViolations =
  /** Dismissed in Merge request bypass reason. */
  | 'DISMISSED_IN_MR';

export type PreviewBillableUserChange = {
  __typename?: 'PreviewBillableUserChange';
  /** Total number of billable users after change. */
  newBillableUserCount?: Maybe<Scalars['Int']['output']>;
  /** Number of seats in subscription. */
  seatsInSubscription?: Maybe<Scalars['Int']['output']>;
  /**  If the group will have an increased overage after change. */
  willIncreaseOverage?: Maybe<Scalars['Boolean']['output']>;
};

/** Representation of who is provided access to. For eg: User/Role/MemberRole/Group. */
export type Principal = {
  __typename?: 'Principal';
  /** Group who is provided access to. */
  group?: Maybe<Group>;
  /** ID of the principal (User, MemberRole, Role, Group). */
  id: Scalars['ID']['output'];
  /** Name of the principal (User, MemberRole, Role, Group). */
  type: PrincipalType;
  /** User who is provided access to. */
  user?: Maybe<UserCore>;
  /** RoleID of the user. */
  userRoleId?: Maybe<Scalars['String']['output']>;
};

/** Representation of who is provided access to. For eg: User/Role/MemberRole/Group. */
export type PrincipalInput = {
  /** Full path of the group principal. Only used when type is GROUP. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the principal. Required unless group_path is provided for Group type. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Type of the principal. */
  type: PrincipalType;
};

/** Types of principal that can have secrets permissions */
export type PrincipalType =
  /** group. */
  | 'GROUP'
  /** member role. */
  | 'MEMBER_ROLE'
  /** predefined role. */
  | 'ROLE'
  /** user. */
  | 'USER';

/** Autogenerated input type of ProcessUserBillablePromotionRequest */
export type ProcessUserBillablePromotionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Status for the member approval request (approved, denied, pending). */
  status: MemberApprovalStatusType;
  /** Global ID of user to be promoted. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of ProcessUserBillablePromotionRequest. */
export type ProcessUserBillablePromotionRequestPayload = {
  __typename?: 'ProcessUserBillablePromotionRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Status of the user promotion process (success, partial_success, failed). */
  result?: Maybe<UserPromotionStatusType>;
};

/** Project-level settings for product analytics provider. */
export type ProductAnalyticsProjectSettings = {
  __typename?: 'ProductAnalyticsProjectSettings';
  /** Base URL for the Cube API. */
  cubeApiBaseUrl?: Maybe<Scalars['String']['output']>;
  /** API key for the Cube API. */
  cubeApiKey?: Maybe<Scalars['String']['output']>;
  /** Connection string for the product analytics configurator. */
  productAnalyticsConfiguratorConnectionString?: Maybe<Scalars['String']['output']>;
  /** Host for the product analytics data collector. */
  productAnalyticsDataCollectorHost?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ProductAnalyticsProjectSettingsUpdate */
export type ProductAnalyticsProjectSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Base URL for the Cube API. */
  cubeApiBaseUrl?: InputMaybe<Scalars['String']['input']>;
  /** API key for the Cube API. */
  cubeApiKey?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the settings belong to. */
  fullPath: Scalars['ID']['input'];
  /** Connection string for the product analytics configurator. */
  productAnalyticsConfiguratorConnectionString?: InputMaybe<Scalars['String']['input']>;
  /** Host for the product analytics data collector. */
  productAnalyticsDataCollectorHost?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProductAnalyticsProjectSettingsUpdate. */
export type ProductAnalyticsProjectSettingsUpdatePayload = {
  __typename?: 'ProductAnalyticsProjectSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Base URL for the Cube API. */
  cubeApiBaseUrl?: Maybe<Scalars['String']['output']>;
  /** API key for the Cube API. */
  cubeApiKey?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Connection string for the product analytics configurator. */
  productAnalyticsConfiguratorConnectionString?: Maybe<Scalars['String']['output']>;
  /** Host for the product analytics data collector. */
  productAnalyticsDataCollectorHost?: Maybe<Scalars['String']['output']>;
};

/** Current state of the product analytics stack. */
export type ProductAnalyticsState =
  /** Stack has been initialized and has data. */
  | 'COMPLETE'
  /** Stack has not been created yet. */
  | 'CREATE_INSTANCE'
  /** Stack is currently initializing. */
  | 'LOADING_INSTANCE'
  /** Stack is waiting for events from users. */
  | 'WAITING_FOR_EVENTS';

export type Project = ProjectInterface & Todoable & {
  __typename?: 'Project';
  /** Size limit for the repository in bytes. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']['output']>;
  /** Admin path for editing project. Only available to admins. */
  adminEditPath?: Maybe<Scalars['String']['output']>;
  /** Admin path of the project. Only available to admins. */
  adminShowPath?: Maybe<Scalars['String']['output']>;
  /** Agent configurations defined by the project */
  agentConfigurations?: Maybe<AgentConfigurationConnection>;
  /**
   * Find a specific AI Agent. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  aiAgent?: Maybe<AiAgent>;
  /**
   * Ai Agents for the project. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  aiAgents?: Maybe<AiAgentConnection>;
  /**
   * AI Catalog item of the project. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  aiCatalogItem?: Maybe<AiCatalogItem>;
  /**
   * AI Catalog items of the project. This field can be resolved for only one project in any single request. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  aiCatalogItems: AiCatalogItemConnection;
  /**
   * AI flow triggers of the project. This field can only be resolved for one project per request. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  aiFlowTriggers?: Maybe<AiFlowTriggerTypeConnection>;
  /**
   * AI-related metrics. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  aiMetrics?: Maybe<AiMetrics>;
  /**
   * AI-related metrics with three months of data retention. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  aiMetricsBasic?: Maybe<AiMetricsBasic>;
  /**
   * AI-related data. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  aiUsageData?: Maybe<AiUsageData>;
  /**
   * AI-related user metrics. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  aiUserMetrics?: Maybe<AiUserMetricsConnection>;
  /**
   * X-ray reports of the project. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  aiXrayReports: AiXrayReportConnection;
  /** A single Alert Management alert of the project. */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Counts of alerts by status for the project. */
  alertManagementAlertStatusCounts?: Maybe<AlertManagementAlertStatusCountsType>;
  /** Alert Management alerts of the project. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** HTTP Integrations which can receive alerts for the project. */
  alertManagementHttpIntegrations?: Maybe<AlertManagementHttpIntegrationConnection>;
  /**
   * Integrations which can receive alerts for the project. Deprecated in GitLab 18.2: Use `alertManagementHttpIntegrations`.
   * @deprecated Use `alertManagementHttpIntegrations`. Deprecated in GitLab 18.2.
   */
  alertManagementIntegrations?: Maybe<AlertManagementIntegrationConnection>;
  /** Extract alert fields from payload for custom mapping. */
  alertManagementPayloadFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /** If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge requests of the project can also be merged with skipped jobs. */
  allowMergeOnSkippedPipeline?: Maybe<Scalars['Boolean']['output']>;
  /** Project allows assigning multiple users to a merge request. */
  allowsMultipleMergeRequestAssignees: Scalars['Boolean']['output'];
  /** Project allows assigning multiple reviewers to a merge request. */
  allowsMultipleMergeRequestReviewers: Scalars['Boolean']['output'];
  /** Status for all analyzers in the project. */
  analyzerStatuses?: Maybe<Array<AnalyzerProjectStatusType>>;
  /** API fuzzing configuration for the project.  */
  apiFuzzingCiConfiguration?: Maybe<ApiFuzzingCiConfiguration>;
  /** Approval Policies of the project */
  approvalPolicies?: Maybe<ApprovalPolicyConnection>;
  /** Indicates if the project or any ancestor is archived. */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if issues referenced by merge requests and commits within the default branch are closed automatically. */
  autocloseReferencedIssues?: Maybe<Scalars['Boolean']['output']>;
  /** Search users for autocompletion */
  autocompleteUsers?: Maybe<Array<AutocompletedUser>>;
  /** List of available deploy keys */
  availableDeployKeys?: Maybe<AccessLevelDeployKeyConnection>;
  /** Avatar URL of the project. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** A single board of the project. */
  board?: Maybe<Board>;
  /** Boards of the project. */
  boards?: Maybe<BoardConnection>;
  /** Branch rules configured for the project. */
  branchRules?: Maybe<BranchRuleConnection>;
  /** Authorized cluster agents for the project through ci_access keyword. */
  ciAccessAuthorizedAgents?: Maybe<ClusterAgentAuthorizationCiAccessConnection>;
  /** CI/CD settings for the project. */
  ciCdSettings?: Maybe<ProjectCiCdSetting>;
  /** Path of the CI configuration file. */
  ciConfigPathOrDefault: Scalars['String']['output'];
  /**
   * CI/CD config variable. Introduced in GitLab 15.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.3.
   */
  ciConfigVariables?: Maybe<Array<CiConfigVariable>>;
  /**
   * Pipeline subscriptions where this project is the upstream project.When this project's pipeline completes, a pipeline is triggered in the downstream project. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciDownstreamProjectSubscriptions?: Maybe<CiProjectSubscriptionConnection>;
  /**
   * The CI Job Tokens authorization logs. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenAuthLogs?: Maybe<CiJobTokenAuthLogConnection>;
  /** The CI Job Tokens scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /**
   * List of CI job token scopes where the project is the source. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciJobTokenScopeAllowlist?: Maybe<CiJobTokenScopeAllowlist>;
  /**
   * Inputs to create a pipeline. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  ciPipelineCreationInputs?: Maybe<Array<CiInputsSpec>>;
  /**
   * Get information about an asynchronous pipeline creation request. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  ciPipelineCreationRequest?: Maybe<CiPipelineCreationRequest>;
  /**
   * Pipeline subscriptions for projects subscribed to the project. Deprecated in GitLab 17.6: Use `ciDownstreamProjectSubscriptions`.
   * @deprecated Use `ciDownstreamProjectSubscriptions`. Deprecated in GitLab 17.6.
   */
  ciSubscribedProjects?: Maybe<CiSubscriptionsProjectConnection>;
  /**
   * Pipeline subscriptions for the project. Deprecated in GitLab 17.6: Use `ciUpstreamProjectSubscriptions`.
   * @deprecated Use `ciUpstreamProjectSubscriptions`. Deprecated in GitLab 17.6.
   */
  ciSubscriptionsProjects?: Maybe<CiSubscriptionsProjectConnection>;
  /** Find a single CI/CD template by name. */
  ciTemplate?: Maybe<CiTemplate>;
  /**
   * Pipeline subscriptions where this project is the downstream project.When an upstream project's pipeline completes, a pipeline is triggered in the downstream project (this project). Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  ciUpstreamProjectSubscriptions?: Maybe<CiProjectSubscriptionConnection>;
  /** List of the project's CI/CD variables. */
  ciVariables?: Maybe<CiProjectVariableConnection>;
  /** Find a single cluster agent by name. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Cluster agents associated with the project. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Code coverage summary associated with the project. */
  codeCoverageSummary?: Maybe<CodeCoverageSummary>;
  /**
   * Get tag names containing a given commit. Introduced in GitLab 16.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.0.
   */
  commitReferences?: Maybe<CommitReferences>;
  /**
   * Compliance control statuses for a project. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  complianceControlStatus?: Maybe<ProjectComplianceControlStatusTypeConnection>;
  /** Compliance frameworks associated with the project. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /**
   * Compliance requirement statuses for a project. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  complianceRequirementStatuses?: Maybe<ProjectComplianceRequirementStatusConnection>;
  /** Compliance standards adherence for the project. */
  complianceStandardsAdherence?: Maybe<ComplianceStandardsAdherenceConnection>;
  /** Component(s) used by the project. */
  componentUsages?: Maybe<CiCatalogResourceComponentUsageConnection>;
  /**
   * Find software dependency versions by component name. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  componentVersions: ComponentVersionConnection;
  /**
   * Find software dependencies by name. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  components?: Maybe<Array<Component>>;
  /**
   * Container expiration policy of the project. Deprecated in GitLab 17.5: Use `container_tags_expiration_policy`.
   * @deprecated Use `container_tags_expiration_policy`. Deprecated in GitLab 17.5.
   */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /**
   * Container protection rules for the project. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  containerProtectionRepositoryRules?: Maybe<ContainerProtectionRepositoryRuleConnection>;
  /**
   * Container repository tag protection rules for the project. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  containerProtectionTagRules?: Maybe<ContainerProtectionTagRuleConnection>;
  /** Indicates if Container registry is enabled for the current user */
  containerRegistryEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Container repositories of the project. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the project. */
  containerRepositoriesCount: Scalars['Int']['output'];
  /** Indicates whether container scanning for registry is enabled or not for the project. Returns `null` if unauthorized. */
  containerScanningForRegistryEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Container tags expiration policy of the project. */
  containerTagsExpirationPolicy?: Maybe<ContainerTagsExpirationPolicy>;
  /** Find corpuses of the project. */
  corpuses?: Maybe<CoverageFuzzingCorpusConnection>;
  /** Timestamp of the project creation. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Visualizations of the project or associated configuration project. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  customizableDashboardVisualizations?: Maybe<CustomizableDashboardVisualizationConnection>;
  /**
   * Customizable dashboards for the project. Introduced in GitLab 15.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.6.
   */
  customizableDashboards?: Maybe<CustomizableDashboardConnection>;
  /** DAST Profile associated with the project. */
  dastProfile?: Maybe<DastProfile>;
  /** DAST Profiles associated with the project. */
  dastProfiles?: Maybe<DastProfileConnection>;
  /** DAST scanner profiles associated with the project. */
  dastScannerProfiles?: Maybe<DastScannerProfileConnection>;
  /** DAST Site Profile associated with the project. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** DAST Site Profiles associated with the project. */
  dastSiteProfiles?: Maybe<DastSiteProfileConnection>;
  /** DAST Site Validations associated with the project. */
  dastSiteValidations?: Maybe<DastSiteValidationConnection>;
  /** Data transfer data point for a specific period. This is mocked data under a development feature flag. */
  dataTransfer?: Maybe<ProjectDataTransfer>;
  /** Software dependencies used by the project. */
  dependencies?: Maybe<DependencyConnection>;
  /**
   * Ancestor dependency paths for a dependency used by the project. \
   *           Returns `null` if `dependency_graph_graphql` feature flag is disabled. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  dependencyPaths?: Maybe<DependencyPathPage>;
  /** Packages Dependency Proxy settings for the project. Requires the packages and dependency proxy to be enabled in the config. Requires the packages feature to be enabled at the project level.  */
  dependencyProxyPackagesSetting?: Maybe<DependencyProxyPackagesSetting>;
  /** Details of the deployment of the project. */
  deployment?: Maybe<Deployment>;
  /** Short description of the project. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Detailed import status of the project. */
  detailedImportStatus?: Maybe<DetailedImportStatus>;
  /** Project's DORA metrics. */
  dora?: Maybe<Dora>;
  /**
   * User access to Duo agentic Chat feature. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  duoAgenticChatAvailable?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Settings for excluding files from Duo context. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  duoContextExclusionSettings?: Maybe<DuoContextExclusionSettings>;
  /**
   * Indicates whether GitLab Duo features are enabled for the project. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  duoFeaturesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Checkpoints for GitLab Duo Agent Platform flows, for all users (remote flows only). */
  duoWorkflowEvents?: Maybe<DuoWorkflowEventConnection>;
  /**
   * Indicates whether Duo Agent Platform is enabled for the project. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  duoWorkflowStatusCheck?: Maybe<DuoWorkflowEnablement>;
  /** GitLab Duo Agent Platform flows for a project, for all users (remote flows only). */
  duoWorkflowWorkflows?: Maybe<DuoWorkflowConnection>;
  /** Path for editing project. */
  editPath: Scalars['String']['output'];
  /** A single environment of the project. */
  environment?: Maybe<Environment>;
  /** Environments of the project. This field can only be resolved for one project in any single request. */
  environments?: Maybe<EnvironmentConnection>;
  /**
   * Path to the project catalog resource. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  exploreCatalogPath?: Maybe<Scalars['String']['output']>;
  /**
   * Flow metrics for value stream analytics. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  flowMetrics?: Maybe<ProjectValueStreamAnalyticsFlowMetrics>;
  /**
   * Details of the fork project compared to its upstream project. Introduced in GitLab 15.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.7.
   */
  forkDetails?: Maybe<ForkDetails>;
  /** Namespaces in which the current user can fork the project into. */
  forkTargets?: Maybe<NamespaceConnection>;
  /** Project the project was forked from. */
  forkedFrom?: Maybe<Project>;
  /** Access level required for forking access. */
  forkingAccessLevel?: Maybe<ProjectFeatureAccess>;
  /** Number of times the project has been forked. */
  forksCount: Scalars['Int']['output'];
  /** Full path of the project. */
  fullPath: Scalars['ID']['output'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /**
   * Google Artifact Registry repository. Returns `null` if the GitLab instance is not a SaaS instance. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  googleCloudArtifactRegistryRepository?: Maybe<GoogleCloudArtifactRegistryRepository>;
  /**
   * Grafana integration details for the project. Deprecated in GitLab 18.3: Feature was removed in 16.0. Always returns null.
   * @deprecated Feature was removed in 16.0. Always returns null. Deprecated in GitLab 18.3.
   */
  grafanaIntegration?: Maybe<GrafanaIntegration>;
  /** Group of the project. */
  group?: Maybe<Group>;
  /** Indicates whether Jira issue creation from vulnerabilities is enabled. */
  hasJiraVulnerabilityIssueCreationEnabled: Scalars['Boolean']['output'];
  /** URL to connect to the project via HTTPS. */
  httpUrlToRepo?: Maybe<Scalars['String']['output']>;
  /** ID of the project. */
  id: Scalars['ID']['output'];
  /** Status of import background job of the project. */
  importStatus?: Maybe<Scalars['String']['output']>;
  /** Incident Management escalation policies of the project. */
  incidentManagementEscalationPolicies?: Maybe<EscalationPolicyTypeConnection>;
  /** Incident Management escalation policy of the project. */
  incidentManagementEscalationPolicy?: Maybe<EscalationPolicyType>;
  /** Incident Management On-call schedules of the project. */
  incidentManagementOncallSchedules?: Maybe<IncidentManagementOncallScheduleConnection>;
  /** Incident Management Timeline event associated with the incident. */
  incidentManagementTimelineEvent?: Maybe<TimelineEventType>;
  /** Timeline event tags for the project. */
  incidentManagementTimelineEventTags?: Maybe<Array<TimelineEventTagType>>;
  /** Incident Management Timeline events associated with the incident. */
  incidentManagementTimelineEvents?: Maybe<TimelineEventTypeConnection>;
  /** List of CI/CD variables the project inherited from its parent group and ancestors. */
  inheritedCiVariables?: Maybe<InheritedCiVariableConnection>;
  /**
   * Indicates if a project is a catalog resource. Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  isCatalogResource?: Maybe<Scalars['Boolean']['output']>;
  /** Project is forked. */
  isForked: Scalars['Boolean']['output'];
  /**
   * Indicates if a project's catalog resource is published. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isPublished?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if the project is archived. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isSelfArchived?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if project deletion is in progress. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  isSelfDeletionInProgress: Scalars['Boolean']['output'];
  /**
   * Indicates if project deletion is scheduled. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  isSelfDeletionScheduled: Scalars['Boolean']['output'];
  /** A single issue of the project. */
  issue?: Maybe<Issue>;
  /** Counts of issues by status for the project. */
  issueStatusCounts?: Maybe<IssueStatusCountsType>;
  /** Issues of the project. */
  issues?: Maybe<IssueConnection>;
  /** Access level required for issues access. */
  issuesAccessLevel?: Maybe<ProjectFeatureAccess>;
  /** Indicates if Issues are enabled for the current user */
  issuesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Status of Jira import background job of the project. */
  jiraImportStatus?: Maybe<Scalars['String']['output']>;
  /** Jira imports into the project. */
  jiraImports?: Maybe<JiraImportConnection>;
  /** One job belonging to the project, selected by ID. */
  job?: Maybe<CiJob>;
  /**
   * CI/CD job analytics for the project. Returns an error if ClickHouse is not configured. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  jobAnalytics?: Maybe<CiJobAnalyticsConnection>;
  /** Jobs of a project. This field can only be resolved for one project in any single request. */
  jobs?: Maybe<CiJobConnection>;
  /** Indicates if CI/CD pipeline jobs are enabled for the current user. */
  jobsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Label available on the project. */
  label?: Maybe<Label>;
  /** Labels available on this project. */
  labels?: Maybe<LabelConnection>;
  /** Programming languages used in the project. */
  languages?: Maybe<Array<RepositoryLanguage>>;
  /** Timestamp of the project last activity. */
  lastActivityAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the project has Large File Storage (LFS) enabled. */
  lfsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Indicates if the project or any ancestor is scheduled for deletion. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  markedForDeletion?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Date when project was scheduled to be deleted. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  markedForDeletionOn?: Maybe<Scalars['Time']['output']>;
  /** Maximum access level of the current user in the project. */
  maxAccessLevel: AccessLevel;
  /**
   * Member roles available for the group. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  memberRoles?: Maybe<MemberRoleConnection>;
  /** Template used to create merge commit message in merge requests. */
  mergeCommitTemplate?: Maybe<Scalars['String']['output']>;
  /** A single merge request of the project. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Regex used to validate the title of merge requests. */
  mergeRequestTitleRegex?: Maybe<Scalars['String']['output']>;
  /** Description of the regex used to validate the title of merge requests. */
  mergeRequestTitleRegexDescription?: Maybe<Scalars['String']['output']>;
  /** Compliance violations reported on merge requests merged within the project. */
  mergeRequestViolations?: Maybe<ComplianceViolationConnection>;
  /** Merge requests of the project. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Access level required for merge requests access. */
  mergeRequestsAccessLevel?: Maybe<ProjectFeatureAccess>;
  /** Indicates that committers of the given merge request cannot approve. */
  mergeRequestsDisableCommittersApproval: Scalars['Boolean']['output'];
  /** Indicates if Merge requests are enabled for the current user */
  mergeRequestsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if no merge commits should be created and all merges should instead be fast-forwarded, which means that merging is only allowed if the branch could be fast-forwarded. */
  mergeRequestsFfOnlyEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Merge trains available to the project. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  mergeTrains?: Maybe<MergeTrainConnection>;
  /** Milestones of the project. */
  milestones?: Maybe<MilestoneConnection>;
  /** Find machine learning experiments */
  mlExperiments?: Maybe<MlExperimentConnection>;
  /**
   * Finds machine learning models Introduced in GitLab 16.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.8.
   */
  mlModels?: Maybe<MlModelConnection>;
  /** Name of the project without the namespace. */
  name: Scalars['String']['output'];
  /** Name of the project including the namespace. */
  nameWithNamespace: Scalars['String']['output'];
  /** Namespace of the project. */
  namespace?: Maybe<Namespace>;
  /** Environments for this project with nested folders, can only be resolved for one project in any single request */
  nestedEnvironments?: Maybe<NestedEnvironmentConnection>;
  /**
   * Logs attached to the project. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  observabilityLogsLinks?: Maybe<ObservabilityLogConnection>;
  /**
   * Metrics attached to the project. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  observabilityMetricsLinks?: Maybe<ObservabilityMetricConnection>;
  /**
   * Traces attached to the project. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  observabilityTracesLinks?: Maybe<ObservabilityTraceConnection>;
  /** Indicates if merge requests of the project can only be merged when all the discussions are resolved. */
  onlyAllowMergeIfAllDiscussionsAreResolved?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates that merges of merge requests should be blocked unless all status checks have passed. */
  onlyAllowMergeIfAllStatusChecksPassed?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if merge requests of the project can only be merged with successful jobs. */
  onlyAllowMergeIfPipelineSucceeds?: Maybe<Scalars['Boolean']['output']>;
  /** Number of open issues for the project. */
  openIssuesCount?: Maybe<Scalars['Int']['output']>;
  /** Number of open merge requests for the project. */
  openMergeRequestsCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Path for editing project at the organization level. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  organizationEditPath?: Maybe<Scalars['String']['output']>;
  /** Packages of the project. */
  packages?: Maybe<PackageConnection>;
  /** Packages cleanup policy for the project. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
  /**
   * Packages protection rules for the project. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  packagesProtectionRules?: Maybe<PackagesProtectionRuleConnection>;
  /** List of the project's Pages Deployments. */
  pagesDeployments?: Maybe<PagesDeploymentConnection>;
  /** Project's Pages site redirects unsecured connections to HTTPS. */
  pagesForceHttps: Scalars['Boolean']['output'];
  /** Project's Pages site uses a unique subdomain. */
  pagesUseUniqueDomain: Scalars['Boolean']['output'];
  /** Path of the project. */
  path: Scalars['String']['output'];
  /** The project's path locks. */
  pathLocks?: Maybe<PathLockConnection>;
  /** Pending member promotions of the project. */
  pendingMemberApprovals?: Maybe<MemberApprovalConnection>;
  /**
   * For projects pending deletion, returns the project's scheduled deletion date. For projects not pending deletion, returns a theoretical date based on current settings if marked for deletion today. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  permanentDeletionDate?: Maybe<Scalars['String']['output']>;
  /** Pipeline of the project. If no arguments are provided, returns the latest pipeline for the head commit on the default branch */
  pipeline?: Maybe<Pipeline>;
  /** Pipeline analytics. */
  pipelineAnalytics?: Maybe<PipelineAnalytics>;
  /** Pipeline counts of the project. */
  pipelineCounts?: Maybe<PipelineCounts>;
  /** Pipeline Execution Policies of the project. */
  pipelineExecutionPolicies?: Maybe<PipelineExecutionPolicyConnection>;
  /** Pipeline Execution Schedule Policies of the namespace. */
  pipelineExecutionSchedulePolicies?: Maybe<PipelineExecutionSchedulePolicyConnection>;
  /** Pipeline schedules of the project. This field can only be resolved for one project per request. */
  pipelineSchedules?: Maybe<PipelineScheduleConnection>;
  /**
   * List of pipeline trigger tokens. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  pipelineTriggers?: Maybe<PipelineTriggerConnection>;
  /** Pipelines of the project. */
  pipelines?: Maybe<PipelineConnection>;
  /** Indicates whether Secret Push Protection is on or not for the project. */
  preReceiveSecretDetectionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if an associated issue from Jira is required. */
  preventMergeWithoutJiraIssueEnabled: Scalars['Boolean']['output'];
  /** Indicates if a link to create or view a merge request should display after a push to Git repositories of the project from the command line. */
  printingMergeRequestLinkEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Product Analytics instrumentation key assigned to the project. Introduced in GitLab 16.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.0.
   */
  productAnalyticsInstrumentationKey?: Maybe<Scalars['String']['output']>;
  /** Project-level settings for product analytics. */
  productAnalyticsSettings?: Maybe<ProductAnalyticsProjectSettings>;
  /**
   * Current state of the product analytics stack for this project.Can only be called for one project in a single request Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  productAnalyticsState?: Maybe<ProductAnalyticsState>;
  /** Members of the project. */
  projectMembers?: Maybe<MemberInterfaceConnection>;
  /**
   * Plan limits for the current project. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  projectPlanLimits?: Maybe<ProjectPlanLimits>;
  /**
   * List of unprotected branches, ignoring any wildcard branch rules. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  protectableBranches?: Maybe<Array<Scalars['String']['output']>>;
  /** Indicates if there is public access to pipelines and job details of the project, including output logs and artifacts. */
  publicJobs?: Maybe<Scalars['Boolean']['output']>;
  /** Project's push rules settings. */
  pushRules?: Maybe<PushRules>;
  /** List of recently visited boards of the project. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** A single release of the project. */
  release?: Maybe<Release>;
  /** Releases of the project. */
  releases?: Maybe<ReleaseConnection>;
  /** Indicates if `Delete source branch` option should be enabled by default for all new merge requests of the project. */
  removeSourceBranchAfterMerge?: Maybe<Scalars['Boolean']['output']>;
  /** Git repository of the project. */
  repository?: Maybe<Repository>;
  /** Size of repository that exceeds the limit in bytes. */
  repositorySizeExcess?: Maybe<Scalars['Float']['output']>;
  /** Indicates if users can request member access to the project. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Find a single requirement. */
  requirement?: Maybe<Requirement>;
  /** Number of requirements for the project by their state. */
  requirementStatesCount?: Maybe<RequirementStatesCount>;
  /** Find requirements. */
  requirements?: Maybe<RequirementConnection>;
  /** Top-level group of the project. */
  rootGroup?: Maybe<Group>;
  /**
   * Information used for provisioning the runner on a cloud provider. Returns `null` if the GitLab instance is not a SaaS instance. Introduced in GitLab 16.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.9.
   */
  runnerCloudProvisioning?: Maybe<CiRunnerCloudProvisioning>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** SAST CI configuration for the project. */
  sastCiConfiguration?: Maybe<SastCiConfiguration>;
  /** Saved replies available to the project. */
  savedReplies?: Maybe<ProjectSavedReplyConnection>;
  /** Saved reply in the project. */
  savedReply?: Maybe<ProjectSavedReply>;
  /** Scan Execution Policies of the project */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /**
   * Scan Result Policies of the project Deprecated in GitLab 16.9: Use `approvalPolicies`.
   * @deprecated Use `approvalPolicies`. Deprecated in GitLab 16.9.
   */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Indicates whether Secret Push Protection is on or not for the project. */
  secretPushProtectionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Security attributes linked to the project. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  securityAttributes?: Maybe<SecurityAttributeConnection>;
  /** Path to project's security dashboard. */
  securityDashboardPath?: Maybe<Scalars['String']['output']>;
  /**
   * A single security exclusion of a project. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  securityExclusion?: Maybe<ProjectSecurityExclusion>;
  /**
   * Security exclusions of the project. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  securityExclusions?: Maybe<ProjectSecurityExclusionConnection>;
  /**
   * Security metrics.This feature is currently under development and not yet available for general use. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  securityMetrics?: Maybe<SecurityMetrics>;
  /**
   * All security policies of the project. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  securityPolicies?: Maybe<SecurityPolicyTypeConnection>;
  /** Security policy project assigned to the project, absent if assigned to a parent group. */
  securityPolicyProject?: Maybe<Project>;
  /** Groups linked to the project, when used as Security Policy Project. */
  securityPolicyProjectLinkedGroups?: Maybe<GroupConnection>;
  /**
   * Namespaces linked to the project, when used as Security Policy Project. Deprecated in GitLab 17.4: This was renamed.
   * @deprecated This was renamed. Please use `security_policy_project_linked_groups`. Deprecated in GitLab 17.4.
   */
  securityPolicyProjectLinkedNamespaces?: Maybe<NamespaceConnection>;
  /** Projects linked to the project, when used as Security Policy Project. */
  securityPolicyProjectLinkedProjects?: Maybe<ProjectConnection>;
  /** Security policy project suggestions */
  securityPolicyProjectSuggestions?: Maybe<ProjectConnection>;
  /**
   * Security scan profiles attached to the project. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  securityScanProfiles?: Maybe<Array<ScanProfileType>>;
  /** Information about security analyzers used in the project. */
  securityScanners?: Maybe<SecurityScanners>;
  /** List of security training providers for the project */
  securityTrainingProviders?: Maybe<Array<ProjectSecurityTraining>>;
  /** Security training URLs for the enabled training providers of the project. */
  securityTrainingUrls?: Maybe<Array<SecurityTrainingUrl>>;
  /** Detailed version of a Sentry error on the project. */
  sentryDetailedError?: Maybe<SentryDetailedError>;
  /** Paginated collection of Sentry errors on the project. */
  sentryErrors?: Maybe<SentryErrorCollection>;
  /** E-mail address of the Service Desk. */
  serviceDeskAddress?: Maybe<Scalars['String']['output']>;
  /** Indicates if the project has Service Desk enabled. */
  serviceDeskEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Project services. */
  services?: Maybe<ServiceConnection>;
  /** Indicates if shared runners are enabled for the project. */
  sharedRunnersEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Snippets of the project. */
  snippets?: Maybe<SnippetConnection>;
  /** Indicates if Snippets are enabled for the current user */
  snippetsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Template used to create squash commit message in merge requests. */
  squashCommitTemplate?: Maybe<Scalars['String']['output']>;
  /** Indicates if `squashReadOnly` is enabled. */
  squashReadOnly: Scalars['Boolean']['output'];
  /** URL to connect to the project via SSH. */
  sshUrlToRepo?: Maybe<Scalars['String']['output']>;
  /** Number of times the project has been starred. */
  starCount: Scalars['Int']['output'];
  /** Statistics of the project. */
  statistics?: Maybe<ProjectStatistics>;
  /** Redirects for Statistics of the project. */
  statisticsDetailsPaths?: Maybe<ProjectStatisticsRedirect>;
  /** Commit message used to apply merge request suggestions. */
  suggestionCommitMessage?: Maybe<Scalars['String']['output']>;
  /**
   * List of project topics (not Git tags). Deprecated in GitLab 13.12: Use `topics`.
   * @deprecated Use `topics`. Deprecated in GitLab 13.12.
   */
  tagList?: Maybe<Scalars['String']['output']>;
  /** Target branch rules of the project. */
  targetBranchRules?: Maybe<ProjectTargetBranchRuleConnection>;
  /** Find a single Terraform state by name. */
  terraformState?: Maybe<TerraformState>;
  /** Terraform states associated with the project. */
  terraformStates?: Maybe<TerraformStateConnection>;
  /**
   * Timelog categories for the project. Introduced in GitLab 15.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the project. */
  timelogs?: Maybe<TimelogConnection>;
  /** List of project topics. */
  topics?: Maybe<Array<Scalars['String']['output']>>;
  /**
   * Tracking key assigned to the project. Introduced in GitLab 16.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.0.
   */
  trackingKey?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the project was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Authorized cluster agents for the project through user_access keyword. */
  userAccessAuthorizedAgents?: Maybe<ClusterAgentAuthorizationUserAccessConnection>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
  /** Information about Value Stream Analytics within the project. */
  valueStreamAnalytics?: Maybe<ValueStreamAnalytics>;
  /**
   * Aggregated usage counts within the project Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  valueStreamDashboardUsageOverview?: Maybe<ValueStreamDashboardCount>;
  /** Value streams available to the project. */
  valueStreams?: Maybe<ValueStreamConnection>;
  /** Visibility of the project. */
  visibility?: Maybe<Scalars['String']['output']>;
  /**
   * Visible forks of the project. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  visibleForks?: Maybe<ProjectConnection>;
  /** Vulnerabilities reported on the project. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the project. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /**
   * All vulnerability archives of the project. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  vulnerabilityArchives?: Maybe<Array<VulnerabilityArchive>>;
  /** Search for vulnerabilities by identifier. */
  vulnerabilityIdentifierSearch?: Maybe<Array<Scalars['String']['output']>>;
  /** Container images reported on the project vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /**
   * Vulnerability Management Policies of the project. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  vulnerabilityManagementPolicies?: Maybe<VulnerabilityManagementPolicyConnection>;
  /** Vulnerability scanners reported on the project vulnerabilities. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the project. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /** Counts for each vulnerability severity in the project. */
  vulnerabilityStatistic?: Maybe<VulnerabilityStatisticType>;
  /** Web path of the project. */
  webPath: Scalars['String']['output'];
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']['output']>;
  /**
   * A single project webhook. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  webhook?: Maybe<ProjectHook>;
  /** Indicates if Wikis are enabled for the current user */
  wikiEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Counts of work items by state for the project. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  workItemStateCounts?: Maybe<WorkItemStateCountsType>;
  /** Work item types available to the project. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
  /**
   * Work items of the project. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItems?: Maybe<WorkItemConnection>;
};


export type ProjectAgentConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectAiAgentArgs = {
  id: Scalars['AiAgentID']['input'];
};


export type ProjectAiAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectAiCatalogItemArgs = {
  id: Scalars['AiCatalogItemID']['input'];
  showSoftDeleted?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProjectAiCatalogItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  allAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<Array<AiCatalogItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectAiFlowTriggersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['AiFlowTriggerID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectAiMetricsArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type ProjectAiMetricsBasicArgs = {
  endDate?: InputMaybe<Scalars['Date']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type ProjectAiUserMetricsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<AiUserMetricsSort>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


export type ProjectAiXrayReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectAlertManagementAlertArgs = {
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  domain?: AlertManagementDomainFilter;
  iid?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type ProjectAlertManagementAlertStatusCountsArgs = {
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  iid?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type ProjectAlertManagementHttpIntegrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['AlertManagementHttpIntegrationID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<AlertManagementIntegrationType>>;
};


export type ProjectAlertManagementIntegrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['GlobalID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectAlertManagementPayloadFieldsArgs = {
  payloadExample: Scalars['String']['input'];
};


export type ProjectApprovalPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectAutocompleteUsersArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectAvailableDeployKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  titleQuery?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectBoardArgs = {
  id: Scalars['BoardID']['input'];
};


export type ProjectBoardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['BoardID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectBranchRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  buildMissing?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiAccessAuthorizedAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiConfigVariablesArgs = {
  failOnCacheMiss?: InputMaybe<Scalars['Boolean']['input']>;
  ref: Scalars['String']['input'];
};


export type ProjectCiDownstreamProjectSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiJobTokenAuthLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiPipelineCreationInputsArgs = {
  ref: Scalars['String']['input'];
};


export type ProjectCiPipelineCreationRequestArgs = {
  requestId: Scalars['String']['input'];
};


export type ProjectCiSubscribedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiSubscriptionsProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiTemplateArgs = {
  name: Scalars['String']['input'];
};


export type ProjectCiUpstreamProjectSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type ProjectClusterAgentArgs = {
  hasRemoteDevelopmentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  hasWorkspacesAgentConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


export type ProjectClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasRemoteDevelopmentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']['input']>;
  hasWorkspacesAgentConfig?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCommitReferencesArgs = {
  commitSha: Scalars['String']['input'];
};


export type ProjectComplianceControlStatusArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ProjectComplianceControlStatusInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ComplianceFrameworkSort>;
};


export type ProjectComplianceRequirementStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ProjectRequirementComplianceStatusInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectComplianceRequirementStatusOrderBy>;
};


export type ProjectComplianceStandardsAdherenceArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ComplianceStandardsProjectAdherenceInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectComponentUsagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectComponentVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentName: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectComponentsArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectContainerProtectionRepositoryRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectContainerProtectionTagRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectContainerRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ContainerRepositorySort>;
};


export type ProjectCorpusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectCustomizableDashboardVisualizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectCustomizableDashboardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<CustomizableDashboardCategory>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectDastProfileArgs = {
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['DastProfileID']['input'];
};


export type ProjectDastProfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectDastScannerProfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectDastSiteProfileArgs = {
  id: Scalars['DastSiteProfileID']['input'];
};


export type ProjectDastSiteProfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectDastSiteValidationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  normalizedTargetUrls?: InputMaybe<Array<Scalars['String']['input']>>;
  status?: InputMaybe<DastSiteValidationStatusEnum>;
};


export type ProjectDataTransferArgs = {
  from?: InputMaybe<Scalars['Date']['input']>;
  to?: InputMaybe<Scalars['Date']['input']>;
};


export type ProjectDependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentIds?: InputMaybe<Array<Scalars['SbomComponentID']['input']>>;
  componentNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  sort?: InputMaybe<DependencySort>;
  sourceTypes?: InputMaybe<Array<SbomSourceType>>;
};


export type ProjectDependencyPathsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  occurrence: Scalars['SbomOccurrenceID']['input'];
};


export type ProjectDeploymentArgs = {
  iid: Scalars['ID']['input'];
};


export type ProjectDuoWorkflowEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  workflowId: Scalars['AiDuoWorkflowsWorkflowID']['input'];
};


export type ProjectDuoWorkflowWorkflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<WorkflowEnvironment>;
  excludeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<DuoWorkflowsWorkflowSort>;
  statusGroup?: InputMaybe<DuoWorkflowStatusGroup>;
  type?: InputMaybe<Scalars['String']['input']>;
  workflowId?: InputMaybe<Scalars['AiDuoWorkflowsWorkflowID']['input']>;
};


export type ProjectEnvironmentArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectForkDetailsArgs = {
  ref?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectForkTargetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']['input']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  memberRoleId?: InputMaybe<Scalars['Int']['input']>;
  role: GitlabSubscriptionsUserRole;
};


export type ProjectIncidentManagementEscalationPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectIncidentManagementEscalationPolicyArgs = {
  id: Scalars['IncidentManagementEscalationPolicyID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectIncidentManagementOncallSchedulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectIncidentManagementTimelineEventArgs = {
  id: Scalars['IncidentManagementTimelineEventID']['input'];
  incidentId: Scalars['IssueID']['input'];
};


export type ProjectIncidentManagementTimelineEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  incidentId: Scalars['IssueID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectInheritedCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<CiGroupVariablesSort>;
};


export type ProjectIssueArgs = {
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  epicId?: InputMaybe<Scalars['String']['input']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIssueStatusCountsArgs = {
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  epicId?: InputMaybe<Scalars['String']['input']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  epicId?: InputMaybe<Scalars['String']['input']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIterationCadencesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  automatic?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  durationInWeeks?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectIterationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IterationSort>;
  state?: InputMaybe<IterationState>;
  timeframe?: InputMaybe<Timeframe>;
};


export type ProjectJiraImportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectJobArgs = {
  id: Scalars['JobID']['input'];
};


export type ProjectJobAnalyticsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fromTime?: InputMaybe<Scalars['Time']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nameSearch?: InputMaybe<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiJobAnalyticsSort>;
  source?: InputMaybe<CiPipelineSources>;
  toTime?: InputMaybe<Scalars['Time']['input']>;
};


export type ProjectJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind?: InputMaybe<CiJobKind>;
  last?: InputMaybe<Scalars['Int']['input']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
  withArtifacts?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProjectLabelArgs = {
  title: Scalars['String']['input'];
};


export type ProjectLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  searchIn?: Array<LabelSearchFieldList>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectMemberRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type ProjectMergeRequestArgs = {
  iid: Scalars['String']['input'];
};


export type ProjectMergeRequestViolationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<ComplianceViolationProjectInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ComplianceViolationSort>;
};


export type ProjectMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


export type ProjectMergeTrainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<MergeTrainStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type ProjectMilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  containingDate?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  searchTitle?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MilestoneSort>;
  state?: InputMaybe<MilestoneStateEnum>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectMlExperimentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<MlModelsOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type ProjectMlModelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<MlModelsOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type ProjectNestedEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectObservabilityLogsLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  fingerprint?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  severityNumber?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  traceIdentifier?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectObservabilityMetricsLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<OpenTelemetryMetricType>;
};


export type ProjectObservabilityTracesLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  traceIdentifier?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeVersionless?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageName?: InputMaybe<Scalars['String']['input']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  packageVersion?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<PackageSort>;
  status?: InputMaybe<PackageStatus>;
};


export type ProjectPackagesProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectPagesDeploymentsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Sort>;
  versioned?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProjectPathLocksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectPendingMemberApprovalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectPipelineArgs = {
  id?: InputMaybe<Scalars['CiPipelineID']['input']>;
  iid?: InputMaybe<Scalars['ID']['input']>;
  sha?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectPipelineAnalyticsArgs = {
  fromTime?: InputMaybe<Scalars['Time']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<CiPipelineSources>;
  toTime?: InputMaybe<Scalars['Time']['input']>;
};


export type ProjectPipelineCountsArgs = {
  ref?: InputMaybe<Scalars['String']['input']>;
  sha?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectPipelineExecutionPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectPipelineExecutionSchedulePoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectPipelineSchedulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<PipelineScheduleSort>;
  status?: InputMaybe<PipelineScheduleStatus>;
};


export type ProjectPipelineTriggersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectPipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectProjectMembersArgs = {
  accessLevels?: InputMaybe<Array<AccessLevelEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relations?: InputMaybe<Array<ProjectMemberRelation>>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MemberSort>;
};


export type ProjectRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectReleaseArgs = {
  tagName: Scalars['String']['input'];
};


export type ProjectReleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ReleaseSort>;
};


export type ProjectRequirementArgs = {
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  workItemIid?: InputMaybe<Scalars['ID']['input']>;
  workItemIids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type ProjectRequirementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  workItemIid?: InputMaybe<Scalars['ID']['input']>;
  workItemIids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type ProjectRunnerCloudProvisioningArgs = {
  cloudProjectId: Scalars['GoogleCloudProject']['input'];
  provider: CiRunnerCloudProvider;
};


export type ProjectRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  creatorId?: InputMaybe<Scalars['UserID']['input']>;
  creatorUsername?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  versionPrefix?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectSavedReplyArgs = {
  id: Scalars['ProjectsSavedReplyID']['input'];
};


export type ProjectScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectSecurityAttributesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectSecurityExclusionArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['SecurityProjectSecurityExclusionID']['input'];
  scanner?: InputMaybe<ExclusionScannerEnum>;
  type?: InputMaybe<ExclusionTypeEnum>;
};


export type ProjectSecurityExclusionsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  scanner?: InputMaybe<ExclusionScannerEnum>;
  type?: InputMaybe<ExclusionTypeEnum>;
};


export type ProjectSecurityMetricsArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
};


export type ProjectSecurityPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  type?: InputMaybe<PolicyType>;
};


export type ProjectSecurityPolicyProjectLinkedGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  topLevelOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProjectSecurityPolicyProjectLinkedNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectSecurityPolicyProjectLinkedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectSecurityPolicyProjectSuggestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyLinked?: InputMaybe<Scalars['Boolean']['input']>;
  search: Scalars['String']['input'];
};


export type ProjectSecurityTrainingProvidersArgs = {
  onlyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProjectSecurityTrainingUrlsArgs = {
  filename?: InputMaybe<Scalars['String']['input']>;
  identifierExternalIds: Array<Scalars['String']['input']>;
};


export type ProjectSentryDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID']['input'];
};


export type ProjectServicesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ServiceType>;
};


export type ProjectSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


export type ProjectTargetBranchRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectTerraformStateArgs = {
  name: Scalars['String']['input'];
};


export type ProjectTerraformStatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectUserAccessAuthorizedAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectValueStreamDashboardUsageOverviewArgs = {
  identifier: ValueStreamDashboardProjectLevelMetric;
  timeframe: Timeframe;
};


export type ProjectValueStreamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectVisibleForksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minimumAccessLevel?: InputMaybe<AccessLevelEnum>;
};


export type ProjectVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  identifierName?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type ProjectVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['ISO8601Date']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['ISO8601Date']['input'];
};


export type ProjectVulnerabilityIdentifierSearchArgs = {
  name: Scalars['String']['input'];
};


export type ProjectVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectVulnerabilityManagementPoliciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deduplicatePolicies?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnscoped?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ProjectVulnerabilitySeveritiesCountArgs = {
  capped?: InputMaybe<Scalars['Boolean']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type ProjectWebhookArgs = {
  id: Scalars['ProjectHookID']['input'];
};


export type ProjectWorkItemStateCountsArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectWorkItemTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<IssueType>;
};


export type ProjectWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  verificationStatusWidget?: InputMaybe<VerificationStatusFilterInput>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};

/** Values for the archived argument */
export type ProjectArchived =
  /** Exclude archived projects. */
  | 'EXCLUDE'
  /** Include archived projects. */
  | 'INCLUDE'
  /** Only archived projects. */
  | 'ONLY';

export type ProjectCiCdSetting = {
  __typename?: 'ProjectCiCdSetting';
  /** Indicates whether pipeline variables can be displayed in the UI. */
  displayPipelineVariables?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether group runners are enabled for the project. */
  groupRunnersEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether CI/CD job tokens generated in this project have restricted access to other projects. */
  jobTokenScopeEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the latest artifact should be kept for the project. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether merged results pipelines are enabled. */
  mergePipelinesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether merge trains are enabled. */
  mergeTrainsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether merge immediately is allowed for merge trains. */
  mergeTrainsSkipTrainAllowed: Scalars['Boolean']['output'];
  /** Minimum role required to set variables when creating a pipeline or running a job. */
  pipelineVariablesMinimumOverrideRole: Scalars['String']['output'];
  /** Project the CI/CD settings belong to. */
  project?: Maybe<Project>;
  /** Indicates the ability to push to the original project repository using a job token */
  pushRepositoryForJobTokenAllowed?: Maybe<Scalars['Boolean']['output']>;
  /** Default process mode for resource groups. */
  resourceGroupDefaultProcessMode?: Maybe<ResourceGroupsProcessMode>;
};

/** Autogenerated input type of ProjectCiCdSettingsUpdate */
export type ProjectCiCdSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether pipeline variables can be displayed in the UI. */
  displayPipelineVariables?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full Path of the project the settings belong to. */
  fullPath: Scalars['ID']['input'];
  /** Indicates whether group runners are enabled for the project. */
  groupRunnersEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether the latest artifact should be kept for the project. */
  keepLatestArtifact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if merged results pipelines are enabled for the project. */
  mergePipelinesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if merge trains are enabled for the project. */
  mergeTrainsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether an option is allowed to merge without refreshing the merge train. Ignored unless the `merge_trains_skip_train` feature flag is also enabled. */
  mergeTrainsSkipTrainAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Minimum role required to set variables when creating a pipeline or running a job. */
  pipelineVariablesMinimumOverrideRole?: InputMaybe<Scalars['String']['input']>;
  /** Indicates the ability to push to the original project repository using a job token */
  pushRepositoryForJobTokenAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Default process mode for resource groups in the project. */
  resourceGroupDefaultProcessMode?: InputMaybe<ResourceGroupsProcessMode>;
};

/** Autogenerated return type of ProjectCiCdSettingsUpdate. */
export type ProjectCiCdSettingsUpdatePayload = {
  __typename?: 'ProjectCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: ProjectCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Compliance status of the project control. */
export type ProjectComplianceControlStatus =
  /** Fail */
  | 'FAIL'
  /** Pass */
  | 'PASS'
  /** Pending */
  | 'PENDING';

export type ProjectComplianceControlStatusInput = {
  /** Compliance requirement id of the statuses. */
  complianceRequirementId?: InputMaybe<Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input']>;
};

/** Compliance control status for a project. */
export type ProjectComplianceControlStatusType = {
  __typename?: 'ProjectComplianceControlStatusType';
  /** Control of the compliance status. */
  complianceRequirementsControl: ComplianceRequirementsControl;
  /** Compliance control status ID. */
  id: Scalars['ID']['output'];
  /** Compliance status of the project for the control. */
  status: ProjectComplianceControlStatus;
  /** Timestamp when the control status was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for ProjectComplianceControlStatusType. */
export type ProjectComplianceControlStatusTypeConnection = {
  __typename?: 'ProjectComplianceControlStatusTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectComplianceControlStatusTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectComplianceControlStatusType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectComplianceControlStatusTypeEdge = {
  __typename?: 'ProjectComplianceControlStatusTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectComplianceControlStatusType>;
};

/** Compliance requirement status for a project. */
export type ProjectComplianceRequirementStatus = {
  __typename?: 'ProjectComplianceRequirementStatus';
  /** Framework of the compliance status. */
  complianceFramework: ComplianceFramework;
  /** Requirement of the compliance status. */
  complianceRequirement: ComplianceRequirement;
  /** Total no. of failed compliance controls for the requirement. */
  failCount: Scalars['Int']['output'];
  /** Compliance requirement status ID. */
  id: Scalars['ID']['output'];
  /** Total no. of passed compliance controls for the requirement. */
  passCount: Scalars['Int']['output'];
  /** Total no. of pending compliance controls for the requirement. */
  pendingCount: Scalars['Int']['output'];
  /** Project of the compliance status. */
  project: Project;
  /** Timestamp when the requirement status was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for ProjectComplianceRequirementStatus. */
export type ProjectComplianceRequirementStatusConnection = {
  __typename?: 'ProjectComplianceRequirementStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectComplianceRequirementStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectComplianceRequirementStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectComplianceRequirementStatusEdge = {
  __typename?: 'ProjectComplianceRequirementStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectComplianceRequirementStatus>;
};

/** Values for order_by field for project requirement statuses. */
export type ProjectComplianceRequirementStatusOrderBy =
  /** Order by frameworks. */
  | 'FRAMEWORK'
  /** Order by projects. */
  | 'PROJECT'
  /** Order by requirements. */
  | 'REQUIREMENT';

/** Compliance violation for a project. */
export type ProjectComplianceViolation = NoteableInterface & Todoable & {
  __typename?: 'ProjectComplianceViolation';
  /** Audit event related to the violation. */
  auditEvent: AuditEvent;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Compliance control of the violation. */
  complianceControl: ComplianceRequirementsControl;
  /** Timestamp when the violation was detected. */
  createdAt: Scalars['Time']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Compliance violation ID. */
  id: Scalars['ID']['output'];
  /** Project issues linked to the violation. */
  issues?: Maybe<IssueConnection>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Project of the compliance violation. */
  project: Project;
  /** Compliance violation status of the project. */
  status: ComplianceViolationStatus;
  /** URL of the object. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** Compliance violation for a project. */
export type ProjectComplianceViolationCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Compliance violation for a project. */
export type ProjectComplianceViolationDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Compliance violation for a project. */
export type ProjectComplianceViolationIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Compliance violation for a project. */
export type ProjectComplianceViolationNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProjectComplianceViolation. */
export type ProjectComplianceViolationConnection = {
  __typename?: 'ProjectComplianceViolationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectComplianceViolationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectComplianceViolation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectComplianceViolationEdge = {
  __typename?: 'ProjectComplianceViolationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectComplianceViolation>;
};

/** Filters for project compliance violations. */
export type ProjectComplianceViolationFilterInput = {
  /** Control ID for which to filter compliance violations. */
  controlId?: InputMaybe<Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementsControlID']['input']>;
  /** Compliance violations created on or after the date (inclusive). */
  createdAfter?: InputMaybe<Scalars['Date']['input']>;
  /** Compliance violations created on or before the date (inclusive). */
  createdBefore?: InputMaybe<Scalars['Date']['input']>;
  /** Project ID for which to filter compliance violations. */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  /** Status of the project compliance violation. */
  status?: InputMaybe<Array<ComplianceViolationStatus>>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Project. */
export type ProjectConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ProjectDataTransfer = {
  __typename?: 'ProjectDataTransfer';
  /** Data nodes. */
  egressNodes?: Maybe<EgressNodeConnection>;
  /** Total egress for that project in that period of time. */
  totalEgress?: Maybe<Scalars['BigInt']['output']>;
};


export type ProjectDataTransferEgressNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Represents the access level required by the user to access a project feature */
export type ProjectFeatureAccess = {
  __typename?: 'ProjectFeatureAccess';
  /** Integer representation of access level. */
  integerValue?: Maybe<Scalars['Int']['output']>;
  /** String representation of access level. */
  stringValue?: Maybe<ProjectFeatureAccessLevel>;
};

/** Access level of a project feature */
export type ProjectFeatureAccessLevel =
  /** Not enabled for anyone. */
  | 'DISABLED'
  /** Enabled for everyone able to access the project. */
  | 'ENABLED'
  /** Enabled only for team members. */
  | 'PRIVATE';

export type ProjectHook = {
  __typename?: 'ProjectHook';
  /** Auto-disabling status of the webhook. */
  alertStatus: WebhookAlertStatus;
  /** Strategy for filtering push events by branch name. */
  branchFilterStrategy: WebhookBranchFilterStrategy;
  /** Whether the webhook is triggered on confidential issues events. */
  confidentialIssuesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on confidential note events. */
  confidentialNoteEvents: Scalars['Boolean']['output'];
  /** Timestamp of when the webhook was created. */
  createdAt: Scalars['Time']['output'];
  /** List of custom header names for the webhook. */
  customHeaders?: Maybe<Array<WebhookCustomHeader>>;
  /** Custom payload template for the webhook request body. */
  customWebhookTemplate?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on deployment events. */
  deploymentEvents: Scalars['Boolean']['output'];
  /** Description of the webhook. */
  description?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the webhook will be automatically re-enabled if temporarily disabled. */
  disabledUntil?: Maybe<Scalars['Time']['output']>;
  /** Whether the webhook is triggered on emoji events. */
  emojiEvents: Scalars['Boolean']['output'];
  /** Whether SSL verification is done when triggering the webhook. */
  enableSslVerification?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the webhook is triggered on feature flag events. */
  featureFlagEvents: Scalars['Boolean']['output'];
  /** ID of the webhook. */
  id: Scalars['ProjectHookID']['output'];
  /** Whether the webhook is triggered on issues events. */
  issuesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on job events. */
  jobEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on merge request events. */
  mergeRequestsEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on milestone events. */
  milestoneEvents: Scalars['Boolean']['output'];
  /** Name of the webhook. */
  name?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on note events. */
  noteEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on pipeline events. */
  pipelineEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on push events. */
  pushEvents: Scalars['Boolean']['output'];
  /** Trigger hook on push events for matching branches only. */
  pushEventsBranchFilter?: Maybe<Scalars['String']['output']>;
  /** Whether the webhook is triggered on releases events. */
  releasesEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on resource access token events. */
  resourceAccessTokenEvents: Scalars['Boolean']['output'];
  /** Whether the webhook is triggered on tag push events. */
  tagPushEvents: Scalars['Boolean']['output'];
  /** URL of the webhook. */
  url: Scalars['String']['output'];
  /** List of URL variable masks to hide sensitive portions of the webhook URL. */
  urlVariables?: Maybe<Array<WebhookUrlVariable>>;
  /** Whether the webhook is triggered on vulnerability events. */
  vulnerabilityEvents: Scalars['Boolean']['output'];
  /** A single webhook event. */
  webhookEvent?: Maybe<WebhookEvent>;
  /** List of recent webhook events. This field can only be resolved for one webhook in any single request. */
  webhookEvents?: Maybe<WebhookEventConnection>;
  /** Whether the webhook is triggered on wiki page events. */
  wikiPageEvents: Scalars['Boolean']['output'];
};


export type ProjectHookWebhookEventArgs = {
  id: Scalars['WebHookLogID']['input'];
  timestampRange?: InputMaybe<TimestampRange>;
};


export type ProjectHookWebhookEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  timestampRange?: InputMaybe<TimestampRange>;
};

/** Autogenerated input type of ProjectInitializeProductAnalytics */
export type ProjectInitializeProductAnalyticsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to initialize. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectInitializeProductAnalytics. */
export type ProjectInitializeProductAnalyticsPayload = {
  __typename?: 'ProjectInitializeProductAnalyticsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project on which the initialization took place. */
  project?: Maybe<Project>;
};

export type ProjectInterface = {
  /** Avatar URL of the project. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Short description of the project. */
  description?: Maybe<Scalars['String']['output']>;
  /** Full path of the project. */
  fullPath?: Maybe<Scalars['ID']['output']>;
  /** ID of the project. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Name of the project without the namespace. */
  name?: Maybe<Scalars['String']['output']>;
  /** Name of the project including the namespace. */
  nameWithNamespace?: Maybe<Scalars['String']['output']>;
  /** Permissions for the current user on the project. */
  userPermissions?: Maybe<ProjectPermissions>;
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ProjectInterface. */
export type ProjectInterfaceConnection = {
  __typename?: 'ProjectInterfaceConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ProjectInterface. */
export type ProjectInterfaceConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProjectInterfaceEdge = {
  __typename?: 'ProjectInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectInterface>;
};

/** Represents a Project Membership */
export type ProjectMember = MemberInterface & {
  __typename?: 'ProjectMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the member. */
  id: Scalars['ID']['output'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Project that User is a member of. */
  project?: Maybe<Project>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
};


/** Represents a Project Membership */
export type ProjectMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID']['input'];
};

/** Autogenerated input type of ProjectMemberBulkUpdate */
export type ProjectMemberBulkUpdateInput = {
  /** Access level to update the members to. */
  accessLevel: MemberAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Date and time the membership expires. */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  /** Global ID of the project. */
  projectId: Scalars['ProjectID']['input'];
  /** Global IDs of the members. */
  userIds: Array<Scalars['UserID']['input']>;
};

/** Autogenerated return type of ProjectMemberBulkUpdate. */
export type ProjectMemberBulkUpdatePayload = {
  __typename?: 'ProjectMemberBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project members after mutation. */
  projectMembers?: Maybe<Array<ProjectMember>>;
  /** List of queued pending members approvals. */
  queuedMemberApprovals?: Maybe<MemberApprovalConnection>;
};


/** Autogenerated return type of ProjectMemberBulkUpdate. */
export type ProjectMemberBulkUpdatePayloadQueuedMemberApprovalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProjectMember. */
export type ProjectMemberConnection = {
  __typename?: 'ProjectMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectMemberEdge = {
  __typename?: 'ProjectMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectMember>;
};

/** Project member relation */
export type ProjectMemberRelation =
  /** Descendants members */
  | 'DESCENDANTS'
  /** Direct members */
  | 'DIRECT'
  /** Inherited members */
  | 'INHERITED'
  /** Invited Groups members */
  | 'INVITED_GROUPS'
  /** Shared Into Ancestors members */
  | 'SHARED_INTO_ANCESTORS';

export type ProjectMinimalAccess = ProjectInterface & {
  __typename?: 'ProjectMinimalAccess';
  /** Avatar URL of the project. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Short description of the project. */
  description?: Maybe<Scalars['String']['output']>;
  /** Full path of the project. */
  fullPath: Scalars['ID']['output'];
  /** ID of the project. */
  id: Scalars['ID']['output'];
  /** Name of the project without the namespace. */
  name: Scalars['String']['output'];
  /** Name of the project including the namespace. */
  nameWithNamespace: Scalars['String']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

export type ProjectNamespaceLinks = NamespacesLinkPaths & {
  __typename?: 'ProjectNamespaceLinks';
  /**
   * Path for autocomplete award emojis. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  autocompleteAwardEmojisPath?: Maybe<Scalars['String']['output']>;
  /**
   * Calendar path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  calendarPath?: Maybe<Scalars['String']['output']>;
  /** Namespace contribution guide path. */
  contributionGuidePath?: Maybe<Scalars['String']['output']>;
  /** Help page path for emails. */
  emailsHelpPagePath?: Maybe<Scalars['String']['output']>;
  /** Namespace epics_list. */
  epicsList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the epics list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  epicsListPath?: Maybe<Scalars['String']['output']>;
  /**
   * CSV export endpoint for work items. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  exportCsvPath?: Maybe<Scalars['String']['output']>;
  /** Namespace group_issues. */
  groupIssues?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the group. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues_list. */
  issuesList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the issues list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  issuesListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues settings path. */
  issuesSettings?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_fetch. */
  labelsFetch?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_manage. */
  labelsManage?: Maybe<Scalars['String']['output']>;
  /** Help page path for Markdown. */
  markdownHelpPath?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the namespace (project.namespace.full_path or group full_path). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  namespaceFullPath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_comment_template_paths. */
  newCommentTemplate?: Maybe<Array<CommentTemplatePath>>;
  /**
   * Path to create a new issue. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newIssuePath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_project. */
  newProject?: Maybe<Scalars['String']['output']>;
  /**
   * New trial path for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newTrialPath?: Maybe<Scalars['String']['output']>;
  /** Email address that can be used to create a new work item in this project. Returns null if incoming email is not configured. More details on how to configure incoming email is in this [documentation](https://docs.gitlab.com/administration/incoming_email/#set-it-up). */
  newWorkItemEmailAddress?: Maybe<Scalars['String']['output']>;
  /** JIRA import path. */
  projectImportJiraPath?: Maybe<Scalars['String']['output']>;
  /** Help page path for quick actions. */
  quickActionsHelpPath?: Maybe<Scalars['String']['output']>;
  /** Namespace register_path. */
  register?: Maybe<Scalars['String']['output']>;
  /** Project releases path. */
  releasesPath?: Maybe<Scalars['String']['output']>;
  /** Namespace report_abuse. */
  reportAbuse?: Maybe<Scalars['String']['output']>;
  /**
   * RSS path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rssPath?: Maybe<Scalars['String']['output']>;
  /** Namespace sign_in_path. */
  signIn?: Maybe<Scalars['String']['output']>;
  /**
   * User email for export CSV. Returns `null` for user namespaces. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  userExportEmail?: Maybe<Scalars['String']['output']>;
};

export type ProjectNamespaceMarkdownPaths = MarkdownPaths & {
  __typename?: 'ProjectNamespaceMarkdownPaths';
  /** Supported paths for autocomplete sources for a given namespace. */
  autocompleteSourcesPath?: Maybe<Scalars['JSON']['output']>;
  /** Path for the markdown preview for given namespace. */
  markdownPreviewPath?: Maybe<Scalars['String']['output']>;
  /** Uploads path for a given namespace. */
  uploadsPath?: Maybe<Scalars['String']['output']>;
};


export type ProjectNamespaceMarkdownPathsAutocompleteSourcesPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['String']['input']>;
};


export type ProjectNamespaceMarkdownPathsMarkdownPreviewPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
};

export type ProjectNamespaceMetadata = NamespaceMetadata & {
  __typename?: 'ProjectNamespaceMetadata';
  /**
   * Default branch of the project. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  defaultBranch?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the group. Returns null for user namespaces. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupId?: Maybe<Scalars['String']['output']>;
  /**
   * User preference for initial sort order. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  initialSort?: Maybe<Scalars['String']['output']>;
  /**
   * Whether issue repositioning is disabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isIssueRepositioningDisabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Maximum allowed attachment size (humanized). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  maxAttachmentSize?: Maybe<Scalars['String']['output']>;
  /**
   * Whether to show the new work item link. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  showNewWorkItem?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Time tracking limit to hours setting. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  timeTrackingLimitToHours?: Maybe<Scalars['Boolean']['output']>;
};

export type ProjectPermissions = {
  __typename?: 'ProjectPermissions';
  /**
   * If `true`, the user can perform `admin_ai_catalog_item` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  adminAiCatalogItem: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `admin_ai_catalog_item_consumer` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  adminAiCatalogItemConsumer: Scalars['Boolean']['output'];
  /** If `true`, the user is an instance administrator. */
  adminAllResources: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_operations` on this resource */
  adminOperations: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_path_locks` on this resource */
  adminPathLocks: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_project` on this resource */
  adminProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_remote_mirror` on this resource */
  adminRemoteMirror: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_wiki` on this resource */
  adminWiki: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_work_item_lifecycle` on this resource */
  adminWorkItemLifecycle: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `archive_project` on this resource */
  archiveProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `change_namespace` on this resource */
  changeNamespace: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `change_visibility_level` on this resource */
  changeVisibilityLevel: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_deployment` on this resource */
  createDeployment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_issue` on this resource */
  createIssue: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_label` on this resource */
  createLabel: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_merge_request_from` on this resource */
  createMergeRequestFrom: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_merge_request_in` on this resource */
  createMergeRequestIn: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_pages` on this resource */
  createPages: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_path_lock` on this resource */
  createPathLock: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_pipeline` on this resource */
  createPipeline: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_pipeline_schedule` on this resource */
  createPipelineSchedule: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_wiki` on this resource */
  createWiki: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_work_item` on this resource */
  createWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_pages` on this resource */
  destroyPages: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_wiki` on this resource */
  destroyWiki: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `download_code` on this resource */
  downloadCode: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `download_wiki_code` on this resource */
  downloadWikiCode: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `fork_project` on this resource */
  forkProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `generate_description` on this resource */
  generateDescription: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `import_issues` on this resource */
  importIssues: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `manage_ai_flow_triggers` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  manageAiFlowTriggers: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `move_design` on this resource */
  moveDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `push_code` on this resource */
  pushCode: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `push_to_delete_protected_branch` on this resource */
  pushToDeleteProtectedBranch: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `read_ai_catalog_item` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  readAiCatalogItem: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `read_ai_catalog_item_consumer` on this resource Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  readAiCatalogItemConsumer: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_commit_status` on this resource */
  readCommitStatus: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_crm_contact` on this resource */
  readCrmContact: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_crm_organization` on this resource */
  readCrmOrganization: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_cycle_analytics` on this resource */
  readCycleAnalytics: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_environment` on this resource */
  readEnvironment: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_pages_content` on this resource */
  readPagesContent: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_path_locks` on this resource */
  readPathLocks: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_project` on this resource */
  readProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_project_member` on this resource */
  readProjectMember: Scalars['Boolean']['output'];
  /**
   * If `true`, the user can perform `read_runner_cloud_provisioning_info` on this resource Introduced in GitLab 18.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.8.
   */
  readRunnerCloudProvisioningInfo: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_wiki` on this resource */
  readWiki: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_fork_project` on this resource */
  removeForkProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_pages` on this resource */
  removePages: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `remove_project` on this resource */
  removeProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `rename_project` on this resource */
  renameProject: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `request_access` on this resource */
  requestAccess: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_design` on this resource */
  updateDesign: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_pages` on this resource */
  updatePages: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_wiki` on this resource */
  updateWiki: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `upload_file` on this resource */
  uploadFile: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `view_edit_page` on this resource */
  viewEditPage: Scalars['Boolean']['output'];
};

/** Plan limits for the current project. */
export type ProjectPlanLimits = {
  __typename?: 'ProjectPlanLimits';
  /** Maximum number of pipeline schedules allowed per project. */
  ciPipelineSchedules?: Maybe<Scalars['Int']['output']>;
};

/** Represents the Geo replication and verification state of a project repository */
export type ProjectRepositoryRegistry = {
  __typename?: 'ProjectRepositoryRegistry';
  /** Indicate if the checksums of the ProjectRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the ProjectRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ProjectRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the ProjectRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the ProjectRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the ProjectRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ProjectRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the Project. */
  projectId: Scalars['ID']['output'];
  /** Timestamp after which the ProjectRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the ProjectRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the ProjectRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the ProjectRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the ProjectRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the ProjectRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the ProjectRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the ProjectRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of ProjectRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the ProjectRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the ProjectRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for ProjectRepositoryRegistry. */
export type ProjectRepositoryRegistryConnection = {
  __typename?: 'ProjectRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ProjectRepositoryRegistry. */
export type ProjectRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProjectRepositoryRegistryEdge = {
  __typename?: 'ProjectRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectRepositoryRegistry>;
};

export type ProjectRequirementComplianceStatusInput = {
  /** Filter compliance requirement statuses by compliance framework. */
  frameworkId?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** Filter compliance requirement statuses by compliance requirement. */
  requirementId?: InputMaybe<Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input']>;
};

export type ProjectSavedReply = {
  __typename?: 'ProjectSavedReply';
  /** Content of the saved reply. */
  content: Scalars['String']['output'];
  /** Global ID of the project-level saved reply. */
  id: Scalars['ProjectsSavedReplyID']['output'];
  /** Name of the saved reply. */
  name: Scalars['String']['output'];
};

/** The connection type for ProjectSavedReply. */
export type ProjectSavedReplyConnection = {
  __typename?: 'ProjectSavedReplyConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ProjectSavedReply. */
export type ProjectSavedReplyConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ProjectSavedReplyCreate */
export type ProjectSavedReplyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
  /** Project for the saved reply. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of ProjectSavedReplyCreate. */
export type ProjectSavedReplyCreatePayload = {
  __typename?: 'ProjectSavedReplyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<ProjectSavedReply>;
};

/** Autogenerated input type of ProjectSavedReplyDestroy */
export type ProjectSavedReplyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the project-level saved reply. */
  id: Scalars['ProjectsSavedReplyID']['input'];
};

/** Autogenerated return type of ProjectSavedReplyDestroy. */
export type ProjectSavedReplyDestroyPayload = {
  __typename?: 'ProjectSavedReplyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<ProjectSavedReply>;
};

/** An edge in a connection. */
export type ProjectSavedReplyEdge = {
  __typename?: 'ProjectSavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSavedReply>;
};

/** Autogenerated input type of ProjectSavedReplyUpdate */
export type ProjectSavedReplyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Global ID of the project-level saved reply. */
  id: Scalars['ProjectsSavedReplyID']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectSavedReplyUpdate. */
export type ProjectSavedReplyUpdatePayload = {
  __typename?: 'ProjectSavedReplyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<ProjectSavedReply>;
};

/** Representation of a project secret. */
export type ProjectSecret = {
  __typename?: 'ProjectSecret';
  /** Branches that can access the secret. */
  branch: Scalars['String']['output'];
  /** Description of the project secret. */
  description?: Maybe<Scalars['String']['output']>;
  /** Environments that can access the secret. */
  environment: Scalars['String']['output'];
  /** Current metadata version of the project secret. */
  metadataVersion?: Maybe<Scalars['Int']['output']>;
  /** Name of the project secret. */
  name: Scalars['String']['output'];
  /** Project the secret belong to. */
  project: Project;
  /** Rotation configuration for the secret. */
  rotationInfo?: Maybe<SecretRotationInfo>;
  /** Computed lifecycle status of the secret, based on timestamps. */
  status: ProjectSecretStatus;
};

/** The connection type for ProjectSecret. */
export type ProjectSecretConnection = {
  __typename?: 'ProjectSecretConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSecretEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSecret>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProjectSecretCreate */
export type ProjectSecretCreateInput = {
  /** Branches that can access the secret. */
  branch: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the project secret. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Environments that can access the secret. */
  environment: Scalars['String']['input'];
  /** Name of the project secret. */
  name: Scalars['String']['input'];
  /** Project of the secret. */
  projectPath: Scalars['ID']['input'];
  /** Number of days between rotation reminders for the secret. */
  rotationIntervalDays?: InputMaybe<Scalars['Int']['input']>;
  /** Value of the project secret. */
  secret: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectSecretCreate. */
export type ProjectSecretCreatePayload = {
  __typename?: 'ProjectSecretCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project secret. */
  projectSecret?: Maybe<ProjectSecret>;
};

/** Autogenerated input type of ProjectSecretDelete */
export type ProjectSecretDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the project secret. */
  name: Scalars['String']['input'];
  /** Project of the secret. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSecretDelete. */
export type ProjectSecretDeletePayload = {
  __typename?: 'ProjectSecretDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted project secret. */
  projectSecret?: Maybe<ProjectSecret>;
};

/** An edge in a connection. */
export type ProjectSecretEdge = {
  __typename?: 'ProjectSecretEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSecret>;
};

/** Status of project secret */
export type ProjectSecretStatus =
  /** Secret is complete. */
  | 'COMPLETED'
  /** Secret creation is in progress. */
  | 'CREATE_IN_PROGRESS'
  /** Secret creation appears stale (started long ago or missing completion timestamp). */
  | 'CREATE_STALE'
  /** Secret update is in progress. */
  | 'UPDATE_IN_PROGRESS'
  /** Secret update appears stale (started long ago or missing completion timestamp). */
  | 'UPDATE_STALE';

/** Autogenerated input type of ProjectSecretUpdate */
export type ProjectSecretUpdateInput = {
  /** New branches that can access the secret. */
  branch?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New description of the project secret. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** New environments that can access the secret. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** This should match the current metadata version of the project secret being updated. */
  metadataCas: Scalars['Int']['input'];
  /** Name of the project secret to update. */
  name: Scalars['String']['input'];
  /** Project of the secret. */
  projectPath: Scalars['ID']['input'];
  /** Number of days between rotation reminders for the secret. */
  rotationIntervalDays?: InputMaybe<Scalars['Int']['input']>;
  /** New value of the project secret. */
  secret?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProjectSecretUpdate. */
export type ProjectSecretUpdatePayload = {
  __typename?: 'ProjectSecretUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated project secret. */
  projectSecret?: Maybe<ProjectSecret>;
};

/** Representation of a project secrets manager. */
export type ProjectSecretsManager = {
  __typename?: 'ProjectSecretsManager';
  /** Project the secrets manager belong to. */
  project: Project;
  /** Status of the project secrets manager. */
  status?: Maybe<ProjectSecretsManagerStatus>;
};

/** Autogenerated input type of ProjectSecretsManagerDeprovision */
export type ProjectSecretsManagerDeprovisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project of the secrets manager. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSecretsManagerDeprovision. */
export type ProjectSecretsManagerDeprovisionPayload = {
  __typename?: 'ProjectSecretsManagerDeprovisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project secrets manager. */
  projectSecretsManager?: Maybe<ProjectSecretsManager>;
};

/** Autogenerated input type of ProjectSecretsManagerInitialize */
export type ProjectSecretsManagerInitializeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Project of the secrets manager. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSecretsManagerInitialize. */
export type ProjectSecretsManagerInitializePayload = {
  __typename?: 'ProjectSecretsManagerInitializePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project secrets manager. */
  projectSecretsManager?: Maybe<ProjectSecretsManager>;
};

/** Values for the project secrets manager status */
export type ProjectSecretsManagerStatus =
  /** Secrets manager has been provisioned and enabled. */
  | 'ACTIVE'
  /** Secrets manager is being deprovisioned. */
  | 'DEPROVISIONING'
  /** Secrets manager is being provisioned. */
  | 'PROVISIONING';

/** Representation of a project secrets permission. */
export type ProjectSecretsPermission = {
  __typename?: 'ProjectSecretsPermission';
  /** Actions that can be performed on secrets. */
  actions: Array<SecretsManagementAction>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: Maybe<Scalars['ISO8601Date']['output']>;
  /** User who created the Secret Permission. */
  grantedBy?: Maybe<UserCore>;
  /** Who is provided access to. For eg: User/Role/MemberRole/Group. */
  principal: Principal;
  /** Project the secrets permission belongs to. */
  project: Project;
};

/** The connection type for ProjectSecretsPermission. */
export type ProjectSecretsPermissionConnection = {
  __typename?: 'ProjectSecretsPermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSecretsPermissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSecretsPermission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProjectSecretsPermissionDelete */
export type ProjectSecretsPermissionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** User/MemberRole/Role/Group whose access is being removed. */
  principal: PrincipalInput;
  /** Project from which the permissions are removed. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSecretsPermissionDelete. */
export type ProjectSecretsPermissionDeletePayload = {
  __typename?: 'ProjectSecretsPermissionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Secrets Permission that was deleted. */
  secretsPermission?: Maybe<ProjectSecretsPermission>;
};

/** An edge in a connection. */
export type ProjectSecretsPermissionEdge = {
  __typename?: 'ProjectSecretsPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSecretsPermission>;
};

/** Autogenerated input type of ProjectSecretsPermissionUpdate */
export type ProjectSecretsPermissionUpdateInput = {
  /** Actions that can be performed on secrets. */
  actions: Array<SecretsManagementAction>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** User/MemberRole/Role/Group that is provided access. */
  principal: PrincipalInput;
  /** Project to which the permissions are added. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSecretsPermissionUpdate. */
export type ProjectSecretsPermissionUpdatePayload = {
  __typename?: 'ProjectSecretsPermissionUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Secrets Permission that was created. */
  secretsPermission?: Maybe<ProjectSecretsPermission>;
};

/** Represents a project-level security scanner exclusion */
export type ProjectSecurityExclusion = {
  __typename?: 'ProjectSecurityExclusion';
  /** Whether the exclusion is active. */
  active: Scalars['Boolean']['output'];
  /** Timestamp of when the exclusion was created. */
  createdAt: Scalars['Time']['output'];
  /** Optional description for the exclusion. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the exclusion. */
  id: Scalars['SecurityProjectSecurityExclusionID']['output'];
  /** Security scanner the exclusion will be used for. */
  scanner: ExclusionScannerEnum;
  /** Type of the exclusion. */
  type: ExclusionTypeEnum;
  /** Timestamp of when the exclusion was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Value of the exclusion. */
  value: Scalars['String']['output'];
};

/** The connection type for ProjectSecurityExclusion. */
export type ProjectSecurityExclusionConnection = {
  __typename?: 'ProjectSecurityExclusionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSecurityExclusionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSecurityExclusion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProjectSecurityExclusionCreate */
export type ProjectSecurityExclusionCreateInput = {
  /** Whether the exclusion is active. */
  active: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional description for the exclusion. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the exclusion will be associated with. */
  projectPath: Scalars['ID']['input'];
  /** Scanner to ignore values for based on the exclusion. */
  scanner: ExclusionScannerEnum;
  /** Type of the exclusion. */
  type: ExclusionTypeEnum;
  /** Value of the exclusion. */
  value: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectSecurityExclusionCreate. */
export type ProjectSecurityExclusionCreatePayload = {
  __typename?: 'ProjectSecurityExclusionCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project security exclusion created. */
  securityExclusion?: Maybe<ProjectSecurityExclusion>;
};

/** Autogenerated input type of ProjectSecurityExclusionDelete */
export type ProjectSecurityExclusionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the exclusion to be deleted. */
  id: Scalars['SecurityProjectSecurityExclusionID']['input'];
};

/** Autogenerated return type of ProjectSecurityExclusionDelete. */
export type ProjectSecurityExclusionDeletePayload = {
  __typename?: 'ProjectSecurityExclusionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type ProjectSecurityExclusionEdge = {
  __typename?: 'ProjectSecurityExclusionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSecurityExclusion>;
};

/** Autogenerated input type of ProjectSecurityExclusionUpdate */
export type ProjectSecurityExclusionUpdateInput = {
  /** Whether the exclusion is active. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional description for the exclusion. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the exclusion to be updated. */
  id: Scalars['SecurityProjectSecurityExclusionID']['input'];
  /** Scanner to ignore values for based on the exclusion. */
  scanner?: InputMaybe<ExclusionScannerEnum>;
  /** Type of the exclusion. */
  type?: InputMaybe<ExclusionTypeEnum>;
  /** Value of the exclusion. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProjectSecurityExclusionUpdate. */
export type ProjectSecurityExclusionUpdatePayload = {
  __typename?: 'ProjectSecurityExclusionUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project security exclusion updated. */
  securityExclusion?: Maybe<ProjectSecurityExclusion>;
};

/** Represents the source of a security policy belonging to a project */
export type ProjectSecurityPolicySource = {
  __typename?: 'ProjectSecurityPolicySource';
  /** Project the policy is associated with. */
  project?: Maybe<Project>;
};

export type ProjectSecurityTraining = {
  __typename?: 'ProjectSecurityTraining';
  /** Description of the training provider. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the training provider. */
  id: Scalars['GlobalID']['output'];
  /** Represents whether the provider is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
  /** Represents whether the provider is set as primary or not. */
  isPrimary: Scalars['Boolean']['output'];
  /** Logo URL of the provider. */
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** Name of the training provider. */
  name: Scalars['String']['output'];
  /** URL of the provider. */
  url: Scalars['String']['output'];
};

/** Autogenerated input type of ProjectSetComplianceFramework */
export type ProjectSetComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the compliance framework to assign to the project. Set to `null` to unset. */
  complianceFrameworkId?: InputMaybe<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** ID of the project to change the compliance framework of. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of ProjectSetComplianceFramework. */
export type ProjectSetComplianceFrameworkPayload = {
  __typename?: 'ProjectSetComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectSetContinuousVulnerabilityScanning */
export type ProjectSetContinuousVulnerabilityScanningInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired status for continuous vulnerability scanning feature. */
  enable: Scalars['Boolean']['input'];
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSetContinuousVulnerabilityScanning. */
export type ProjectSetContinuousVulnerabilityScanningPayload = {
  __typename?: 'ProjectSetContinuousVulnerabilityScanningPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether feature is enabled. */
  continuousVulnerabilityScanningEnabled: Scalars['Boolean']['output'];
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of ProjectSetLocked */
export type ProjectSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path to the file. */
  filePath: Scalars['String']['input'];
  /** Whether or not to lock the file path. */
  lock: Scalars['Boolean']['input'];
  /** Full path of the project to mutate. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSetLocked. */
export type ProjectSetLockedPayload = {
  __typename?: 'ProjectSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

export type ProjectSetting = {
  __typename?: 'ProjectSetting';
  /** Settings for excluding files from Duo context. */
  duoContextExclusionSettings?: Maybe<DuoContextExclusionSettings>;
  /** Indicates whether GitLab Duo features are enabled for the project. */
  duoFeaturesEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Project the settings belong to. */
  project?: Maybe<Project>;
  /**
   * Indicates whether web-based commit signing is enabled for the project. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  webBasedCommitSigningEnabled: Scalars['Boolean']['output'];
};

/** Autogenerated input type of ProjectSettingsUpdate */
export type ProjectSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Settings for excluding files from Duo context. */
  duoContextExclusionSettings?: InputMaybe<DuoContextExclusionSettingsInput>;
  /** Indicates whether GitLab Duo features are enabled for the project. */
  duoFeaturesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full Path of the project the settings belong to. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of ProjectSettingsUpdate. */
export type ProjectSettingsUpdatePayload = {
  __typename?: 'ProjectSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project settings after mutation. */
  projectSettings: ProjectSetting;
};

/** Values for sorting projects */
export type ProjectSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** ID by ascending order. */
  | 'ID_ASC'
  /** ID by descending order. */
  | 'ID_DESC'
  /** Latest activity by ascending order. */
  | 'LATEST_ACTIVITY_ASC'
  /** Latest activity by descending order. */
  | 'LATEST_ACTIVITY_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Path by ascending order. */
  | 'PATH_ASC'
  /** Path by descending order. */
  | 'PATH_DESC'
  /** Stars by ascending order. */
  | 'STARS_ASC'
  /** Stars by descending order. */
  | 'STARS_DESC'
  /** Storage size by ascending order. */
  | 'STORAGE_SIZE_ASC'
  /** Storage size by descending order. */
  | 'STORAGE_SIZE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

export type ProjectStatistics = {
  __typename?: 'ProjectStatistics';
  /** Build artifacts size of the project in bytes. */
  buildArtifactsSize: Scalars['Float']['output'];
  /** Commit count of the project. */
  commitCount: Scalars['Float']['output'];
  /** Container registry size of the project in bytes. */
  containerRegistrySize?: Maybe<Scalars['Float']['output']>;
  /**
   * Build artifacts size in bytes with any applicable cost factor for forks applied. This will equal build_artifacts_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredBuildArtifactsSize: Scalars['Float']['output'];
  /**
   * LFS objects size in bytes with any applicable cost factor for forks applied. This will equal lfs_objects_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredLfsObjectsSize: Scalars['Float']['output'];
  /**
   * Packages size in bytes with any applicable cost factor for forks applied. This will equal packages_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredPackagesSize: Scalars['Float']['output'];
  /**
   * Repository size in bytes with any applicable cost factor for forks applied. This will equal repository_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredRepositorySize: Scalars['Float']['output'];
  /**
   * Snippets size in bytes with any applicable cost factor for forks applied. This will equal snippets_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredSnippetsSize: Scalars['Float']['output'];
  /**
   * Storage size in bytes with any applicable cost factor for forks applied. This will equal storage_size if there is no applicable cost factor. Introduced in GitLab 16.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.2.
   */
  costFactoredStorageSize: Scalars['Float']['output'];
  /**
   * Wiki size in bytes with any applicable cost factor for forks applied. This will equal wiki_size if there is no applicable cost factor. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  costFactoredWikiSize: Scalars['Float']['output'];
  /** Large File Storage (LFS) object size of the project in bytes. */
  lfsObjectsSize: Scalars['Float']['output'];
  /** Packages size of the project in bytes. */
  packagesSize: Scalars['Float']['output'];
  /** CI Pipeline artifacts size in bytes. */
  pipelineArtifactsSize?: Maybe<Scalars['Float']['output']>;
  /** Repository size of the project in bytes. */
  repositorySize: Scalars['Float']['output'];
  /** Snippets size of the project in bytes. */
  snippetsSize?: Maybe<Scalars['Float']['output']>;
  /** Storage size of the project in bytes. */
  storageSize: Scalars['Float']['output'];
  /** Uploads size of the project in bytes. */
  uploadsSize?: Maybe<Scalars['Float']['output']>;
  /** Wiki size of the project in bytes. */
  wikiSize?: Maybe<Scalars['Float']['output']>;
};

export type ProjectStatisticsRedirect = {
  __typename?: 'ProjectStatisticsRedirect';
  /** Redirection Route for job_artifacts. */
  buildArtifacts: Scalars['String']['output'];
  /** Redirection Route for container_registry. */
  containerRegistry: Scalars['String']['output'];
  /** Redirection Route for packages. */
  packages: Scalars['String']['output'];
  /** Redirection Route for repository. */
  repository: Scalars['String']['output'];
  /** Redirection Route for snippets. */
  snippets: Scalars['String']['output'];
  /** Redirection Route for wiki. */
  wiki: Scalars['String']['output'];
};

/** Autogenerated input type of ProjectSubscriptionCreate */
export type ProjectSubscriptionCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the downstream project of the Project Subscription. */
  projectPath: Scalars['String']['input'];
  /** Full path of the upstream project of the Project Subscription. */
  upstreamPath: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectSubscriptionCreate. */
export type ProjectSubscriptionCreatePayload = {
  __typename?: 'ProjectSubscriptionCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project Subscription created by the mutation. */
  subscription?: Maybe<CiSubscriptionsProject>;
};

/** Autogenerated input type of ProjectSubscriptionDelete */
export type ProjectSubscriptionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the subscription to delete. */
  subscriptionId: Scalars['CiSubscriptionsProjectID']['input'];
};

/** Autogenerated return type of ProjectSubscriptionDelete. */
export type ProjectSubscriptionDeletePayload = {
  __typename?: 'ProjectSubscriptionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectSyncFork */
export type ProjectSyncForkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to initialize. */
  projectPath: Scalars['ID']['input'];
  /** Ref of the fork to fetch into. */
  targetBranch: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectSyncFork. */
export type ProjectSyncForkPayload = {
  __typename?: 'ProjectSyncForkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated fork details. */
  details?: Maybe<ForkDetails>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type ProjectTargetBranchRule = {
  __typename?: 'ProjectTargetBranchRule';
  /** Timestamp of when the target branch rule was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the target branch rule. */
  id: Scalars['ProjectsTargetBranchRuleID']['output'];
  /** Name of the target branch rule. */
  name: Scalars['String']['output'];
  /** Target branch for the target branch rule. */
  targetBranch: Scalars['String']['output'];
};

/** The connection type for ProjectTargetBranchRule. */
export type ProjectTargetBranchRuleConnection = {
  __typename?: 'ProjectTargetBranchRuleConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectTargetBranchRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectTargetBranchRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ProjectTargetBranchRule. */
export type ProjectTargetBranchRuleConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ProjectTargetBranchRuleCreate */
export type ProjectTargetBranchRuleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name for the target branch rule. */
  name: Scalars['String']['input'];
  /** Project ID for the target branch rule. */
  projectId: Scalars['ProjectID']['input'];
  /** Target branch for the target branch rule. */
  targetBranch: Scalars['String']['input'];
};

/** Autogenerated return type of ProjectTargetBranchRuleCreate. */
export type ProjectTargetBranchRuleCreatePayload = {
  __typename?: 'ProjectTargetBranchRuleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Target branch rule after mutation. */
  targetBranchRule?: Maybe<ProjectTargetBranchRule>;
};

/** Autogenerated input type of ProjectTargetBranchRuleDestroy */
export type ProjectTargetBranchRuleDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID for the target branch rule. */
  id: Scalars['ProjectsTargetBranchRuleID']['input'];
};

/** Autogenerated return type of ProjectTargetBranchRuleDestroy. */
export type ProjectTargetBranchRuleDestroyPayload = {
  __typename?: 'ProjectTargetBranchRuleDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type ProjectTargetBranchRuleEdge = {
  __typename?: 'ProjectTargetBranchRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectTargetBranchRule>;
};

/** The context type of the tracked context */
export type ProjectTrackedContext =
  /** Branch type */
  | 'BRANCH'
  /** Tag type */
  | 'TAG';

/** Input for specifying a project tracked context */
export type ProjectTrackedContextInput = {
  /** Name of the tracked context. */
  name: Scalars['String']['input'];
  /** Type of the tracked context. */
  type: ProjectTrackedContext;
};

/** Autogenerated input type of ProjectUpdateComplianceFrameworks */
export type ProjectUpdateComplianceFrameworksInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the compliance framework to update for the project. */
  complianceFrameworkIds: Array<Scalars['ComplianceManagementFrameworkID']['input']>;
  /** ID of the project to change the compliance framework of. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of ProjectUpdateComplianceFrameworks. */
export type ProjectUpdateComplianceFrameworksPayload = {
  __typename?: 'ProjectUpdateComplianceFrameworksPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetrics = {
  __typename?: 'ProjectValueStreamAnalyticsFlowMetrics';
  /** Median time from first commit to issue closed */
  cycleTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of production deployments in the given period. */
  deploymentCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of issues opened in the given period. */
  issueCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of open issues closed (completed) in the given period. Maximum value is 10,001. */
  issuesCompletedCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from when the issue was created to when it was closed. */
  leadTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from merge request creation to merge request merged. */
  timeToMerge?: Maybe<ValueStreamAnalyticsMetric>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsCycleTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsDeploymentCountArgs = {
  from: Scalars['Time']['input'];
  to: Scalars['Time']['input'];
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsIssueCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsIssuesCompletedCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsLeadTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  from: Scalars['Time']['input'];
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  to: Scalars['Time']['input'];
  weight?: InputMaybe<Scalars['Int']['input']>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsTimeToMergeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  from: Scalars['Time']['input'];
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  to: Scalars['Time']['input'];
};

/** Represents the Geo replication and verification state of a project_wiki_repository */
export type ProjectWikiRepositoryRegistry = {
  __typename?: 'ProjectWikiRepositoryRegistry';
  /** Indicate if the checksums of the ProjectWikiRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the ProjectWikiRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ProjectWikiRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the ProjectWikiRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the ProjectWikiRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the ProjectWikiRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the ProjectWikiRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** ID of the Project Wiki Repository. */
  projectWikiRepositoryId: Scalars['ID']['output'];
  /** Timestamp after which the ProjectWikiRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the ProjectWikiRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the ProjectWikiRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the ProjectWikiRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the ProjectWikiRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the ProjectWikiRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the ProjectWikiRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the ProjectWikiRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of ProjectWikiRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the ProjectWikiRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the ProjectWikiRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for ProjectWikiRepositoryRegistry. */
export type ProjectWikiRepositoryRegistryConnection = {
  __typename?: 'ProjectWikiRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectWikiRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectWikiRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for ProjectWikiRepositoryRegistry. */
export type ProjectWikiRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProjectWikiRepositoryRegistryEdge = {
  __typename?: 'ProjectWikiRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectWikiRepositoryRegistry>;
};

/** The alert condition for Prometheus */
export type PrometheusAlert = {
  __typename?: 'PrometheusAlert';
  /** Human-readable text of the alert condition. */
  humanizedText: Scalars['String']['output'];
  /** ID of the alert condition. */
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of PrometheusIntegrationCreate */
export type PrometheusIntegrationCreateInput = {
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the integration. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']['input']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID']['input'];
  /** Type of integration to create. Cannot be changed after creation. */
  type?: InputMaybe<AlertManagementIntegrationType>;
};

/** Autogenerated return type of PrometheusIntegrationCreate. */
export type PrometheusIntegrationCreatePayload = {
  __typename?: 'PrometheusIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationResetToken */
export type PrometheusIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID']['input'];
};

/** Autogenerated return type of PrometheusIntegrationResetToken. */
export type PrometheusIntegrationResetTokenPayload = {
  __typename?: 'PrometheusIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationUpdate */
export type PrometheusIntegrationUpdateInput = {
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID']['input'];
  /** Name of the integration. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']['input']>;
};

/** Autogenerated return type of PrometheusIntegrationUpdate. */
export type PrometheusIntegrationUpdatePayload = {
  __typename?: 'PrometheusIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PromoteToEpic */
export type PromoteToEpicInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group the promoted epic will belong to. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of PromoteToEpic. */
export type PromoteToEpicPayload = {
  __typename?: 'PromoteToEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after issue promotion. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Values for prompt injection protection for a namespace. */
export type PromptInjectionProtectionLevel =
  /** Scan and block detected prompt injection attempts. */
  | 'INTERRUPT'
  /** Scan and log results, but do not block requests. */
  | 'LOG_ONLY'
  /** Turn off scanning entirely. No prompt data is sent to third-party services. */
  | 'NO_CHECKS';

/** Protected Environments of the environment. */
export type ProtectedEnvironment = {
  __typename?: 'ProtectedEnvironment';
  /** Which group, user or role is allowed to approve deployments to the environment. */
  approvalRules?: Maybe<ProtectedEnvironmentApprovalRuleConnection>;
  /** Which group, user or role is allowed to execute deployments to the environment. */
  deployAccessLevels?: Maybe<ProtectedEnvironmentDeployAccessLevelConnection>;
  /** Group details. Present if it's group-level protected environment. */
  group?: Maybe<Group>;
  /** Name of the environment if it's a project-level protected environment. Tier of the environment if it's a group-level protected environment. */
  name?: Maybe<Scalars['String']['output']>;
  /** Project details. Present if it's project-level protected environment. */
  project?: Maybe<Project>;
  /** Required approval count for Unified Approval Setting. */
  requiredApprovalCount?: Maybe<Scalars['Int']['output']>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentDeployAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRule = {
  __typename?: 'ProtectedEnvironmentApprovalRule';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']['output']>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentApprovalRule. */
export type ProtectedEnvironmentApprovalRuleConnection = {
  __typename?: 'ProtectedEnvironmentApprovalRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentApprovalRuleEdge = {
  __typename?: 'ProtectedEnvironmentApprovalRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentApprovalRule>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRuleForSummary = {
  __typename?: 'ProtectedEnvironmentApprovalRuleForSummary';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Current approvals of the deployment. */
  approvals?: Maybe<Array<DeploymentApproval>>;
  /** Approved count. */
  approvedCount?: Maybe<Scalars['Int']['output']>;
  /** Indicates whether a user is authorized to approve. */
  canApprove?: Maybe<Scalars['Boolean']['output']>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Pending approval count. */
  pendingApprovalCount?: Maybe<Scalars['Int']['output']>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']['output']>;
  /** Status of the approval summary. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironment. */
export type ProtectedEnvironmentConnection = {
  __typename?: 'ProtectedEnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Which group, user or role is allowed to execute deployments to the environment. */
export type ProtectedEnvironmentDeployAccessLevel = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevel';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentDeployAccessLevel. */
export type ProtectedEnvironmentDeployAccessLevelConnection = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentDeployAccessLevelEdge = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentDeployAccessLevel>;
};

/** An edge in a connection. */
export type ProtectedEnvironmentEdge = {
  __typename?: 'ProtectedEnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironment>;
};

/** Defines which user roles, users, or groups can push to a protected branch. */
export type PushAccessLevel = {
  __typename?: 'PushAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int']['output'];
  /** Human readable representation for the access level. */
  accessLevelDescription: Scalars['String']['output'];
  /** Deploy key assigned to the access level. */
  deployKey?: Maybe<AccessLevelDeployKey>;
  /** Group associated with the access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with the access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for PushAccessLevel. */
export type PushAccessLevelConnection = {
  __typename?: 'PushAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PushAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PushAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PushAccessLevelEdge = {
  __typename?: 'PushAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PushAccessLevel>;
};

/** Defines which user roles, users, deploy keys, or groups can push to a protected branch. */
export type PushAccessLevelInput = {
  /** Access level allowed to perform action. */
  accessLevel?: InputMaybe<Scalars['Int']['input']>;
  /** Deploy key assigned to the access level. */
  deployKeyId?: InputMaybe<Scalars['DeployKeyID']['input']>;
  /** Group associated with the access level. */
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  /** User associated with the access level. */
  userId?: InputMaybe<Scalars['UserID']['input']>;
};

/** Represents rules that commit pushes must follow. */
export type PushRules = {
  __typename?: 'PushRules';
  /** Indicates whether commits not signed through GPG will be rejected. */
  rejectUnsignedCommits: Scalars['Boolean']['output'];
};

/** Pypi metadata */
export type PypiMetadata = {
  __typename?: 'PypiMetadata';
  /** Author email address(es) in RFC-822 format. */
  authorEmail?: Maybe<Scalars['String']['output']>;
  /** Longer description that can run to several paragraphs. */
  description?: Maybe<Scalars['String']['output']>;
  /** Markup syntax used in the description field. */
  descriptionContentType?: Maybe<Scalars['String']['output']>;
  /** ID of the metadatum. */
  id: Scalars['PackagesPypiMetadatumID']['output'];
  /** List of keywords, separated by commas. */
  keywords?: Maybe<Scalars['String']['output']>;
  /** Metadata version. */
  metadataVersion?: Maybe<Scalars['String']['output']>;
  /** Required Python version of the Pypi package. */
  requiredPython?: Maybe<Scalars['String']['output']>;
  /** One-line summary of the description. */
  summary?: Maybe<Scalars['String']['output']>;
};

export type Query = {
  __typename?: 'Query';
  /**
   * Find an abuse report. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  abuseReport?: Maybe<AbuseReport>;
  /**
   * List of permissions for fine-grained access tokens Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  accessTokenPermissions: Array<AccessTokenPermission>;
  /** Retrieve all active add-on purchases. This query can be used in GitLab.com and self-managed environments. */
  addOnPurchases?: Maybe<Array<AddOnPurchase>>;
  /**
   * Find groups visible to the current admin. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  adminGroups?: Maybe<GroupInterfaceConnection>;
  /**
   * Finds a single admin custom role for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  adminMemberRole?: Maybe<AdminMemberRole>;
  /**
   * List of all admin customizable permissions. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  adminMemberRolePermissions?: Maybe<CustomizableAdminPermissionConnection>;
  /**
   * Admin custom roles available for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  adminMemberRoles?: Maybe<AdminMemberRoleConnection>;
  /**
   * Find projects visible to the current admin. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  adminProjects?: Maybe<ProjectInterfaceConnection>;
  /**
   * Get flow configuration for an AI Catalog agent. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  aiCatalogAgentFlowConfig?: Maybe<Scalars['String']['output']>;
  /**
   * List of AI Catalog built-in tools. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  aiCatalogBuiltInTools: AiCatalogBuiltInToolConnection;
  /**
   * AI Catalog items configured for use. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  aiCatalogConfiguredItems: AiCatalogItemConsumerConnection;
  /**
   * Find an AI Catalog item. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  aiCatalogItem?: Maybe<AiCatalogItem>;
  /**
   * Find a single AI Catalog item consumer by ID. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  aiCatalogItemConsumer?: Maybe<AiCatalogItemConsumer>;
  /**
   * List of AI Catalog items. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  aiCatalogItems: AiCatalogItemConnection;
  /**
   * Get available models for Duo Agentic Chat Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  aiChatAvailableModels?: Maybe<AvailableModels>;
  /** Get available GitLab Duo Chat context presets for the current user for a specific URL */
  aiChatContextPresets?: Maybe<ContextPreset>;
  /**
   * Get projects that can be included by the current user in a GitLab Duo Chat context Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  aiChatIncludedProjects?: Maybe<ProjectConnection>;
  /**
   * List conversation threads of AI features. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  aiConversationThreads: AiConversationsThreadConnection;
  /**
   * List of configurable AI features. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  aiFeatureSettings?: Maybe<AiFeatureSettingConnection>;
  /**
   * Core agents in GitLab. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  aiFoundationalChatAgents: AiFoundationalChatAgentConnection;
  /**
   * Find GitLab Duo Chat messages. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  aiMessages: AiMessageConnection;
  /**
   * List of configurable AI features for namespace Model Selection. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  aiModelSelectionNamespaceSettings?: Maybe<AiModelSelectionNamespaceFeatureSettingConnection>;
  /**
   * Returns the self-hosted model if an ID is provided, otherwise returns all models. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  aiSelfHostedModels?: Maybe<AiSelfHostedModelConnection>;
  /** Get available GitLab Duo Chat slash commands for the current user for a specific URL */
  aiSlashCommands?: Maybe<Array<SlashCommand>>;
  /**
   * Instance level AI-related data. Admins only. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  aiUsageData?: Maybe<AiInstanceUsageData>;
  /** Definitions for all audit events available on the instance. */
  auditEventDefinitions: AuditEventDefinitionConnection;
  /** Instance-level Amazon S3 configurations for audit events. */
  auditEventsInstanceAmazonS3Configurations?: Maybe<InstanceAmazonS3ConfigurationTypeConnection>;
  /**
   * Instance-level external audit event streaming destinations. Introduced in GitLab 16.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.11.
   */
  auditEventsInstanceStreamingDestinations?: Maybe<InstanceAuditEventStreamingDestinationConnection>;
  /**
   * Find code visible to the current user Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  blobSearch?: Maybe<BlobSearch>;
  /** Find an issue board list. */
  boardList?: Maybe<BoardList>;
  /** CI related settings that apply to the entire instance. */
  ciApplicationSettings?: Maybe<CiApplicationSettings>;
  /**
   * A single CI/CD Catalog resource visible to an authorized user Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  ciCatalogResource?: Maybe<CiCatalogResource>;
  /**
   * All CI/CD Catalog resources under a common namespace, visible to an authorized user Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  ciCatalogResources?: Maybe<CiCatalogResourceConnection>;
  /**
   * Linted and processed contents of a CI config.
   * Should not be requested more than once per request. Deprecated in GitLab 18.1: Use CiLint mutation: <https://docs.gitlab.com/api/graphql/reference/#mutationcilint>.
   * @deprecated Use CiLint mutation: <https://docs.gitlab.com/api/graphql/reference/#mutationcilint>. Deprecated in GitLab 18.1.
   */
  ciConfig?: Maybe<CiConfig>;
  /** Returns available filters for GitLab Dedicated runner usage data. */
  ciDedicatedHostedRunnerFilters?: Maybe<CiDedicatedHostedRunnerFilters>;
  /** Compute usage data for runners across namespaces on GitLab Dedicated. Defaults to the current year if no year or billing month is specified. Ultimate only. */
  ciDedicatedHostedRunnerUsage?: Maybe<CiDedicatedHostedRunnerUsageConnection>;
  /** Compute usage data for a namespace. */
  ciMinutesUsage?: Maybe<CiMinutesNamespaceMonthlyUsageConnection>;
  /** Stage belonging to a CI pipeline. */
  ciPipelineStage?: Maybe<CiStage>;
  /** Time taken for CI jobs to be picked up by runner by percentile. Enable the ClickHouse database backend to use this query. */
  ciQueueingHistory?: Maybe<QueueingDelayHistory>;
  /** List of the instance's CI/CD variables. */
  ciVariables?: Maybe<CiInstanceVariableConnection>;
  /**
   * Run a series of status checks for Cloud Connector features. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  cloudConnectorStatus?: Maybe<CloudConnectorStatus>;
  /** Get the list of all the compliance requirement controls. */
  complianceRequirementControls?: Maybe<ComplianceRequirementControl>;
  /** Find a container repository. */
  containerRepository?: Maybe<ContainerRepositoryDetails>;
  /** Fields related to the current license. */
  currentLicense?: Maybe<CurrentLicense>;
  /** Get information about current user. */
  currentUser?: Maybe<CurrentUser>;
  /**
   * Find a custom field by its ID. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  customField?: Maybe<CustomField>;
  /** Find a dependency. */
  dependency?: Maybe<Dependency>;
  /** Fields related to design management. */
  designManagement: DesignManagement;
  /** Get configured DevOps adoption namespaces. **Status**: Beta. This endpoint is subject to change without notice. */
  devopsAdoptionEnabledNamespaces?: Maybe<DevopsAdoptionEnabledNamespaceConnection>;
  /**
   * List namespaces suitable to be set as default namespace. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  duoDefaultNamespaceCandidates?: Maybe<NamespaceConnection>;
  /**
   * Get GitLab Duo settings Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  duoSettings?: Maybe<DuoSettings>;
  /**
   * List the events for a Duo Agent Platform. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  duoWorkflowEvents: DuoWorkflowEventConnection;
  /**
   * List the workflows owned by the current user. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  duoWorkflowWorkflows: DuoWorkflowConnection;
  /** Testing endpoint to validate the API with */
  echo: Scalars['String']['output'];
  epicBoardList?: Maybe<EpicList>;
  /**
   * Check if a feature flag is enabled Deprecated in GitLab 17.4: Replaced with metadata.featureFlags.
   * @deprecated Replaced with metadata.featureFlags. Deprecated in GitLab 17.4.
   */
  featureFlagEnabled: Scalars['Boolean']['output'];
  /** A user's frecently visited groups */
  frecentGroups?: Maybe<Array<Group>>;
  /** A user's frecently visited projects */
  frecentProjects?: Maybe<Array<Project>>;
  /** Find a Geo node. */
  geoNode?: Maybe<GeoNode>;
  /** Whether Ona is enabled in application settings. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Details about an artifact in the Google Artifact Registry. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  googleCloudArtifactRegistryRepositoryArtifact?: Maybe<GoogleCloudArtifactRegistryArtifactDetails>;
  /** Find a group. */
  group?: Maybe<Group>;
  /**
   * Find a group secrets manager. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupSecretsManager?: Maybe<GroupSecretsManager>;
  /**
   * List group secrets permissions. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  groupSecretsPermissions?: Maybe<GroupSecretsPermissionConnection>;
  /** Find groups. */
  groups?: Maybe<GroupConnection>;
  /** Instance level external audit event destinations. */
  instanceExternalAuditEventDestinations?: Maybe<InstanceExternalAuditEventDestinationConnection>;
  /** Instance level google cloud logging configurations. */
  instanceGoogleCloudLoggingConfigurations?: Maybe<InstanceGoogleCloudLoggingConfigurationTypeConnection>;
  /** Fields related to Instance Security Dashboard. */
  instanceSecurityDashboard?: Maybe<InstanceSecurityDashboard>;
  /** @deprecated **Status**: Experiment. Introduced in GitLab 17.0. */
  integrationExclusions?: Maybe<IntegrationExclusionConnection>;
  /** Find an issue. */
  issue?: Maybe<Issue>;
  /**
   * Find issues visible to the current user. At least one filter must be provided. Introduced in GitLab 15.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.6.
   */
  issues?: Maybe<IssueConnection>;
  /** Find an iteration. */
  iteration?: Maybe<Iteration>;
  /** All jobs on this GitLab instance. Returns an empty result for users without administrator access. */
  jobs?: Maybe<CiJobInterfaceConnection>;
  /**
   * LDAP admin links. Available only for GitLab Self-Managed. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  ldapAdminRoleLinks?: Maybe<LdapAdminRoleLinkConnection>;
  /** Fields related to entries in the license history. */
  licenseHistoryEntries?: Maybe<LicenseHistoryEntryConnection>;
  /**
   * Finds a single custom role for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  memberRole?: Maybe<MemberRole>;
  /**
   * List of all standard customizable permissions. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  memberRolePermissions?: Maybe<CustomizableStandardPermissionConnection>;
  /**
   * Custom roles available for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  memberRoles?: Maybe<MemberRoleConnection>;
  /** Find a merge request. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Metadata about GitLab. */
  metadata?: Maybe<Metadata>;
  /** Find a milestone. */
  milestone?: Maybe<Milestone>;
  /** Find a machine learning experiment. */
  mlExperiment?: Maybe<MlExperiment>;
  /**
   * Find machine learning models. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  mlModel?: Maybe<MlModel>;
  /** Find a namespace. */
  namespace?: Maybe<Namespace>;
  /** Security-filtered projects for a namespace */
  namespaceSecurityProjects?: Maybe<ProjectConnection>;
  /**
   * Find a note. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  note?: Maybe<Note>;
  /**
   * Check if OpenBao instance is healthy and reachable. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  openbaoHealth: Scalars['Boolean']['output'];
  /**
   * Find an organization. Introduced in GitLab 16.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.4.
   */
  organization?: Maybe<Organization>;
  /**
   * List organizations. Introduced in GitLab 16.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.8.
   */
  organizations?: Maybe<OrganizationConnection>;
  /** Find a package. This field can only be resolved for one query in any single request. Returns `null` if a package has no `default` status. */
  package?: Maybe<PackageDetailsType>;
  /** Find a project. */
  project?: Maybe<Project>;
  /** Find a project compliance violation. */
  projectComplianceViolation?: Maybe<ProjectComplianceViolation>;
  /**
   * View a specific project secret. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  projectSecret?: Maybe<ProjectSecret>;
  /**
   * List project secrets. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  projectSecrets?: Maybe<ProjectSecretConnection>;
  /**
   * Find a project secrets manager. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  projectSecretsManager?: Maybe<ProjectSecretsManager>;
  /**
   * List project secrets that need to be rotated. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  projectSecretsNeedingRotation?: Maybe<ProjectSecretConnection>;
  /**
   * List project secrets permissions. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  projectSecretsPermissions?: Maybe<ProjectSecretsPermissionConnection>;
  /** Find projects visible to the current user. */
  projects?: Maybe<ProjectConnection>;
  /** Information about the complexity of the GraphQL query. */
  queryComplexity?: Maybe<QueryComplexity>;
  /** Find a runner. */
  runner?: Maybe<CiRunner>;
  /**
   * Supported runner platforms. Deprecated in GitLab 15.9: No longer used, use gitlab-runner documentation to learn about supported platforms.
   * @deprecated No longer used, use gitlab-runner documentation to learn about supported platforms. Deprecated in GitLab 15.9.
   */
  runnerPlatforms?: Maybe<RunnerPlatformConnection>;
  /**
   * Runner setup instructions. Deprecated in GitLab 15.9: No longer used, use gitlab-runner documentation to learn about runner registration commands.
   * @deprecated No longer used, use gitlab-runner documentation to learn about runner registration commands. Deprecated in GitLab 15.9.
   */
  runnerSetup?: Maybe<RunnerSetup>;
  /** Runner usage by runner. Enable the ClickHouse database backend to use this query. */
  runnerUsage?: Maybe<Array<CiRunnerUsage>>;
  /** Runner usage by project. Enable the ClickHouse database backend to use this query. */
  runnerUsageByProject?: Maybe<Array<CiRunnerUsageByProject>>;
  /** Get all runners in the GitLab instance (project and shared). Access is restricted to users with administrator access. */
  runners?: Maybe<CiRunnerConnection>;
  /**
   * List secret permissions. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  secretPermissions?: Maybe<SecretPermissionConnection>;
  /**
   * Get the current security policy synchronization status. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  securityPoliciesSyncStatus?: Maybe<PoliciesSyncUpdated>;
  /**
   * Get security scan profile by ID. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  securityScanProfile: ScanProfileType;
  /**
   * Users within the self-managed instance who are eligible for add-ons. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  selfManagedAddOnEligibleUsers?: Maybe<AddOnUserConnection>;
  /** Fields related to users within a self-managed instance that are pending role promotion approval. */
  selfManagedUsersQueuedForRolePromotion?: Maybe<UsersQueuedForRolePromotionConnection>;
  /** Find Snippets visible to the current user. */
  snippets?: Maybe<SnippetConnection>;
  /**
   * Finds a single default role for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  standardRole?: Maybe<StandardRole>;
  /**
   * Default roles available for the instance. Available only for GitLab Self-Managed. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  standardRoles?: Maybe<StandardRoleConnection>;
  /** Fields related to entries in future subscriptions. */
  subscriptionFutureEntries?: Maybe<SubscriptionFutureEntryConnection>;
  /**
   * Usage data of consumables under the subscription. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  subscriptionUsage?: Maybe<GitlabSubscriptionUsage>;
  /**
   * Find a synthetic note Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  syntheticNote?: Maybe<Note>;
  /** Find timelogs visible to the current user. */
  timelogs?: Maybe<TimelogConnection>;
  /** Retrieve a single to-do item */
  todo?: Maybe<Todo>;
  /** Find project topics. */
  topics?: Maybe<TopicConnection>;
  /** Get statistics on the instance. */
  usageTrendsMeasurements?: Maybe<UsageTrendsMeasurementConnection>;
  /** Find a user. */
  user?: Maybe<UserCore>;
  /** Find users. */
  users?: Maybe<UserCoreConnection>;
  /**
   * Find a container virtual registry. Returns null if the `container_virtual_registries` feature flag is disabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  virtualRegistriesContainerRegistry?: Maybe<ContainerRegistryDetails>;
  /**
   * Find a Maven virtual registry. Returns null if the `maven_virtual_registry` feature flag is disabled. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  virtualRegistriesPackagesMavenRegistry?: Maybe<MavenRegistryDetails>;
  /**
   * Find a Maven upstream registry. Returns null if the `maven_virtual_registry` feature flag is disabled. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  virtualRegistriesPackagesMavenUpstream?: Maybe<MavenUpstreamDetails>;
  /** Vulnerabilities reported on projects on the current user's instance security dashboard. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects on the current user's instance security dashboard. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Find a vulnerability. */
  vulnerability?: Maybe<Vulnerability>;
  /**
   * Find a wiki page. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  wikiPage?: Maybe<WikiPage>;
  /**
   * Find a work item. Introduced in GitLab 15.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.1.
   */
  workItem?: Maybe<WorkItem>;
  /**
   * Allowed work item statuses from the root groups the current user belongs to. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  workItemAllowedStatuses?: Maybe<WorkItemStatusConnection>;
  /**
   * Find a work item description template. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  workItemDescriptionTemplateContent?: Maybe<WorkItemDescriptionTemplate>;
  /**
   * Find work items by their reference. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  workItemsByReference?: Maybe<WorkItemConnection>;
  /** Find a workspace. */
  workspace?: Maybe<Workspace>;
  /** Find workspaces across the entire instance. This field is only available to instance admins, it will return an empty result for all non-admins. */
  workspaces?: Maybe<WorkspaceConnection>;
};


export type QueryAbuseReportArgs = {
  id: Scalars['AbuseReportID']['input'];
};


export type QueryAddOnPurchasesArgs = {
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
};


export type QueryAdminGroupsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  ownedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  parentPath?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topLevelOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAdminMemberRoleArgs = {
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type QueryAdminMemberRolePermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAdminMemberRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type QueryAdminProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  aimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  archived?: InputMaybe<ProjectArchived>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fullPaths?: InputMaybe<Array<Scalars['String']['input']>>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRepositoryCheckFailed?: InputMaybe<Scalars['Boolean']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  membership?: InputMaybe<Scalars['Boolean']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  personal?: InputMaybe<Scalars['Boolean']['input']>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topics?: InputMaybe<Array<Scalars['String']['input']>>;
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAiCatalogAgentFlowConfigArgs = {
  agentVersionId: Scalars['AiCatalogItemVersionID']['input'];
  flowConfigType: AiCatalogFlowConfigType;
};


export type QueryAiCatalogBuiltInToolsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAiCatalogConfiguredItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  foundationalFlowReference?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  includeInherited?: InputMaybe<Scalars['Boolean']['input']>;
  itemId?: InputMaybe<Scalars['AiCatalogItemID']['input']>;
  itemType?: InputMaybe<AiCatalogItemType>;
  itemTypes?: InputMaybe<Array<AiCatalogItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
};


export type QueryAiCatalogItemArgs = {
  id: Scalars['AiCatalogItemID']['input'];
  showSoftDeleted?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAiCatalogItemConsumerArgs = {
  id: Scalars['AiCatalogItemConsumerID']['input'];
};


export type QueryAiCatalogItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemType?: InputMaybe<AiCatalogItemType>;
  itemTypes?: InputMaybe<Array<AiCatalogItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAiChatAvailableModelsArgs = {
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  rootNamespaceId?: InputMaybe<Scalars['GroupID']['input']>;
};


export type QueryAiChatContextPresetsArgs = {
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  questionCount?: InputMaybe<Scalars['Int']['input']>;
  resourceId?: InputMaybe<Scalars['AiModelID']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAiChatIncludedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAiConversationThreadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  conversationType?: InputMaybe<AiConversationsThreadsConversationType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['AiConversationThreadID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAiFeatureSettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  selfHostedModelId?: InputMaybe<Scalars['AiSelfHostedModelID']['input']>;
};


export type QueryAiFoundationalChatAgentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
};


export type QueryAiMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  agentVersionId?: InputMaybe<Scalars['AiAgentVersionID']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  conversationType?: InputMaybe<AiConversationsThreadsConversationType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  requestIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  roles?: InputMaybe<Array<AiMessageRole>>;
  threadId?: InputMaybe<Scalars['AiConversationThreadID']['input']>;
};


export type QueryAiModelSelectionNamespaceSettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId: Scalars['GroupID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAiSelfHostedModelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['AiSelfHostedModelID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAiSlashCommandsArgs = {
  url: Scalars['String']['input'];
};


export type QueryAuditEventDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAuditEventsInstanceAmazonS3ConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAuditEventsInstanceStreamingDestinationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryBlobSearchArgs = {
  search: Scalars['String']['input'];
};


export type QueryBoardListArgs = {
  id: Scalars['ListID']['input'];
  issueFilters?: InputMaybe<BoardIssueInput>;
};


export type QueryCiCatalogResourceArgs = {
  fullPath?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['CiCatalogResourceID']['input']>;
};


export type QueryCiCatalogResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  scope?: InputMaybe<CiCatalogResourceScope>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiCatalogResourceSort>;
  topics?: InputMaybe<Array<Scalars['String']['input']>>;
  verificationLevel?: InputMaybe<CiCatalogResourceVerificationLevel>;
};


export type QueryCiConfigArgs = {
  content: Scalars['String']['input'];
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  projectPath: Scalars['ID']['input'];
  sha?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCiDedicatedHostedRunnerUsageArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  billingMonth?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  grouping?: InputMaybe<GroupingEnum>;
  last?: InputMaybe<Scalars['Int']['input']>;
  runnerId?: InputMaybe<Scalars['CiRunnerID']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCiMinutesUsageArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
};


export type QueryCiPipelineStageArgs = {
  id: Scalars['CiStageID']['input'];
};


export type QueryCiQueueingHistoryArgs = {
  fromTime?: InputMaybe<Scalars['Time']['input']>;
  runnerType?: InputMaybe<CiRunnerType>;
  toTime?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type QueryContainerRepositoryArgs = {
  id: Scalars['ContainerRepositoryID']['input'];
};


export type QueryCustomFieldArgs = {
  id: Scalars['IssuablesCustomFieldID']['input'];
};


export type QueryDependencyArgs = {
  id: Scalars['SbomOccurrenceID']['input'];
};


export type QueryDevopsAdoptionEnabledNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDuoDefaultNamespaceCandidatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDuoWorkflowEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  workflowId: Scalars['AiDuoWorkflowsWorkflowID']['input'];
};


export type QueryDuoWorkflowWorkflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<WorkflowEnvironment>;
  excludeTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<DuoWorkflowsWorkflowSort>;
  statusGroup?: InputMaybe<DuoWorkflowStatusGroup>;
  type?: InputMaybe<Scalars['String']['input']>;
  workflowId?: InputMaybe<Scalars['AiDuoWorkflowsWorkflowID']['input']>;
};


export type QueryEchoArgs = {
  text: Scalars['String']['input'];
};


export type QueryEpicBoardListArgs = {
  epicFilters?: InputMaybe<EpicFilters>;
  id: Scalars['BoardsEpicListID']['input'];
};


export type QueryFeatureFlagEnabledArgs = {
  name: Scalars['String']['input'];
};


export type QueryGeoNodeArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGoogleCloudArtifactRegistryRepositoryArtifactArgs = {
  googleCloudProjectId: Scalars['String']['input'];
  image: Scalars['String']['input'];
  location: Scalars['String']['input'];
  projectPath: Scalars['ID']['input'];
  repository: Scalars['String']['input'];
};


export type QueryGroupArgs = {
  fullPath: Scalars['ID']['input'];
};


export type QueryGroupSecretsManagerArgs = {
  groupPath: Scalars['ID']['input'];
};


export type QueryGroupSecretsPermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupPath: Scalars['ID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGroupsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  ownedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  parentPath?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topLevelOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryInstanceExternalAuditEventDestinationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInstanceGoogleCloudLoggingConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationExclusionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  integrationName: IntegrationType;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIssueArgs = {
  id: Scalars['IssueID']['input'];
};


export type QueryIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assigneeId?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  epicId?: InputMaybe<Scalars['String']['input']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']['input']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  iterationTitle?: InputMaybe<Scalars['String']['input']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  weight?: InputMaybe<Scalars['String']['input']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type QueryIterationArgs = {
  id: Scalars['IterationID']['input'];
};


export type QueryJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
};


export type QueryLdapAdminRoleLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryLicenseHistoryEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMemberRoleArgs = {
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type QueryMemberRolePermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMemberRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['MemberRoleID']['input']>;
  ids?: InputMaybe<Array<Scalars['MemberRoleID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MemberRolesOrderBy>;
  sort?: InputMaybe<SortDirectionEnum>;
};


export type QueryMergeRequestArgs = {
  id: Scalars['MergeRequestID']['input'];
};


export type QueryMilestoneArgs = {
  id: Scalars['MilestoneID']['input'];
};


export type QueryMlExperimentArgs = {
  id: Scalars['MlExperimentID']['input'];
};


export type QueryMlModelArgs = {
  id: Scalars['MlModelID']['input'];
};


export type QueryNamespaceArgs = {
  fullPath: Scalars['ID']['input'];
};


export type QueryNamespaceSecurityProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  attributeFilters?: InputMaybe<Array<AttributeFilterInput>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespaceId: Scalars['NamespaceID']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  securityAnalyzerFilters?: InputMaybe<Array<AnalyzerFilterInput>>;
  vulnerabilityCountFilters?: InputMaybe<Array<VulnerabilityCountFilterInput>>;
};


export type QueryNoteArgs = {
  id: Scalars['NoteID']['input'];
};


export type QueryOrganizationArgs = {
  id: Scalars['OrganizationsOrganizationID']['input'];
};


export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPackageArgs = {
  id: Scalars['PackagesPackageID']['input'];
};


export type QueryProjectArgs = {
  fullPath: Scalars['ID']['input'];
};


export type QueryProjectComplianceViolationArgs = {
  id: Scalars['ComplianceManagementProjectsComplianceViolationID']['input'];
};


export type QueryProjectSecretArgs = {
  name: Scalars['String']['input'];
  projectPath: Scalars['ID']['input'];
};


export type QueryProjectSecretsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath: Scalars['ID']['input'];
};


export type QueryProjectSecretsManagerArgs = {
  projectPath: Scalars['ID']['input'];
};


export type QueryProjectSecretsNeedingRotationArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath: Scalars['ID']['input'];
};


export type QueryProjectSecretsPermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath: Scalars['ID']['input'];
};


export type QueryProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  aimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  archived?: InputMaybe<ProjectArchived>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fullPaths?: InputMaybe<Array<Scalars['String']['input']>>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRepositoryCheckFailed?: InputMaybe<Scalars['Boolean']['input']>;
  markedForDeletionOn?: InputMaybe<Scalars['Date']['input']>;
  membership?: InputMaybe<Scalars['Boolean']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  personal?: InputMaybe<Scalars['Boolean']['input']>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  topics?: InputMaybe<Array<Scalars['String']['input']>>;
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRunnerArgs = {
  id: Scalars['CiRunnerID']['input'];
};


export type QueryRunnerPlatformsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRunnerSetupArgs = {
  architecture: Scalars['String']['input'];
  platform: Scalars['String']['input'];
};


export type QueryRunnerUsageArgs = {
  fromDate?: InputMaybe<Scalars['Date']['input']>;
  fullPath?: InputMaybe<Scalars['ID']['input']>;
  runnerType?: InputMaybe<CiRunnerType>;
  runnersLimit?: InputMaybe<Scalars['Int']['input']>;
  toDate?: InputMaybe<Scalars['Date']['input']>;
};


export type QueryRunnerUsageByProjectArgs = {
  fromDate?: InputMaybe<Scalars['Date']['input']>;
  fullPath?: InputMaybe<Scalars['ID']['input']>;
  projectsLimit?: InputMaybe<Scalars['Int']['input']>;
  runnerType?: InputMaybe<CiRunnerType>;
  toDate?: InputMaybe<Scalars['Date']['input']>;
};


export type QueryRunnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  creatorId?: InputMaybe<Scalars['UserID']['input']>;
  creatorUsername?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  versionPrefix?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySecretPermissionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectPath: Scalars['ID']['input'];
};


export type QuerySecurityPoliciesSyncStatusArgs = {
  policyConfigurationId: Scalars['SecurityOrchestrationPolicyConfigurationID']['input'];
};


export type QuerySecurityScanProfileArgs = {
  id: Scalars['SecurityScanProfileID']['input'];
};


export type QuerySelfManagedAddOnEligibleUsersArgs = {
  addOnPurchaseIds: Array<Scalars['GitlabSubscriptionsAddOnPurchaseID']['input']>;
  addOnType: GitlabSubscriptionsAddOnType;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignedSeat?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GitlabSubscriptionsUserSort>;
};


export type QuerySelfManagedUsersQueuedForRolePromotionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QuerySnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Scalars['UserID']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  explore?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


export type QueryStandardRoleArgs = {
  accessLevel?: InputMaybe<Array<MemberAccessLevel>>;
};


export type QueryStandardRolesArgs = {
  accessLevel?: InputMaybe<Array<MemberAccessLevel>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QuerySubscriptionFutureEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QuerySubscriptionUsageArgs = {
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySyntheticNoteArgs = {
  noteableId: Scalars['NoteableID']['input'];
  sha: Scalars['String']['input'];
};


export type QueryTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTodoArgs = {
  id: Scalars['TodoID']['input'];
};


export type QueryTopicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryUsageTrendsMeasurementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  identifier: MeasurementIdentifier;
  last?: InputMaybe<Scalars['Int']['input']>;
  recordedAfter?: InputMaybe<Scalars['Time']['input']>;
  recordedBefore?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['UserID']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type QueryUsersArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  admins?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  humans?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Sort>;
  usernames?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryVirtualRegistriesContainerRegistryArgs = {
  id: Scalars['VirtualRegistriesContainerRegistryID']['input'];
};


export type QueryVirtualRegistriesPackagesMavenRegistryArgs = {
  id: Scalars['VirtualRegistriesPackagesMavenRegistryID']['input'];
};


export type QueryVirtualRegistriesPackagesMavenUpstreamArgs = {
  id: Scalars['VirtualRegistriesPackagesMavenUpstreamID']['input'];
};


export type QueryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']['input']>>;
  dismissalReason?: InputMaybe<Array<VulnerabilityDismissalReason>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasAiResolution?: InputMaybe<Scalars['Boolean']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  hasMergeRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasRemediations?: InputMaybe<Scalars['Boolean']['input']>;
  hasResolution?: InputMaybe<Scalars['Boolean']['input']>;
  identifierName?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  owaspTopTen?: InputMaybe<Array<VulnerabilityOwaspTop10>>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']['input']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']['input']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type QueryVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['ISO8601Date']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['ISO8601Date']['input'];
};


export type QueryVulnerabilityArgs = {
  id: Scalars['VulnerabilityID']['input'];
};


export type QueryWikiPageArgs = {
  namespaceId?: InputMaybe<Scalars['NamespaceID']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWorkItemArgs = {
  id: Scalars['WorkItemID']['input'];
};


export type QueryWorkItemAllowedStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWorkItemDescriptionTemplateContentArgs = {
  templateContentInput: WorkItemDescriptionTemplateContentInput;
};


export type QueryWorkItemsByReferenceArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  contextNamespacePath?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  refs: Array<Scalars['String']['input']>;
};


export type QueryWorkspaceArgs = {
  id: Scalars['RemoteDevelopmentWorkspaceID']['input'];
};


export type QueryWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
  userIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

export type QueryComplexity = {
  __typename?: 'QueryComplexity';
  /** GraphQL query complexity limit. */
  limit?: Maybe<Scalars['Int']['output']>;
  /** GraphQL query complexity score. */
  score?: Maybe<Scalars['Int']['output']>;
};

/** Aggregated statistics about queueing times for CI jobs */
export type QueueingDelayHistory = {
  __typename?: 'QueueingDelayHistory';
  /** Time series. */
  timeSeries?: Maybe<Array<QueueingHistoryTimeSeries>>;
};

/** The amount of time for a job to be picked up by a runner, in percentiles. */
export type QueueingHistoryTimeSeries = {
  __typename?: 'QueueingHistoryTimeSeries';
  /** 50th percentile. 50% of the durations are lower than this value. */
  p50?: Maybe<Scalars['Duration']['output']>;
  /** 75th percentile. 75% of the durations are lower than this value. */
  p75?: Maybe<Scalars['Duration']['output']>;
  /** 90th percentile. 90% of the durations are lower than this value. */
  p90?: Maybe<Scalars['Duration']['output']>;
  /** 95th percentile. 95% of the durations are lower than this value. */
  p95?: Maybe<Scalars['Duration']['output']>;
  /** 99th percentile. 99% of the durations are lower than this value. */
  p99?: Maybe<Scalars['Duration']['output']>;
  /** Start of the time interval. */
  time: Scalars['Time']['output'];
};

export type QuickActionsStatus = {
  __typename?: 'QuickActionsStatus';
  /** Quick action command names. */
  commandNames?: Maybe<Array<Scalars['String']['output']>>;
  /** Returns true if only quick action commands were in the note. */
  commandsOnly?: Maybe<Scalars['Boolean']['output']>;
  /** Error messages from quick actions that failed to apply. */
  errorMessages?: Maybe<Array<Scalars['String']['output']>>;
  /** Response messages from quick actions. */
  messages?: Maybe<Array<Scalars['String']['output']>>;
};

/** Dependency reachability status */
export type ReachabilityType =
  /** Dependency is imported and in use. */
  | 'IN_USE'
  /** Dependency is not in use. */
  | 'NOT_FOUND'
  /** Dependency reachability status is not available. */
  | 'UNKNOWN';

/** Recent failure history of a test case. */
export type RecentFailures = {
  __typename?: 'RecentFailures';
  /** Name of the base branch of the project. */
  baseBranch?: Maybe<Scalars['String']['output']>;
  /** Number of times the test case has failed in the past 14 days. */
  count?: Maybe<Scalars['Int']['output']>;
};

export type RecentlyViewedItem = {
  __typename?: 'RecentlyViewedItem';
  /** Recently viewed item. */
  item: RecentlyViewedItemUnion;
  /** When the item was last viewed. */
  viewedAt: Scalars['Time']['output'];
};

export type RecentlyViewedItemUnion = Epic | Issue | MergeRequest;

/** Type of ref */
export type RefType =
  /** Ref type for branches. */
  | 'HEADS'
  /** Ref type for tags. */
  | 'TAGS';

/** Autogenerated input type of RefreshFindingTokenStatus */
export type RefreshFindingTokenStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Vulnerability whose token status should be refreshed. */
  vulnerabilityId: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of RefreshFindingTokenStatus. */
export type RefreshFindingTokenStatusPayload = {
  __typename?: 'RefreshFindingTokenStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated token status record for the given finding. */
  findingTokenStatus?: Maybe<VulnerabilityFindingTokenStatus>;
};

/** Autogenerated input type of RefreshSecurityFindingTokenStatus */
export type RefreshSecurityFindingTokenStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the Security::Finding whose token status should be refreshed (MR context). */
  securityFindingUuid: Scalars['String']['input'];
};

/** Autogenerated return type of RefreshSecurityFindingTokenStatus. */
export type RefreshSecurityFindingTokenStatusPayload = {
  __typename?: 'RefreshSecurityFindingTokenStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated token status record for the given Security::Finding. */
  findingTokenStatus?: Maybe<SecurityFindingTokenStatus>;
};

/** Autogenerated input type of RefreshStandardsAdherenceChecks */
export type RefreshStandardsAdherenceChecksInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Group path. */
  groupPath: Scalars['ID']['input'];
};

/** Autogenerated return type of RefreshStandardsAdherenceChecks. */
export type RefreshStandardsAdherenceChecksPayload = {
  __typename?: 'RefreshStandardsAdherenceChecksPayload';
  /** Progress of standards adherence checks. */
  adherenceChecksStatus?: Maybe<StandardsAdherenceChecksStatus>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of RefreshVulnerabilityFindingTokenStatus */
export type RefreshVulnerabilityFindingTokenStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Vulnerability whose token status should be refreshed. */
  vulnerabilityId: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of RefreshVulnerabilityFindingTokenStatus. */
export type RefreshVulnerabilityFindingTokenStatusPayload = {
  __typename?: 'RefreshVulnerabilityFindingTokenStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated token status record for the given Vulnerabilities::Finding. */
  findingTokenStatus?: Maybe<VulnerabilityFindingTokenStatus>;
};

export type Registrable = CiSecureFileRegistry | ContainerRepositoryRegistry | DependencyProxyBlobRegistry | DependencyProxyManifestRegistry | DesignManagementRepositoryRegistry | GroupWikiRepositoryRegistry | JobArtifactRegistry | LfsObjectRegistry | MergeRequestDiffRegistry | PackageFileRegistry | PackagesNugetSymbolRegistry | PagesDeploymentRegistry | PipelineArtifactRegistry | ProjectRepositoryRegistry | ProjectWikiRepositoryRegistry | SnippetRepositoryRegistry | TerraformStateVersionRegistry | UploadRegistry;

export type RegistryInterface = {
  /** Description of the virtual registry. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the virtual registry. */
  id: Scalars['ID']['output'];
  /** Name of the virtual registry. */
  name: Scalars['String']['output'];
  /** Timestamp of when the virtual registry was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** State of a Geo registry */
export type RegistryState =
  /** Registry that failed to sync. */
  | 'FAILED'
  /** Registry waiting to be synced. */
  | 'PENDING'
  /** Registry currently syncing. */
  | 'STARTED'
  /** Registry that is synced. */
  | 'SYNCED';

/** Relationship of the policies to resync. */
export type RelationshipType =
  /** Policies defined for the project/group only. */
  | 'DIRECT'
  /** Policies defined for the project/group and ancestor groups. */
  | 'INHERITED';

/** The position to which the object should be moved */
export type RelativePositionType =
  /** Object is moved after an adjacent object. */
  | 'AFTER'
  /** Object is moved before an adjacent object. */
  | 'BEFORE';

/** Represents a release */
export type Release = {
  __typename?: 'Release';
  /** Assets of the release. */
  assets?: Maybe<ReleaseAssets>;
  /** User that created the release. */
  author?: Maybe<UserCore>;
  /** Commit associated with the release. */
  commit?: Maybe<Commit>;
  /** Timestamp of when the release was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Description (also known as "release notes") of the release. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Evidence for the release. */
  evidences?: Maybe<ReleaseEvidenceConnection>;
  /** Indicates the release is a historical release. */
  historicalRelease?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the release. */
  id: Scalars['ReleaseID']['output'];
  /** Links of the release. */
  links?: Maybe<ReleaseLinks>;
  /** Milestones associated to the release. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the release. */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the release was released. */
  releasedAt?: Maybe<Scalars['Time']['output']>;
  /** Name of the tag associated with the release. */
  tagName?: Maybe<Scalars['String']['output']>;
  /** Relative web path to the tag associated with the release. */
  tagPath?: Maybe<Scalars['String']['output']>;
  /** Indicates the release is an upcoming release. */
  upcomingRelease?: Maybe<Scalars['Boolean']['output']>;
};


/** Represents a release */
export type ReleaseEvidencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a release */
export type ReleaseMilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an asset link associated with a release */
export type ReleaseAssetLink = {
  __typename?: 'ReleaseAssetLink';
  /** Relative path for the direct asset link. */
  directAssetPath?: Maybe<Scalars['String']['output']>;
  /** Direct asset URL of the link. */
  directAssetUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the link. */
  id: Scalars['ID']['output'];
  /** Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`. */
  linkType?: Maybe<ReleaseAssetLinkType>;
  /** Name of the link. */
  name?: Maybe<Scalars['String']['output']>;
  /** URL of the link. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ReleaseAssetLink. */
export type ReleaseAssetLinkConnection = {
  __typename?: 'ReleaseAssetLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseAssetLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseAssetLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ReleaseAssetLinkCreate */
export type ReleaseAssetLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']['input']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name: Scalars['String']['input'];
  /** Full path of the project the asset link is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Name of the associated release's tag. */
  tagName: Scalars['String']['input'];
  /** URL of the asset link. */
  url: Scalars['String']['input'];
};

/** Autogenerated return type of ReleaseAssetLinkCreate. */
export type ReleaseAssetLinkCreatePayload = {
  __typename?: 'ReleaseAssetLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** Autogenerated input type of ReleaseAssetLinkDelete */
export type ReleaseAssetLinkDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the release asset link to delete. */
  id: Scalars['ReleasesLinkID']['input'];
};

/** Autogenerated return type of ReleaseAssetLinkDelete. */
export type ReleaseAssetLinkDeletePayload = {
  __typename?: 'ReleaseAssetLinkDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted release asset link. */
  link?: Maybe<ReleaseAssetLink>;
};

/** An edge in a connection. */
export type ReleaseAssetLinkEdge = {
  __typename?: 'ReleaseAssetLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseAssetLink>;
};

/** Fields that are available when modifying a release asset link */
export type ReleaseAssetLinkInput = {
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']['input']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name: Scalars['String']['input'];
  /** URL of the asset link. */
  url: Scalars['String']['input'];
};

/** Type of the link: `other`, `runbook`, `image`, `package` */
export type ReleaseAssetLinkType =
  /** Image link type */
  | 'IMAGE'
  /** Other link type */
  | 'OTHER'
  /** Package link type */
  | 'PACKAGE'
  /** Runbook link type */
  | 'RUNBOOK';

/** Autogenerated input type of ReleaseAssetLinkUpdate */
export type ReleaseAssetLinkUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']['input']>;
  /** ID of the release asset link to update. */
  id: Scalars['ReleasesLinkID']['input'];
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** URL of the asset link. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ReleaseAssetLinkUpdate. */
export type ReleaseAssetLinkUpdatePayload = {
  __typename?: 'ReleaseAssetLinkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** A container for all assets associated with a release */
export type ReleaseAssets = {
  __typename?: 'ReleaseAssets';
  /** Number of assets of the release. */
  count?: Maybe<Scalars['Int']['output']>;
  /** Asset links of the release. */
  links?: Maybe<ReleaseAssetLinkConnection>;
  /** Sources of the release. */
  sources?: Maybe<ReleaseSourceConnection>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsSourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Fields that are available when modifying release assets */
export type ReleaseAssetsInput = {
  /** List of asset links to associate to the release. */
  links?: InputMaybe<Array<ReleaseAssetLinkInput>>;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: 'ReleaseConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Release. */
export type ReleaseConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ReleaseCreate */
export type ReleaseCreateInput = {
  /** Assets associated to the release. */
  assets?: InputMaybe<ReleaseAssetsInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description (also known as "release notes") of the release. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Commit SHA or branch name to use if creating a new tag. */
  ref?: InputMaybe<Scalars['String']['input']>;
  /** Date and time for the release. Defaults to the current time. Expected in ISO 8601 format (`2019-03-15T08:00:00Z`). Only provide this field if creating an upcoming or historical release. */
  releasedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Message to use if creating a new annotated tag. */
  tagMessage?: InputMaybe<Scalars['String']['input']>;
  /** Name of the tag to associate with the release. */
  tagName: Scalars['String']['input'];
};

/** Autogenerated return type of ReleaseCreate. */
export type ReleaseCreatePayload = {
  __typename?: 'ReleaseCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of ReleaseDelete */
export type ReleaseDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Name of the tag associated with the release to delete. */
  tagName: Scalars['String']['input'];
};

/** Autogenerated return type of ReleaseDelete. */
export type ReleaseDeletePayload = {
  __typename?: 'ReleaseDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted release. */
  release?: Maybe<Release>;
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: 'ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Evidence for a release */
export type ReleaseEvidence = {
  __typename?: 'ReleaseEvidence';
  /** Timestamp when the evidence was collected. */
  collectedAt?: Maybe<Scalars['Time']['output']>;
  /** URL from where the evidence can be downloaded. */
  filepath?: Maybe<Scalars['String']['output']>;
  /** ID of the evidence. */
  id: Scalars['ID']['output'];
  /** SHA1 ID of the evidence hash. */
  sha?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ReleaseEvidence. */
export type ReleaseEvidenceConnection = {
  __typename?: 'ReleaseEvidenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEvidenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseEvidence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseEvidenceEdge = {
  __typename?: 'ReleaseEvidenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseEvidence>;
};

export type ReleaseLinks = {
  __typename?: 'ReleaseLinks';
  /** HTTP URL of the issues page, filtered by the release and `state=closed`. */
  closedIssuesUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the merge request page, filtered by the release and `state=closed`. */
  closedMergeRequestsUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the release's edit page. */
  editUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the merge request page, filtered by the release and `state=merged`. */
  mergedMergeRequestsUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the issues page, filtered by the release and `state=open`. */
  openedIssuesUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the merge request page, filtered by the release and `state=open`. */
  openedMergeRequestsUrl?: Maybe<Scalars['String']['output']>;
  /** HTTP URL of the release. */
  selfUrl?: Maybe<Scalars['String']['output']>;
};

/** Values for sorting releases */
export type ReleaseSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Released at by ascending order. */
  | 'RELEASED_AT_ASC'
  /** Released at by descending order. */
  | 'RELEASED_AT_DESC';

/** Represents the source code attached to a release in a particular format */
export type ReleaseSource = {
  __typename?: 'ReleaseSource';
  /** Format of the source. */
  format?: Maybe<Scalars['String']['output']>;
  /** Download URL of the source. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ReleaseSource. */
export type ReleaseSourceConnection = {
  __typename?: 'ReleaseSourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseSourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseSource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseSourceEdge = {
  __typename?: 'ReleaseSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseSource>;
};

/** Release tag ID wildcard values */
export type ReleaseTagWildcardId =
  /** Release tag is assigned. */
  | 'ANY'
  /** No release tag is assigned. */
  | 'NONE';

/** Autogenerated input type of ReleaseUpdate */
export type ReleaseUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description (release notes) of the release. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Release date. */
  releasedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Name of the tag associated with the release. */
  tagName: Scalars['String']['input'];
};

/** Autogenerated return type of ReleaseUpdate. */
export type ReleaseUpdatePayload = {
  __typename?: 'ReleaseUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of RemoveProjectFromSecurityDashboard */
export type RemoveProjectFromSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project to remove from the Instance Security Dashboard. */
  id: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of RemoveProjectFromSecurityDashboard. */
export type RemoveProjectFromSecurityDashboardPayload = {
  __typename?: 'RemoveProjectFromSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type ReplicationStateEnum =
  /** Replication process finished but failed. */
  | 'FAILED'
  /** Replication process has not started. */
  | 'PENDING'
  /** Replication process is in progress. */
  | 'STARTED'
  /** Replication process finished successfully. */
  | 'SYNCED';

/** Autogenerated input type of RepositionImageDiffNote */
export type RepositionImageDiffNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the DiffNote to update. */
  id: Scalars['DiffNoteID']['input'];
  /** Position of the note on a diff. */
  position: UpdateDiffImagePositionInput;
};

/** Autogenerated return type of RepositionImageDiffNote. */
export type RepositionImageDiffNotePayload = {
  __typename?: 'RepositionImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

export type Repository = {
  __typename?: 'Repository';
  /** Blobs contained within the repository */
  blobs?: Maybe<RepositoryBlobConnection>;
  /** Names of branches available in this repository that match the search pattern. */
  branchNames?: Maybe<Array<Scalars['String']['output']>>;
  /** Path to CODEOWNERS file in a ref. */
  codeOwnersPath?: Maybe<Scalars['String']['output']>;
  /** Commit from the repository. */
  commit?: Maybe<Commit>;
  /**
   * List of commits from the repository. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  commits?: Maybe<CommitConnection>;
  /** Shows a disk path of the repository. */
  diskPath?: Maybe<Scalars['String']['output']>;
  /** Indicates repository has no visible content. */
  empty: Scalars['Boolean']['output'];
  /** Indicates a corresponding Git repository exists on disk. */
  exists: Scalars['Boolean']['output'];
  /** The last commit made in the repository for the given path and ref. */
  lastCommit?: Maybe<Commit>;
  /** Paginated tree of the repository. */
  paginatedTree?: Maybe<TreeConnection>;
  /** Default branch of the repository. */
  rootRef?: Maybe<Scalars['String']['output']>;
  /** Tree of the repository. */
  tree?: Maybe<Tree>;
  /** Shows linting errors in the CODEOWNER file of the repository. */
  validateCodeownerFile?: Maybe<RepositoryCodeownerValidation>;
};


export type RepositoryBlobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  paths: Array<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryBranchNamesArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  searchPattern: Scalars['String']['input'];
};


export type RepositoryCodeOwnersPathArgs = {
  ref?: InputMaybe<Scalars['String']['input']>;
};


export type RepositoryCommitArgs = {
  ref: Scalars['String']['input'];
};


export type RepositoryCommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  committedAfter?: InputMaybe<Scalars['Time']['input']>;
  committedBefore?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  ref: Scalars['String']['input'];
};


export type RepositoryLastCommitArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryPaginatedTreeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  recursive?: InputMaybe<Scalars['Boolean']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryTreeArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
  recursive?: InputMaybe<Scalars['Boolean']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryValidateCodeownerFileArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
};

export type RepositoryBlob = {
  __typename?: 'RepositoryBlob';
  /** Whether the current project is archived. */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Content of blob is encoded base64. Returns `null` if the `unicode_escaped_data` feature flag is disabled. Introduced in GitLab 17.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.1.
   */
  base64EncodedBlob?: Maybe<Scalars['String']['output']>;
  /**
   * Blob blame. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  blame?: Maybe<Blame>;
  /** Web path to blob blame page. */
  blamePath?: Maybe<Scalars['String']['output']>;
  /** Whether the current user can push to the branch. */
  canCurrentUserPushToBranch?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the current user can modify the blob. */
  canModifyBlob?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the current user can modify the blob with Web IDE. */
  canModifyBlobWithWebIde: Scalars['Boolean']['output'];
  /** Web path for code navigation. */
  codeNavigationPath?: Maybe<Scalars['String']['output']>;
  /** List of code owners for the blob. */
  codeOwners?: Maybe<Array<UserCore>>;
  /** Web path to edit the blob in the old-style editor. */
  editBlobPath?: Maybe<Scalars['String']['output']>;
  /** Web path to blob on an environment. */
  environmentExternalUrlForRouteMap?: Maybe<Scalars['String']['output']>;
  /** Environment on which the blob is available. */
  environmentFormattedExternalUrl?: Maybe<Scalars['String']['output']>;
  /** External storage being used, if enabled (for instance, 'LFS'). */
  externalStorage?: Maybe<Scalars['String']['output']>;
  /** Web path to download the raw blob via external storage, if enabled. */
  externalStorageUrl?: Maybe<Scalars['String']['output']>;
  /** Expected format of the blob based on the extension. */
  fileType?: Maybe<Scalars['String']['output']>;
  /** Web path to find file. */
  findFilePath?: Maybe<Scalars['String']['output']>;
  /** Web path to edit the blob using a forked project. */
  forkAndEditPath?: Maybe<Scalars['String']['output']>;
  /** Web path to view the blob using a forked project. */
  forkAndViewPath?: Maybe<Scalars['String']['output']>;
  /** URL to the blob within Ona. */
  gitpodBlobUrl?: Maybe<Scalars['String']['output']>;
  /** Web path to blob history page. */
  historyPath?: Maybe<Scalars['String']['output']>;
  /** ID of the blob. */
  id: Scalars['ID']['output'];
  /** Web path to edit the blob in the Web IDE. */
  ideEditPath?: Maybe<Scalars['String']['output']>;
  /** Web path to edit the blob in the Web IDE using a forked project. */
  ideForkAndEditPath?: Maybe<Scalars['String']['output']>;
  /** Blob language. */
  language?: Maybe<Scalars['String']['output']>;
  /** LFS OID of the blob. */
  lfsOid?: Maybe<Scalars['String']['output']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']['output']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']['output']>;
  /** OID of the blob. */
  oid: Scalars['String']['output'];
  /** Path of the blob. */
  path: Scalars['String']['output'];
  /** Web path to blob permalink. */
  permalinkPath?: Maybe<Scalars['String']['output']>;
  /** Web path to edit .gitlab-ci.yml file. */
  pipelineEditorPath?: Maybe<Scalars['String']['output']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']['output']>;
  /** Web path for the root of the blob. */
  projectBlobPathRoot?: Maybe<Scalars['String']['output']>;
  /** Raw content of the blob. */
  rawBlob?: Maybe<Scalars['String']['output']>;
  /** Web path to download the raw blob. */
  rawPath?: Maybe<Scalars['String']['output']>;
  /** Size (in bytes) of the blob, or the blob target if stored externally. */
  rawSize?: Maybe<Scalars['BigInt']['output']>;
  /** Raw content of the blob, if the blob is text data. */
  rawTextBlob?: Maybe<Scalars['String']['output']>;
  /** Web path to replace the blob content. */
  replacePath?: Maybe<Scalars['String']['output']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<BlobViewer>;
  /** Indicator to show Duo Agent Platform action. */
  showDuoWorkflowAction?: Maybe<Scalars['Boolean']['output']>;
  /** Blob content simple viewer. */
  simpleViewer: BlobViewer;
  /** Size (in bytes) of the blob. */
  size?: Maybe<Scalars['BigInt']['output']>;
  /** Whether the blob's content is stored externally (for instance, in LFS). */
  storedExternally?: Maybe<Scalars['Boolean']['output']>;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']['output']>;
};


export type RepositoryBlobBlameArgs = {
  fromLine?: InputMaybe<Scalars['Int']['input']>;
  ignoreRevs?: InputMaybe<Scalars['Boolean']['input']>;
  toLine?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RepositoryBlob. */
export type RepositoryBlobConnection = {
  __typename?: 'RepositoryBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RepositoryBlobEdge = {
  __typename?: 'RepositoryBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryBlob>;
};

export type RepositoryCodeownerError = {
  __typename?: 'RepositoryCodeownerError';
  /** Linting error code. */
  code: Scalars['String']['output'];
  /** Lines where the error occurred. */
  lines: Array<Scalars['Int']['output']>;
};

export type RepositoryCodeownerValidation = {
  __typename?: 'RepositoryCodeownerValidation';
  /** Total number of validation error in the file. */
  total: Scalars['Int']['output'];
  /** Specific lint error code. */
  validationErrors: Array<RepositoryCodeownerError>;
};

export type RepositoryLanguage = {
  __typename?: 'RepositoryLanguage';
  /** Color to visualize the repository language. */
  color?: Maybe<Scalars['Color']['output']>;
  /** Name of the repository language. */
  name: Scalars['String']['output'];
  /** Percentage of the repository's languages. */
  share?: Maybe<Scalars['Float']['output']>;
};

/** Represents a requirement */
export type Requirement = {
  __typename?: 'Requirement';
  /** Author of the requirement. */
  author: UserCore;
  /** Timestamp of when the requirement was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the requirement. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description`. */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** ID of the requirement. */
  id: Scalars['ID']['output'];
  /**
   * Internal ID of the requirement. Deprecated in GitLab 15.8: Use work_item_iid instead.
   * @deprecated Use work_item_iid instead. Deprecated in GitLab 15.8.
   */
  iid: Scalars['String']['output'];
  /** Indicates if latest test report was created by user. */
  lastTestReportManuallyCreated?: Maybe<Scalars['Boolean']['output']>;
  /** Latest requirement test report state. */
  lastTestReportState?: Maybe<TestReportState>;
  /** Project to which the requirement belongs. */
  project: Project;
  /** State of the requirement. */
  state: RequirementState;
  /** Test reports of the requirement. */
  testReports?: Maybe<TestReportConnection>;
  /** Title of the requirement. */
  title?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `title`. */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the requirement was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: RequirementPermissions;
  /** Work item IID of the requirement, will replace current IID as identifier soon. */
  workItemIid: Scalars['String']['output'];
};


/** Represents a requirement */
export type RequirementTestReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Sort>;
};

/** The connection type for Requirement. */
export type RequirementConnection = {
  __typename?: 'RequirementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RequirementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Requirement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Compliance control coverage statistics across all requirements. */
export type RequirementControlCoverage = {
  __typename?: 'RequirementControlCoverage';
  /** Number of controls that failed compliance checks. */
  failed: Scalars['Int']['output'];
  /** Number of controls that passed compliance checks. */
  passed: Scalars['Int']['output'];
  /** Number of controls pending evaluation. */
  pending: Scalars['Int']['output'];
};

/** Coverage statistics requirements. */
export type RequirementCoverage = {
  __typename?: 'RequirementCoverage';
  /** Count of failed requirements. */
  failed: Scalars['Int']['output'];
  /** Count of passed requirements. */
  passed: Scalars['Int']['output'];
  /** Count of pending requirements. */
  pending: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RequirementEdge = {
  __typename?: 'RequirementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Requirement>;
};

export type RequirementLegacyFilterInput = {
  /** List of legacy requirement IIDs of work items. or example `["1", "2"]`. */
  legacyIids: Array<Scalars['String']['input']>;
};

/** Check permissions for the current user on a requirement */
export type RequirementPermissions = {
  __typename?: 'RequirementPermissions';
  /** If `true`, the user can perform `admin_requirement` on this resource */
  adminRequirement: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_requirement` on this resource */
  createRequirement: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_requirement` on this resource */
  destroyRequirement: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_requirement` on this resource */
  readRequirement: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_requirement` on this resource */
  updateRequirement: Scalars['Boolean']['output'];
};

/** State of a requirement */
export type RequirementState =
  /** Archived requirement. */
  | 'ARCHIVED'
  /** Open requirement. */
  | 'OPENED';

/** Counts of requirements by their state */
export type RequirementStatesCount = {
  __typename?: 'RequirementStatesCount';
  /** Number of archived requirements. */
  archived?: Maybe<Scalars['Int']['output']>;
  /** Number of opened requirements. */
  opened?: Maybe<Scalars['Int']['output']>;
};

/** Status of a requirement based on last test report */
export type RequirementStatusFilter =
  /** Failed test report. */
  | 'FAILED'
  /** Requirements without any test report. */
  | 'MISSING'
  /** Passed test report. */
  | 'PASSED';

export type ResolvableInterface = {
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean']['output'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean']['output'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};

/** Process mode for resource groups */
export type ResourceGroupsProcessMode =
  /** Newest first. */
  | 'NEWEST_FIRST'
  /** Newest ready first. */
  | 'NEWEST_READY_FIRST'
  /** Oldest first. */
  | 'OLDEST_FIRST'
  /** Unordered. */
  | 'UNORDERED';

/** Resource quotas of a workspace. */
export type ResourceQuotas = {
  __typename?: 'ResourceQuotas';
  /** Number of cpu cores. */
  cpu: Scalars['String']['output'];
  /** Bytes of memory. */
  memory: Scalars['String']['output'];
};

/** Autogenerated input type of RestorePagesDeployment */
export type RestorePagesDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the Pages Deployment. */
  id: Scalars['PagesDeploymentID']['input'];
};

/** Autogenerated return type of RestorePagesDeployment. */
export type RestorePagesDeploymentPayload = {
  __typename?: 'RestorePagesDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Restored Pages Deployment. */
  pagesDeployment: PagesDeployment;
};

/** Autogenerated input type of ResyncSecurityPolicies */
export type ResyncSecurityPoliciesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group. */
  fullPath: Scalars['String']['input'];
  /** Relationship of the policies to resync. */
  relationship?: InputMaybe<RelationshipType>;
};

/** Autogenerated return type of ResyncSecurityPolicies. */
export type ResyncSecurityPoliciesPayload = {
  __typename?: 'ResyncSecurityPoliciesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Reviewer ID wildcard values */
export type ReviewerWildcardId =
  /** Any reviewer is assigned. */
  | 'ANY'
  /** No reviewer is assigned. */
  | 'NONE';

/** Risk factors contributing to the total risk score */
export type RiskFactors = {
  __typename?: 'RiskFactors';
  /**
   * Factor based on average vulnerability score. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  vulnerabilitiesAverageScore?: Maybe<VulnerabilityAverageScoreFactor>;
};

/** Risk rating levels based on score ranges */
export type RiskRating =
  /** Critical risk (76100). */
  | 'CRITICAL'
  /** High risk (5175). */
  | 'HIGH'
  /** Low risk (025). */
  | 'LOW'
  /** Medium risk (2650). */
  | 'MEDIUM'
  /** Unknown risk level. */
  | 'UNKNOWN';

/** Total risk score information */
export type RiskScore = {
  __typename?: 'RiskScore';
  /**
   * Risk scores grouped by project. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  byProject?: Maybe<RiskScoreByProjectConnection>;
  /**
   * Risk factors contributing to the score. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  factors?: Maybe<RiskFactors>;
  /**
   * Total number of projects with risk scores. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Overall risk rating. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rating: RiskRating;
  /**
   * Overall risk score. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  score: Scalars['Float']['output'];
};


/** Total risk score information */
export type RiskScoreByProjectArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Risk score information for a specific project. */
export type RiskScoreByProject = {
  __typename?: 'RiskScoreByProject';
  /**
   * Risk score belongs to the project. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  project?: Maybe<Project>;
  /**
   * Risk rating for the project. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rating?: Maybe<RiskRating>;
  /**
   * Risk score for the project. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  score?: Maybe<Scalars['Float']['output']>;
};

/** The connection type for RiskScoreByProject. */
export type RiskScoreByProjectConnection = {
  __typename?: 'RiskScoreByProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RiskScoreByProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RiskScoreByProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RiskScoreByProjectEdge = {
  __typename?: 'RiskScoreByProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RiskScoreByProject>;
};

export type RoleInterface = {
  /** Role description. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * URL path to the role details webpage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  detailsPath?: Maybe<Scalars['String']['output']>;
  /** Role ID. */
  id: Scalars['ID']['output'];
  /** Role name. */
  name?: Maybe<Scalars['String']['output']>;
};

export type RootStorageStatistics = {
  __typename?: 'RootStorageStatistics';
  /** CI artifacts size in bytes. */
  buildArtifactsSize: Scalars['Float']['output'];
  /** Container registry size in bytes. */
  containerRegistrySize: Scalars['Float']['output'];
  /** Indicates whether the deduplicated container registry size for the namespace is an estimated value or not. */
  containerRegistrySizeIsEstimated: Scalars['Boolean']['output'];
  /**
   * Total storage in bytes with any applicable cost factor for forks applied. This will equal storage_size if there is no applicable cost factor. Introduced in GitLab 16.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.2.
   */
  costFactoredStorageSize: Scalars['Float']['output'];
  /** Dependency Proxy sizes in bytes. */
  dependencyProxySize: Scalars['Float']['output'];
  /** LFS objects size in bytes. */
  lfsObjectsSize: Scalars['Float']['output'];
  /** Packages size in bytes. */
  packagesSize: Scalars['Float']['output'];
  /** CI pipeline artifacts size in bytes. */
  pipelineArtifactsSize: Scalars['Float']['output'];
  /**
   * Indicates whether the deduplicated container registry size for the namespace is an estimated value or not. Deprecated in GitLab 16.2: Use `container_registry_size_is_estimated`.
   * @deprecated Use `container_registry_size_is_estimated`. Deprecated in GitLab 16.2.
   */
  registrySizeEstimated: Scalars['Boolean']['output'];
  /** Git repository size in bytes. */
  repositorySize: Scalars['Float']['output'];
  /** Snippets size in bytes. */
  snippetsSize: Scalars['Float']['output'];
  /** Total storage in bytes. */
  storageSize: Scalars['Float']['output'];
  /** Uploads size in bytes. */
  uploadsSize: Scalars['Float']['output'];
  /** Wiki size in bytes. */
  wikiSize: Scalars['Float']['output'];
};

export type RunnerArchitecture = {
  __typename?: 'RunnerArchitecture';
  /** Download location for the runner for the platform architecture. */
  downloadLocation: Scalars['String']['output'];
  /** Name of the runner platform architecture. */
  name: Scalars['String']['output'];
};

/** The connection type for RunnerArchitecture. */
export type RunnerArchitectureConnection = {
  __typename?: 'RunnerArchitectureConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerArchitectureEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerArchitecture>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerArchitectureEdge = {
  __typename?: 'RunnerArchitectureEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerArchitecture>;
};

/** Autogenerated input type of RunnerAssignToProject */
export type RunnerAssignToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to which the runner will be assigned. */
  projectPath: Scalars['ID']['input'];
  /** ID of the runner to assign to the project . */
  runnerId: Scalars['CiRunnerID']['input'];
};

/** Autogenerated return type of RunnerAssignToProject. */
export type RunnerAssignToProjectPayload = {
  __typename?: 'RunnerAssignToProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of RunnerBulkPause */
export type RunnerBulkPauseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of the runners to pause or unpause. */
  ids: Array<Scalars['CiRunnerID']['input']>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused: Scalars['Boolean']['input'];
};

/** Autogenerated return type of RunnerBulkPause. */
export type RunnerBulkPausePayload = {
  __typename?: 'RunnerBulkPausePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Number of records effectively updated. Only present if operation was performed synchronously. */
  updatedCount?: Maybe<Scalars['Int']['output']>;
  /** Runners after mutation. */
  updatedRunners?: Maybe<Array<CiRunner>>;
};

/** Autogenerated input type of RunnerCacheClear */
export type RunnerCacheClearInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the project that will have its runner cache cleared. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of RunnerCacheClear. */
export type RunnerCacheClearPayload = {
  __typename?: 'RunnerCacheClearPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of RunnerCreate */
export type RunnerCreateInput = {
  /** Access level of the runner. */
  accessLevel?: InputMaybe<CiRunnerAccessLevel>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the runner. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the group that the runner is created in (valid only for group runner). */
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  /** Indicates the runner is locked. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: InputMaybe<Scalars['String']['input']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: InputMaybe<Scalars['Int']['input']>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the project that the runner is created in (valid only for project runner). */
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged?: InputMaybe<Scalars['Boolean']['input']>;
  /** Type of the runner to create. */
  runnerType: CiRunnerType;
  /** Tags associated with the runner. */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of RunnerCreate. */
export type RunnerCreatePayload = {
  __typename?: 'RunnerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Runner after mutation. */
  runner?: Maybe<CiRunner>;
};

/** Autogenerated input type of RunnerDelete */
export type RunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the runner to delete. */
  id: Scalars['CiRunnerID']['input'];
};

/** Autogenerated return type of RunnerDelete. */
export type RunnerDeletePayload = {
  __typename?: 'RunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type RunnerPermissions = {
  __typename?: 'RunnerPermissions';
  /** If `true`, the user can perform `assign_runner` on this resource */
  assignRunner: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `delete_runner` on this resource */
  deleteRunner: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_runner` on this resource */
  readRunner: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_runner` on this resource */
  updateRunner: Scalars['Boolean']['output'];
};

export type RunnerPlatform = {
  __typename?: 'RunnerPlatform';
  /** Runner architectures supported for the platform. */
  architectures?: Maybe<RunnerArchitectureConnection>;
  /** Human readable name of the runner platform. */
  humanReadableName: Scalars['String']['output'];
  /** Name slug of the runner platform. */
  name: Scalars['String']['output'];
};


export type RunnerPlatformArchitecturesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RunnerPlatform. */
export type RunnerPlatformConnection = {
  __typename?: 'RunnerPlatformConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerPlatformEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerPlatform>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerPlatformEdge = {
  __typename?: 'RunnerPlatformEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerPlatform>;
};

export type RunnerSetup = {
  __typename?: 'RunnerSetup';
  /** Instructions for installing the runner on the specified architecture. */
  installInstructions: Scalars['String']['output'];
  /** Instructions for registering the runner. The actual registration tokens are not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown. */
  registerInstructions?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RunnerUnassignFromProject */
export type RunnerUnassignFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project from which the runner will be unassigned. */
  projectPath: Scalars['ID']['input'];
  /** ID of the runner to unassign from the project. */
  runnerId: Scalars['CiRunnerID']['input'];
};

/** Autogenerated return type of RunnerUnassignFromProject. */
export type RunnerUnassignFromProjectPayload = {
  __typename?: 'RunnerUnassignFromProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of RunnerUpdate */
export type RunnerUpdateInput = {
  /** Access level of the runner. */
  accessLevel?: InputMaybe<CiRunnerAccessLevel>;
  /** Projects associated with the runner. Available only for project runners. */
  associatedProjects?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the runner. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the runner to update. */
  id: Scalars['CiRunnerID']['input'];
  /** Indicates the runner is locked. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: InputMaybe<Scalars['String']['input']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: InputMaybe<Scalars['Int']['input']>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged?: InputMaybe<Scalars['Boolean']['input']>;
  /** Tags associated with the runner. */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of RunnerUpdate. */
export type RunnerUpdatePayload = {
  __typename?: 'RunnerUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Runner after mutation. */
  runner?: Maybe<CiRunner>;
};

/** Autogenerated input type of RunnersExportUsage */
export type RunnersExportUsageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UTC start date of the period to report on. Defaults to the start of last full month. */
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** Filter jobs by the full path of the group or project they belong to. For example, `gitlab-org` or `gitlab-org/gitlab`. Available only to administrators and users with the Maintainer role for the group (when a group is specified), or project (when a project is specified). Limited to runners from 5000 child projects. */
  fullPath?: InputMaybe<Scalars['ID']['input']>;
  /** Maximum number of projects to return. All other runner usage will be attributed to an `<Other projects>` entry. Defaults to 1000 projects. */
  maxProjectCount?: InputMaybe<Scalars['Int']['input']>;
  /** Scope of the runners to include in the report. */
  runnerType?: InputMaybe<CiRunnerType>;
  /**
   * UTC end date of the period to report on. " \
   *             "Defaults to the end of the month specified by `fromDate`.
   */
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};

/** Autogenerated return type of RunnersExportUsage. */
export type RunnersExportUsagePayload = {
  __typename?: 'RunnersExportUsagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of RunnersRegistrationTokenReset */
export type RunnersRegistrationTokenResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project or group to reset the token for. Omit if resetting instance runner token. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Scope of the object to reset the token for. */
  type: CiRunnerType;
};

/** Autogenerated return type of RunnersRegistrationTokenReset. */
export type RunnersRegistrationTokenResetPayload = {
  __typename?: 'RunnersRegistrationTokenResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Runner token after mutation. */
  token?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SafeDisablePipelineVariables */
export type SafeDisablePipelineVariablesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group to disable pipeline variables for. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of SafeDisablePipelineVariables. */
export type SafeDisablePipelineVariablesPayload = {
  __typename?: 'SafeDisablePipelineVariablesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Indicates whether the migration was successfully enqueued. */
  success: Scalars['Boolean']['output'];
};

/** Represents a CI configuration of SAST */
export type SastCiConfiguration = {
  __typename?: 'SastCiConfiguration';
  /** List of analyzers entities attached to SAST configuration. */
  analyzers?: Maybe<SastCiConfigurationAnalyzersEntityConnection>;
  /** List of global entities related to SAST configuration. */
  global?: Maybe<SastCiConfigurationEntityConnection>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationAnalyzersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationGlobalArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationPipelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntity = {
  __typename?: 'SastCiConfigurationAnalyzersEntity';
  /** Analyzer description that is displayed on the form. */
  description?: Maybe<Scalars['String']['output']>;
  /** Indicates whether an analyzer is enabled. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** Analyzer label used in the config UI. */
  label?: Maybe<Scalars['String']['output']>;
  /** Name of the analyzer. */
  name?: Maybe<Scalars['String']['output']>;
  /** List of supported variables. */
  variables?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for SastCiConfigurationAnalyzersEntity. */
export type SastCiConfigurationAnalyzersEntityConnection = {
  __typename?: 'SastCiConfigurationAnalyzersEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationAnalyzersEntityEdge = {
  __typename?: 'SastCiConfigurationAnalyzersEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationAnalyzersEntity>;
};

/** Represents the analyzers entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityInput = {
  /** State of the analyzer. */
  enabled: Scalars['Boolean']['input'];
  /** Name of analyzer. */
  name: Scalars['String']['input'];
  /** List of variables for the analyzer. */
  variables?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntity = {
  __typename?: 'SastCiConfigurationEntity';
  /** Default value that is used if value is empty. */
  defaultValue?: Maybe<Scalars['String']['output']>;
  /** Entity description that is displayed on the form. */
  description?: Maybe<Scalars['String']['output']>;
  /** CI keyword of entity. */
  field?: Maybe<Scalars['String']['output']>;
  /** Label for entity used in the form. */
  label?: Maybe<Scalars['String']['output']>;
  /** Different possible values of the field. */
  options?: Maybe<SastCiConfigurationOptionsEntityConnection>;
  /** Size of the UI component. */
  size?: Maybe<SastUiComponentSize>;
  /** Type of the field value. */
  type?: Maybe<Scalars['String']['output']>;
  /** Current value of the entity. */
  value?: Maybe<Scalars['String']['output']>;
};


/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityOptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for SastCiConfigurationEntity. */
export type SastCiConfigurationEntityConnection = {
  __typename?: 'SastCiConfigurationEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationEntityEdge = {
  __typename?: 'SastCiConfigurationEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationEntity>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityInput = {
  /** Default value that is used if value is empty. */
  defaultValue: Scalars['String']['input'];
  /** CI keyword of entity. */
  field: Scalars['String']['input'];
  /** Current value of the entity. */
  value: Scalars['String']['input'];
};

/** Represents a CI configuration of SAST */
export type SastCiConfigurationInput = {
  /** List of analyzers and related variables for the SAST configuration. */
  analyzers?: InputMaybe<Array<SastCiConfigurationAnalyzersEntityInput>>;
  /** List of global entities related to SAST configuration. */
  global?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
};

/** Represents an entity for options in SAST CI configuration */
export type SastCiConfigurationOptionsEntity = {
  __typename?: 'SastCiConfigurationOptionsEntity';
  /** Label of option entity. */
  label?: Maybe<Scalars['String']['output']>;
  /** Value of option entity. */
  value?: Maybe<Scalars['String']['output']>;
};

/** The connection type for SastCiConfigurationOptionsEntity. */
export type SastCiConfigurationOptionsEntityConnection = {
  __typename?: 'SastCiConfigurationOptionsEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationOptionsEntityEdge = {
  __typename?: 'SastCiConfigurationOptionsEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationOptionsEntity>;
};

/** Size of UI component in SAST configuration page */
export type SastUiComponentSize =
  /** Size of UI component in SAST configuration page is large. */
  | 'LARGE'
  /** Size of UI component in SAST configuration page is medium. */
  | 'MEDIUM'
  /** Size of UI component in SAST configuration page is small. */
  | 'SMALL';

export type SavedReply = {
  __typename?: 'SavedReply';
  /** Content of the saved reply. */
  content: Scalars['String']['output'];
  /** Global ID of the user saved reply. */
  id: Scalars['UsersSavedReplyID']['output'];
  /** Name of the saved reply. */
  name: Scalars['String']['output'];
};

/** The connection type for SavedReply. */
export type SavedReplyConnection = {
  __typename?: 'SavedReplyConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for SavedReply. */
export type SavedReplyConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of SavedReplyCreate */
export type SavedReplyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of SavedReplyCreate. */
export type SavedReplyCreatePayload = {
  __typename?: 'SavedReplyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyDestroy */
export type SavedReplyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the user saved reply. */
  id: Scalars['UsersSavedReplyID']['input'];
};

/** Autogenerated return type of SavedReplyDestroy. */
export type SavedReplyDestroyPayload = {
  __typename?: 'SavedReplyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** An edge in a connection. */
export type SavedReplyEdge = {
  __typename?: 'SavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyUpdate */
export type SavedReplyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Content of the saved reply. */
  content: Scalars['String']['input'];
  /** Global ID of the user saved reply. */
  id: Scalars['UsersSavedReplyID']['input'];
  /** Name of the saved reply. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of SavedReplyUpdate. */
export type SavedReplyUpdatePayload = {
  __typename?: 'SavedReplyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Values for sbom source types */
export type SbomSourceType =
  /** Source Type: container_scanning. */
  | 'CONTAINER_SCANNING'
  /** Source Type: container_scanning_for_registry. */
  | 'CONTAINER_SCANNING_FOR_REGISTRY'
  /** Source Type: dependency_scanning. */
  | 'DEPENDENCY_SCANNING'
  /** Enum source nil. */
  | 'NIL_SOURCE';

/** Represents the security scan information */
export type Scan = {
  __typename?: 'Scan';
  /** List of errors. */
  errors: Array<Scalars['String']['output']>;
  /** Name of the scan. */
  name: Scalars['String']['output'];
  /** Indicates the status of the scan. */
  status: ScanStatus;
  /** List of warnings. */
  warnings: Array<Scalars['String']['output']>;
};

/** The connection type for Scan. */
export type ScanConnection = {
  __typename?: 'ScanConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Scan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanEdge = {
  __typename?: 'ScanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Scan>;
};

/** Represents the scan execution policy */
export type ScanExecutionPolicy = OrchestrationPolicy & {
  __typename?: 'ScanExecutionPolicy';
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /**
   * All deprecated properties in the policy. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  deprecatedProperties?: Maybe<Array<Scalars['String']['output']>>;
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** Represents policy fields related to the scan execution policy. */
export type ScanExecutionPolicyAttributesType = {
  __typename?: 'ScanExecutionPolicyAttributesType';
  /**
   * All deprecated properties in the policy. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  deprecatedProperties?: Maybe<Array<Scalars['String']['output']>>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
};

/** Autogenerated input type of ScanExecutionPolicyCommit */
export type ScanExecutionPolicyCommitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  fullPath?: InputMaybe<Scalars['String']['input']>;
  /** Name of the policy. If the name is null, the `name` field from `policy_yaml` is used. */
  name: Scalars['String']['input'];
  /** Changes the operation mode. */
  operationMode: MutationOperationMode;
  /** YAML snippet of the policy. */
  policyYaml: Scalars['String']['input'];
};

/** Autogenerated return type of ScanExecutionPolicyCommit. */
export type ScanExecutionPolicyCommitPayload = {
  __typename?: 'ScanExecutionPolicyCommitPayload';
  /** Name of the branch to which the policy changes are committed. */
  branch?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Validation errors encountered during execution of the mutation. */
  validationErrors?: Maybe<Array<SecurityPolicyValidationError>>;
};

/** The connection type for ScanExecutionPolicy. */
export type ScanExecutionPolicyConnection = {
  __typename?: 'ScanExecutionPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanExecutionPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanExecutionPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanExecutionPolicyEdge = {
  __typename?: 'ScanExecutionPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanExecutionPolicy>;
};

/** Options for filtering by scan mode. */
export type ScanModeEnum =
  /** Return results from all scans. */
  | 'ALL'
  /** Return results from full scans. */
  | 'FULL'
  /** Return results from partial scans. */
  | 'PARTIAL';

/** A scan profile. */
export type ScanProfileType = {
  __typename?: 'ScanProfileType';
  /** Timestamp of when the scan profile was created. */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Description of the security scan profile. */
  description: Scalars['String']['output'];
  /** Indicates whether the scan profile is a default profile. */
  gitlabRecommended: Scalars['Boolean']['output'];
  /** Global ID of the security scan profile. */
  id?: Maybe<Scalars['SecurityScanProfileID']['output']>;
  /** Name of the security scan profile. */
  name: Scalars['String']['output'];
  /** Scan profile type. */
  scanType: SecurityScanProfileType;
  /** Timestamp of when the scan profile was last updated. */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Represents the scan result policy */
export type ScanResultPolicy = OrchestrationPolicy & {
  __typename?: 'ScanResultPolicy';
  /** Multiple approvers action. */
  actionApprovers?: Maybe<Array<PolicyApproversType>>;
  /** All potential approvers of the group type, including groups inaccessible to the user. */
  allGroupApprovers?: Maybe<Array<PolicyApprovalGroup>>;
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Approvers of the custom role type. Users belonging to these role(s) alone will be approvers. */
  customRoles?: Maybe<Array<MemberRole>>;
  /**
   * All deprecated properties in the policy. Introduced in GitLab 16.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.10.
   */
  deprecatedProperties?: Maybe<Array<Scalars['String']['output']>>;
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Enforcement type of the policy. Can be "enforce" or "warn". */
  enforcementType?: Maybe<PolicyEnforcementType>;
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Approvers of the role type. Users belonging to these role(s) alone will be approvers. */
  roleApprovers?: Maybe<Array<MemberAccessLevelName>>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Approvers of the user type. */
  userApprovers?: Maybe<Array<UserCore>>;
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** The connection type for ScanResultPolicy. */
export type ScanResultPolicyConnection = {
  __typename?: 'ScanResultPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanResultPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanResultPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanResultPolicyEdge = {
  __typename?: 'ScanResultPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanResultPolicy>;
};

/** The status of the security scan */
export type ScanStatus =
  /** The scan has been created. */
  | 'CREATED'
  /** The related CI build failed. */
  | 'JOB_FAILED'
  /** Report couldn't be prepared. */
  | 'PREPARATION_FAILED'
  /** Preparing the report for the scan. */
  | 'PREPARING'
  /** Report for the scan has been removed from the database. */
  | 'PURGED'
  /** The report artifact provided by the CI build couldn't be parsed. */
  | 'REPORT_ERROR'
  /** The report has been successfully prepared. */
  | 'SUCCEEDED';

/** Represents a resource scanned by a security scan */
export type ScannedResource = {
  __typename?: 'ScannedResource';
  /** HTTP request method used to access the URL. */
  requestMethod?: Maybe<Scalars['String']['output']>;
  /** URL scanned by the scanner. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ScannedResource. */
export type ScannedResourceConnection = {
  __typename?: 'ScannedResourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScannedResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScannedResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScannedResourceEdge = {
  __typename?: 'ScannedResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ScannedResource>;
};

/** JSON structure of a matched chunk */
export type SearchBlobChunk = {
  __typename?: 'SearchBlobChunk';
  /**
   * Path of the file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  lines?: Maybe<Array<SearchBlobLine>>;
  /**
   * Number of matches in the chunk. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  matchCountInChunk?: Maybe<Scalars['Int']['output']>;
};

/** JSON structure of a file with matches */
export type SearchBlobFileType = {
  __typename?: 'SearchBlobFileType';
  /**
   * Blame URL of the file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  blameUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Maximum matches per file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  chunks?: Maybe<Array<SearchBlobChunk>>;
  /**
   * URL of the file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Language of the file. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  language?: Maybe<Scalars['String']['output']>;
  /**
   * Matches per file up to a max of 50 chunks.             Default is 3 Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  matchCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Total number of matches per file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  matchCountTotal?: Maybe<Scalars['Int']['output']>;
  /**
   * Path of the file. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  path?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the project. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  projectPath?: Maybe<Scalars['String']['output']>;
};

/** JSON structure of each line in a matched chunk */
export type SearchBlobLine = {
  __typename?: 'SearchBlobLine';
  /**
   * Column numbers of the first and last highlighted characters on a line. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  highlights?: Maybe<Array<Array<Scalars['Int']['output']>>>;
  /**
   * Line number of the blob. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  lineNumber?: Maybe<Scalars['Int']['output']>;
  /**
   * Text content of the blob. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  text?: Maybe<Scalars['String']['output']>;
};

/** Level of search */
export type SearchLevel =
  /** Global search including all groups and projects. */
  | 'GLOBAL'
  /** Group search. */
  | 'GROUP'
  /** Project search. */
  | 'PROJECT';

/** Type of search */
export type SearchType =
  /** Advanced search. */
  | 'ADVANCED'
  /** Basic search. */
  | 'BASIC'
  /** Exact code search. */
  | 'ZOEKT';

/** Representation of a secret permission. */
export type SecretPermission = {
  __typename?: 'SecretPermission';
  /** Actions that can be performed on secrets. */
  actions: Array<SecretsManagementAction>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: Maybe<Scalars['ISO8601Date']['output']>;
  /** User who created the Secret Permission. */
  grantedBy?: Maybe<UserCore>;
  /** Permissions to be provided. ['create', 'update', 'read', 'delete']. */
  permissions: Scalars['String']['output'];
  /** Who is provided access to. For eg: User/Role/MemberRole/Group. */
  principal: Principal;
  /** Project the secret permission belong to. */
  project: Project;
};

/** The connection type for SecretPermission. */
export type SecretPermissionConnection = {
  __typename?: 'SecretPermissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecretPermissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecretPermission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of SecretPermissionDelete */
export type SecretPermissionDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whose permission to be deleted. */
  principal: PrincipalInput;
  /** Project permissions for the secret. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of SecretPermissionDelete. */
export type SecretPermissionDeletePayload = {
  __typename?: 'SecretPermissionDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted Secret Permission. */
  secretPermission?: Maybe<SecretPermission>;
};

/** An edge in a connection. */
export type SecretPermissionEdge = {
  __typename?: 'SecretPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SecretPermission>;
};

/** Autogenerated input type of SecretPermissionUpdate */
export type SecretPermissionUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date for Secret Permission (optional). */
  expiredAt?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** Permissions to be provided. ['create', 'update', 'read', 'delete']. */
  permissions: Array<Scalars['String']['input']>;
  /** User/MemberRole/Role/Group that is provided access. */
  principal: PrincipalInput;
  /** Project to which the permissions are added. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of SecretPermissionUpdate. */
export type SecretPermissionUpdatePayload = {
  __typename?: 'SecretPermissionUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Secret Permission that was created. */
  secretPermission?: Maybe<SecretPermission>;
};

/** Rotation configuration and status for a project secret. */
export type SecretRotationInfo = {
  __typename?: 'SecretRotationInfo';
  /** When the rotation configuration was created. */
  createdAt: Scalars['Time']['output'];
  /** When the last rotation reminder was sent. */
  lastReminderAt?: Maybe<Scalars['Time']['output']>;
  /** When the next rotation reminder will be sent. */
  nextReminderAt: Scalars['Time']['output'];
  /** Number of days between rotation reminders. */
  rotationIntervalDays: Scalars['Int']['output'];
  /** Current rotation status. */
  status: SecretRotationStatus;
  /** When the rotation configuration was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Status of secret rotation */
export type SecretRotationStatus =
  /** Rotation is due within 7 days. */
  | 'APPROACHING'
  /** Rotation is not due soon. */
  | 'OK'
  /** Rotation is overdue (reminder was sent). */
  | 'OVERDUE';

/** Actions that can be performed on secrets */
export type SecretsManagementAction =
  /** Delete secrets. */
  | 'DELETE'
  /** Read secrets. */
  | 'READ'
  /** Create and update secrets. */
  | 'WRITE';

/** A security attribute */
export type SecurityAttribute = {
  __typename?: 'SecurityAttribute';
  /** Color of the security attribute. */
  color: Scalars['Color']['output'];
  /** Description of the security attribute. */
  description?: Maybe<Scalars['String']['output']>;
  /** Editable state of the security attribute. */
  editableState: SecurityCategoryEditableState;
  /** Global ID of the security attribute. */
  id: Scalars['SecurityAttributeID']['output'];
  /** Name of the security attribute. */
  name: Scalars['String']['output'];
  /** Security category the attribute belongs to. */
  securityCategory: SecurityCategory;
};

/** Mode for bulk updating security attributes */
export type SecurityAttributeBulkUpdateMode =
  /** Add attributes to projects (keeps existing attributes). */
  | 'ADD'
  /** Remove attributes from projects. */
  | 'REMOVE'
  /** Replace all existing attributes with the specified attributes. */
  | 'REPLACE';

/** The connection type for SecurityAttribute. */
export type SecurityAttributeConnection = {
  __typename?: 'SecurityAttributeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityAttributeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityAttribute>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of SecurityAttributeCreate */
export type SecurityAttributeCreateInput = {
  /** Attributes to create. */
  attributes: Array<SecurityAttributeInput>;
  /** Global ID of the security category. */
  categoryId: Scalars['SecurityCategoryID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the namespace. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of SecurityAttributeCreate. */
export type SecurityAttributeCreatePayload = {
  __typename?: 'SecurityAttributeCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created security attributes. */
  securityAttributes?: Maybe<Array<SecurityAttribute>>;
};

/** Autogenerated input type of SecurityAttributeDestroy */
export type SecurityAttributeDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the security attribute to destroy. */
  id: Scalars['SecurityAttributeID']['input'];
};

/** Autogenerated return type of SecurityAttributeDestroy. */
export type SecurityAttributeDestroyPayload = {
  __typename?: 'SecurityAttributeDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Global ID of the destroyed security attribute. */
  deletedAttributeGid?: Maybe<Scalars['SecurityAttributeID']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type SecurityAttributeEdge = {
  __typename?: 'SecurityAttributeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityAttribute>;
};

/** Input type for security attribute */
export type SecurityAttributeInput = {
  /** Color of the security attribute. */
  color: Scalars['Color']['input'];
  /** Description of the security attribute. */
  description: Scalars['String']['input'];
  /** Name of the security attribute. */
  name: Scalars['String']['input'];
};

/** Autogenerated input type of SecurityAttributeProjectUpdate */
export type SecurityAttributeProjectUpdateInput = {
  /** Global IDs of the security attributes to add to the project. */
  addAttributeIds?: InputMaybe<Array<Scalars['SecurityAttributeID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the project. */
  projectId: Scalars['ProjectID']['input'];
  /** Global IDs of the security attributes to remove from the project. */
  removeAttributeIds?: InputMaybe<Array<Scalars['SecurityAttributeID']['input']>>;
};

/** Autogenerated return type of SecurityAttributeProjectUpdate. */
export type SecurityAttributeProjectUpdatePayload = {
  __typename?: 'SecurityAttributeProjectUpdatePayload';
  /** Number of attributes added. */
  addedCount?: Maybe<Scalars['Int']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated project. */
  project?: Maybe<Project>;
  /** Number of attributes removed. */
  removedCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of SecurityAttributeUpdate */
export type SecurityAttributeUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Color of the security attribute. */
  color?: InputMaybe<Scalars['Color']['input']>;
  /** Description of the security attribute. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the security attribute. */
  id: Scalars['SecurityAttributeID']['input'];
  /** Name of the security attribute. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of SecurityAttributeUpdate. */
export type SecurityAttributeUpdatePayload = {
  __typename?: 'SecurityAttributeUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated security attribute. */
  securityAttribute?: Maybe<SecurityAttribute>;
};

/** A security category */
export type SecurityCategory = {
  __typename?: 'SecurityCategory';
  /** Description of the security category. */
  description?: Maybe<Scalars['String']['output']>;
  /** Editable state of the security category. */
  editableState: SecurityCategoryEditableState;
  /** Global ID of the security category. */
  id: Scalars['SecurityCategoryID']['output'];
  /** Whether multiple attributes can be selected. */
  multipleSelection: Scalars['Boolean']['output'];
  /** Name of the security category. */
  name: Scalars['String']['output'];
  /** Security attributes belonging to the category. */
  securityAttributes?: Maybe<Array<SecurityAttribute>>;
  /** Template type for predefined categories. */
  templateType?: Maybe<SecurityCategoryTemplateType>;
};

/** Autogenerated input type of SecurityCategoryCreate */
export type SecurityCategoryCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the security category. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether multiple attributes can be selected. */
  multipleSelection?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the security category. */
  name: Scalars['String']['input'];
  /** Global ID of the category namespace. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of SecurityCategoryCreate. */
export type SecurityCategoryCreatePayload = {
  __typename?: 'SecurityCategoryCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created security category. */
  securityCategory?: Maybe<SecurityCategory>;
};

/** Autogenerated input type of SecurityCategoryDestroy */
export type SecurityCategoryDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the security category to destroy. */
  id: Scalars['SecurityCategoryID']['input'];
};

/** Autogenerated return type of SecurityCategoryDestroy. */
export type SecurityCategoryDestroyPayload = {
  __typename?: 'SecurityCategoryDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Global IDs of the deleted security attributes. */
  deletedAttributesGid?: Maybe<Array<Scalars['SecurityAttributeID']['output']>>;
  /** Global ID of the deleted security category. */
  deletedCategoryGid?: Maybe<Scalars['SecurityCategoryID']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Editable state for security categories and attributes */
export type SecurityCategoryEditableState =
  /** Editable state. */
  | 'EDITABLE'
  /** Editable attributes state. */
  | 'EDITABLE_ATTRIBUTES'
  /** Locked state. */
  | 'LOCKED';

/** Template type for predefined security categories */
export type SecurityCategoryTemplateType =
  /** Application category. */
  | 'APPLICATION'
  /** Business impact category. */
  | 'BUSINESS_IMPACT'
  /** Business unit category. */
  | 'BUSINESS_UNIT'
  /** Exposure category. */
  | 'EXPOSURE';

/** Autogenerated input type of SecurityCategoryUpdate */
export type SecurityCategoryUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the security category. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the security category. */
  id: Scalars['SecurityCategoryID']['input'];
  /** Name of the security category. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the category namespace. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of SecurityCategoryUpdate. */
export type SecurityCategoryUpdatePayload = {
  __typename?: 'SecurityCategoryUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated security category. */
  securityCategory?: Maybe<SecurityCategory>;
};

/** Autogenerated input type of SecurityFindingCreateIssue */
export type SecurityFindingCreateIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID']['input'];
  /** UUID of the security finding to be used to create an issue. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingCreateIssue. */
export type SecurityFindingCreateIssuePayload = {
  __typename?: 'SecurityFindingCreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of SecurityFindingCreateMergeRequest */
export type SecurityFindingCreateMergeRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the security finding to be used to create a merge request. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingCreateMergeRequest. */
export type SecurityFindingCreateMergeRequestPayload = {
  __typename?: 'SecurityFindingCreateMergeRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Merge Request created after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of SecurityFindingCreateVulnerability */
export type SecurityFindingCreateVulnerabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the security finding to be used to create a vulnerability. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingCreateVulnerability. */
export type SecurityFindingCreateVulnerabilityPayload = {
  __typename?: 'SecurityFindingCreateVulnerabilityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability created after mutation. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Autogenerated input type of SecurityFindingDismiss */
export type SecurityFindingDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why finding should be dismissed. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Reason why finding should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
  /** UUID of the finding to be dismissed. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingDismiss. */
export type SecurityFindingDismissPayload = {
  __typename?: 'SecurityFindingDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Dismissed finding. */
  securityFinding?: Maybe<PipelineSecurityReportFinding>;
  /** UUID of dismissed finding. */
  uuid?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SecurityFindingExternalIssueLinkCreate */
export type SecurityFindingExternalIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** External tracker type of the external issue link. */
  externalTracker: VulnerabilityExternalIssueLinkExternalTracker;
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID']['input'];
  /** UUID of the security finding to be used to create an issue. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingExternalIssueLinkCreate. */
export type SecurityFindingExternalIssueLinkCreatePayload = {
  __typename?: 'SecurityFindingExternalIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created external issue link. */
  externalIssueLink?: Maybe<VulnerabilityExternalIssueLink>;
};

/** Autogenerated input type of SecurityFindingJiraIssueFormUrlCreate */
export type SecurityFindingJiraIssueFormUrlCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID']['input'];
  /** UUID of the security finding to be used to create an issue. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingJiraIssueFormUrlCreate. */
export type SecurityFindingJiraIssueFormUrlCreatePayload = {
  __typename?: 'SecurityFindingJiraIssueFormUrlCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** URL to Jira issue creation form with pre-filled vulnerability data. */
  jiraIssueFormUrl?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SecurityFindingRevertToDetected */
export type SecurityFindingRevertToDetectedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment that explains why finding was reverted to detected status. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the finding to be dismissed. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingRevertToDetected. */
export type SecurityFindingRevertToDetectedPayload = {
  __typename?: 'SecurityFindingRevertToDetectedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Finding reverted to detected. */
  securityFinding?: Maybe<PipelineSecurityReportFinding>;
};

/** Autogenerated input type of SecurityFindingSeverityOverride */
export type SecurityFindingSeverityOverrideInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New severity value for the finding. */
  severity: VulnerabilitySeverity;
  /** UUID of the finding to modify. */
  uuid: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityFindingSeverityOverride. */
export type SecurityFindingSeverityOverridePayload = {
  __typename?: 'SecurityFindingSeverityOverridePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Finding of which the severity was modified. */
  securityFinding?: Maybe<PipelineSecurityReportFinding>;
};

/** Represents the status of a secret token found in a security finding */
export type SecurityFindingTokenStatus = {
  __typename?: 'SecurityFindingTokenStatus';
  /** When the token status was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the finding token status. */
  id: Scalars['ID']['output'];
  /** When the token was last verified with the issuing service. */
  lastVerifiedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the token (unknown, active, inactive). */
  status: VulnerabilityFindingTokenStatusState;
  /** When the token status was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Represents security metrics */
export type SecurityMetrics = {
  __typename?: 'SecurityMetrics';
  /**
   * Total risk score information.
   * This feature is currently under development and not yet available for general use Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  riskScore?: Maybe<RiskScore>;
  /**
   * Vulnerability metrics over time with filtering and grouping capabilities.
   * This feature is currently under development and not yet available for general use
   */
  vulnerabilitiesOverTime?: Maybe<VulnerabilitiesOverTimeConnection>;
  /**
   * Count of open vulnerabilities per severity level.
   * This feature is currently under development and not yet available for general use
   */
  vulnerabilitiesPerSeverity?: Maybe<VulnerabilitiesPerSeverity>;
};


/** Represents security metrics */
export type SecurityMetricsVulnerabilitiesOverTimeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['ISO8601Date']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  startDate: Scalars['ISO8601Date']['input'];
};

/** Represents a security policy */
export type SecurityPolicy = {
  __typename?: 'SecurityPolicy';
  /** ID of the security policy. */
  id: Scalars['ID']['output'];
  /** Name of the security policy. */
  name: Scalars['String']['output'];
};

/** Autogenerated input type of SecurityPolicyProjectAssign */
export type SecurityPolicyProjectAssignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']['input']>;
  /** ID of the security policy project. */
  securityPolicyProjectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of SecurityPolicyProjectAssign. */
export type SecurityPolicyProjectAssignPayload = {
  __typename?: 'SecurityPolicyProjectAssignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of SecurityPolicyProjectCreateAsync */
export type SecurityPolicyProjectCreateAsyncInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group. */
  fullPath: Scalars['String']['input'];
};

/** Autogenerated return type of SecurityPolicyProjectCreateAsync. */
export type SecurityPolicyProjectCreateAsyncPayload = {
  __typename?: 'SecurityPolicyProjectCreateAsyncPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of SecurityPolicyProjectCreate */
export type SecurityPolicyProjectCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of SecurityPolicyProjectCreate. */
export type SecurityPolicyProjectCreatePayload = {
  __typename?: 'SecurityPolicyProjectCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Security Policy Project that was created. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of SecurityPolicyProjectUnassign */
export type SecurityPolicyProjectUnassignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of SecurityPolicyProjectUnassign. */
export type SecurityPolicyProjectUnassignPayload = {
  __typename?: 'SecurityPolicyProjectUnassignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type SecurityPolicyRelationType =
  /** Policies defined for the group's descendant projects/groups only. Only valid for group policies. Policies apply only to the 50 most recently created descendant policy projects. */
  | 'DESCENDANT'
  /** Policies defined for the project/group only. */
  | 'DIRECT'
  /** Policies defined for the project/group and ancestor groups. */
  | 'INHERITED'
  /** Policies defined for the project/group's ancestor groups only. */
  | 'INHERITED_ONLY';

/** Represents a policy source. Its fields depend on the source type. */
export type SecurityPolicySource = GroupSecurityPolicySource | ProjectSecurityPolicySource;

/** Represents the security policy */
export type SecurityPolicyType = OrchestrationPolicy & {
  __typename?: 'SecurityPolicyType';
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Attributes specific to the policy type. */
  policyAttributes: PolicyAttributesUnion;
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Description of the policy type. */
  type?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** The connection type for SecurityPolicyType. */
export type SecurityPolicyTypeConnection = {
  __typename?: 'SecurityPolicyTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityPolicyTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityPolicyType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SecurityPolicyTypeEdge = {
  __typename?: 'SecurityPolicyTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityPolicyType>;
};

/** Security policy validation error */
export type SecurityPolicyValidationError = {
  __typename?: 'SecurityPolicyValidationError';
  /** Error field. */
  field: Scalars['String']['output'];
  /** Index of the errored action. */
  index?: Maybe<Scalars['Int']['output']>;
  /** Error level. */
  level: Scalars['String']['output'];
  /** Error message. */
  message: Scalars['String']['output'];
  /** Error title. */
  title?: Maybe<Scalars['String']['output']>;
};

export type SecurityPreferredLicenseSourceConfiguration =
  /** Use internal instance license database as a source of license information for dependencies. */
  | 'PMDB'
  /** Use the SBOM as a source of license information for dependencies. */
  | 'SBOM';

/** Represents summary of a security report */
export type SecurityReportSummary = {
  __typename?: 'SecurityReportSummary';
  /** Aggregated counts for the `api_fuzzing` scan */
  apiFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `cluster_image_scanning` scan */
  clusterImageScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `container_scanning` scan */
  containerScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `container_scanning_for_registry` scan */
  containerScanningForRegistry?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `coverage_fuzzing` scan */
  coverageFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dast` scan */
  dast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dependency_scanning` scan */
  dependencyScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `generic` scan */
  generic?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `sast` scan */
  sast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `secret_detection` scan */
  secretDetection?: Maybe<SecurityReportSummarySection>;
};

/** Represents a section of a summary of a security report */
export type SecurityReportSummarySection = {
  __typename?: 'SecurityReportSummarySection';
  /** List of the first 20 scanned resources. */
  scannedResources?: Maybe<ScannedResourceConnection>;
  /** Total number of scanned resources. */
  scannedResourcesCount?: Maybe<Scalars['Int']['output']>;
  /** Path to download all the scanned resources in CSV format. */
  scannedResourcesCsvPath?: Maybe<Scalars['String']['output']>;
  /** List of security scans ran for the type. */
  scans: ScanConnection;
  /** Total number of vulnerabilities. */
  vulnerabilitiesCount?: Maybe<Scalars['Int']['output']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScannedResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type SecurityReportTypeEnum =
  /** API FUZZING scan report */
  | 'API_FUZZING'
  /** CLUSTER IMAGE SCANNING scan report */
  | 'CLUSTER_IMAGE_SCANNING'
  /** CONTAINER SCANNING scan report */
  | 'CONTAINER_SCANNING'
  /** COVERAGE FUZZING scan report */
  | 'COVERAGE_FUZZING'
  /** DAST scan report */
  | 'DAST'
  /** DEPENDENCY SCANNING scan report */
  | 'DEPENDENCY_SCANNING'
  /** SAST scan report */
  | 'SAST'
  /** SAST ADVANCED scan report */
  | 'SAST_ADVANCED'
  /** SAST IAC scan report */
  | 'SAST_IAC'
  /** SECRET DETECTION scan report */
  | 'SECRET_DETECTION';

/** Scan profile type */
export type SecurityScanProfileType =
  /** Container scanning */
  | 'CONTAINER_SCANNING'
  /** Dependency scanning */
  | 'DEPENDENCY_SCANNING'
  /** Sast */
  | 'SAST'
  /** Secret detection */
  | 'SECRET_DETECTION';

/** The type of the security scanner */
export type SecurityScannerType =
  /** API fuzzing scanner */
  | 'API_FUZZING'
  /** Cluster image scanning scanner */
  | 'CLUSTER_IMAGE_SCANNING'
  /** Container scanning scanner */
  | 'CONTAINER_SCANNING'
  /** Coverage fuzzing scanner */
  | 'COVERAGE_FUZZING'
  /** DAST scanner */
  | 'DAST'
  /** Dependency scanning scanner */
  | 'DEPENDENCY_SCANNING'
  /** SAST scanner */
  | 'SAST'
  /** SAST advanced scanner */
  | 'SAST_ADVANCED'
  /** SAST IaC scanner */
  | 'SAST_IAC'
  /** Secret detection scanner */
  | 'SECRET_DETECTION';

/** Represents a list of security scanners */
export type SecurityScanners = {
  __typename?: 'SecurityScanners';
  /** List of analyzers which are available for the project. */
  available?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which are enabled for the project. */
  enabled?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which ran successfully in the latest pipeline. */
  pipelineRun?: Maybe<Array<SecurityScannerType>>;
};

/** Autogenerated input type of SecurityTrainingUpdate */
export type SecurityTrainingUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Sets the training provider as enabled for the project. */
  isEnabled: Scalars['Boolean']['input'];
  /** Sets the training provider as primary for the project. */
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
  /** ID of the provider. */
  providerId: Scalars['SecurityTrainingProviderID']['input'];
};

/** Autogenerated return type of SecurityTrainingUpdate. */
export type SecurityTrainingUpdatePayload = {
  __typename?: 'SecurityTrainingUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Represents the training entity subject to mutation. */
  training?: Maybe<ProjectSecurityTraining>;
};

/** Represents a URL related to a security training */
export type SecurityTrainingUrl = {
  __typename?: 'SecurityTrainingUrl';
  /** Name of the vulnerability identifier. */
  identifier?: Maybe<Scalars['String']['output']>;
  /** Name of the training provider. */
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the request to training provider. */
  status?: Maybe<TrainingUrlRequestStatus>;
  /** URL of the link for security training content. */
  url?: Maybe<Scalars['String']['output']>;
};

/** A Sentry error */
export type SentryDetailedError = {
  __typename?: 'SentryDetailedError';
  /** Count of occurrences. */
  count: Scalars['Int']['output'];
  /** Culprit of the error. */
  culprit: Scalars['String']['output'];
  /** External Base URL of the Sentry Instance. */
  externalBaseUrl: Scalars['String']['output'];
  /** External URL of the error. */
  externalUrl: Scalars['String']['output'];
  /** Commit the error was first seen. */
  firstReleaseLastCommit?: Maybe<Scalars['String']['output']>;
  /** Release short version the error was first seen. */
  firstReleaseShortVersion?: Maybe<Scalars['String']['output']>;
  /** Release version the error was first seen. */
  firstReleaseVersion?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time']['output'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** GitLab commit SHA attributed to the Error based on the release version. */
  gitlabCommit?: Maybe<Scalars['String']['output']>;
  /** Path to the GitLab page for the GitLab commit attributed to the error. */
  gitlabCommitPath?: Maybe<Scalars['String']['output']>;
  /** URL of GitLab Issue. */
  gitlabIssuePath?: Maybe<Scalars['String']['output']>;
  /** ID (global ID) of the error. */
  id: Scalars['ID']['output'];
  /** Error tracking backend. */
  integrated?: Maybe<Scalars['Boolean']['output']>;
  /** Commit the error was last seen. */
  lastReleaseLastCommit?: Maybe<Scalars['String']['output']>;
  /** Release short version the error was last seen. */
  lastReleaseShortVersion?: Maybe<Scalars['String']['output']>;
  /** Release version the error was last seen. */
  lastReleaseVersion?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time']['output'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']['output']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String']['output'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID']['output'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String']['output'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String']['output'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String']['output'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Tags associated with the Sentry Error. */
  tags: SentryErrorTags;
  /** Title of the error. */
  title: Scalars['String']['output'];
  /** Type of the error. */
  type: Scalars['String']['output'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int']['output'];
};

/** A Sentry error. A simplified version of SentryDetailedError */
export type SentryError = {
  __typename?: 'SentryError';
  /** Count of occurrences. */
  count: Scalars['Int']['output'];
  /** Culprit of the error. */
  culprit: Scalars['String']['output'];
  /** External URL of the error. */
  externalUrl: Scalars['String']['output'];
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time']['output'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** ID (global ID) of the error. */
  id: Scalars['ID']['output'];
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time']['output'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']['output']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String']['output'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID']['output'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String']['output'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String']['output'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String']['output'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Title of the error. */
  title: Scalars['String']['output'];
  /** Type of the error. */
  type: Scalars['String']['output'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int']['output'];
};

/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollection = {
  __typename?: 'SentryErrorCollection';
  /** Detailed version of a Sentry error on the project. */
  detailedError?: Maybe<SentryDetailedError>;
  /** Stack Trace of Sentry Error. */
  errorStackTrace?: Maybe<SentryErrorStackTrace>;
  /** Collection of Sentry Errors. */
  errors?: Maybe<SentryErrorConnection>;
  /** External URL for Sentry. */
  externalUrl?: Maybe<Scalars['String']['output']>;
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID']['input'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorStackTraceArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID']['input'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for SentryError. */
export type SentryErrorConnection = {
  __typename?: 'SentryErrorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SentryErrorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SentryError>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SentryErrorEdge = {
  __typename?: 'SentryErrorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SentryError>;
};

export type SentryErrorFrequency = {
  __typename?: 'SentryErrorFrequency';
  /** Count of errors received since the previously recorded time. */
  count: Scalars['Int']['output'];
  /** Time the error frequency stats were recorded. */
  time: Scalars['Time']['output'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTrace = {
  __typename?: 'SentryErrorStackTrace';
  /** Time the stack trace was received by Sentry. */
  dateReceived: Scalars['String']['output'];
  /** ID of the Sentry error. */
  issueId: Scalars['String']['output'];
  /** Stack trace entries for the Sentry error. */
  stackTraceEntries: Array<SentryErrorStackTraceEntry>;
};

/** An object context for a Sentry error stack trace */
export type SentryErrorStackTraceContext = {
  __typename?: 'SentryErrorStackTraceContext';
  /** Code number of the context. */
  code: Scalars['String']['output'];
  /** Line number of the context. */
  line: Scalars['Int']['output'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTraceEntry = {
  __typename?: 'SentryErrorStackTraceEntry';
  /** Function in which the Sentry error occurred. */
  col?: Maybe<Scalars['String']['output']>;
  /** File in which the Sentry error occurred. */
  fileName?: Maybe<Scalars['String']['output']>;
  /** Function in which the Sentry error occurred. */
  function?: Maybe<Scalars['String']['output']>;
  /** Function in which the Sentry error occurred. */
  line?: Maybe<Scalars['String']['output']>;
  /** Context of the Sentry error. */
  traceContext?: Maybe<Array<SentryErrorStackTraceContext>>;
};

/** State of a Sentry error */
export type SentryErrorStatus =
  /** Error has been ignored. */
  | 'IGNORED'
  /** Error has been resolved. */
  | 'RESOLVED'
  /** Error has been ignored until next release. */
  | 'RESOLVED_IN_NEXT_RELEASE'
  /** Error is unresolved. */
  | 'UNRESOLVED';

/** State of a Sentry error */
export type SentryErrorTags = {
  __typename?: 'SentryErrorTags';
  /** Severity level of the Sentry Error. */
  level?: Maybe<Scalars['String']['output']>;
  /** Logger of the Sentry Error. */
  logger?: Maybe<Scalars['String']['output']>;
};

export type Service = {
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Service. */
export type ServiceConnection = {
  __typename?: 'ServiceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ServiceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Service>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ServiceEdge = {
  __typename?: 'ServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Service>;
};

export type ServiceType =
  /** Apple App Store Connect integration */
  | 'APPLE_APP_STORE_SERVICE'
  /** Asana integration */
  | 'ASANA_SERVICE'
  /** Assembla integration */
  | 'ASSEMBLA_SERVICE'
  /** Atlassian Bamboo integration */
  | 'BAMBOO_SERVICE'
  /** Bugzilla integration */
  | 'BUGZILLA_SERVICE'
  /** Buildkite integration */
  | 'BUILDKITE_SERVICE'
  /** Campfire integration */
  | 'CAMPFIRE_SERVICE'
  /** ClickUp integration */
  | 'CLICKUP_SERVICE'
  /** Confluence Workspace integration */
  | 'CONFLUENCE_SERVICE'
  /** Custom issue tracker integration */
  | 'CUSTOM_ISSUE_TRACKER_SERVICE'
  /** Datadog integration */
  | 'DATADOG_SERVICE'
  /** Diffblue Cover integration */
  | 'DIFFBLUE_COVER_SERVICE'
  /** Discord Notifications integration */
  | 'DISCORD_SERVICE'
  /** Drone integration */
  | 'DRONE_CI_SERVICE'
  /** Emails on push integration */
  | 'EMAILS_ON_PUSH_SERVICE'
  /** EWM integration */
  | 'EWM_SERVICE'
  /** External wiki integration */
  | 'EXTERNAL_WIKI_SERVICE'
  /** GitHub integration */
  | 'GITHUB_SERVICE'
  /** GitLab for Slack app integration */
  | 'GITLAB_SLACK_APPLICATION_SERVICE'
  /** GitGuardian integration */
  | 'GIT_GUARDIAN_SERVICE'
  /** Google Artifact Management integration (SaaS only) */
  | 'GOOGLE_CLOUD_PLATFORM_ARTIFACT_REGISTRY_SERVICE'
  /** Google Cloud IAM integration (SaaS only) */
  | 'GOOGLE_CLOUD_PLATFORM_WORKLOAD_IDENTITY_FEDERATION_SERVICE'
  /** Google Play integration */
  | 'GOOGLE_PLAY_SERVICE'
  /** Google Chat integration */
  | 'HANGOUTS_CHAT_SERVICE'
  /** Harbor integration */
  | 'HARBOR_SERVICE'
  /** irker (IRC gateway) integration */
  | 'IRKER_SERVICE'
  /** Jenkins integration */
  | 'JENKINS_SERVICE'
  /** GitLab for Jira Cloud app integration */
  | 'JIRA_CLOUD_APP_SERVICE'
  /** Jira issues integration */
  | 'JIRA_SERVICE'
  /** Linear integration */
  | 'LINEAR_SERVICE'
  /** Matrix notifications integration */
  | 'MATRIX_SERVICE'
  /** Mattermost notifications integration */
  | 'MATTERMOST_SERVICE'
  /** Mattermost slash commands integration */
  | 'MATTERMOST_SLASH_COMMANDS_SERVICE'
  /** Microsoft Teams notifications integration */
  | 'MICROSOFT_TEAMS_SERVICE'
  /** Packagist integration */
  | 'PACKAGIST_SERVICE'
  /** Phorge integration */
  | 'PHORGE_SERVICE'
  /** Pipeline status emails integration */
  | 'PIPELINES_EMAIL_SERVICE'
  /** Pivotal Tracker integration */
  | 'PIVOTALTRACKER_SERVICE'
  /** Pumble integration */
  | 'PUMBLE_SERVICE'
  /** Pushover integration */
  | 'PUSHOVER_SERVICE'
  /** Redmine integration */
  | 'REDMINE_SERVICE'
  /** Slack notifications integration */
  | 'SLACK_SERVICE'
  /** Slack slash commands integration */
  | 'SLACK_SLASH_COMMANDS_SERVICE'
  /** Squash TM integration */
  | 'SQUASH_TM_SERVICE'
  /** JetBrains TeamCity integration */
  | 'TEAMCITY_SERVICE'
  /** Telegram integration */
  | 'TELEGRAM_SERVICE'
  /** Unify Circuit integration */
  | 'UNIFY_CIRCUIT_SERVICE'
  /** Webex Teams integration */
  | 'WEBEX_TEAMS_SERVICE'
  /** JetBrains YouTrack integration */
  | 'YOUTRACK_SERVICE'
  /** ZenTao integration */
  | 'ZENTAO_SERVICE';

/** Autogenerated input type of SetContainerScanningForRegistry */
export type SetContainerScanningForRegistryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired status for container scanning for registry feature. */
  enable: Scalars['Boolean']['input'];
  /** Full path of the namespace (project). */
  namespacePath: Scalars['ID']['input'];
};

/** Autogenerated return type of SetContainerScanningForRegistry. */
export type SetContainerScanningForRegistryPayload = {
  __typename?: 'SetContainerScanningForRegistryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether the feature is enabled. */
  containerScanningForRegistryEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of SetGroupSecretPushProtection */
export type SetGroupSecretPushProtectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group. */
  namespacePath: Scalars['ID']['input'];
  /** IDs of projects to exclude from the feature. */
  projectsToExclude?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Whether to enable the feature. */
  secretPushProtectionEnabled: Scalars['Boolean']['input'];
};

/** Autogenerated return type of SetGroupSecretPushProtection. */
export type SetGroupSecretPushProtectionPayload = {
  __typename?: 'SetGroupSecretPushProtectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of SetGroupValidityChecks */
export type SetGroupValidityChecksInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group. */
  namespacePath: Scalars['ID']['input'];
  /** IDs of projects to exclude from validity checks configuration. */
  projectsToExclude?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Whether to enable validity checks for all projects in the group. */
  validityChecksEnabled: Scalars['Boolean']['input'];
};

/** Autogenerated return type of SetGroupValidityChecks. */
export type SetGroupValidityChecksPayload = {
  __typename?: 'SetGroupValidityChecksPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Indicates whether validity checks have been enabled for the group. */
  validityChecksEnabled: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SetLicenseConfigurationSource */
export type SetLicenseConfigurationSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project. */
  projectPath: Scalars['ID']['input'];
  /** Preferred source of license information for dependencies. */
  source: SecurityPreferredLicenseSourceConfiguration;
};

/** Autogenerated return type of SetLicenseConfigurationSource. */
export type SetLicenseConfigurationSourcePayload = {
  __typename?: 'SetLicenseConfigurationSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Preferred source of license information for dependencies. */
  licenseConfigurationSource?: Maybe<SecurityPreferredLicenseSourceConfiguration>;
};

/** Autogenerated input type of SetPagesForceHttps */
export type SetPagesForceHttpsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Path of the project to set the pages force HTTPS. */
  projectPath: Scalars['ID']['input'];
  /** Indicates user wants to enforce HTTPS on their pages. */
  value: Scalars['Boolean']['input'];
};

/** Autogenerated return type of SetPagesForceHttps. */
export type SetPagesForceHttpsPayload = {
  __typename?: 'SetPagesForceHttpsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project that was updated. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of SetPagesUseUniqueDomain */
export type SetPagesUseUniqueDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Path of the project to set the pages to use unique domains. */
  projectPath: Scalars['ID']['input'];
  /** Indicates user wants to use unique subdomains for their pages. */
  value: Scalars['Boolean']['input'];
};

/** Autogenerated return type of SetPagesUseUniqueDomain. */
export type SetPagesUseUniqueDomainPayload = {
  __typename?: 'SetPagesUseUniqueDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Project that was updated. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of SetPreReceiveSecretDetection */
export type SetPreReceiveSecretDetectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired status for secret push protection feature. */
  enable: Scalars['Boolean']['input'];
  /** Full path of the namespace (project). */
  namespacePath: Scalars['ID']['input'];
};

/** Autogenerated return type of SetPreReceiveSecretDetection. */
export type SetPreReceiveSecretDetectionPayload = {
  __typename?: 'SetPreReceiveSecretDetectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Whether the feature is enabled. */
  preReceiveSecretDetectionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the feature is enabled. */
  secretPushProtectionEnabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of SetSecretPushProtection */
export type SetSecretPushProtectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired status for secret push protection feature. */
  enable: Scalars['Boolean']['input'];
  /** Full path of the namespace (project). */
  namespacePath: Scalars['ID']['input'];
};

/** Autogenerated return type of SetSecretPushProtection. */
export type SetSecretPushProtectionPayload = {
  __typename?: 'SetSecretPushProtectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Whether the feature is enabled. */
  preReceiveSecretDetectionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the feature is enabled. */
  secretPushProtectionEnabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of SetValidityChecks */
export type SetValidityChecksInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired status for validity checks feature. */
  enable: Scalars['Boolean']['input'];
  /** Full path of the namespace (project). */
  namespacePath: Scalars['ID']['input'];
};

/** Autogenerated return type of SetValidityChecks. */
export type SetValidityChecksPayload = {
  __typename?: 'SetValidityChecksPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Whether the feature is enabled. */
  validityChecksEnabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents a vulnerability severity override */
export type SeverityOverride = {
  __typename?: 'SeverityOverride';
  /** User who changed the severity. */
  author: UserCore;
  /** Time of severity change. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** New severity of the vulnerability. */
  newSeverity: VulnerabilitySeverity;
  /** Original severity of the vulnerability. */
  originalSeverity: VulnerabilitySeverity;
};

/** The connection type for SeverityOverride. */
export type SeverityOverrideConnection = {
  __typename?: 'SeverityOverrideConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SeverityOverrideEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SeverityOverride>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SeverityOverrideEdge = {
  __typename?: 'SeverityOverrideEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SeverityOverride>;
};

/** How to format SHA strings. */
export type ShaFormat =
  /** Unabbreviated format. */
  | 'LONG'
  /** Abbreviated format. Short SHAs are typically eight characters long. */
  | 'SHORT';

export type SharedRunnersSetting =
  /** Sharing of runners is disabled and overridable. */
  | 'DISABLED_AND_OVERRIDABLE'
  /** Sharing of runners is disabled and unoverridable. */
  | 'DISABLED_AND_UNOVERRIDABLE'
  /** Sharing of runners is enabled. */
  | 'ENABLED';

/** Duo Chat slash command */
export type SlashCommand = {
  __typename?: 'SlashCommand';
  /** Description of what the slash command does. */
  description: Scalars['String']['output'];
  /** Name of the slash command. */
  name: Scalars['String']['output'];
  /** Indicates whether the command should be submitted automatically when clicked. */
  shouldSubmit: Scalars['Boolean']['output'];
};

/** Represents a snippet entry */
export type Snippet = NoteableInterface & {
  __typename?: 'Snippet';
  /** Owner of the snippet. */
  author?: Maybe<UserCore>;
  /** Snippet blobs. */
  blobs?: Maybe<SnippetBlobConnection>;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Timestamp the snippet was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the snippet. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** File Name of the snippet. */
  fileName?: Maybe<Scalars['String']['output']>;
  /** Indicates the snippet is hidden because the author has been banned. */
  hidden: Scalars['Boolean']['output'];
  /** HTTP URL to the snippet repository. */
  httpUrlToRepo?: Maybe<Scalars['String']['output']>;
  /** ID of the snippet. */
  id: Scalars['SnippetID']['output'];
  /** Indicates whether the snippet was imported. */
  imported: Scalars['Boolean']['output'];
  /** Import source of the snippet. */
  importedFrom: ImportSource;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Project the snippet is associated with. */
  project?: Maybe<Project>;
  /** Raw URL of the snippet. */
  rawUrl: Scalars['String']['output'];
  /** SSH URL to the snippet repository. */
  sshUrlToRepo?: Maybe<Scalars['String']['output']>;
  /** Title of the snippet. */
  title: Scalars['String']['output'];
  /** Timestamp the snippet was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: SnippetPermissions;
  /** Visibility Level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
  /** Web URL of the snippet. */
  webUrl: Scalars['String']['output'];
};


/** Represents a snippet entry */
export type SnippetBlobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  paths?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** Represents a snippet entry */
export type SnippetCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a snippet entry */
export type SnippetDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a snippet entry */
export type SnippetNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the snippet blob */
export type SnippetBlob = {
  __typename?: 'SnippetBlob';
  /** Shows whether the blob is binary. */
  binary: Scalars['Boolean']['output'];
  /** Blob external storage. */
  externalStorage?: Maybe<Scalars['String']['output']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']['output']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Blob path. */
  path?: Maybe<Scalars['String']['output']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']['output']>;
  /** Blob raw content endpoint path. */
  rawPath: Scalars['String']['output'];
  /** Raw content of the blob, if the blob is text data. */
  rawPlainData?: Maybe<Scalars['String']['output']>;
  /** Shows whether the blob is rendered as text. */
  renderedAsText: Scalars['Boolean']['output'];
  /** Blob highlighted data. */
  richData?: Maybe<Scalars['String']['output']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<SnippetBlobViewer>;
  /** Blob content simple viewer. */
  simpleViewer: SnippetBlobViewer;
  /** Blob size. */
  size: Scalars['Int']['output'];
};

/** Type of a snippet blob input action */
export type SnippetBlobActionEnum =
  /** Create a snippet blob. */
  | 'create'
  /** Delete a snippet blob. */
  | 'delete'
  /** Move a snippet blob. */
  | 'move'
  /** Update a snippet blob. */
  | 'update';

/** Represents an action to perform over a snippet file */
export type SnippetBlobActionInputType = {
  /** Type of input action. */
  action: SnippetBlobActionEnum;
  /** Snippet file content. */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Path of the snippet file. */
  filePath: Scalars['String']['input'];
  /** Previous path of the snippet file. */
  previousPath?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for SnippetBlob. */
export type SnippetBlobConnection = {
  __typename?: 'SnippetBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetBlobEdge>>>;
  /** Indicates if the snippet has unretrievable blobs. */
  hasUnretrievableBlobs: Scalars['Boolean']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetBlobEdge = {
  __typename?: 'SnippetBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetBlob>;
};

/** Represents how the blob content should be displayed */
export type SnippetBlobViewer = {
  __typename?: 'SnippetBlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean']['output'];
  /** Content file type. */
  fileType: Scalars['String']['output'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean']['output'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String']['output'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']['output']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean']['output'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** The connection type for Snippet. */
export type SnippetConnection = {
  __typename?: 'SnippetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Snippet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetEdge = {
  __typename?: 'SnippetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Snippet>;
};

export type SnippetPermissions = {
  __typename?: 'SnippetPermissions';
  /** If `true`, the user can perform `admin_snippet` on this resource */
  adminSnippet: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_snippet` on this resource */
  readSnippet: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `report_snippet` on this resource */
  reportSnippet: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_snippet` on this resource */
  updateSnippet: Scalars['Boolean']['output'];
};

/** Represents the Geo sync and verification state of a snippet repository */
export type SnippetRepositoryRegistry = {
  __typename?: 'SnippetRepositoryRegistry';
  /** Indicate if the checksums of the SnippetRepositoryRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the SnippetRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the SnippetRepositoryRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the SnippetRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the SnippetRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the SnippetRepositoryRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the SnippetRepositoryRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the SnippetRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the SnippetRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** ID of the Snippet Repository. */
  snippetRepositoryId: Scalars['ID']['output'];
  /** Sync state of the SnippetRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the SnippetRepositoryRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the SnippetRepositoryRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the SnippetRepositoryRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the SnippetRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the SnippetRepositoryRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of SnippetRepositoryRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the SnippetRepositoryRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the SnippetRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for SnippetRepositoryRegistry. */
export type SnippetRepositoryRegistryConnection = {
  __typename?: 'SnippetRepositoryRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for SnippetRepositoryRegistry. */
export type SnippetRepositoryRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type SnippetRepositoryRegistryEdge = {
  __typename?: 'SnippetRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetRepositoryRegistry>;
};

/** Common sort values */
export type Sort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** Values for sort direction */
export type SortDirectionEnum =
  /** Ascending order. */
  | 'ASC'
  /** Descending order. */
  | 'DESC';

/** Values for sorting the mapping of users on source instance to users on destination instance. */
export type SourceUserSort =
  /** ID of the source user by ascending order. */
  | 'ID_ASC'
  /** ID of the source user by descending order. */
  | 'ID_DESC'
  /** Instance source name by ascending order. */
  | 'SOURCE_NAME_ASC'
  /** Instance source name by descending order. */
  | 'SOURCE_NAME_DESC'
  /** Status of the mapping by ascending order. */
  | 'STATUS_ASC'
  /** Status of the mapping by descending order. */
  | 'STATUS_DESC';

/** Squash option overrides for a protected branch */
export type SquashOption = {
  __typename?: 'SquashOption';
  /** Help text for the squash option. */
  helpText: Scalars['String']['output'];
  /** Human-readable description of the squash option. */
  option: Scalars['String']['output'];
};

/** Options for default squash behaviour for merge requests */
export type SquashOptionSetting =
  /** Allow. */
  | 'ALLOWED'
  /** Require. */
  | 'ALWAYS'
  /** Encourage. */
  | 'ENCOURAGED'
  /** Do not allow. */
  | 'NEVER';

/** SSH signature for a signed commit */
export type SshSignature = CommitSignature & {
  __typename?: 'SshSignature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']['output']>;
  /** SSH key used for the signature. */
  key?: Maybe<Key>;
  /** Fingerprint of the key. */
  keyFingerprintSha256?: Maybe<Scalars['String']['output']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

/** Represents a standard role */
export type StandardRole = MemberRoleInterface & RoleInterface & {
  __typename?: 'StandardRole';
  /** Access level as a number. */
  accessLevel: Scalars['Int']['output'];
  /** Role description. */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * URL path to the role details webpage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  detailsPath?: Maybe<Scalars['String']['output']>;
  /** Role ID. */
  id: Scalars['ID']['output'];
  /**
   * Number of times the role has been directly assigned to a group or project member. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  membersCount?: Maybe<Scalars['Int']['output']>;
  /** Role name. */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Number of users who have been directly assigned the role in at least one group or project. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  usersCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for StandardRole. */
export type StandardRoleConnection = {
  __typename?: 'StandardRoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StandardRoleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<StandardRole>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type StandardRoleEdge = {
  __typename?: 'StandardRoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<StandardRole>;
};

/** Progress of standards adherence checks */
export type StandardsAdherenceChecksStatus = {
  __typename?: 'StandardsAdherenceChecksStatus';
  /** Number of adherence checks successfully completed. */
  checksCompleted: Scalars['Int']['output'];
  /** UTC timestamp when the adherence checks scan was started. */
  startedAt: Scalars['Time']['output'];
  /** Number of adherence checks multiplied by the number of projects in the group. */
  totalChecks: Scalars['Int']['output'];
};

/** Autogenerated input type of StarProject */
export type StarProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to star or unstar. */
  projectId: Scalars['ProjectID']['input'];
  /** Indicates whether to star or unstar the project. */
  starred: Scalars['Boolean']['input'];
};

/** Autogenerated return type of StarProject. */
export type StarProjectPayload = {
  __typename?: 'StarProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Number of stars for the project. */
  count: Scalars['String']['output'];
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type StatusAction = {
  __typename?: 'StatusAction';
  /** Title for the button, for example: Retry the job. */
  buttonTitle?: Maybe<Scalars['String']['output']>;
  /**
   * Custom confirmation message for a manual job. Introduced in GitLab 17.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.0.
   */
  confirmationMessage?: Maybe<Scalars['String']['output']>;
  /** Icon used in the action button. */
  icon?: Maybe<Scalars['String']['output']>;
  /** ID for a status action. */
  id: Scalars['String']['output'];
  /** Method for the action, for example: :post. */
  method?: Maybe<Scalars['String']['output']>;
  /** Path for the action. */
  path?: Maybe<Scalars['String']['output']>;
  /** Title for the action, for example: Retry. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Input for mapping a removed status to a replacement status */
export type StatusMappingInput = {
  /** Global ID of the replacement status. */
  newStatusId: Scalars['WorkItemsStatusesStatusID']['input'];
  /** Global ID of the status being removed/replaced. */
  oldStatusId: Scalars['WorkItemsStatusesStatusID']['input'];
};

/** an expression with a string value. */
export type StringExpression = ExpressionInterface & {
  __typename?: 'StringExpression';
  /** Field the expression applies to. */
  field: Scalars['String']['output'];
  /** Operator of the expression. */
  operator: Scalars['String']['output'];
  /** String value of the expression. */
  value: Scalars['String']['output'];
};

export type Submodule = Entry & {
  __typename?: 'Submodule';
  /** Flat path of the entry. */
  flatPath: Scalars['String']['output'];
  /** ID of the entry. */
  id: Scalars['ID']['output'];
  /** Name of the entry. */
  name: Scalars['String']['output'];
  /** Path of the entry. */
  path: Scalars['String']['output'];
  /** SHA of the entry. */
  sha: Scalars['String']['output'];
  /** Tree URL for the sub-module. */
  treeUrl?: Maybe<Scalars['String']['output']>;
  /** Type of tree entry. */
  type: EntryType;
  /** Web URL for the sub-module. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Submodule. */
export type SubmoduleConnection = {
  __typename?: 'SubmoduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubmoduleEdge = {
  __typename?: 'SubmoduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Submodule>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /**
   * Triggered when a response from AI integration is received. Introduced in GitLab 15.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.11.
   */
  aiCompletionResponse?: Maybe<AiMessage>;
  /** Triggered when a job changes state. */
  ciJobProcessed?: Maybe<CiJob>;
  /** Triggered when a job status is updated. */
  ciJobStatusUpdated?: Maybe<CiJob>;
  /** Triggered when pipeline creation requests are updated for a merge request. */
  ciPipelineCreationRequestsUpdated?: Maybe<MergeRequest>;
  /**
   * Triggered when a pipeline schedule is updated. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  ciPipelineScheduleStatusUpdated?: Maybe<PipelineSchedule>;
  /**
   * Triggered when a pipeline status is updated. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  ciPipelineStatusUpdated?: Maybe<Pipeline>;
  /**
   * Triggered when any pipeline status is updated. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  ciPipelineStatusesUpdated?: Maybe<Pipeline>;
  /**
   * Triggered when jobs in a stage are updated. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  ciStageUpdated?: Maybe<CiJob>;
  /** Triggered when the assignees of an issuable are updated. */
  issuableAssigneesUpdated?: Maybe<Issuable>;
  /** Triggered when the due date or start date of an issuable is updated. */
  issuableDatesUpdated?: Maybe<Issuable>;
  /** Triggered when the description of an issuable is updated. */
  issuableDescriptionUpdated?: Maybe<Issuable>;
  /** Triggered when the epic of an issuable is updated. */
  issuableEpicUpdated?: Maybe<Issuable>;
  /** Triggered when the health status of an issuable is updated. */
  issuableHealthStatusUpdated?: Maybe<Issuable>;
  /** Triggered when the iteration of an issuable is updated. */
  issuableIterationUpdated?: Maybe<Issuable>;
  /** Triggered when the labels of an issuable are updated. */
  issuableLabelsUpdated?: Maybe<Issuable>;
  /** Triggered when the milestone of an issuable is updated. */
  issuableMilestoneUpdated?: Maybe<Issuable>;
  /** Triggered when the title of an issuable is updated. */
  issuableTitleUpdated?: Maybe<Issuable>;
  /**
   * Triggered when a todo on an issuable is updated. Introduced in GitLab 17.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.5.
   */
  issuableTodoUpdated?: Maybe<Issuable>;
  /** Triggered when the weight of an issuable is updated. */
  issuableWeightUpdated?: Maybe<Issuable>;
  /** Triggered when the crm contacts of an issuable are updated. */
  issueCrmContactsUpdated?: Maybe<Issuable>;
  /** Triggered when approval state of a merge request is updated. */
  mergeRequestApprovalStateUpdated?: Maybe<Issuable>;
  /** Triggered when a merge request diff is generated. */
  mergeRequestDiffGenerated?: Maybe<Issuable>;
  /** Triggered when the merge status of a merge request is updated. */
  mergeRequestMergeStatusUpdated?: Maybe<Issuable>;
  /** Triggered when the reviewers of a merge request are updated. */
  mergeRequestReviewersUpdated?: Maybe<Issuable>;
  /**
   * Triggered when the security policy sync updates the status. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  securityPoliciesSyncUpdated?: Maybe<PoliciesSyncUpdated>;
  /**
   * Triggered when the security policy project is created for a specific group or project. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  securityPolicyProjectCreated?: Maybe<PolicyProjectCreated>;
  /**
   * Triggered when a merge request the user is an assignee or a reviewer of is updated. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  userMergeRequestUpdated?: Maybe<MergeRequest>;
  /**
   * Triggered when a note is created. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  workItemNoteCreated?: Maybe<Note>;
  /**
   * Triggered when a note is deleted. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  workItemNoteDeleted?: Maybe<DeletedNote>;
  /**
   * Triggered when a note is updated. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  workItemNoteUpdated?: Maybe<Note>;
  /** Triggered when a work item is updated. */
  workItemUpdated?: Maybe<WorkItem>;
  /** Triggered when the checkpoints/events of a workflow is updated. */
  workflowEventsUpdated?: Maybe<DuoWorkflowEvent>;
};


export type SubscriptionAiCompletionResponseArgs = {
  agentVersionId?: InputMaybe<Scalars['AiAgentVersionID']['input']>;
  aiAction?: InputMaybe<AiAction>;
  clientSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['AiModelID']['input']>;
  userId?: InputMaybe<Scalars['UserID']['input']>;
};


export type SubscriptionCiJobProcessedArgs = {
  projectId: Scalars['ProjectID']['input'];
  withArtifacts?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionCiJobStatusUpdatedArgs = {
  jobId: Scalars['CiBuildID']['input'];
};


export type SubscriptionCiPipelineCreationRequestsUpdatedArgs = {
  mergeRequestId: Scalars['MergeRequestID']['input'];
};


export type SubscriptionCiPipelineScheduleStatusUpdatedArgs = {
  projectId: Scalars['ProjectID']['input'];
};


export type SubscriptionCiPipelineStatusUpdatedArgs = {
  pipelineId: Scalars['CiPipelineID']['input'];
};


export type SubscriptionCiPipelineStatusesUpdatedArgs = {
  projectId: Scalars['ProjectID']['input'];
};


export type SubscriptionCiStageUpdatedArgs = {
  stageId: Scalars['CiStageID']['input'];
};


export type SubscriptionIssuableAssigneesUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableDatesUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableDescriptionUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableEpicUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableHealthStatusUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableIterationUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableLabelsUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableMilestoneUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableTitleUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableTodoUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssuableWeightUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionIssueCrmContactsUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionMergeRequestApprovalStateUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionMergeRequestDiffGeneratedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionMergeRequestMergeStatusUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionMergeRequestReviewersUpdatedArgs = {
  issuableId: Scalars['IssuableID']['input'];
};


export type SubscriptionSecurityPoliciesSyncUpdatedArgs = {
  policyConfigurationId: Scalars['SecurityOrchestrationPolicyConfigurationID']['input'];
};


export type SubscriptionSecurityPolicyProjectCreatedArgs = {
  fullPath: Scalars['String']['input'];
};


export type SubscriptionUserMergeRequestUpdatedArgs = {
  userId: Scalars['UserID']['input'];
};


export type SubscriptionWorkItemNoteCreatedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']['input']>;
};


export type SubscriptionWorkItemNoteDeletedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']['input']>;
};


export type SubscriptionWorkItemNoteUpdatedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']['input']>;
};


export type SubscriptionWorkItemUpdatedArgs = {
  workItemId: Scalars['WorkItemID']['input'];
};


export type SubscriptionWorkflowEventsUpdatedArgs = {
  workflowId: Scalars['AiDuoWorkflowsWorkflowID']['input'];
};

/** Represents an entry from the future subscriptions */
export type SubscriptionFutureEntry = {
  __typename?: 'SubscriptionFutureEntry';
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']['output']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']['output']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']['output']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']['output']>;
  /** Name of the subscription plan. */
  plan: Scalars['String']['output'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']['output']>;
  /** Type of license the subscription will yield. */
  type: Scalars['String']['output'];
  /** Number of paid user seats. */
  usersInLicenseCount?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for SubscriptionFutureEntry. */
export type SubscriptionFutureEntryConnection = {
  __typename?: 'SubscriptionFutureEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubscriptionFutureEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SubscriptionFutureEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubscriptionFutureEntryEdge = {
  __typename?: 'SubscriptionFutureEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SubscriptionFutureEntry>;
};

/** Types of change for a subscription history record */
export type SubscriptionHistoryChangeType =
  /** This was the previous state before the subscription was destroyed. */
  | 'GITLAB_SUBSCRIPTION_DESTROYED'
  /** This was the previous state before the subscription was updated. */
  | 'GITLAB_SUBSCRIPTION_UPDATED';

/** Status of the subscription to an issuable. */
export type SubscriptionStatus =
  /** User is explicitly subscribed to the issuable. */
  | 'EXPLICITLY_SUBSCRIBED'
  /** User is explicitly unsubscribed from the issuable. */
  | 'EXPLICITLY_UNSUBSCRIBED';

/** Represents a Suggested Reviewers result set */
export type SuggestedReviewersType = {
  __typename?: 'SuggestedReviewersType';
  /** List of accepted reviewer usernames. */
  accepted?: Maybe<Array<Scalars['String']['output']>>;
  /** Timestamp of when the suggestions were created. */
  createdAt: Scalars['Time']['output'];
  /** List of suggested reviewer usernames. */
  suggested: Array<Scalars['String']['output']>;
  /** Timestamp of when the suggestions were updated. */
  updatedAt: Scalars['Time']['output'];
};

export type SystemNoteMetadata = {
  __typename?: 'SystemNoteMetadata';
  /** System note metadata action. */
  action?: Maybe<Scalars['String']['output']>;
  /** Version of the changed description. */
  descriptionVersion?: Maybe<DescriptionVersion>;
  /** Global ID of the specific system note metadata. */
  id: Scalars['SystemNoteMetadataID']['output'];
};

export type Tag = {
  __typename?: 'Tag';
  /** Commit for the tag. */
  commit?: Maybe<Commit>;
  /** Tagging message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Name of the tag. */
  name: Scalars['String']['output'];
};

/** Autogenerated input type of TagCreate */
export type TagCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Tagging message. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Name of the tag. */
  name: Scalars['String']['input'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID']['input'];
  /** Tag name or commit SHA to create tag from. */
  ref: Scalars['String']['input'];
};

/** Autogenerated return type of TagCreate. */
export type TagCreatePayload = {
  __typename?: 'TagCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Tag after mutation. */
  tag?: Maybe<Tag>;
};

/** Autogenerated input type of TagDelete */
export type TagDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the tag. */
  name: Scalars['String']['input'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of TagDelete. */
export type TagDeletePayload = {
  __typename?: 'TagDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Tag after mutation. */
  tag?: Maybe<Tag>;
};

/** Completion status of tasks */
export type TaskCompletionStatus = {
  __typename?: 'TaskCompletionStatus';
  /** Number of completed tasks. */
  completedCount: Scalars['Int']['output'];
  /** Number of total tasks. */
  count: Scalars['Int']['output'];
};

/** Terraform module metadata */
export type TerraformModuleMetadata = {
  __typename?: 'TerraformModuleMetadata';
  /** Timestamp of when the metadata was created. */
  createdAt: Scalars['Time']['output'];
  /** Fields of the metadata. */
  fields: TerraformModuleMetadataFields;
  /** ID of the metadata. */
  id: Scalars['PackagesTerraformModuleMetadatumID']['output'];
  /** Timestamp of when the metadata was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Terraform module metadata dependencies */
export type TerraformModuleMetadataDependencies = {
  __typename?: 'TerraformModuleMetadataDependencies';
  /** Modules of the module. */
  modules?: Maybe<Array<TerraformModuleMetadataDependency>>;
  /** Providers of the module. */
  providers?: Maybe<Array<TerraformModuleMetadataDependency>>;
};

/** Terraform module metadata dependency */
export type TerraformModuleMetadataDependency = {
  __typename?: 'TerraformModuleMetadataDependency';
  /** Name of the dependency. */
  name: Scalars['String']['output'];
  /** Source of the dependency. */
  source?: Maybe<Scalars['String']['output']>;
  /** Version of the dependency. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Terraform module metadata example */
export type TerraformModuleMetadataExample = TerraformModuleMetadataSharedFields & {
  __typename?: 'TerraformModuleMetadataExample';
  /** Inputs of the module. */
  inputs?: Maybe<Array<TerraformModuleMetadataInput>>;
  /** Name of the example. */
  name: Scalars['String']['output'];
  /** Outputs of the module. */
  outputs?: Maybe<Array<TerraformModuleMetadataOutput>>;
  /** Readme data. */
  readme?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `readme` */
  readmeHtml?: Maybe<Scalars['String']['output']>;
};

/** Terraform module metadata fields type */
export type TerraformModuleMetadataFields = {
  __typename?: 'TerraformModuleMetadataFields';
  /** Examples of the module. */
  examples?: Maybe<Array<TerraformModuleMetadataExample>>;
  /** Root module. */
  root: TerraformModuleMetadataRoot;
  /** Submodules of the module. */
  submodules?: Maybe<Array<TerraformModuleMetadataSubmodule>>;
};

/** Terraform module metadata input type */
export type TerraformModuleMetadataInput = {
  __typename?: 'TerraformModuleMetadataInput';
  /** Default value of the input. */
  default?: Maybe<Scalars['String']['output']>;
  /** Description of the input. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the input. */
  name: Scalars['String']['output'];
  /** Type of the input. */
  type: Scalars['String']['output'];
};

/** Terraform module metadata output */
export type TerraformModuleMetadataOutput = {
  __typename?: 'TerraformModuleMetadataOutput';
  /** Description of the output field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the output field. */
  name: Scalars['String']['output'];
};

/** Metadata for Terraform root module */
export type TerraformModuleMetadataRoot = TerraformModuleMetadataSharedFields & {
  __typename?: 'TerraformModuleMetadataRoot';
  /** Dependencies of the module. */
  dependencies?: Maybe<TerraformModuleMetadataDependencies>;
  /** Inputs of the module. */
  inputs?: Maybe<Array<TerraformModuleMetadataInput>>;
  /** Outputs of the module. */
  outputs?: Maybe<Array<TerraformModuleMetadataOutput>>;
  /** Readme data. */
  readme?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `readme` */
  readmeHtml?: Maybe<Scalars['String']['output']>;
  /** Resources of the module. */
  resources?: Maybe<Array<Scalars['String']['output']>>;
};

export type TerraformModuleMetadataSharedFields = {
  /** Inputs of the module. */
  inputs?: Maybe<Array<TerraformModuleMetadataInput>>;
  /** Outputs of the module. */
  outputs?: Maybe<Array<TerraformModuleMetadataOutput>>;
  /** Readme data. */
  readme?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `readme` */
  readmeHtml?: Maybe<Scalars['String']['output']>;
};

/** Terraform module metadata submodule */
export type TerraformModuleMetadataSubmodule = TerraformModuleMetadataSharedFields & {
  __typename?: 'TerraformModuleMetadataSubmodule';
  /** Dependencies of the submodule. */
  dependencies?: Maybe<TerraformModuleMetadataDependencies>;
  /** Inputs of the module. */
  inputs?: Maybe<Array<TerraformModuleMetadataInput>>;
  /** Name of the submodule. */
  name: Scalars['String']['output'];
  /** Outputs of the module. */
  outputs?: Maybe<Array<TerraformModuleMetadataOutput>>;
  /** Readme data. */
  readme?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `readme` */
  readmeHtml?: Maybe<Scalars['String']['output']>;
  /** Resources of the submodule. */
  resources?: Maybe<Array<Scalars['String']['output']>>;
};

export type TerraformState = {
  __typename?: 'TerraformState';
  /** Timestamp the Terraform state was created. */
  createdAt: Scalars['Time']['output'];
  /** Timestamp the Terraform state was deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Terraform state. */
  id: Scalars['ID']['output'];
  /** Latest version of the Terraform state. */
  latestVersion?: Maybe<TerraformStateVersion>;
  /** Timestamp the Terraform state was locked. */
  lockedAt?: Maybe<Scalars['Time']['output']>;
  /** User currently holding a lock on the Terraform state. */
  lockedByUser?: Maybe<UserCore>;
  /** Name of the Terraform state. */
  name: Scalars['String']['output'];
  /** Timestamp the Terraform state was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for TerraformState. */
export type TerraformStateConnection = {
  __typename?: 'TerraformStateConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformState>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for TerraformState. */
export type TerraformStateConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of TerraformStateDelete */
export type TerraformStateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID']['input'];
};

/** Autogenerated return type of TerraformStateDelete. */
export type TerraformStateDeletePayload = {
  __typename?: 'TerraformStateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type TerraformStateEdge = {
  __typename?: 'TerraformStateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformState>;
};

/** Autogenerated input type of TerraformStateLock */
export type TerraformStateLockInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID']['input'];
};

/** Autogenerated return type of TerraformStateLock. */
export type TerraformStateLockPayload = {
  __typename?: 'TerraformStateLockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of TerraformStateUnlock */
export type TerraformStateUnlockInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID']['input'];
};

/** Autogenerated return type of TerraformStateUnlock. */
export type TerraformStateUnlockPayload = {
  __typename?: 'TerraformStateUnlockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type TerraformStateVersion = {
  __typename?: 'TerraformStateVersion';
  /** Timestamp the version was created. */
  createdAt: Scalars['Time']['output'];
  /** User that created the version. */
  createdByUser?: Maybe<UserCore>;
  /** URL for downloading the version's JSON file. */
  downloadPath?: Maybe<Scalars['String']['output']>;
  /** ID of the Terraform state version. */
  id: Scalars['ID']['output'];
  /** Job that created the version. */
  job?: Maybe<CiJob>;
  /** Serial number of the version. */
  serial?: Maybe<Scalars['Int']['output']>;
  /** Timestamp the version was updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Represents the Geo sync and verification state of a terraform state version */
export type TerraformStateVersionRegistry = {
  __typename?: 'TerraformStateVersionRegistry';
  /** Indicate if the checksums of the TerraformStateVersionRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the TerraformStateVersionRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the TerraformStateVersionRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the TerraformStateVersionRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the TerraformStateVersionRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the TerraformStateVersionRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the TerraformStateVersionRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the TerraformStateVersionRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the TerraformStateVersionRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the TerraformStateVersionRegistry */
  state?: Maybe<RegistryState>;
  /** ID of the terraform state version. */
  terraformStateVersionId: Scalars['ID']['output'];
  /** The local checksum of the TerraformStateVersionRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the TerraformStateVersionRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the TerraformStateVersionRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the TerraformStateVersionRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the TerraformStateVersionRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of TerraformStateVersionRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the TerraformStateVersionRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the TerraformStateVersionRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for TerraformStateVersionRegistry. */
export type TerraformStateVersionRegistryConnection = {
  __typename?: 'TerraformStateVersionRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateVersionRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformStateVersionRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for TerraformStateVersionRegistry. */
export type TerraformStateVersionRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type TerraformStateVersionRegistryEdge = {
  __typename?: 'TerraformStateVersionRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformStateVersionRegistry>;
};

/** Test case in pipeline test report. */
export type TestCase = {
  __typename?: 'TestCase';
  /** URL of the test case attachment file. */
  attachmentUrl?: Maybe<Scalars['String']['output']>;
  /** Classname of the test case. */
  classname?: Maybe<Scalars['String']['output']>;
  /** Test case execution time in seconds. */
  executionTime?: Maybe<Scalars['Float']['output']>;
  /** Path to the file of the test case. */
  file?: Maybe<Scalars['String']['output']>;
  /** Name of the test case. */
  name?: Maybe<Scalars['String']['output']>;
  /** Recent failure history of the test case on the base branch. */
  recentFailures?: Maybe<RecentFailures>;
  /** Stack trace of the test case. */
  stackTrace?: Maybe<Scalars['String']['output']>;
  /** Status of the test case (error, failed, success, skipped). */
  status?: Maybe<TestCaseStatus>;
  /** System output of the test case. */
  systemOutput?: Maybe<Scalars['String']['output']>;
};

/** The connection type for TestCase. */
export type TestCaseConnection = {
  __typename?: 'TestCaseConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestCaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestCase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for TestCase. */
export type TestCaseConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type TestCaseEdge = {
  __typename?: 'TestCaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TestCase>;
};

export type TestCaseStatus =
  /** Test case that has a status of error. */
  | 'error'
  /** Test case that has a status of failed. */
  | 'failed'
  /** Test case that has a status of skipped. */
  | 'skipped'
  /** Test case that has a status of success. */
  | 'success';

/** Represents a requirement test report */
export type TestReport = {
  __typename?: 'TestReport';
  /** Author of the test report. */
  author?: Maybe<UserCore>;
  /** Timestamp of when the test report was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the test report. */
  id: Scalars['ID']['output'];
  /** State of the test report. */
  state: TestReportState;
  /** Indicates whether the test report was generated with references to legacy requirement IIDs. */
  usesLegacyIid?: Maybe<Scalars['Boolean']['output']>;
};

/** The connection type for TestReport. */
export type TestReportConnection = {
  __typename?: 'TestReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestReportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestReport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestReportEdge = {
  __typename?: 'TestReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TestReport>;
};

/** State of a test report */
export type TestReportState =
  /** Failed test report. */
  | 'FAILED'
  /** Passed test report. */
  | 'PASSED';

/** Test report for a pipeline */
export type TestReportSummary = {
  __typename?: 'TestReportSummary';
  /** Test suites belonging to a pipeline test report. */
  testSuites: TestSuiteSummaryConnection;
  /** Total report statistics for a pipeline test report. */
  total: TestReportTotal;
};


/** Test report for a pipeline */
export type TestReportSummaryTestSuitesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Total test report statistics. */
export type TestReportTotal = {
  __typename?: 'TestReportTotal';
  /** Total number of the test cases. */
  count?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that had an error. */
  error?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that failed. */
  failed?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that were skipped. */
  skipped?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that succeeded. */
  success?: Maybe<Scalars['Int']['output']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']['output']>;
  /** Total duration of the tests. */
  time?: Maybe<Scalars['Float']['output']>;
};

/** Test suite in a pipeline test report. */
export type TestSuite = {
  __typename?: 'TestSuite';
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']['output']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']['output']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']['output']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']['output']>;
  /** Test cases in the test suite. */
  testCases?: Maybe<TestCaseConnection>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']['output']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']['output']>;
};


/** Test suite in a pipeline test report. */
export type TestSuiteTestCasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Test suite summary in a pipeline test report. */
export type TestSuiteSummary = {
  __typename?: 'TestSuiteSummary';
  /** IDs of the builds used to run the test suite. */
  buildIds?: Maybe<Array<Scalars['ID']['output']>>;
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']['output']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']['output']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']['output']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']['output']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']['output']>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']['output']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']['output']>;
};

/** The connection type for TestSuiteSummary. */
export type TestSuiteSummaryConnection = {
  __typename?: 'TestSuiteSummaryConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestSuiteSummaryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestSuiteSummary>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for TestSuiteSummary. */
export type TestSuiteSummaryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type TestSuiteSummaryEdge = {
  __typename?: 'TestSuiteSummaryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TestSuiteSummary>;
};

/** Represents the time report stats for timeboxes */
export type TimeReportStats = {
  __typename?: 'TimeReportStats';
  /** Completed issues metrics. */
  complete?: Maybe<TimeboxMetrics>;
  /** Incomplete issues metrics. */
  incomplete?: Maybe<TimeboxMetrics>;
  /** Total issues metrics. */
  total?: Maybe<TimeboxMetrics>;
};

export type TimeTrackingTimelogCategory = {
  __typename?: 'TimeTrackingTimelogCategory';
  /** Whether the category is billable or not. */
  billable?: Maybe<Scalars['Boolean']['output']>;
  /** Billing rate for the category. */
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Color assigned to the category. */
  color?: Maybe<Scalars['Color']['output']>;
  /** When the category was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the category. */
  description?: Maybe<Scalars['String']['output']>;
  /** Internal ID of the timelog category. */
  id: Scalars['ID']['output'];
  /** Name of the category. */
  name: Scalars['String']['output'];
  /** When the category was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for TimeTrackingTimelogCategory. */
export type TimeTrackingTimelogCategoryConnection = {
  __typename?: 'TimeTrackingTimelogCategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimeTrackingTimelogCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimeTrackingTimelogCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimeTrackingTimelogCategoryEdge = {
  __typename?: 'TimeTrackingTimelogCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TimeTrackingTimelogCategory>;
};

/** Represents measured stats metrics for timeboxes */
export type TimeboxMetrics = {
  __typename?: 'TimeboxMetrics';
  /** Count metric. */
  count: Scalars['Int']['output'];
  /** Weight metric. */
  weight: Scalars['Int']['output'];
};

/** Represents a historically accurate report about the timebox */
export type TimeboxReport = {
  __typename?: 'TimeboxReport';
  /** Daily scope and completed totals for burnup charts. */
  burnupTimeSeries?: Maybe<Array<BurnupChartDailyTotals>>;
  /** If the report cannot be generated, information about why. */
  error?: Maybe<TimeboxReportError>;
  /** Represents the time report stats for the timebox. */
  stats?: Maybe<TimeReportStats>;
};

/** Explains why we could not generate a timebox report. */
export type TimeboxReportError = {
  __typename?: 'TimeboxReportError';
  /** Machine readable code, categorizing the error. */
  code?: Maybe<TimeboxReportErrorReason>;
  /** Human readable message explaining what happened. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Category of error. */
export type TimeboxReportErrorReason =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** One or both of start_date and due_date is missing. */
  | 'MISSING_DATES'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** There are too many events. */
  | 'TOO_MANY_EVENTS'
  /** This type does not support timebox reports. */
  | 'UNSUPPORTED'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

export type TimeboxReportInterface = {
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
};


export type TimeboxReportInterfaceReportArgs = {
  fullPath?: InputMaybe<Scalars['String']['input']>;
};

/** A time-frame defined as a closed inclusive range of two dates */
export type Timeframe = {
  /** End of the range. */
  end: Scalars['Date']['input'];
  /** Start of the range. */
  start: Scalars['Date']['input'];
};

/** Autogenerated input type of TimelineEventCreate */
export type TimelineEventCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Incident ID of the timeline event. */
  incidentId: Scalars['IssueID']['input'];
  /** Text note of the timeline event. */
  note: Scalars['String']['input'];
  /** Timestamp of when the event occurred. */
  occurredAt: Scalars['Time']['input'];
  /** Tags for the incident timeline event. */
  timelineEventTagNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of TimelineEventCreate. */
export type TimelineEventCreatePayload = {
  __typename?: 'TimelineEventCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventDestroy */
export type TimelineEventDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Timeline event ID to remove. */
  id: Scalars['IncidentManagementTimelineEventID']['input'];
};

/** Autogenerated return type of TimelineEventDestroy. */
export type TimelineEventDestroyPayload = {
  __typename?: 'TimelineEventDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventPromoteFromNote */
export type TimelineEventPromoteFromNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Note ID from which the timeline event promoted. */
  noteId: Scalars['NoteID']['input'];
};

/** Autogenerated return type of TimelineEventPromoteFromNote. */
export type TimelineEventPromoteFromNotePayload = {
  __typename?: 'TimelineEventPromoteFromNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventTagCreate */
export type TimelineEventTagCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Name of the tag. */
  name: Scalars['String']['input'];
  /** Project to create the timeline event tag in. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of TimelineEventTagCreate. */
export type TimelineEventTagCreatePayload = {
  __typename?: 'TimelineEventTagCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timeline event tag. */
  timelineEventTag?: Maybe<TimelineEventTagType>;
};

/** Describes a tag on an incident management timeline event. */
export type TimelineEventTagType = {
  __typename?: 'TimelineEventTagType';
  /** ID of the timeline event tag. */
  id: Scalars['IncidentManagementTimelineEventTagID']['output'];
  /** Name of the timeline event tag. */
  name: Scalars['String']['output'];
};

/** The connection type for TimelineEventTagType. */
export type TimelineEventTagTypeConnection = {
  __typename?: 'TimelineEventTagTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTagTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventTagType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTagTypeEdge = {
  __typename?: 'TimelineEventTagTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventTagType>;
};

/** Describes an incident management timeline event */
export type TimelineEventType = {
  __typename?: 'TimelineEventType';
  /** Indicates the timeline event icon. */
  action: Scalars['String']['output'];
  /** User that created the timeline event. */
  author?: Maybe<UserCore>;
  /** Timestamp when the event created. */
  createdAt: Scalars['Time']['output'];
  /** Indicates the timeline event is editable. */
  editable: Scalars['Boolean']['output'];
  /** ID of the timeline event. */
  id: Scalars['IncidentManagementTimelineEventID']['output'];
  /** Incident of the timeline event. */
  incident: Issue;
  /** Text note of the timeline event. */
  note?: Maybe<Scalars['String']['output']>;
  /** HTML note of the timeline event. */
  noteHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the event occurred. */
  occurredAt: Scalars['Time']['output'];
  /** Note from which the timeline event was created. */
  promotedFromNote?: Maybe<Note>;
  /** Tags for the incident timeline event. */
  timelineEventTags?: Maybe<TimelineEventTagTypeConnection>;
  /** Timestamp when the event updated. */
  updatedAt: Scalars['Time']['output'];
  /** User that updated the timeline event. */
  updatedByUser?: Maybe<UserCore>;
};


/** Describes an incident management timeline event */
export type TimelineEventTypeTimelineEventTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for TimelineEventType. */
export type TimelineEventTypeConnection = {
  __typename?: 'TimelineEventTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTypeEdge = {
  __typename?: 'TimelineEventTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventUpdate */
export type TimelineEventUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the timeline event to update. */
  id: Scalars['IncidentManagementTimelineEventID']['input'];
  /** Text note of the timeline event. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the event occurred. */
  occurredAt?: InputMaybe<Scalars['Time']['input']>;
  /** Tags for the incident timeline event. */
  timelineEventTagNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of TimelineEventUpdate. */
export type TimelineEventUpdatePayload = {
  __typename?: 'TimelineEventUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

export type Timelog = {
  __typename?: 'Timelog';
  /** Internal ID of the timelog. */
  id: Scalars['ID']['output'];
  /** Issue that logged time was added to. */
  issue?: Maybe<Issue>;
  /** Merge request that logged time was added to. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Note where the quick action was executed to add the logged time. */
  note?: Maybe<Note>;
  /** Target project of the timelog merge request or issue. */
  project: Project;
  /** Timestamp of when the time tracked was spent at. */
  spentAt?: Maybe<Scalars['Time']['output']>;
  /** Summary of how the time was spent. */
  summary?: Maybe<Scalars['String']['output']>;
  /** Time spent displayed in seconds. */
  timeSpent: Scalars['Int']['output'];
  /** User that logged the time. */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: TimelogPermissions;
};

/** The connection type for Timelog. */
export type TimelogConnection = {
  __typename?: 'TimelogConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Timelog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total time spent in seconds. */
  totalSpentTime: Scalars['BigInt']['output'];
};


/** The connection type for Timelog. */
export type TimelogConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of TimelogCreate */
export type TimelogCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the issuable (Issue, WorkItem or MergeRequest). */
  issuableId: Scalars['IssuableID']['input'];
  /** Timestamp of when the time was spent. If empty, defaults to current time. */
  spentAt?: InputMaybe<Scalars['Time']['input']>;
  /** Summary of time spent. */
  summary: Scalars['String']['input'];
  /** Amount of time spent. */
  timeSpent: Scalars['String']['input'];
};

/** Autogenerated return type of TimelogCreate. */
export type TimelogCreatePayload = {
  __typename?: 'TimelogCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** Autogenerated input type of TimelogDelete */
export type TimelogDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the timelog. */
  id: Scalars['TimelogID']['input'];
};

/** Autogenerated return type of TimelogDelete. */
export type TimelogDeletePayload = {
  __typename?: 'TimelogDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** An edge in a connection. */
export type TimelogEdge = {
  __typename?: 'TimelogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Timelog>;
};

export type TimelogPermissions = {
  __typename?: 'TimelogPermissions';
  /** If `true`, the user can perform `admin_timelog` on this resource */
  adminTimelog: Scalars['Boolean']['output'];
};

/** Values for sorting timelogs */
export type TimelogSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Spent at ascending order. */
  | 'SPENT_AT_ASC'
  /** Spent at descending order. */
  | 'SPENT_AT_DESC'
  /** Time spent ascending order. */
  | 'TIME_SPENT_ASC'
  /** Time spent descending order. */
  | 'TIME_SPENT_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** A closed, inclusive range of two timestamps */
export type TimestampRange = {
  /** End of the range. */
  end: Scalars['Time']['input'];
  /** Start of the range. */
  start: Scalars['Time']['input'];
};

/** Representing a to-do entry */
export type Todo = {
  __typename?: 'Todo';
  /** Action of the to-do item. */
  action: TodoActionEnum;
  /** Author of the to-do item. */
  author: UserCore;
  /** Body of the to-do item. */
  body: Scalars['String']['output'];
  /** Timestamp the to-do item was created. */
  createdAt: Scalars['Time']['output'];
  /** Group the to-do item is associated with. */
  group?: Maybe<Group>;
  /** ID of the to-do item. */
  id: Scalars['ID']['output'];
  /** Access type of access request to-do items. */
  memberAccessType?: Maybe<Scalars['String']['output']>;
  /** Note which created the to-do item. */
  note?: Maybe<Note>;
  /** Project the to-do item is associated with. */
  project?: Maybe<Project>;
  /** Time until when the todo is snoozed. */
  snoozedUntil?: Maybe<Scalars['Time']['output']>;
  /** State of the to-do item. */
  state: TodoStateEnum;
  /**
   * Target of the to-do item. Deprecated in GitLab 17.4: Under certain circumstances, the `target` field on a to-do item can be `null`. The GraphQL schema currently declares `target` field as non-nullable. Use the new `target_entity` field instead.
   * @deprecated Under certain circumstances, the `target` field on a to-do item can be `null`. The GraphQL schema currently declares `target` field as non-nullable. Use the new `target_entity` field instead. Deprecated in GitLab 17.4.
   */
  target: Todoable;
  /** Target of the to-do item. */
  targetEntity?: Maybe<Todoable>;
  /** Target type of the to-do item. */
  targetType: TodoTargetEnum;
  /** URL of the to-do item target. */
  targetUrl?: Maybe<Scalars['String']['output']>;
};

export type TodoActionEnum =
  /** Todo action name for added_approver. */
  | 'added_approver'
  /** Todo action name for approval_required. */
  | 'approval_required'
  /** Todo action name for assigned. */
  | 'assigned'
  /** Todo action name for build_failed. */
  | 'build_failed'
  /** Todo action name for directly_addressed. */
  | 'directly_addressed'
  /** Todo action name for duo_core_access_granted. */
  | 'duo_core_access_granted'
  /** Todo action name for duo_enterprise_access_granted. */
  | 'duo_enterprise_access_granted'
  /** Todo action name for duo_pro_access_granted. */
  | 'duo_pro_access_granted'
  /** Todo action name for marked. */
  | 'marked'
  /** Todo action name for member_access_requested. */
  | 'member_access_requested'
  /** Todo action name for mentioned. */
  | 'mentioned'
  /** Todo action name for merge_train_removed. */
  | 'merge_train_removed'
  /** Todo action name for okr_checkin_requested. */
  | 'okr_checkin_requested'
  /** Todo action name for review_requested. */
  | 'review_requested'
  /** Todo action name for review_submitted. */
  | 'review_submitted'
  /** Todo action name for ssh_key_expired. */
  | 'ssh_key_expired'
  /** Todo action name for ssh_key_expiring_soon. */
  | 'ssh_key_expiring_soon'
  /** Todo action name for unmergeable. */
  | 'unmergeable';

/** The connection type for Todo. */
export type TodoConnection = {
  __typename?: 'TodoConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TodoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Todo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for Todo. */
export type TodoConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of TodoCreate */
export type TodoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. */
  targetId: Scalars['TodoableID']['input'];
};

/** Autogenerated return type of TodoCreate. */
export type TodoCreatePayload = {
  __typename?: 'TodoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** To-do item created. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of TodoDeleteAllDone */
export type TodoDeleteAllDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** To-do items marked as done before the timestamp will be deleted. */
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};

/** Autogenerated return type of TodoDeleteAllDone. */
export type TodoDeleteAllDonePayload = {
  __typename?: 'TodoDeleteAllDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of TodoDeleteMany */
export type TodoDeleteManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the to-do items to process (a maximum of 100 is supported at once). */
  ids: Array<Scalars['TodoID']['input']>;
};

/** Autogenerated return type of TodoDeleteMany. */
export type TodoDeleteManyPayload = {
  __typename?: 'TodoDeleteManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type TodoEdge = {
  __typename?: 'TodoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Todo>;
};

/** Autogenerated input type of TodoMarkDone */
export type TodoMarkDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the to-do item to mark as done. */
  id: Scalars['TodoID']['input'];
};

/** Autogenerated return type of TodoMarkDone. */
export type TodoMarkDonePayload = {
  __typename?: 'TodoMarkDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodoResolveMany */
export type TodoResolveManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the to-do items to process (a maximum of 100 is supported at once). */
  ids: Array<Scalars['TodoID']['input']>;
};

/** Autogenerated return type of TodoResolveMany. */
export type TodoResolveManyPayload = {
  __typename?: 'TodoResolveManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Resolved to-do items. */
  todos: Array<Todo>;
};

/** Autogenerated input type of TodoRestore */
export type TodoRestoreInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the to-do item to restore. */
  id: Scalars['TodoID']['input'];
};

/** Autogenerated input type of TodoRestoreMany */
export type TodoRestoreManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the to-do items to process (a maximum of 100 is supported at once). */
  ids: Array<Scalars['TodoID']['input']>;
};

/** Autogenerated return type of TodoRestoreMany. */
export type TodoRestoreManyPayload = {
  __typename?: 'TodoRestoreManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Restored to-do items. */
  todos: Array<Todo>;
};

/** Autogenerated return type of TodoRestore. */
export type TodoRestorePayload = {
  __typename?: 'TodoRestorePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodoSnooze */
export type TodoSnoozeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the to-do item to be snoozed. */
  id: Scalars['TodoID']['input'];
  /** Time until which the todo should be snoozed. */
  snoozeUntil: Scalars['Time']['input'];
};

/** Autogenerated input type of TodoSnoozeMany */
export type TodoSnoozeManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the to-do items to process (a maximum of 100 is supported at once). */
  ids: Array<Scalars['TodoID']['input']>;
  /** Time until which the todos should be snoozed. */
  snoozeUntil: Scalars['Time']['input'];
};

/** Autogenerated return type of TodoSnoozeMany. */
export type TodoSnoozeManyPayload = {
  __typename?: 'TodoSnoozeManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Snoozed to-do items. */
  todos: Array<Todo>;
};

/** Autogenerated return type of TodoSnooze. */
export type TodoSnoozePayload = {
  __typename?: 'TodoSnoozePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Sort options for todos. */
export type TodoSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** By label priority in ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** By label priority in descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

export type TodoStateEnum =
  /** State of the todo is done. */
  | 'done'
  /** State of the todo is pending. */
  | 'pending';

export type TodoTargetEnum =
  /** Alert. */
  | 'ALERT'
  /** Commit. */
  | 'COMMIT'
  /** Project Compliance Violation. */
  | 'COMPLIANCE_VIOLATION'
  /** Design. */
  | 'DESIGN'
  /** An Epic. */
  | 'EPIC'
  /** Issue. */
  | 'ISSUE'
  /** SSH key. */
  | 'KEY'
  /** Merge request. */
  | 'MERGEREQUEST'
  /** Namespace. */
  | 'NAMESPACE'
  /** Project. */
  | 'PROJECT'
  /** User. */
  | 'USER'
  /** Vulnerability. */
  | 'VULNERABILITY'
  /** Wiki page. */
  | 'WIKIPAGEMETA'
  /** Work item. */
  | 'WORKITEM';

/** Autogenerated input type of TodoUnSnooze */
export type TodoUnSnoozeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the to-do item to be snoozed. */
  id: Scalars['TodoID']['input'];
};

/** Autogenerated return type of TodoUnSnooze. */
export type TodoUnSnoozePayload = {
  __typename?: 'TodoUnSnoozePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodoUnsnoozeMany */
export type TodoUnsnoozeManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the to-do items to process (a maximum of 100 is supported at once). */
  ids: Array<Scalars['TodoID']['input']>;
};

/** Autogenerated return type of TodoUnsnoozeMany. */
export type TodoUnsnoozeManyPayload = {
  __typename?: 'TodoUnsnoozeManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Unsnoozed to-do items. */
  todos: Array<Todo>;
};

export type Todoable = {
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** URL of the object. */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of TodosMarkAllDone */
export type TodosMarkAllDoneInput = {
  /** Action to be filtered. */
  action?: InputMaybe<Array<TodoActionEnum>>;
  /** ID of an author. */
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of a group. */
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** ID of a project. */
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. If argument is omitted, all pending to-do items of the current user are marked as done. */
  targetId?: InputMaybe<Scalars['TodoableID']['input']>;
  /** Type of the todo. */
  type?: InputMaybe<Array<TodoTargetEnum>>;
};

/** Autogenerated return type of TodosMarkAllDone. */
export type TodosMarkAllDonePayload = {
  __typename?: 'TodosMarkAllDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated to-do items. */
  todos: Array<Todo>;
};

export type Topic = {
  __typename?: 'Topic';
  /** URL to avatar image file of the topic. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Description of the topic. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** ID of the topic. */
  id: Scalars['ID']['output'];
  /** Name of the topic. */
  name: Scalars['String']['output'];
  /** Title of the topic. */
  title: Scalars['String']['output'];
};

/** The connection type for Topic. */
export type TopicConnection = {
  __typename?: 'TopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Topic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TopicEdge = {
  __typename?: 'TopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Topic>;
};

/** Attributes for defining a tracking event. */
export type TrackingEventInput = {
  /** Event action. */
  action: Scalars['String']['input'];
  /** Event category. */
  category: Scalars['String']['input'];
  /** Extra metadata for the event. */
  extra?: InputMaybe<Scalars['JSON']['input']>;
  /** Event label. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Event property. */
  property?: InputMaybe<Scalars['String']['input']>;
  /** Event value. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Status of the request to the training provider. The URL of a TrainingUrl is calculated asynchronously. When PENDING, the URL of the TrainingUrl will be null. When COMPLETED, the URL of the TrainingUrl will be available. */
export type TrainingUrlRequestStatus =
  /** Completed request. */
  | 'COMPLETED'
  /** Pending request. */
  | 'PENDING';

export type Tree = {
  __typename?: 'Tree';
  /** Blobs of the tree. */
  blobs: BlobConnection;
  /** Last commit for the tree. */
  lastCommit?: Maybe<Commit>;
  /**
   * Web path to tree permalink. The `permalinkPath` field returns a string that represents the web path to a specific version of a directory, identified by its commit SHA. Use this path to create permanent links to directories at specific points in your repository's history. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  permalinkPath?: Maybe<Scalars['String']['output']>;
  /** Sub-modules of the tree. */
  submodules: SubmoduleConnection;
  /** Trees of the tree. */
  trees: TreeEntryConnection;
};


export type TreeBlobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type TreeLastCommitArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
  refType?: InputMaybe<RefType>;
};


export type TreeSubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type TreeTreesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Tree. */
export type TreeConnection = {
  __typename?: 'TreeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Tree>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEdge = {
  __typename?: 'TreeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Tree>;
};

/** Represents a directory */
export type TreeEntry = Entry & {
  __typename?: 'TreeEntry';
  /** Flat path of the entry. */
  flatPath: Scalars['String']['output'];
  /** ID of the entry. */
  id: Scalars['ID']['output'];
  /** Name of the entry. */
  name: Scalars['String']['output'];
  /** Path of the entry. */
  path: Scalars['String']['output'];
  /** SHA of the entry. */
  sha: Scalars['String']['output'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path for the tree entry (directory). */
  webPath?: Maybe<Scalars['String']['output']>;
  /** Web URL for the tree entry (directory). */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** The connection type for TreeEntry. */
export type TreeEntryConnection = {
  __typename?: 'TreeEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TreeEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEntryEdge = {
  __typename?: 'TreeEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TreeEntry>;
};

export type TypeEnum =
  /** Snippet created independent of any project. */
  | 'personal'
  /** Snippet related to a specific project. */
  | 'project';

export type UnionedEpicFilterInput = {
  /** Filters epics that are authored by one of the given users. */
  authorUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters epics that have at least one of the given labels. */
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UnionedIssueFilterInput = {
  /** Filters issues that are assigned to at least one of the given users. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters issues that are authored by one of the given users. */
  authorUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters issues that have at least one of the given labels. */
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UnionedMergeRequestFilterInput = {
  /** Filters MRs that are assigned to at least one of the given users. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UnionedWorkItemFilterInput = {
  /** Filters work items that are assigned to at least one of the given users (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters work items that are authored by one of the given users (maximum is 100 usernames). */
  authorUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filters work items that have at least one of the given labels (maximum is 100 labels). */
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated input type of UnlinkProjectComplianceViolationIssue */
export type UnlinkProjectComplianceViolationIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the issue to be unlinked. */
  issueIid: Scalars['String']['input'];
  /** Full path of the project the issue belongs to. */
  projectPath: Scalars['ID']['input'];
  /** Global ID of the project compliance violation. */
  violationId: Scalars['ComplianceManagementProjectsComplianceViolationID']['input'];
};

/** Autogenerated return type of UnlinkProjectComplianceViolationIssue. */
export type UnlinkProjectComplianceViolationIssuePayload = {
  __typename?: 'UnlinkProjectComplianceViolationIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated project compliance violation. */
  violation?: Maybe<ProjectComplianceViolation>;
};

/** Defines which user roles, users, or groups can unprotect a protected branch. */
export type UnprotectAccessLevel = {
  __typename?: 'UnprotectAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int']['output'];
  /** Human readable representation for the access level. */
  accessLevelDescription: Scalars['String']['output'];
  /** Group associated with the access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with the access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for UnprotectAccessLevel. */
export type UnprotectAccessLevelConnection = {
  __typename?: 'UnprotectAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UnprotectAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UnprotectAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UnprotectAccessLevelEdge = {
  __typename?: 'UnprotectAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UnprotectAccessLevel>;
};

/** Autogenerated input type of UpdateAlertStatus */
export type UpdateAlertStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String']['input'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** Status to set the alert. */
  status: AlertManagementStatus;
};

/** Autogenerated return type of UpdateAlertStatus. */
export type UpdateAlertStatusPayload = {
  __typename?: 'UpdateAlertStatusPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of UpdateBoardEpicUserPreferences */
export type UpdateBoardEpicUserPreferencesInput = {
  /** Board global ID. */
  boardId: Scalars['BoardID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the epic should be collapsed in the board. */
  collapsed: Scalars['Boolean']['input'];
  /** ID of an epic to set preferences for. */
  epicId: Scalars['EpicID']['input'];
};

/** Autogenerated return type of UpdateBoardEpicUserPreferences. */
export type UpdateBoardEpicUserPreferencesPayload = {
  __typename?: 'UpdateBoardEpicUserPreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** User preferences for the epic in the board after mutation. */
  epicUserPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateBoard */
export type UpdateBoardInput = {
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']['input']>;
  /** Board global ID. */
  id: Scalars['BoardID']['input'];
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateBoardList */
export type UpdateBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the list is collapsed for the user. */
  collapsed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the list. */
  listId: Scalars['ListID']['input'];
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateBoardList. */
export type UpdateBoardListPayload = {
  __typename?: 'UpdateBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mutated list. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of UpdateBoard. */
export type UpdateBoardPayload = {
  __typename?: 'UpdateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateComplianceFramework */
export type UpdateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance framework to update. */
  id: Scalars['ComplianceManagementFrameworkID']['input'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of UpdateComplianceFramework. */
export type UpdateComplianceFrameworkPayload = {
  __typename?: 'UpdateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Compliance framework after mutation. */
  complianceFramework?: Maybe<ComplianceFramework>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateComplianceRequirement */
export type UpdateComplianceRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Controls to add or update to the compliance requirement. */
  controls?: InputMaybe<Array<ComplianceRequirementsControlInput>>;
  /** Global ID of the compliance requirement to update. */
  id: Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementID']['input'];
  /** Parameters to update the compliance requirement with. */
  params: ComplianceRequirementInput;
};

/** Autogenerated return type of UpdateComplianceRequirement. */
export type UpdateComplianceRequirementPayload = {
  __typename?: 'UpdateComplianceRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Compliance requirement after updation. */
  requirement?: Maybe<ComplianceRequirement>;
};

/** Autogenerated input type of UpdateComplianceRequirementsControl */
export type UpdateComplianceRequirementsControlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the compliance requirement control to update. */
  id: Scalars['ComplianceManagementComplianceFrameworkComplianceRequirementsControlID']['input'];
  /** Parameters to update the compliance requirement control with. */
  params: ComplianceRequirementsControlInput;
};

/** Autogenerated return type of UpdateComplianceRequirementsControl. */
export type UpdateComplianceRequirementsControlPayload = {
  __typename?: 'UpdateComplianceRequirementsControlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Compliance requirement control after updation. */
  requirementsControl?: Maybe<ComplianceRequirementsControl>;
};

/** Autogenerated input type of UpdateContainerExpirationPolicy */
export type UpdateContainerExpirationPolicyInput = {
  /** Schedule of the container expiration policy. */
  cadence?: InputMaybe<ContainerExpirationPolicyCadenceEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the container expiration policy is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of tags to retain. */
  keepN?: InputMaybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching the regex pattern will expire. */
  nameRegex?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Tags with names matching the regex pattern will be preserved. */
  nameRegexKeep?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Tags older than the given age will expire. */
  olderThan?: InputMaybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Project path where the container expiration policy is located. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateContainerExpirationPolicy. */
export type UpdateContainerExpirationPolicyPayload = {
  __typename?: 'UpdateContainerExpirationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Container expiration policy after mutation. Deprecated in GitLab 17.5: Use `container_tags_expiration_policy`.
   * @deprecated Use `container_tags_expiration_policy`. Deprecated in GitLab 17.5.
   */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /** Container tags expiration policy after mutation. */
  containerTagsExpirationPolicy?: Maybe<ContainerTagsExpirationPolicy>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateContainerProtectionRepositoryRule */
export type UpdateContainerProtectionRepositoryRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the container repository protection rule to be updated. */
  id: Scalars['ContainerRegistryProtectionRuleID']['input'];
  /** Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForDelete?: InputMaybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: InputMaybe<ContainerProtectionRepositoryRuleAccessLevel>;
  /** Container repository path pattern protected by the protection rule. Must start with the projects full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the projects full path. */
  repositoryPathPattern?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateContainerProtectionRepositoryRule. */
export type UpdateContainerProtectionRepositoryRulePayload = {
  __typename?: 'UpdateContainerProtectionRepositoryRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Container repository protection rule after mutation. */
  containerProtectionRepositoryRule?: Maybe<ContainerProtectionRepositoryRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateContainerProtectionTagRule */
export type UpdateContainerProtectionTagRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the tag protection rule to update. */
  id: Scalars['ContainerRegistryProtectionTagRuleID']['input'];
};

/** Autogenerated return type of UpdateContainerProtectionTagRule. */
export type UpdateContainerProtectionTagRulePayload = {
  __typename?: 'UpdateContainerProtectionTagRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Protection rule for container image tags after creation. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  containerProtectionTagRule?: Maybe<ContainerProtectionTagRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateDependencyProxyImageTtlGroupPolicy */
export type UpdateDependencyProxyImageTtlGroupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group path for the group dependency proxy image TTL policy. */
  groupPath: Scalars['ID']['input'];
  /** Number of days to retain a cached image file. */
  ttl?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateDependencyProxyImageTtlGroupPolicy. */
export type UpdateDependencyProxyImageTtlGroupPolicyPayload = {
  __typename?: 'UpdateDependencyProxyImageTtlGroupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Group image TTL policy after mutation. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateDependencyProxyPackagesSettings */
export type UpdateDependencyProxyPackagesSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the dependency proxy for packages is enabled for the project. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Password for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time. */
  mavenExternalRegistryPassword?: InputMaybe<Scalars['String']['input']>;
  /** URL for the external Maven packages registry. */
  mavenExternalRegistryUrl?: InputMaybe<Scalars['String']['input']>;
  /** Username for the external Maven packages registry. */
  mavenExternalRegistryUsername?: InputMaybe<Scalars['String']['input']>;
  /** Project path for the dependency proxy for packages settings. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateDependencyProxyPackagesSettings. */
export type UpdateDependencyProxyPackagesSettingsPayload = {
  __typename?: 'UpdateDependencyProxyPackagesSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Dependency proxy for packages settings after mutation. */
  dependencyProxyPackagesSetting?: Maybe<DependencyProxyPackagesSetting>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateDependencyProxySettings */
export type UpdateDependencyProxySettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group path for the group dependency proxy. */
  groupPath: Scalars['ID']['input'];
  /** Identity credential used to authenticate with Docker Hub when pulling images. Can be a username (for password or personal access token (PAT)) or organization name (for organization access token (OAT)). */
  identity?: InputMaybe<Scalars['String']['input']>;
  /** Secret credential used to authenticate with Docker Hub when pulling images. Can be a password, personal access token (PAT), or organization access token (OAT). */
  secret?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateDependencyProxySettings. */
export type UpdateDependencyProxySettingsPayload = {
  __typename?: 'UpdateDependencyProxySettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Group dependency proxy settings after mutation. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

export type UpdateDiffImagePositionInput = {
  /** Total height of the image. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** Total width of the image. */
  width?: InputMaybe<Scalars['Int']['input']>;
  /** X position of the note. */
  x?: InputMaybe<Scalars['Int']['input']>;
  /** Y position of the note. */
  y?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateEpicBoardList */
export type UpdateEpicBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the list is collapsed for the user. */
  collapsed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Global ID of the epic list. */
  listId: Scalars['BoardsEpicListID']['input'];
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateEpicBoardList. */
export type UpdateEpicBoardListPayload = {
  __typename?: 'UpdateEpicBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Mutated epic list. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of UpdateEpic */
export type UpdateEpicInput = {
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Color of the epic. */
  color?: InputMaybe<Scalars['Color']['input']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']['input']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID']['input'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID']['input'];
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Array of labels to be removed from the epic. */
  removeLabels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']['input']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** State event for the epic. */
  stateEvent?: InputMaybe<EpicStateEvent>;
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateEpic. */
export type UpdateEpicPayload = {
  __typename?: 'UpdateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateImageDiffNote */
export type UpdateImageDiffNoteInput = {
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the note to update. */
  id: Scalars['NoteID']['input'];
  /** Position of the note on a diff. */
  position?: InputMaybe<UpdateDiffImagePositionInput>;
};

/** Autogenerated return type of UpdateImageDiffNote. */
export type UpdateImageDiffNotePayload = {
  __typename?: 'UpdateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** IDs of labels to be added to the issue. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** IID of the issue to mutate. */
  iid: Scalars['String']['input'];
  /** IDs of labels to be set. Replaces existing issue labels. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID']['input'];
  /** IDs of labels to be removed from the issue. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Close or reopen an issue. */
  stateEvent?: InputMaybe<IssueStateEvent>;
  /** Estimated time to complete the issue. Use `null` or `0` to remove the current estimate. */
  timeEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Title of the issue. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateIssue. */
export type UpdateIssuePayload = {
  __typename?: 'UpdateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateIteration */
export type UpdateIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']['input']>;
  /** Group of the iteration. */
  groupPath: Scalars['ID']['input'];
  /** Global ID of the iteration. */
  id: Scalars['ID']['input'];
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']['input']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIteration. */
export type UpdateIterationPayload = {
  __typename?: 'UpdateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of UpdateNamespacePackageSettings */
export type UpdateNamespacePackageSettingsInput = {
  /** Indicates whether audit events are created when publishing or deleting a package in the namespace (Premium and Ultimate only). */
  auditEventsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  genericDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Indicates whether duplicate generic packages are allowed for the namespace. */
  genericDuplicatesAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  mavenDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Indicates whether duplicate Maven packages are allowed for the namespace. */
  mavenDuplicatesAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether Maven package forwarding is allowed for the namespace. */
  mavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** Namespace path where the namespace package setting is located. */
  namespacePath: Scalars['ID']['input'];
  /** Indicates whether npm package forwarding is allowed for the namespace. */
  npmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect.  */
  nugetDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Indicates whether duplicate NuGet packages are allowed for the namespace. */
  nugetDuplicatesAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether the NuGet symbol server is enabled for the namespace. */
  nugetSymbolServerEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates whether PyPI package forwarding is allowed for the namespace. */
  pypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']['input']>;
  /** When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. */
  terraformModuleDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']['input']>;
  /** Indicates whether duplicate Terraform packages are allowed for the namespace. */
  terraformModuleDuplicatesAllowed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateNamespacePackageSettings. */
export type UpdateNamespacePackageSettingsPayload = {
  __typename?: 'UpdateNamespacePackageSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace package setting after mutation. */
  packageSettings?: Maybe<PackageSettings>;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the note to update. */
  id: Scalars['NoteID']['input'];
};

/** Autogenerated return type of UpdateNote. */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
  /** Status of quick actions after mutation. */
  quickActionsStatus?: Maybe<QuickActionsStatus>;
};

/** Autogenerated input type of UpdatePackagesCleanupPolicy */
export type UpdatePackagesCleanupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles?: InputMaybe<PackagesCleanupKeepDuplicatedPackageFilesEnum>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePackagesCleanupPolicy. */
export type UpdatePackagesCleanupPolicyPayload = {
  __typename?: 'UpdatePackagesCleanupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Packages cleanup policy after mutation. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
};

/** Autogenerated input type of UpdatePackagesProtectionRule */
export type UpdatePackagesProtectionRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the package protection rule to be updated. */
  id: Scalars['PackagesProtectionRuleID']['input'];
  /** Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`. */
  minimumAccessLevelForPush?: InputMaybe<PackagesProtectionRuleAccessLevel>;
  /** Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed. */
  packageNamePattern?: InputMaybe<Scalars['String']['input']>;
  /** Package type protected by the protection rule. For example, `NPM`, `PYPI`. */
  packageType?: InputMaybe<PackagesProtectionRulePackageType>;
};

/** Autogenerated return type of UpdatePackagesProtectionRule. */
export type UpdatePackagesProtectionRulePayload = {
  __typename?: 'UpdatePackagesProtectionRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Packages protection rule after mutation. */
  packageProtectionRule?: Maybe<PackagesProtectionRule>;
};

/** Autogenerated input type of UpdateProjectComplianceViolation */
export type UpdateProjectComplianceViolationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the project compliance violation to update. */
  id: Scalars['ComplianceManagementProjectsComplianceViolationID']['input'];
  /** New status for the project compliance violation. */
  status: ComplianceViolationStatus;
};

/** Autogenerated return type of UpdateProjectComplianceViolation. */
export type UpdateProjectComplianceViolationPayload = {
  __typename?: 'UpdateProjectComplianceViolationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Compliance violation after status update. */
  complianceViolation?: Maybe<ProjectComplianceViolation>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateRequirement */
export type UpdateRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Creates a test report for the requirement with the given state. */
  lastTestReportState?: InputMaybe<TestReportState>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID']['input'];
  /** State of the requirement. */
  state?: InputMaybe<RequirementState>;
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** IID of the requirement work item to update. */
  workItemIid?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateRequirement. */
export type UpdateRequirementPayload = {
  __typename?: 'UpdateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of UpdateSnippet */
export type UpdateSnippetInput = {
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID']['input'];
  /** Title of the snippet. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Visibility level of the snippet. */
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
};

/** Autogenerated return type of UpdateSnippet. */
export type UpdateSnippetPayload = {
  __typename?: 'UpdateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Attributes to update value stream stage. */
export type UpdateValueStreamStageInput = {
  /** Whether the stage is customized. If false, it assigns a built-in default stage by name. */
  custom?: InputMaybe<Scalars['Boolean']['input']>;
  /** End event identifier. */
  endEventIdentifier?: InputMaybe<ValueStreamStageEvent>;
  /** Label ID associated with the end event identifier. */
  endEventLabelId?: InputMaybe<Scalars['LabelID']['input']>;
  /** Whether the stage is hidden. */
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of the stage to be updated. */
  id?: InputMaybe<Scalars['AnalyticsCycleAnalyticsStageID']['input']>;
  /** Name of the stage. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Start event identifier. */
  startEventIdentifier?: InputMaybe<ValueStreamStageEvent>;
  /** Label ID associated with the start event identifier. */
  startEventLabelId?: InputMaybe<Scalars['LabelID']['input']>;
};

/** Autogenerated input type of UpdateVirtualRegistriesSetting */
export type UpdateVirtualRegistriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable or disable the virtual registries. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group path for the group virtual registries. */
  fullPath: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateVirtualRegistriesSetting. */
export type UpdateVirtualRegistriesSettingPayload = {
  __typename?: 'UpdateVirtualRegistriesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Virtual registries settings after mutation. */
  virtualRegistriesSetting?: Maybe<VirtualRegistriesSetting>;
};

/** Autogenerated input type of UploadDelete */
export type UploadDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Upload filename. */
  filename: Scalars['String']['input'];
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Secret part of upload path. */
  secret: Scalars['String']['input'];
};

/** Autogenerated return type of UploadDelete. */
export type UploadDeletePayload = {
  __typename?: 'UploadDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted upload. */
  upload?: Maybe<FileUpload>;
};

/** Represents the Geo replication and verification state of an upload. */
export type UploadRegistry = {
  __typename?: 'UploadRegistry';
  /** Indicate if the checksums of the UploadRegistry do not match on the primary and secondary. */
  checksumMismatch?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the UploadRegistry was created */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** ID of the Upload. */
  fileId: Scalars['ID']['output'];
  /**
   * Indicate if a forced redownload is to be performed. Deprecated in GitLab 17.10: Removed from registry tables in the database in favor of the newer reusable framework.
   * @deprecated Removed from registry tables in the database in favor of the newer reusable framework. Deprecated in GitLab 17.10.
   */
  forceToRedownload?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the UploadRegistry */
  id: Scalars['ID']['output'];
  /** Error message during sync of the UploadRegistry */
  lastSyncFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp of the most recent successful sync of the UploadRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  /** Indicate if the UploadRegistry is missing on primary. */
  missingOnPrimary?: Maybe<Scalars['Boolean']['output']>;
  /** ID of the UploadRegistry's model record. */
  modelRecordId?: Maybe<Scalars['Int']['output']>;
  /** Timestamp after which the UploadRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed sync attempts of the UploadRegistry */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Sync state of the UploadRegistry */
  state?: Maybe<RegistryState>;
  /** The local checksum of the UploadRegistry */
  verificationChecksum?: Maybe<Scalars['String']['output']>;
  /** The expected checksum of the UploadRegistry in case of mismatch. */
  verificationChecksumMismatched?: Maybe<Scalars['String']['output']>;
  /** Error message during verification of the UploadRegistry */
  verificationFailure?: Maybe<Scalars['String']['output']>;
  /** Timestamp after which the UploadRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']['output']>;
  /** Number of consecutive failed verification attempts of the UploadRegistry */
  verificationRetryCount?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the verification of UploadRegistry started */
  verificationStartedAt?: Maybe<Scalars['Time']['output']>;
  /** Verification state of the UploadRegistry */
  verificationState?: Maybe<VerificationStateEnum>;
  /** Timestamp of the most recent successful verification of the UploadRegistry */
  verifiedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for UploadRegistry. */
export type UploadRegistryConnection = {
  __typename?: 'UploadRegistryConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UploadRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UploadRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for UploadRegistry. */
export type UploadRegistryConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type UploadRegistryEdge = {
  __typename?: 'UploadRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UploadRegistry>;
};

/** Represents a recorded measurement (object count) for the Admins */
export type UsageTrendsMeasurement = {
  __typename?: 'UsageTrendsMeasurement';
  /** Object count. */
  count: Scalars['Int']['output'];
  /** Type of objects being measured. */
  identifier: MeasurementIdentifier;
  /** Time the measurement was recorded. */
  recordedAt?: Maybe<Scalars['Time']['output']>;
};

/** The connection type for UsageTrendsMeasurement. */
export type UsageTrendsMeasurementConnection = {
  __typename?: 'UsageTrendsMeasurementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UsageTrendsMeasurementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UsageTrendsMeasurement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UsageTrendsMeasurementEdge = {
  __typename?: 'UsageTrendsMeasurementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UsageTrendsMeasurement>;
};

/** Representation of a GitLab user. */
export type User = {
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
};


/** Representation of a GitLab user. */
export type UserAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Representation of a GitLab user. */
export type UserAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Representation of a GitLab user. */
export type UserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Representation of a GitLab user. */
export type UserEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** Representation of a GitLab user. */
export type UserNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Representation of a GitLab user. */
export type UserPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** Representation of a GitLab user. */
export type UserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Representation of a GitLab user. */
export type UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Representation of a GitLab user. */
export type UserSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** Representation of a GitLab user. */
export type UserSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** Representation of a GitLab user. */
export type UserStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Representation of a GitLab user. */
export type UserTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** Representation of a GitLab user. */
export type UserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** Representation of a GitLab user. */
export type UserUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type UserAchievement = {
  __typename?: 'UserAchievement';
  /** Achievement awarded. */
  achievement: Achievement;
  /** Awarded by. */
  awardedByUser: UserCore;
  /** Timestamp the achievement was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the user achievement. */
  id: Scalars['AchievementsUserAchievementID']['output'];
  /** Priority of the user achievement. */
  priority?: Maybe<Scalars['Int']['output']>;
  /** Timestamp the achievement was revoked. */
  revokedAt?: Maybe<Scalars['Time']['output']>;
  /** Revoked by. */
  revokedByUser?: Maybe<UserCore>;
  /** Indicates whether or not the achievement is shown on the profile. */
  showOnProfile: Scalars['Boolean']['output'];
  /** Timestamp the achievement was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Achievement recipient. */
  user: UserCore;
};

/** The connection type for UserAchievement. */
export type UserAchievementConnection = {
  __typename?: 'UserAchievementConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserAchievementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserAchievement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for UserAchievement. */
export type UserAchievementConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type UserAchievementEdge = {
  __typename?: 'UserAchievementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserAchievement>;
};

/** Autogenerated input type of UserAchievementPrioritiesUpdate */
export type UserAchievementPrioritiesUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the user achievements being prioritized, ordered from highest to lowest priority. */
  userAchievementIds: Array<Scalars['AchievementsUserAchievementID']['input']>;
};

/** Autogenerated return type of UserAchievementPrioritiesUpdate. */
export type UserAchievementPrioritiesUpdatePayload = {
  __typename?: 'UserAchievementPrioritiesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated user achievements. */
  userAchievements: Array<UserAchievement>;
};

/** Autogenerated input type of UserAchievementsDelete */
export type UserAchievementsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the user achievement being deleted. */
  userAchievementId: Scalars['AchievementsUserAchievementID']['input'];
};

/** Autogenerated return type of UserAchievementsDelete. */
export type UserAchievementsDeletePayload = {
  __typename?: 'UserAchievementsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted user achievement. */
  userAchievement?: Maybe<UserAchievement>;
};

/** Autogenerated input type of UserAchievementsUpdate */
export type UserAchievementsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether or not the user achievement is visible on the profile. */
  showOnProfile: Scalars['Boolean']['input'];
  /** Global ID of the user achievement being updated. */
  userAchievementId: Scalars['AchievementsUserAchievementID']['input'];
};

/** Autogenerated return type of UserAchievementsUpdate. */
export type UserAchievementsUpdatePayload = {
  __typename?: 'UserAchievementsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Achievement award. */
  userAchievement?: Maybe<UserAchievement>;
};

/** An assignment of an AddOnPurchase to a User. */
export type UserAddOnAssignment = {
  __typename?: 'UserAddOnAssignment';
  /** Add-on purchase the user is assigned to. */
  addOnPurchase: AddOnPurchase;
};

/** Autogenerated input type of UserAddOnAssignmentBulkCreate */
export type UserAddOnAssignmentBulkCreateInput = {
  /** Global ID of AddOnPurchase to be assigned to. */
  addOnPurchaseId: Scalars['GitlabSubscriptionsAddOnPurchaseID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of user to be assigned. */
  userIds: Array<Scalars['UserID']['input']>;
};

/** Autogenerated return type of UserAddOnAssignmentBulkCreate. */
export type UserAddOnAssignmentBulkCreatePayload = {
  __typename?: 'UserAddOnAssignmentBulkCreatePayload';
  /** AddOnPurchase state after mutation. */
  addOnPurchase?: Maybe<AddOnPurchase>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Users who the add-on purchase was assigned to. */
  users?: Maybe<AddOnUserConnection>;
};


/** Autogenerated return type of UserAddOnAssignmentBulkCreate. */
export type UserAddOnAssignmentBulkCreatePayloadUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UserAddOnAssignmentBulkRemove */
export type UserAddOnAssignmentBulkRemoveInput = {
  /** Global ID of AddOnPurchase to be unassigned from. */
  addOnPurchaseId: Scalars['GitlabSubscriptionsAddOnPurchaseID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of user to be unassigned. */
  userIds: Array<Scalars['UserID']['input']>;
};

/** Autogenerated return type of UserAddOnAssignmentBulkRemove. */
export type UserAddOnAssignmentBulkRemovePayload = {
  __typename?: 'UserAddOnAssignmentBulkRemovePayload';
  /** AddOnPurchase state after mutation. */
  addOnPurchase?: Maybe<AddOnPurchase>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Users who was unassigned from the add-on purchase. */
  users?: Maybe<AddOnUserConnection>;
};


/** Autogenerated return type of UserAddOnAssignmentBulkRemove. */
export type UserAddOnAssignmentBulkRemovePayloadUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for UserAddOnAssignment. */
export type UserAddOnAssignmentConnection = {
  __typename?: 'UserAddOnAssignmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserAddOnAssignmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserAddOnAssignment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserAddOnAssignmentCreate */
export type UserAddOnAssignmentCreateInput = {
  /** Global ID of AddOnPurchase to be assigned to. */
  addOnPurchaseId: Scalars['GitlabSubscriptionsAddOnPurchaseID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of user to be assigned. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of UserAddOnAssignmentCreate. */
export type UserAddOnAssignmentCreatePayload = {
  __typename?: 'UserAddOnAssignmentCreatePayload';
  /** AddOnPurchase state after mutation. */
  addOnPurchase?: Maybe<AddOnPurchase>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User who the add-on purchase was assigned to. */
  user?: Maybe<AddOnUser>;
};

/** An edge in a connection. */
export type UserAddOnAssignmentEdge = {
  __typename?: 'UserAddOnAssignmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserAddOnAssignment>;
};

/** Autogenerated input type of UserAddOnAssignmentRemove */
export type UserAddOnAssignmentRemoveInput = {
  /** Global ID of AddOnPurchase assignment belongs to. */
  addOnPurchaseId: Scalars['GitlabSubscriptionsAddOnPurchaseID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of user whose assignment will be removed. */
  userId: Scalars['UserID']['input'];
};

/** Autogenerated return type of UserAddOnAssignmentRemove. */
export type UserAddOnAssignmentRemovePayload = {
  __typename?: 'UserAddOnAssignmentRemovePayload';
  /** AddOnPurchase state after mutation. */
  addOnPurchase?: Maybe<AddOnPurchase>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User that the add-on was removed from. */
  user?: Maybe<AddOnUser>;
};

export type UserCallout = {
  __typename?: 'UserCallout';
  /** Date when the callout was dismissed. */
  dismissedAt?: Maybe<Scalars['Time']['output']>;
  /** Name of the feature that the callout is for. */
  featureName?: Maybe<UserCalloutFeatureNameEnum>;
};

/** The connection type for UserCallout. */
export type UserCalloutConnection = {
  __typename?: 'UserCalloutConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCalloutEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCallout>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserCalloutCreate */
export type UserCalloutCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Feature name you want to dismiss the callout for. */
  featureName: Scalars['String']['input'];
};

/** Autogenerated return type of UserCalloutCreate. */
export type UserCalloutCreatePayload = {
  __typename?: 'UserCalloutCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User callout dismissed. */
  userCallout: UserCallout;
};

/** An edge in a connection. */
export type UserCalloutEdge = {
  __typename?: 'UserCalloutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCallout>;
};

/** Name of the feature that the callout is for. */
export type UserCalloutFeatureNameEnum =
  /** Callout feature name for active_user_count_threshold. */
  | 'ACTIVE_USER_COUNT_THRESHOLD'
  /** Callout feature name for ai_experiment_sast_fp_detection. */
  | 'AI_EXPERIMENT_SAST_FP_DETECTION'
  /** Callout feature name for branch_rules_info_callout. */
  | 'BRANCH_RULES_INFO_CALLOUT'
  /** Callout feature name for branch_rules_tip_callout. */
  | 'BRANCH_RULES_TIP_CALLOUT'
  /** Callout feature name for buy_pipeline_minutes_notification_dot. */
  | 'BUY_PIPELINE_MINUTES_NOTIFICATION_DOT'
  /** Callout feature name for canary_deployment. */
  | 'CANARY_DEPLOYMENT'
  /** Callout feature name for ci_deprecation_warning_for_types_keyword. */
  | 'CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD'
  /** Callout feature name for ci_minutes_limit_alert_danger_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_DANGER_STAGE'
  /** Callout feature name for ci_minutes_limit_alert_exceeded_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_EXCEEDED_STAGE'
  /** Callout feature name for ci_minutes_limit_alert_warning_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_WARNING_STAGE'
  /** Callout feature name for cluster_security_warning. */
  | 'CLUSTER_SECURITY_WARNING'
  /** Callout feature name for deployment_approvals_empty_state. */
  | 'DEPLOYMENT_APPROVALS_EMPTY_STATE'
  /** Callout feature name for deployment_details_feedback. */
  | 'DEPLOYMENT_DETAILS_FEEDBACK'
  /** Callout feature name for dora_dashboard_migration_group. */
  | 'DORA_DASHBOARD_MIGRATION_GROUP'
  /** Callout feature name for dora_dashboard_migration_project. */
  | 'DORA_DASHBOARD_MIGRATION_PROJECT'
  /** Callout feature name for duo_amazon_q_alert. */
  | 'DUO_AMAZON_Q_ALERT'
  /** Callout feature name for duo_chat_callout. */
  | 'DUO_CHAT_CALLOUT'
  /** Callout feature name for email_otp_enrollment_callout. */
  | 'EMAIL_OTP_ENROLLMENT_CALLOUT'
  /** Callout feature name for expired_trial_status_widget. */
  | 'EXPIRED_TRIAL_STATUS_WIDGET'
  /** Callout feature name for explore_duo_core_banner. */
  | 'EXPLORE_DUO_CORE_BANNER'
  /** Callout feature name for feature_flags_new_version. */
  | 'FEATURE_FLAGS_NEW_VERSION'
  /** Callout feature name for focused_vulnerability_reporting. */
  | 'FOCUSED_VULNERABILITY_REPORTING'
  /** Callout feature name for gcp_signup_offer. */
  | 'GCP_SIGNUP_OFFER'
  /** Callout feature name for geo_enable_hashed_storage. */
  | 'GEO_ENABLE_HASHED_STORAGE'
  /** Callout feature name for geo_migrate_hashed_storage. */
  | 'GEO_MIGRATE_HASHED_STORAGE'
  /** Callout feature name for gke_cluster_integration. */
  | 'GKE_CLUSTER_INTEGRATION'
  /** Callout feature name for gold_trial_billings. */
  | 'GOLD_TRIAL_BILLINGS'
  /** Callout feature name for joining_a_project_alert. */
  | 'JOINING_A_PROJECT_ALERT'
  /** Callout feature name for merge_request_dashboard_display_preferences_popover. */
  | 'MERGE_REQUEST_DASHBOARD_DISPLAY_PREFERENCES_POPOVER'
  /** Callout feature name for merge_request_dashboard_show_drafts. */
  | 'MERGE_REQUEST_DASHBOARD_SHOW_DRAFTS'
  /** Callout feature name for namespace_over_storage_users_combined_alert. */
  | 'NAMESPACE_OVER_STORAGE_USERS_COMBINED_ALERT'
  /** Callout feature name for namespace_storage_limit_alert_alert_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ALERT_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_error_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ERROR_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_warning_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for namespace_storage_pre_enforcement_banner. */
  | 'NAMESPACE_STORAGE_PRE_ENFORCEMENT_BANNER'
  /** Callout feature name for new_merge_request_dashboard_welcome. */
  | 'NEW_MERGE_REQUEST_DASHBOARD_WELCOME'
  /** Callout feature name for new_mr_dashboard_banner. */
  | 'NEW_MR_DASHBOARD_BANNER'
  /** Callout feature name for new_top_level_group_alert. */
  | 'NEW_TOP_LEVEL_GROUP_ALERT'
  /** Callout feature name for new_user_signups_cap_reached. */
  | 'NEW_USER_SIGNUPS_CAP_REACHED'
  /** Callout feature name for openssl_callout. */
  | 'OPENSSL_CALLOUT'
  /** Callout feature name for period_in_terraform_state_name_alert. */
  | 'PERIOD_IN_TERRAFORM_STATE_NAME_ALERT'
  /** Callout feature name for personal_access_token_expiry. */
  | 'PERSONAL_ACCESS_TOKEN_EXPIRY'
  /** Callout feature name for personal_homepage_preferences_banner. */
  | 'PERSONAL_HOMEPAGE_PREFERENCES_BANNER'
  /** Callout feature name for personal_project_limitations_banner. */
  | 'PERSONAL_PROJECT_LIMITATIONS_BANNER'
  /** Callout feature name for pipeline_inputs_announcement_banner. */
  | 'PIPELINE_INPUTS_ANNOUNCEMENT_BANNER'
  /** Callout feature name for pipeline_needs_banner. */
  | 'PIPELINE_NEEDS_BANNER'
  /** Callout feature name for pipeline_needs_hover_tip. */
  | 'PIPELINE_NEEDS_HOVER_TIP'
  /** Callout feature name for pipeline_new_inputs_adoption_banner. */
  | 'PIPELINE_NEW_INPUTS_ADOPTION_BANNER'
  /** Callout feature name for pipeline_schedules_inputs_adoption_banner. */
  | 'PIPELINE_SCHEDULES_INPUTS_ADOPTION_BANNER'
  /** Callout feature name for pipl_compliance_alert. */
  | 'PIPL_COMPLIANCE_ALERT'
  /** Callout feature name for preview_user_over_limit_free_plan_alert. */
  | 'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for product_usage_data_collection_changes. */
  | 'PRODUCT_USAGE_DATA_COLLECTION_CHANGES'
  /** Callout feature name for profile_personal_access_token_expiry. */
  | 'PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY'
  /** Callout feature name for project_repository_limit_alert_warning_threshold. */
  | 'PROJECT_REPOSITORY_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for registration_enabled_callout. */
  | 'REGISTRATION_ENABLED_CALLOUT'
  /** Callout feature name for security_configuration_devops_alert. */
  | 'SECURITY_CONFIGURATION_DEVOPS_ALERT'
  /** Callout feature name for security_configuration_upgrade_banner. */
  | 'SECURITY_CONFIGURATION_UPGRADE_BANNER'
  /** Callout feature name for security_newsletter_callout. */
  | 'SECURITY_NEWSLETTER_CALLOUT'
  /** Callout feature name for security_policy_protected_branch_modification. */
  | 'SECURITY_POLICY_PROTECTED_BRANCH_MODIFICATION'
  /** Callout feature name for security_training_feature_promotion. */
  | 'SECURITY_TRAINING_FEATURE_PROMOTION'
  /** Callout feature name for submit_license_usage_data_banner. */
  | 'SUBMIT_LICENSE_USAGE_DATA_BANNER'
  /** Callout feature name for suggest_pipeline. */
  | 'SUGGEST_PIPELINE'
  /** Callout feature name for suggest_popover_dismissed. */
  | 'SUGGEST_POPOVER_DISMISSED'
  /** Callout feature name for tabs_position_highlight. */
  | 'TABS_POSITION_HIGHLIGHT'
  /** Callout feature name for terraform_notification_dismissed. */
  | 'TERRAFORM_NOTIFICATION_DISMISSED'
  /** Callout feature name for threat_monitoring_info. */
  | 'THREAT_MONITORING_INFO'
  /** Callout feature name for transition_to_jihu_callout. */
  | 'TRANSITION_TO_JIHU_CALLOUT'
  /** Callout feature name for trial_status_reminder_d3. */
  | 'TRIAL_STATUS_REMINDER_D3'
  /** Callout feature name for trial_status_reminder_d14. */
  | 'TRIAL_STATUS_REMINDER_D14'
  /** Callout feature name for two_factor_auth_recovery_settings_check. */
  | 'TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK'
  /** Callout feature name for ultimate_trial. */
  | 'ULTIMATE_TRIAL'
  /** Callout feature name for unfinished_tag_cleanup_callout. */
  | 'UNFINISHED_TAG_CLEANUP_CALLOUT'
  /** Callout feature name for user_reached_limit_free_plan_alert. */
  | 'USER_REACHED_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for verification_reminder. */
  | 'VERIFICATION_REMINDER'
  /** Callout feature name for vsd_feedback_banner. */
  | 'VSD_FEEDBACK_BANNER'
  /** Callout feature name for vulnerability_archival. */
  | 'VULNERABILITY_ARCHIVAL'
  /** Callout feature name for vulnerability_report_grouping. */
  | 'VULNERABILITY_REPORT_GROUPING'
  /** Callout feature name for vulnerability_report_limited_experience. */
  | 'VULNERABILITY_REPORT_LIMITED_EXPERIENCE'
  /** Callout feature name for web_ide_alert_dismissed. */
  | 'WEB_IDE_ALERT_DISMISSED'
  /** Callout feature name for web_ide_ci_environments_guidance. */
  | 'WEB_IDE_CI_ENVIRONMENTS_GUIDANCE'
  /** Callout feature name for work_item_consolidated_list_feedback. */
  | 'WORK_ITEM_CONSOLIDATED_LIST_FEEDBACK'
  /** Callout feature name for work_item_epic_feedback. */
  | 'WORK_ITEM_EPIC_FEEDBACK';

/** Core representation of a GitLab user. */
export type UserCore = Todoable & User & {
  __typename?: 'UserCore';
  /** Indicates if the user is active. */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']['output']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean']['output'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']['output']>;
  /** Projects the user has contributed to. */
  contributedProjects?: Maybe<ProjectConnection>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']['output']>;
  /**
   * User email. Deprecated in GitLab 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.
   */
  email?: Maybe<Scalars['String']['output']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** GitHub profile name of the user. */
  github?: Maybe<Scalars['String']['output']>;
  /** Whether Ona is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** User callouts that belong to the user per group. */
  groupCallouts?: Maybe<UserGroupCalloutConnection>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']['output']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** Indicates if the user is a regular user. */
  human?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the user. */
  id: Scalars['UserID']['output'];
  /** IDE settings. */
  ide?: Maybe<Ide>;
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Date the user last performed any actions. */
  lastActivityOn?: Maybe<Scalars['Date']['output']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project. */
  name: Scalars['String']['output'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']['output']>;
  /**
   * Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.6.
   */
  organizations?: Maybe<OrganizationConnection>;
  /**
   * Personal access tokens of the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  personalAccessTokens?: Maybe<PersonalAccessTokenConnection>;
  /** Web path to the Ona section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Web path to enable Ona for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']['output']>;
  /** Project count for the user. */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** Pronouns of the user. */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']['output']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** X (formerly Twitter) username of the user. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Type of the user. */
  type: UserType;
  /**
   * Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Preferences for the user. */
  userPreferences?: Maybe<UserPreferences>;
  /** Username of the user. Unique within the instance of GitLab. */
  username: Scalars['String']['output'];
  /** Web path of the user. */
  webPath: Scalars['String']['output'];
  /** Web URL of the user. */
  webUrl: Scalars['String']['output'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** Core representation of a GitLab user. */
export type UserCoreAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  includeAssigned?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  reviewerUsername?: InputMaybe<Scalars['String']['input']>;
  reviewerWildcardId?: InputMaybe<ReviewerWildcardId>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreContributedProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePersonal?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Core representation of a GitLab user. */
export type UserCoreEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreGroupCalloutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<GroupSort>;
};


/** Core representation of a GitLab user. */
export type UserCoreNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  soloOwned?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCorePersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  expiresAfter?: InputMaybe<Scalars['Date']['input']>;
  expiresBefore?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastUsedAfter?: InputMaybe<Scalars['Time']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<AccessTokenSort>;
  state?: InputMaybe<AccessTokenState>;
};


/** Core representation of a GitLab user. */
export type UserCoreProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  approvedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  approver?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeUsername?: InputMaybe<Scalars['String']['input']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  deployedAfter?: InputMaybe<Scalars['Time']['input']>;
  deployedBefore?: InputMaybe<Scalars['Time']['input']>;
  deploymentId?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  environmentName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mergedAfter?: InputMaybe<Scalars['Time']['input']>;
  mergedBefore?: InputMaybe<Scalars['Time']['input']>;
  mergedBy?: InputMaybe<Scalars['String']['input']>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  or?: InputMaybe<UnionedMergeRequestFilterInput>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  projectPath?: InputMaybe<Scalars['String']['input']>;
  releaseTag?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  state?: InputMaybe<MergeRequestState>;
  subscribed?: InputMaybe<SubscriptionStatus>;
  targetBranches?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID']['input'];
};


/** Core representation of a GitLab user. */
export type UserCoreSnippetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** Core representation of a GitLab user. */
export type UserCoreStarredProjectsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minAccessLevel?: InputMaybe<AccessLevelEnum>;
  programmingLanguageName?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
};


/** Core representation of a GitLab user. */
export type UserCoreTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endTime?: InputMaybe<Scalars['Time']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['GroupID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ProjectID']['input']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startTime?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']['input']>;
  authorId?: InputMaybe<Array<Scalars['ID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Array<Scalars['ID']['input']>>;
  isSnoozed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<TodoSort>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** Core representation of a GitLab user. */
export type UserCoreUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeHidden?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Core representation of a GitLab user. */
export type UserCoreWorkspacesArgs = {
  actualStates?: InputMaybe<Array<Scalars['String']['input']>>;
  after?: InputMaybe<Scalars['String']['input']>;
  agentIds?: InputMaybe<Array<Scalars['ClustersAgentID']['input']>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

/** The connection type for UserCore. */
export type UserCoreConnection = {
  __typename?: 'UserCoreConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCoreEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCore>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for UserCore. */
export type UserCoreConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type UserCoreEdge = {
  __typename?: 'UserCoreEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCore>;
};

export type UserGroupCallout = {
  __typename?: 'UserGroupCallout';
  /** Date when the callout was dismissed. */
  dismissedAt: Scalars['Time']['output'];
  /** Name of the feature that the callout is for. */
  featureName: UserGroupCalloutFeatureName;
  /** Group id that the callout applies. */
  groupId: Scalars['GroupID']['output'];
};

/** The connection type for UserGroupCallout. */
export type UserGroupCalloutConnection = {
  __typename?: 'UserGroupCalloutConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserGroupCalloutEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserGroupCallout>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserGroupCalloutCreate */
export type UserGroupCalloutCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Feature name you want to dismiss the callout for. */
  featureName: Scalars['String']['input'];
  /** Group for the callout. */
  groupId: Scalars['GroupID']['input'];
};

/** Autogenerated return type of UserGroupCalloutCreate. */
export type UserGroupCalloutCreatePayload = {
  __typename?: 'UserGroupCalloutCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User group callout dismissed. */
  userGroupCallout: UserGroupCallout;
};

/** An edge in a connection. */
export type UserGroupCalloutEdge = {
  __typename?: 'UserGroupCalloutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserGroupCallout>;
};

/** Name of the feature that the callout is for. */
export type UserGroupCalloutFeatureName =
  /** Callout feature name for all_seats_used_alert. */
  | 'ALL_SEATS_USED_ALERT'
  /** Callout feature name for approaching_seat_count_threshold. */
  | 'APPROACHING_SEAT_COUNT_THRESHOLD'
  /** Callout feature name for ci_minutes_limit_alert_danger_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_DANGER_STAGE'
  /** Callout feature name for ci_minutes_limit_alert_exceeded_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_EXCEEDED_STAGE'
  /** Callout feature name for ci_minutes_limit_alert_warning_stage. */
  | 'CI_MINUTES_LIMIT_ALERT_WARNING_STAGE'
  /** Callout feature name for compliance_framework_settings_moved_callout. */
  | 'COMPLIANCE_FRAMEWORK_SETTINGS_MOVED_CALLOUT'
  /** Callout feature name for end_of_trial_modal. */
  | 'END_OF_TRIAL_MODAL'
  /** Callout feature name for enforcement_at_limit_alert. */
  | 'ENFORCEMENT_AT_LIMIT_ALERT'
  /** Callout feature name for expired_duo_enterprise_trial_widget. */
  | 'EXPIRED_DUO_ENTERPRISE_TRIAL_WIDGET'
  /** Callout feature name for expired_duo_pro_trial_widget. */
  | 'EXPIRED_DUO_PRO_TRIAL_WIDGET'
  /** Callout feature name for expired_trial_status_widget. */
  | 'EXPIRED_TRIAL_STATUS_WIDGET'
  /** Callout feature name for free_group_limited_alert. */
  | 'FREE_GROUP_LIMITED_ALERT'
  /** Callout feature name for invite_members_banner. */
  | 'INVITE_MEMBERS_BANNER'
  /** Callout feature name for mrs_premium_message_callout. */
  | 'MRS_PREMIUM_MESSAGE_CALLOUT'
  /** Callout feature name for namespace_over_storage_users_combined_alert. */
  | 'NAMESPACE_OVER_STORAGE_USERS_COMBINED_ALERT'
  /** Callout feature name for namespace_storage_limit_alert_alert_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ALERT_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_error_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ERROR_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_warning_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for namespace_storage_pre_enforcement_banner. */
  | 'NAMESPACE_STORAGE_PRE_ENFORCEMENT_BANNER'
  /** Callout feature name for namespace_user_cap_reached_alert. */
  | 'NAMESPACE_USER_CAP_REACHED_ALERT'
  /** Callout feature name for preview_usage_quota_free_plan_alert. */
  | 'PREVIEW_USAGE_QUOTA_FREE_PLAN_ALERT'
  /** Callout feature name for preview_user_over_limit_free_plan_alert. */
  | 'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for project_premium_message_callout. */
  | 'PROJECT_PREMIUM_MESSAGE_CALLOUT'
  /** Callout feature name for project_repository_limit_alert_warning_threshold. */
  | 'PROJECT_REPOSITORY_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for repository_premium_message_callout. */
  | 'REPOSITORY_PREMIUM_MESSAGE_CALLOUT'
  /** Callout feature name for unlimited_members_during_trial_alert. */
  | 'UNLIMITED_MEMBERS_DURING_TRIAL_ALERT'
  /** Callout feature name for usage_quota_trial_alert. */
  | 'USAGE_QUOTA_TRIAL_ALERT'
  /** Callout feature name for user_reached_limit_free_plan_alert. */
  | 'USER_REACHED_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for virtual_registry_permission_change_alert. */
  | 'VIRTUAL_REGISTRY_PERMISSION_CHANGE_ALERT'
  /** Callout feature name for web_hook_disabled. */
  | 'WEB_HOOK_DISABLED';

export type UserMemberRole = {
  __typename?: 'UserMemberRole';
  /** Global ID of the user member role association. */
  id: Scalars['GlobalID']['output'];
  /** Member Role to which the user belongs. */
  memberRole: MemberRole;
  /** User to which the member role belongs. */
  user: UserCore;
};

/**
 * Information about a merge request given a specific user.
 *
 * This object has two parts to its state: a `User` and a `MergeRequest`. All
 * fields relate to interactions between the two entities.
 *
 */
export type UserMergeRequestInteraction = {
  __typename?: 'UserMergeRequestInteraction';
  /** Approval rules that apply to the user for the merge request. */
  applicableApprovalRules?: Maybe<Array<ApprovalRule>>;
  /** Whether the user has approved the merge request. */
  approved: Scalars['Boolean']['output'];
  /** Whether the user can merge the merge request. */
  canMerge: Scalars['Boolean']['output'];
  /** Whether the user can update the merge request. */
  canUpdate: Scalars['Boolean']['output'];
  /** State of the review by the user. */
  reviewState?: Maybe<MergeRequestReviewState>;
  /** Whether the user has provided a review for the merge request. */
  reviewed: Scalars['Boolean']['output'];
};

export type UserNamespaceLinks = NamespacesLinkPaths & {
  __typename?: 'UserNamespaceLinks';
  /**
   * Path for autocomplete award emojis. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  autocompleteAwardEmojisPath?: Maybe<Scalars['String']['output']>;
  /**
   * Calendar path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  calendarPath?: Maybe<Scalars['String']['output']>;
  /** Namespace contribution guide path. */
  contributionGuidePath?: Maybe<Scalars['String']['output']>;
  /** Help page path for emails. */
  emailsHelpPagePath?: Maybe<Scalars['String']['output']>;
  /** Namespace epics_list. */
  epicsList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the epics list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  epicsListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace group_issues. */
  groupIssues?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the group. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues_list. */
  issuesList?: Maybe<Scalars['String']['output']>;
  /**
   * Path to the issues list for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  issuesListPath?: Maybe<Scalars['String']['output']>;
  /** Namespace issues settings path. */
  issuesSettings?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_fetch. */
  labelsFetch?: Maybe<Scalars['String']['output']>;
  /** Namespace labels_manage. */
  labelsManage?: Maybe<Scalars['String']['output']>;
  /** Help page path for Markdown. */
  markdownHelpPath?: Maybe<Scalars['String']['output']>;
  /**
   * Full path of the namespace (project.namespace.full_path or group full_path). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  namespaceFullPath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_comment_template_paths. */
  newCommentTemplate?: Maybe<Array<CommentTemplatePath>>;
  /**
   * Path to create a new issue. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newIssuePath?: Maybe<Scalars['String']['output']>;
  /** Namespace new_project. */
  newProject?: Maybe<Scalars['String']['output']>;
  /**
   * New trial path for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newTrialPath?: Maybe<Scalars['String']['output']>;
  /** Help page path for quick actions. */
  quickActionsHelpPath?: Maybe<Scalars['String']['output']>;
  /** Namespace register_path. */
  register?: Maybe<Scalars['String']['output']>;
  /** Namespace report_abuse. */
  reportAbuse?: Maybe<Scalars['String']['output']>;
  /**
   * RSS path for work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  rssPath?: Maybe<Scalars['String']['output']>;
  /** Namespace sign_in_path. */
  signIn?: Maybe<Scalars['String']['output']>;
  /**
   * User email for export CSV. Returns `null` for user namespaces. Introduced in GitLab 18.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.3.
   */
  userExportEmail?: Maybe<Scalars['String']['output']>;
};

export type UserNamespaceMarkdownPaths = MarkdownPaths & {
  __typename?: 'UserNamespaceMarkdownPaths';
  /** Supported paths for autocomplete sources for a given namespace. */
  autocompleteSourcesPath?: Maybe<Scalars['JSON']['output']>;
  /** Path for the markdown preview for given namespace. */
  markdownPreviewPath?: Maybe<Scalars['String']['output']>;
  /** Uploads path for a given namespace. */
  uploadsPath?: Maybe<Scalars['String']['output']>;
};


export type UserNamespaceMarkdownPathsAutocompleteSourcesPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
  workItemTypeId?: InputMaybe<Scalars['String']['input']>;
};


export type UserNamespaceMarkdownPathsMarkdownPreviewPathArgs = {
  iid?: InputMaybe<Scalars['String']['input']>;
};

export type UserNamespaceMetadata = NamespaceMetadata & {
  __typename?: 'UserNamespaceMetadata';
  /**
   * ID of the group. Returns null for user namespaces. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  groupId?: Maybe<Scalars['String']['output']>;
  /**
   * User preference for initial sort order. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  initialSort?: Maybe<Scalars['String']['output']>;
  /**
   * Whether issue repositioning is disabled for the namespace. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  isIssueRepositioningDisabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Maximum allowed attachment size (humanized). Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  maxAttachmentSize?: Maybe<Scalars['String']['output']>;
  /**
   * Whether to show the new work item link. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  showNewWorkItem?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Time tracking limit to hours setting. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  timeTrackingLimitToHours?: Maybe<Scalars['Boolean']['output']>;
};

export type UserPermissions = {
  __typename?: 'UserPermissions';
  /** If `true`, the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean']['output'];
};

export type UserPreferences = {
  __typename?: 'UserPreferences';
  /** Status of the Web IDE Extension Marketplace opt-in for the user. */
  extensionsMarketplaceOptInStatus: ExtensionsMarketplaceOptInStatus;
  /** Sort order for issue lists. */
  issuesSort?: Maybe<IssueSort>;
  /** Merge request dashboard list rendering type. */
  mergeRequestDashboardListType?: Maybe<MergeRequestsDashboardListType>;
  /** Show draft merge requests on merge request dashboard. */
  mergeRequestDashboardShowDrafts?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Whether the new UI is enabled for the user. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  newUiEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Default list view for organization groups and projects. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  organizationGroupsProjectsDisplay: OrganizationGroupProjectDisplay;
  /**
   * Sort order for organization groups and projects. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  organizationGroupsProjectsSort?: Maybe<OrganizationGroupProjectSort>;
  /** Sort order for projects. */
  projectsSort?: Maybe<ProjectSort>;
  /**
   * Timezone of the user. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  timezone?: Maybe<Scalars['String']['output']>;
  /** Use work item view instead of legacy issue view. */
  useWorkItemsView?: Maybe<Scalars['Boolean']['output']>;
  /** Determines whether the pipeline list shows ID or IID. */
  visibilityPipelineIdType?: Maybe<VisibilityPipelineIdType>;
  /** Display settings for the work item lists. */
  workItemsDisplaySettings: Scalars['JSON']['output'];
};

/** Autogenerated input type of UserPreferencesUpdate */
export type UserPreferencesUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Default namespace context for Duo features when namespace can not be inferred. */
  duoDefaultNamespaceId?: InputMaybe<Scalars['Int']['input']>;
  /** Status of the Web IDE Extension Marketplace opt-in for the user. */
  extensionsMarketplaceOptInStatus?: InputMaybe<ExtensionsMarketplaceOptInStatus>;
  /** Sort order for issue lists. */
  issuesSort?: InputMaybe<IssueSort>;
  /** Merge request dashboard list rendering type. */
  mergeRequestDashboardListType?: InputMaybe<MergeRequestsDashboardListType>;
  /** Show draft merge requests on the merge request dashboard. */
  mergeRequestDashboardShowDrafts?: InputMaybe<Scalars['Boolean']['input']>;
  /** Sort order for issue lists. */
  mergeRequestsSort?: InputMaybe<MergeRequestSort>;
  /** Sort order for projects. */
  projectsSort?: InputMaybe<ProjectSort>;
  /** Use work item view instead of legacy issue view. */
  useWorkItemsView?: InputMaybe<Scalars['Boolean']['input']>;
  /** Determines whether the pipeline list shows ID or IID. */
  visibilityPipelineIdType?: InputMaybe<VisibilityPipelineIdType>;
};

/** Autogenerated return type of UserPreferencesUpdate. */
export type UserPreferencesUpdatePayload = {
  __typename?: 'UserPreferencesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User preferences after mutation. */
  userPreferences?: Maybe<UserPreferences>;
};

/** Types of User Promotion States. */
export type UserPromotionStatusType =
  /** Failed to apply promotion requests for user. */
  | 'FAILED'
  /** User promotion was successful, but all promotion requests were not successfully applied. */
  | 'PARTIAL_SUCCESS'
  /** Successfully applied all promotion requests for user. */
  | 'SUCCESS';

/** Autogenerated input type of UserSetNamespaceCommitEmail */
export type UserSetNamespaceCommitEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the email to set. */
  emailId?: InputMaybe<Scalars['EmailID']['input']>;
  /** ID of the namespace to set the namespace commit email for. */
  namespaceId: Scalars['NamespaceID']['input'];
};

/** Autogenerated return type of UserSetNamespaceCommitEmail. */
export type UserSetNamespaceCommitEmailPayload = {
  __typename?: 'UserSetNamespaceCommitEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User namespace commit email after mutation. */
  namespaceCommitEmail?: Maybe<NamespaceCommitEmail>;
};

/** Possible states of a user */
export type UserState =
  /** User is active and can use the system. */
  | 'active'
  /** User is blocked, and their contributions are hidden. */
  | 'banned'
  /** User has been blocked by an administrator and cannot use the system. */
  | 'blocked'
  /** User is blocked and pending approval. */
  | 'blocked_pending_approval'
  /** User is no longer active and cannot use the system. */
  | 'deactivated'
  /** User has been blocked by the system. */
  | 'ldap_blocked';

export type UserStatus = {
  __typename?: 'UserStatus';
  /** User availability status. */
  availability: AvailabilityEnum;
  /** Timestamp when the status should be automatically cleared. */
  clearStatusAt?: Maybe<Scalars['Time']['output']>;
  /** Indicates if the user is disabled for assignment in Duo features. */
  disabledForDuoUsage: Scalars['Boolean']['output'];
  /** Reason why the user is disabled for assignment in Duo features. */
  disabledForDuoUsageReason?: Maybe<Scalars['String']['output']>;
  /** String representation of emoji. */
  emoji?: Maybe<Scalars['String']['output']>;
  /** User status message. */
  message?: Maybe<Scalars['String']['output']>;
  /** HTML of the user status message */
  messageHtml?: Maybe<Scalars['String']['output']>;
};

/** Possible types of user */
export type UserType =
  /** Admin bot */
  | 'ADMIN_BOT'
  /** Alert bot */
  | 'ALERT_BOT'
  /** Automation bot */
  | 'AUTOMATION_BOT'
  /** Duo code review bot */
  | 'DUO_CODE_REVIEW_BOT'
  /** Ghost */
  | 'GHOST'
  /** Human */
  | 'HUMAN'
  /** Import user */
  | 'IMPORT_USER'
  /** Placeholder */
  | 'PLACEHOLDER'
  /** Project bot */
  | 'PROJECT_BOT'
  /** Security bot */
  | 'SECURITY_BOT'
  /** Security policy bot */
  | 'SECURITY_POLICY_BOT'
  /** Service account */
  | 'SERVICE_ACCOUNT'
  /** Service user */
  | 'SERVICE_USER'
  /** Support bot */
  | 'SUPPORT_BOT'
  /** Visual review bot */
  | 'VISUAL_REVIEW_BOT';

/** Represents a Pending Member Approval Queued for Role Promotion */
export type UsersQueuedForRolePromotion = {
  __typename?: 'UsersQueuedForRolePromotion';
  /** Highest New GitLab::Access level requested for the member. */
  newAccessLevel?: Maybe<AccessLevel>;
  /** User that is associated with the member approval object. */
  user?: Maybe<UserCore>;
};

/** The connection type for UsersQueuedForRolePromotion. */
export type UsersQueuedForRolePromotionConnection = {
  __typename?: 'UsersQueuedForRolePromotionConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UsersQueuedForRolePromotionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UsersQueuedForRolePromotion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for UsersQueuedForRolePromotion. */
export type UsersQueuedForRolePromotionConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type UsersQueuedForRolePromotionEdge = {
  __typename?: 'UsersQueuedForRolePromotionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UsersQueuedForRolePromotion>;
};

export type ValueStream = {
  __typename?: 'ValueStream';
  /** ID of the value stream. */
  id: Scalars['AnalyticsCycleAnalyticsValueStreamID']['output'];
  /** Name of the value stream. */
  name: Scalars['String']['output'];
  /** Namespace the value stream belongs to. */
  namespace: Namespace;
  /**
   * Project the value stream belongs to, returns empty if it belongs to a group. Introduced in GitLab 15.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.6.
   */
  project?: Maybe<Project>;
  /** Value Stream stages. */
  stages?: Maybe<Array<ValueStreamStage>>;
};


export type ValueStreamStagesArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type ValueStreamAnalytics = {
  __typename?: 'ValueStreamAnalytics';
  /** Shows information about background data collection and aggregation. */
  aggregationStatus?: Maybe<AggregationStatus>;
};

export type ValueStreamAnalyticsDateMetric = {
  __typename?: 'ValueStreamAnalyticsDateMetric';
  /** Date for the metric. */
  date?: Maybe<Scalars['Date']['output']>;
  /** Identifier for the metric. */
  identifier: Scalars['String']['output'];
  /** Optional links for drilling down. */
  links: Array<ValueStreamMetricLinkType>;
  /** Title for the metric. */
  title: Scalars['String']['output'];
  /** Unit of measurement. */
  unit?: Maybe<Scalars['String']['output']>;
  /** Value for the metric. */
  value?: Maybe<Scalars['Float']['output']>;
};

export type ValueStreamAnalyticsMetric = {
  __typename?: 'ValueStreamAnalyticsMetric';
  /** Identifier for the metric. */
  identifier: Scalars['String']['output'];
  /** Optional links for drilling down. */
  links: Array<ValueStreamMetricLinkType>;
  /** Title for the metric. */
  title: Scalars['String']['output'];
  /** Unit of measurement. */
  unit?: Maybe<Scalars['String']['output']>;
  /** Value for the metric. */
  value?: Maybe<Scalars['Float']['output']>;
};

/** The connection type for ValueStream. */
export type ValueStreamConnection = {
  __typename?: 'ValueStreamConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ValueStreamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ValueStream>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ValueStreamCreate */
export type ValueStreamCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Value stream name. */
  name: Scalars['String']['input'];
  /** Full path of the namespace(project or group) the value stream is created in. */
  namespacePath: Scalars['ID']['input'];
  /** Value stream configuration. */
  setting?: InputMaybe<ValueStreamSettingInput>;
  /** Value stream stages. */
  stages?: InputMaybe<Array<CreateValueStreamStageInput>>;
};

/** Autogenerated return type of ValueStreamCreate. */
export type ValueStreamCreatePayload = {
  __typename?: 'ValueStreamCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created value stream. */
  valueStream?: Maybe<ValueStream>;
};

/** Represents a recorded measurement (object count) for the requested group */
export type ValueStreamDashboardCount = {
  __typename?: 'ValueStreamDashboardCount';
  /** Object count. */
  count?: Maybe<Scalars['Int']['output']>;
  /** Type of object being measured. */
  identifier: ValueStreamDashboardMetric;
  /** Time the measurement was taken. */
  recordedAt?: Maybe<Scalars['Time']['output']>;
};

/** Possible identifier types for a measurement */
export type ValueStreamDashboardMetric =
  /** Contributor count. EXPERIMENTAL: Only available on the SaaS version of GitLab when the ClickHouse database backend is enabled. */
  | 'CONTRIBUTORS'
  /** Group count. */
  | 'GROUPS'
  /** Issue count. */
  | 'ISSUES'
  /** Merge request count. */
  | 'MERGE_REQUESTS'
  /** Pipeline count. */
  | 'PIPELINES'
  /** Project count. */
  | 'PROJECTS'
  /** User count. */
  | 'USERS';

/** Possible identifier types for project-level measurement */
export type ValueStreamDashboardProjectLevelMetric =
  /** Contributor count. EXPERIMENTAL: Only available on the SaaS version of GitLab when the ClickHouse database backend is enabled. */
  | 'CONTRIBUTORS'
  /** Issue count. */
  | 'ISSUES'
  /** Merge request count. */
  | 'MERGE_REQUESTS'
  /** Pipeline count. */
  | 'PIPELINES';

/** Autogenerated input type of ValueStreamDestroy */
export type ValueStreamDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the value stream to destroy. */
  id: Scalars['AnalyticsCycleAnalyticsValueStreamID']['input'];
};

/** Autogenerated return type of ValueStreamDestroy. */
export type ValueStreamDestroyPayload = {
  __typename?: 'ValueStreamDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Value stream deleted after mutation. */
  valueStream?: Maybe<ValueStream>;
};

/** An edge in a connection. */
export type ValueStreamEdge = {
  __typename?: 'ValueStreamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ValueStream>;
};

export type ValueStreamMetricLinkType = {
  __typename?: 'ValueStreamMetricLinkType';
  /** Link to the metric documentation. */
  docsLink?: Maybe<Scalars['Boolean']['output']>;
  /** Label for the link. */
  label: Scalars['String']['output'];
  /** Name of the link group. */
  name: Scalars['String']['output'];
  /** Drill-down URL. */
  url: Scalars['String']['output'];
};

/** Attributes for value stream setting. */
export type ValueStreamSettingInput = {
  /** Projects' global IDs used to filter value stream data. */
  projectIdsFilter?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
};

export type ValueStreamStage = {
  __typename?: 'ValueStreamStage';
  /** Whether the stage is customized. */
  custom: Scalars['Boolean']['output'];
  /** HTML description of the end event. */
  endEventHtmlDescription: Scalars['String']['output'];
  /** End event identifier. */
  endEventIdentifier: ValueStreamStageEvent;
  /** Label associated with end event. */
  endEventLabel?: Maybe<Label>;
  /** Whether the stage is hidden. */
  hidden: Scalars['Boolean']['output'];
  /** ID of the value stream. */
  id: Scalars['AnalyticsCycleAnalyticsStageID']['output'];
  /** Aggregated metrics for the given stage */
  metrics: ValueStreamStageMetrics;
  /** Name of the stage. */
  name: Scalars['String']['output'];
  /** HTML description of the start event. */
  startEventHtmlDescription: Scalars['String']['output'];
  /** Start event identifier. */
  startEventIdentifier: ValueStreamStageEvent;
  /** Label associated with start event. */
  startEventLabel?: Maybe<Label>;
};


export type ValueStreamStageMetricsArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  epicId?: InputMaybe<Scalars['ID']['input']>;
  iterationId?: InputMaybe<Scalars['ID']['input']>;
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
  milestoneTitle?: InputMaybe<Scalars['String']['input']>;
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NegatedValueStreamAnalyticsIssuableFilterInput>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']['input']>>;
  timeframe: Timeframe;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Stage event identifiers */
export type ValueStreamStageEvent =
  /** Code stage start event. */
  | 'CODE_STAGE_START'
  /** Issue closed event. */
  | 'ISSUE_CLOSED'
  /** Issue created event. */
  | 'ISSUE_CREATED'
  /** Issue deployed to production event. */
  | 'ISSUE_DEPLOYED_TO_PRODUCTION'
  /** Issue first added to board event. */
  | 'ISSUE_FIRST_ADDED_TO_BOARD'
  /** Issue first added to iteration event. */
  | 'ISSUE_FIRST_ADDED_TO_ITERATION'
  /** Issue first assigned at event. */
  | 'ISSUE_FIRST_ASSIGNED_AT'
  /** Issue first associated with milestone event. */
  | 'ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE'
  /** Issue first mentioned in commit event. */
  | 'ISSUE_FIRST_MENTIONED_IN_COMMIT'
  /** Issue label added event. */
  | 'ISSUE_LABEL_ADDED'
  /** Issue label removed event. */
  | 'ISSUE_LABEL_REMOVED'
  /** Issue last edited event. */
  | 'ISSUE_LAST_EDITED'
  /** Issue stage end event. */
  | 'ISSUE_STAGE_END'
  /** Merge request closed event. */
  | 'MERGE_REQUEST_CLOSED'
  /** Merge request created event. */
  | 'MERGE_REQUEST_CREATED'
  /** Merge request first assigned at event. */
  | 'MERGE_REQUEST_FIRST_ASSIGNED_AT'
  /** Merge request first commit at event. */
  | 'MERGE_REQUEST_FIRST_COMMIT_AT'
  /** Merge request first deployed to production event. */
  | 'MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION'
  /** Merge request label added event. */
  | 'MERGE_REQUEST_LABEL_ADDED'
  /** Merge request label removed event. */
  | 'MERGE_REQUEST_LABEL_REMOVED'
  /** Merge request last approved at event. */
  | 'MERGE_REQUEST_LAST_APPROVED_AT'
  /** Merge request last build finished event. */
  | 'MERGE_REQUEST_LAST_BUILD_FINISHED'
  /** Merge request last build started event. */
  | 'MERGE_REQUEST_LAST_BUILD_STARTED'
  /** Merge request last edited event. */
  | 'MERGE_REQUEST_LAST_EDITED'
  /** Merge request merged event. */
  | 'MERGE_REQUEST_MERGED'
  /** Merge request reviewer first assigned event. */
  | 'MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED'
  /** Plan stage start event. */
  | 'PLAN_STAGE_START';

/** Sorting values available to value stream stage items */
export type ValueStreamStageItemSort =
  /** Duration by ascending order. */
  | 'DURATION_ASC'
  /** Duration by ascending order. */
  | 'DURATION_DESC'
  /** Stage end event time by ascending order. */
  | 'END_EVENT_ASC'
  /** Stage end event time by descending order. */
  | 'END_EVENT_DESC';

export type ValueStreamStageItems = {
  __typename?: 'ValueStreamStageItems';
  /** Duration of the item on the stage. */
  duration?: Maybe<Scalars['String']['output']>;
  /** Duration of item on stage in milliseconds. */
  durationInMilliseconds?: Maybe<Scalars['BigInt']['output']>;
  /** When exited the stage. */
  endEventTimestamp?: Maybe<Scalars['Time']['output']>;
  /** Item record. */
  record?: Maybe<Issuable>;
};

/** The connection type for ValueStreamStageItems. */
export type ValueStreamStageItemsConnection = {
  __typename?: 'ValueStreamStageItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ValueStreamStageItemsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ValueStreamStageItems>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ValueStreamStageItemsEdge = {
  __typename?: 'ValueStreamStageItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ValueStreamStageItems>;
};

export type ValueStreamStageMetrics = {
  __typename?: 'ValueStreamStageMetrics';
  /** Average duration in seconds. */
  average?: Maybe<ValueStreamAnalyticsMetric>;
  /** Limited item count. The backend counts maximum 1000 items, for free projects, and maximum 10,000 items for licensed projects or licensed groups. */
  count?: Maybe<ValueStreamAnalyticsMetric>;
  /**
   * Items in the stage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  items?: Maybe<ValueStreamStageItemsConnection>;
  /** Median duration in seconds. */
  median?: Maybe<ValueStreamAnalyticsMetric>;
  /**
   * Data series in the value stream stage. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  series: ValueStreamStageSeries;
};


export type ValueStreamStageMetricsItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<ValueStreamStageItemSort>;
};

export type ValueStreamStageSeries = {
  __typename?: 'ValueStreamStageSeries';
  /** Average duration for each day within the given date range. */
  averageDurations?: Maybe<Array<ValueStreamAnalyticsDateMetric>>;
};

/** Autogenerated input type of ValueStreamUpdate */
export type ValueStreamUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the value stream to update. */
  id: Scalars['AnalyticsCycleAnalyticsValueStreamID']['input'];
  /** Value stream name. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Value stream configuration. */
  setting?: InputMaybe<ValueStreamSettingInput>;
  /** Value stream stages. */
  stages?: InputMaybe<Array<UpdateValueStreamStageInput>>;
};

/** Autogenerated return type of ValueStreamUpdate. */
export type ValueStreamUpdatePayload = {
  __typename?: 'ValueStreamUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated value stream. */
  valueStream?: Maybe<ValueStream>;
};

export type VerificationStateEnum =
  /** Verification process is disabled. */
  | 'DISABLED'
  /** Verification process finished but failed. */
  | 'FAILED'
  /** Verification process has not started. */
  | 'PENDING'
  /** Verification process is in progress. */
  | 'STARTED'
  /** Verification process finished successfully. */
  | 'SUCCEEDED';

/** Verification status of a GPG, X.509 or SSH signature for a commit. */
export type VerificationStatus =
  /** multiple_signatures verification status. */
  | 'MULTIPLE_SIGNATURES'
  /** other_user verification status. */
  | 'OTHER_USER'
  /** revoked_key verification status. */
  | 'REVOKED_KEY'
  /** same_user_different_email verification status. */
  | 'SAME_USER_DIFFERENT_EMAIL'
  /** unknown_key verification status. */
  | 'UNKNOWN_KEY'
  /** unverified verification status. */
  | 'UNVERIFIED'
  /** unverified_author_email verification status. */
  | 'UNVERIFIED_AUTHOR_EMAIL'
  /** unverified_key verification status. */
  | 'UNVERIFIED_KEY'
  /** verified verification status. */
  | 'VERIFIED'
  /** verified_ca verification status. */
  | 'VERIFIED_CA'
  /** verified_system verification status. */
  | 'VERIFIED_SYSTEM';

export type VerificationStatusFilterInput = {
  /** Verification status of the work item. */
  verificationStatus: RequirementStatusFilter;
};

export type VerificationStatusInput = {
  /** Verification status of the work item. */
  verificationStatus: TestReportState;
};

/** Autogenerated input type of VerifiedNamespaceCreate */
export type VerifiedNamespaceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Root namespace path. */
  namespacePath: Scalars['ID']['input'];
  /** Verification level for a root namespace. */
  verificationLevel: CiCatalogResourceVerificationLevel;
};

/** Autogenerated return type of VerifiedNamespaceCreate. */
export type VerifiedNamespaceCreatePayload = {
  __typename?: 'VerifiedNamespaceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of VirtualRegistriesCleanupPolicyUpsert */
export type VirtualRegistriesCleanupPolicyUpsertInput = {
  /** Job cadence for the cleanup process. Allowed values are 1, 7, 14, 30, 90. Default is 7. */
  cadence?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable or disable the virtual registries cleanup policy. Default is `false`. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Group path for the group virtual registries. */
  fullPath: Scalars['ID']['input'];
  /** Keep packages for the period after download. Range is 1-365. Default is 30. */
  keepNDaysAfterDownload?: InputMaybe<Scalars['Int']['input']>;
  /** Whether to notify group owners when cleanup runs fail. Default is `false`. */
  notifyOnFailure?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to notify group owners when cleanup runs succeed. Default is `false`. */
  notifyOnSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of VirtualRegistriesCleanupPolicyUpsert. */
export type VirtualRegistriesCleanupPolicyUpsertPayload = {
  __typename?: 'VirtualRegistriesCleanupPolicyUpsertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Virtual registries cleanup policy after mutation. */
  virtualRegistriesCleanupPolicy?: Maybe<VirtualRegistryCleanupPolicy>;
};

/** Root group level virtual registries settings */
export type VirtualRegistriesSetting = {
  __typename?: 'VirtualRegistriesSetting';
  /** Indicates whether virtual registries are enabled for the group. */
  enabled: Scalars['Boolean']['output'];
};

/** Represents a virtual registry cleanup policy */
export type VirtualRegistryCleanupPolicy = {
  __typename?: 'VirtualRegistryCleanupPolicy';
  /**
   * Frequency in days for running the cleanup policy. Valid values: 1, 7, 14, 30, 90. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  cadence: Scalars['Int']['output'];
  /**
   * Timestamp when the cleanup policy was created. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  createdAt: Scalars['Time']['output'];
  /**
   * Whether the cleanup policy is enabled. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  enabled: Scalars['Boolean']['output'];
  /**
   * Error message when the cleanup policy fails. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  failureMessage?: Maybe<Scalars['String']['output']>;
  /**
   * Number of days to keep cached entries after their last download. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  keepNDaysAfterDownload: Scalars['Int']['output'];
  /**
   * Last time that the virtual registry cleanup policy executed. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  lastRunAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Number of entries deleted during the last cleanup run. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  lastRunDeletedEntriesCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Size in bytes of data deleted during the last cleanup run. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  lastRunDeletedSize?: Maybe<Scalars['Int']['output']>;
  /**
   * Detailed metrics from the last cleanup run. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  lastRunDetailedMetrics?: Maybe<CleanupPolicyLastRunDetailedMetrics>;
  /**
   * Next time the virtual registry cleanup policy runs. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  nextRunAt?: Maybe<Scalars['Time']['output']>;
  /**
   * Boolean to notify group owners on failed cleanup runs. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  notifyOnFailure: Scalars['Boolean']['output'];
  /**
   * Boolean to notify group owners on successful cleanup runs. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  notifyOnSuccess: Scalars['Boolean']['output'];
  /**
   * Current execution status of the cleanup policy. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  status: PolicyStatus;
  /**
   * Timestamp when the cleanup policy was last updated. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  updatedAt: Scalars['Time']['output'];
};

export type VisibilityLevelsEnum =
  /** Internal visibility level. */
  | 'internal'
  /** Private visibility level. */
  | 'private'
  /** Public visibility level. */
  | 'public';

/** Determines whether the pipeline list shows ID or IID */
export type VisibilityPipelineIdType =
  /** Display pipeline ID. */
  | 'ID'
  /** Display pipeline IID. */
  | 'IID';

export type VisibilityScopesEnum =
  /** Snippet is visible for any logged in user except external users. */
  | 'internal'
  /** Snippet is visible only to the snippet creator. */
  | 'private'
  /** Snippet can be accessed without any authentication. */
  | 'public';

/** Autogenerated input type of VulnerabilitiesArchive */
export type VulnerabilitiesArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Last update date of vulnerabilities being archived. */
  date: Scalars['Date']['input'];
  /** ID of the project to attach the vulnerability to. */
  projectId: Scalars['ProjectID']['input'];
};

/** Autogenerated return type of VulnerabilitiesArchive. */
export type VulnerabilitiesArchivePayload = {
  __typename?: 'VulnerabilitiesArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Status of the action. */
  status: Scalars['String']['output'];
};

/** Represents the count of vulnerabilities by severity on a particular day. This data is retained for 365 days */
export type VulnerabilitiesCountByDay = {
  __typename?: 'VulnerabilitiesCountByDay';
  /** Total number of vulnerabilities on a particular day with critical severity */
  critical: Scalars['Int']['output'];
  /** Date for the count. */
  date: Scalars['ISO8601Date']['output'];
  /** Total number of vulnerabilities on a particular day with high severity */
  high: Scalars['Int']['output'];
  /** Total number of vulnerabilities on a particular day with info severity */
  info: Scalars['Int']['output'];
  /** Total number of vulnerabilities on a particular day with low severity */
  low: Scalars['Int']['output'];
  /** Total number of vulnerabilities on a particular day with medium severity */
  medium: Scalars['Int']['output'];
  /** Total number of vulnerabilities on a particular day. */
  total: Scalars['Int']['output'];
  /** Total number of vulnerabilities on a particular day with unknown severity */
  unknown: Scalars['Int']['output'];
};

/** The connection type for VulnerabilitiesCountByDay. */
export type VulnerabilitiesCountByDayConnection = {
  __typename?: 'VulnerabilitiesCountByDayConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilitiesCountByDayEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilitiesCountByDay>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilitiesCountByDayEdge = {
  __typename?: 'VulnerabilitiesCountByDayEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilitiesCountByDay>;
};

/** Autogenerated input type of VulnerabilitiesCreateIssue */
export type VulnerabilitiesCreateIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID']['input'];
  /** IDs of vulnerabilities to link to the given issue.  Up to 100 can be provided. */
  vulnerabilityIds: Array<Scalars['VulnerabilityID']['input']>;
};

/** Autogenerated return type of VulnerabilitiesCreateIssue. */
export type VulnerabilitiesCreateIssuePayload = {
  __typename?: 'VulnerabilitiesCreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of VulnerabilitiesDismiss */
export type VulnerabilitiesDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability was dismissed (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Reason why vulnerability should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
  /** IDs of the vulnerabilities to be dismissed (maximum 100 entries). */
  vulnerabilityIds: Array<Scalars['VulnerabilityID']['input']>;
};

/** Autogenerated return type of VulnerabilitiesDismiss. */
export type VulnerabilitiesDismissPayload = {
  __typename?: 'VulnerabilitiesDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerabilities after state change. */
  vulnerabilities: Array<Vulnerability>;
};

/** Represents vulnerability metrics over time with filtering and grouping capabilities */
export type VulnerabilitiesOverTime = {
  __typename?: 'VulnerabilitiesOverTime';
  /** Vulnerability counts grouped by report type. */
  byReportType?: Maybe<Array<VulnerabilityReportTypeCount>>;
  /** Vulnerability counts grouped by severity level. */
  bySeverity?: Maybe<Array<VulnerabilitySeverityCount>>;
  /** Total number of vulnerabilities for the date. */
  count: Scalars['Int']['output'];
  /** Date for the metrics. */
  date: Scalars['ISO8601Date']['output'];
};

/** The connection type for VulnerabilitiesOverTime. */
export type VulnerabilitiesOverTimeConnection = {
  __typename?: 'VulnerabilitiesOverTimeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilitiesOverTimeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilitiesOverTime>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilitiesOverTimeEdge = {
  __typename?: 'VulnerabilitiesOverTimeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilitiesOverTime>;
};

/** Represents vulnerability counts grouped by severity level */
export type VulnerabilitiesPerSeverity = {
  __typename?: 'VulnerabilitiesPerSeverity';
  /** Number of CRITICAL severity vulnerabilities. */
  critical?: Maybe<VulnerabilitySeverityCount>;
  /** Number of HIGH severity vulnerabilities. */
  high?: Maybe<VulnerabilitySeverityCount>;
  /** Number of INFO severity vulnerabilities. */
  info?: Maybe<VulnerabilitySeverityCount>;
  /** Number of LOW severity vulnerabilities. */
  low?: Maybe<VulnerabilitySeverityCount>;
  /** Number of MEDIUM severity vulnerabilities. */
  medium?: Maybe<VulnerabilitySeverityCount>;
  /** Number of UNKNOWN severity vulnerabilities. */
  unknown?: Maybe<VulnerabilitySeverityCount>;
};

/** Autogenerated input type of VulnerabilitiesRemoveAllFromProject */
export type VulnerabilitiesRemoveAllFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of project for which all Vulnerabilities should be removed. The deletion will happen in the background so the changes will not be visible immediately. */
  projectIds: Array<Scalars['ProjectID']['input']>;
  /** When set as `true`, deletes only the vulnerabilities no longer detected. When set as `false`, deletes only the vulnerabilities still detected. */
  resolvedOnDefaultBranch?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of VulnerabilitiesRemoveAllFromProject. */
export type VulnerabilitiesRemoveAllFromProjectPayload = {
  __typename?: 'VulnerabilitiesRemoveAllFromProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Projects for which the deletion was scheduled. */
  projects: Array<Project>;
};

/** Represents a vulnerability */
export type Vulnerability = NoteableInterface & Todoable & {
  __typename?: 'Vulnerability';
  /** Indicates whether the type of vulnerability can be resolved with AI. */
  aiResolutionAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the specific vulnerability can be resolved with AI. */
  aiResolutionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /**
   * AI workflows triggered for the vulnerability. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  aiWorkflows?: Maybe<VulnerabilityTriggeredWorkflowConnection>;
  /**
   * Indicates whether the vulnerability is about to be archived in the next month. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  archivalInformation: VulnerabilityArchivalInformation;
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** Timestamp of when the vulnerability state was changed to confirmed. */
  confirmedAt?: Maybe<Scalars['Time']['output']>;
  /** User that confirmed the vulnerability. */
  confirmedBy?: Maybe<UserCore>;
  /** Enrichment (EPSS score and KEV) for CVE vulnerabilities. */
  cveEnrichment?: Maybe<CveEnrichmentType>;
  /** CVSS information for the vulnerability. */
  cvss: Array<CvssType>;
  /**
   * Dependencies for the vulnerability. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  dependencies: DependencyConnection;
  /** Description of the vulnerability. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Details of the vulnerability. */
  details: Array<VulnerabilityDetail>;
  /** Timestamp of when the vulnerability was first detected. */
  detectedAt: Scalars['Time']['output'];
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Reason for dismissal. Returns `null` for states other than `dismissed`. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** Timestamp of when the vulnerability state was changed to dismissed. */
  dismissedAt?: Maybe<Scalars['Time']['output']>;
  /** User that dismissed the vulnerability. */
  dismissedBy?: Maybe<UserCore>;
  /** List of external issue links related to the vulnerability. */
  externalIssueLinks: VulnerabilityExternalIssueLinkConnection;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']['output']>;
  /** Status of the secret token associated with this vulnerability */
  findingTokenStatus?: Maybe<VulnerabilityFindingTokenStatus>;
  /**
   * Flags set on the vulnerability. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  flags?: Maybe<VulnerabilityFlagConnection>;
  /** Indicates whether there is a remediation available for the vulnerability. */
  hasRemediations?: Maybe<Scalars['Boolean']['output']>;
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID']['output'];
  /** Identifiers of the vulnerability. */
  identifiers: Array<VulnerabilityIdentifier>;
  /**
   * Pipeline where the vulnerability was first detected. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  initialDetectedPipeline?: Maybe<Pipeline>;
  /** List of issue links related to the vulnerability. */
  issueLinks: VulnerabilityIssueLinkConnection;
  /**
   * Pipeline where the vulnerability was last detected. Introduced in GitLab 18.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.2.
   */
  latestDetectedPipeline?: Maybe<Pipeline>;
  /**
   * Latest flag for the vulnerability. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  latestFlag?: Maybe<VulnerabilityFlag>;
  /**
   * Latest security report finding for the vulnerability. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  latestSecurityReportFinding?: Maybe<PipelineSecurityReportFinding>;
  /** List of links associated with the vulnerability. */
  links: Array<VulnerabilityLink>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Merge requests that are linked to fix the vulnerability. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /**
   * Indicates whether the vulnerability was auto-dismissed by a security policy. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  policyAutoDismissed?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Policy violation for the vulnerability. Introduced in GitLab 18.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.6.
   */
  policyViolations?: Maybe<PolicyViolations>;
  /** Indicates whether the vulnerability is present on the default branch or not. */
  presentOnDefaultBranch: Scalars['Boolean']['output'];
  /** Primary identifier of the vulnerability. */
  primaryIdentifier?: Maybe<VulnerabilityIdentifier>;
  /** Project on which the vulnerability was found. */
  project?: Maybe<Project>;
  /**
   * Reachability status of the vulnerability. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  reachability?: Maybe<ReachabilityType>;
  /** Type of the security report that found the vulnerability (SAST, DEPENDENCY_SCANNING, CONTAINER_SCANNING, DAST, SECRET_DETECTION, COVERAGE_FUZZING, API_FUZZING, CLUSTER_IMAGE_SCANNING, CONTAINER_SCANNING_FOR_REGISTRY, GENERIC). `Scan Type` in the UI. */
  reportType?: Maybe<VulnerabilityReportType>;
  /**
   * Information about the representation of the vulnerability, such as resolved commit SHA. Introduced in GitLab 17.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.7.
   */
  representationInformation?: Maybe<VulnerabilityRepresentationInformation>;
  /** Timestamp of when the vulnerability state was changed to resolved. */
  resolvedAt?: Maybe<Scalars['Time']['output']>;
  /** User that resolved the vulnerability. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether the vulnerability is fixed on the default branch or not. */
  resolvedOnDefaultBranch: Scalars['Boolean']['output'];
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability (INFO, UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL) */
  severity?: Maybe<VulnerabilitySeverity>;
  /** List of severity changes for the vulnerability. */
  severityOverrides?: Maybe<SeverityOverrideConnection>;
  /** Recommended solution for the vulnerability. */
  solution?: Maybe<Scalars['String']['output']>;
  /** State of the vulnerability (DETECTED, CONFIRMED, RESOLVED, DISMISSED) */
  state?: Maybe<VulnerabilityState>;
  /** Comment given for the vulnerability state change. */
  stateComment?: Maybe<Scalars['String']['output']>;
  /** List of state transitions related to the vulnerability. */
  stateTransitions?: Maybe<VulnerabilityStateTransitionTypeConnection>;
  /** Title of the vulnerability. */
  title?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the vulnerability was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
  /** Number of user notes attached to the vulnerability. */
  userNotesCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: VulnerabilityPermissions;
  /** UUID of the vulnerability finding. Can be used to look up the associated security report finding. */
  uuid: Scalars['String']['output'];
  /** Path to the vulnerability's details page. */
  vulnerabilityPath?: Maybe<Scalars['String']['output']>;
  /** URL to the vulnerability's details page. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** Represents a vulnerability */
export type VulnerabilityAiWorkflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityDependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  componentIds?: InputMaybe<Array<Scalars['SbomComponentID']['input']>>;
  componentNames?: InputMaybe<Array<Scalars['String']['input']>>;
  componentVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  sort?: InputMaybe<DependencySort>;
  sourceTypes?: InputMaybe<Array<SbomSourceType>>;
};


/** Represents a vulnerability */
export type VulnerabilityDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityExternalIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityFlagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  linkType?: InputMaybe<VulnerabilityIssueLinkType>;
};


/** Represents a vulnerability */
export type VulnerabilityMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilitySeverityOverridesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a vulnerability */
export type VulnerabilityStateTransitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents vulnerability archival information */
export type VulnerabilityArchivalInformation = {
  __typename?: 'VulnerabilityArchivalInformation';
  /** Indicates whether the vulnerability is about to be archived in the next month. */
  aboutToBeArchived: Scalars['Boolean']['output'];
  /** Date when the vulnerability is expected to be archived. */
  expectedToBeArchivedOn?: Maybe<Scalars['Date']['output']>;
};

/** Represents a vulnerability archive */
export type VulnerabilityArchive = {
  __typename?: 'VulnerabilityArchive';
  /** Number of records the archive contains. */
  archivedRecordsCount: Scalars['Int']['output'];
  /** Month of the archive, represented as a number from 1 (January) to 12 (December). */
  month: Scalars['Int']['output'];
  /** Year of the archive. */
  year: Scalars['Int']['output'];
};

/** Risk factor based on average vulnerability score */
export type VulnerabilityAverageScoreFactor = {
  __typename?: 'VulnerabilityAverageScoreFactor';
  /**
   * Factor value contributing to the risk score. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  factor: Scalars['Float']['output'];
};

/** Autogenerated input type of VulnerabilityConfirm */
export type VulnerabilityConfirmInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability was confirmed (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** ID of the vulnerability to be confirmed. */
  id: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityConfirm. */
export type VulnerabilityConfirmPayload = {
  __typename?: 'VulnerabilityConfirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** The connection type for Vulnerability. */
export type VulnerabilityConnection = {
  __typename?: 'VulnerabilityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Vulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a container image reported on the related vulnerability */
export type VulnerabilityContainerImage = {
  __typename?: 'VulnerabilityContainerImage';
  /** Name of the container image. */
  name?: Maybe<Scalars['String']['output']>;
};

/** The connection type for VulnerabilityContainerImage. */
export type VulnerabilityContainerImageConnection = {
  __typename?: 'VulnerabilityContainerImageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityContainerImageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityContainerImage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityContainerImageEdge = {
  __typename?: 'VulnerabilityContainerImageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityContainerImage>;
};

/** Input type for filtering projects by vulnerability count and severity */
export type VulnerabilityCountFilterInput = {
  /** Number of vulnerabilities to filter by. */
  count: Scalars['Int']['input'];
  /** Comparison operator for the vulnerability count. */
  operator: ComparisonOperator;
  /** Severity level of vulnerabilities to filter by. */
  severity: VulnerabilitySeverity;
};

/** Autogenerated input type of VulnerabilityCreate */
export type VulnerabilityCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp of when the vulnerability state changed to confirmed (defaults to creation time if status is `confirmed`). */
  confirmedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Long text section that describes the vulnerability in more detail. */
  description: Scalars['String']['input'];
  /** Timestamp of when the vulnerability was first detected (defaults to creation time). */
  detectedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Timestamp of when the vulnerability state changed to dismissed (defaults to creation time if status is `dismissed`). */
  dismissedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Array of CVE or CWE identifiers for the vulnerability. */
  identifiers: Array<VulnerabilityIdentifierInput>;
  /** Name of the vulnerability. */
  name: Scalars['String']['input'];
  /** ID of the project to attach the vulnerability to. */
  project: Scalars['ProjectID']['input'];
  /** Tracked context to associate with the vulnerability. */
  projectTrackedContext?: InputMaybe<ProjectTrackedContextInput>;
  /** Timestamp of when the vulnerability state changed to resolved (defaults to creation time if status is `resolved`). */
  resolvedAt?: InputMaybe<Scalars['Time']['input']>;
  /** Information about the scanner used to discover the vulnerability. */
  scanner: VulnerabilityScannerInput;
  /** Severity of the vulnerability (defaults to `unknown`). */
  severity?: InputMaybe<VulnerabilitySeverity>;
  /** Instructions for how to fix the vulnerability. */
  solution?: InputMaybe<Scalars['String']['input']>;
  /** State of the vulnerability (defaults to `detected`). */
  state?: InputMaybe<VulnerabilityState>;
};

/** Autogenerated return type of VulnerabilityCreate. */
export type VulnerabilityCreatePayload = {
  __typename?: 'VulnerabilityCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability created. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability detail field. The fields with data will depend on the vulnerability detail type */
export type VulnerabilityDetail = VulnerabilityDetailBase | VulnerabilityDetailBoolean | VulnerabilityDetailCode | VulnerabilityDetailCodeFlows | VulnerabilityDetailCommit | VulnerabilityDetailDiff | VulnerabilityDetailFileLocation | VulnerabilityDetailInt | VulnerabilityDetailList | VulnerabilityDetailMarkdown | VulnerabilityDetailModuleLocation | VulnerabilityDetailNamedList | VulnerabilityDetailTable | VulnerabilityDetailText | VulnerabilityDetailUrl;

/** Represents the vulnerability details base */
export type VulnerabilityDetailBase = {
  __typename?: 'VulnerabilityDetailBase';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details boolean value */
export type VulnerabilityDetailBoolean = {
  __typename?: 'VulnerabilityDetailBoolean';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the field. */
  value: Scalars['Boolean']['output'];
};

/** Represents the vulnerability details code field */
export type VulnerabilityDetailCode = {
  __typename?: 'VulnerabilityDetailCode';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Language of the code. */
  lang?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Source code. */
  value: Scalars['String']['output'];
};

/** Represents the vulnerability details code flow node item */
export type VulnerabilityDetailCodeFlowNode = {
  __typename?: 'VulnerabilityDetailCodeFlowNode';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Location of the file. */
  fileLocation: VulnerabilityDetailFileLocation;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Node Type. */
  nodeType: CodeFlowNodeType;
};

/** Represents the vulnerability details code flows item */
export type VulnerabilityDetailCodeFlows = {
  __typename?: 'VulnerabilityDetailCodeFlows';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** List of flows represented by list of CodeFlowNodeItem. */
  items: Array<Array<VulnerabilityDetailCodeFlowNode>>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details commit field */
export type VulnerabilityDetailCommit = {
  __typename?: 'VulnerabilityDetailCommit';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Commit SHA value. */
  value: Scalars['String']['output'];
};

/** Represents the vulnerability details diff field */
export type VulnerabilityDetailDiff = {
  __typename?: 'VulnerabilityDetailDiff';
  /** Value of the field after the change. */
  after: Scalars['String']['output'];
  /** Value of the field before the change. */
  before: Scalars['String']['output'];
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailFileLocation = {
  __typename?: 'VulnerabilityDetailFileLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** File name. */
  fileName: Scalars['String']['output'];
  /** End line number of the file location. */
  lineEnd?: Maybe<Scalars['Int']['output']>;
  /** Start line number of the file location. */
  lineStart: Scalars['Int']['output'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details integer value */
export type VulnerabilityDetailInt = {
  __typename?: 'VulnerabilityDetailInt';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the field. */
  value: Scalars['Int']['output'];
};

/** Represents the vulnerability details list value */
export type VulnerabilityDetailList = {
  __typename?: 'VulnerabilityDetailList';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** List of details. */
  items: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details Markdown field */
export type VulnerabilityDetailMarkdown = {
  __typename?: 'VulnerabilityDetailMarkdown';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the Markdown field. */
  value: Scalars['String']['output'];
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailModuleLocation = {
  __typename?: 'VulnerabilityDetailModuleLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Module name. */
  moduleName: Scalars['String']['output'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Offset of the module location. */
  offset: Scalars['Int']['output'];
};

/** Represents the vulnerability details named list */
export type VulnerabilityDetailNamedList = {
  __typename?: 'VulnerabilityDetailNamedList';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /**
   * Named list of details. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  items: Array<VulnerabilityDetailNamedListItem>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability details named list item */
export type VulnerabilityDetailNamedListItem = {
  __typename?: 'VulnerabilityDetailNamedListItem';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Value of the field. Introduced in GitLab 16.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.1.
   */
  value: VulnerabilityDetail;
};

/** Represents an individual row in a table */
export type VulnerabilityDetailRow = {
  __typename?: 'VulnerabilityDetailRow';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the field. */
  row: Array<VulnerabilityDetail>;
};

/** Represents the vulnerability details table value */
export type VulnerabilityDetailTable = {
  __typename?: 'VulnerabilityDetailTable';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Table headers. */
  headers: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Table rows. */
  rows: Array<VulnerabilityDetailRow>;
};

/** Represents the vulnerability details text field */
export type VulnerabilityDetailText = {
  __typename?: 'VulnerabilityDetailText';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the text field. */
  value: Scalars['String']['output'];
};

/** Represents the vulnerability details URL field */
export type VulnerabilityDetailUrl = {
  __typename?: 'VulnerabilityDetailUrl';
  /** Description of the field. */
  description?: Maybe<Scalars['String']['output']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Href of the URL. */
  href: Scalars['String']['output'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']['output']>;
  /** Text of the URL. */
  text?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of VulnerabilityDismissFalsePositiveFlag */
export type VulnerabilityDismissFalsePositiveFlagInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the vulnerability to dismiss false positive flag for. */
  id: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityDismissFalsePositiveFlag. */
export type VulnerabilityDismissFalsePositiveFlagPayload = {
  __typename?: 'VulnerabilityDismissFalsePositiveFlagPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability after dismissing false positive flag. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Autogenerated input type of VulnerabilityDismiss */
export type VulnerabilityDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability was dismissed (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Reason why vulnerability should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
  /** ID of the vulnerability to be dismissed. */
  id: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityDismiss. */
export type VulnerabilityDismissPayload = {
  __typename?: 'VulnerabilityDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** The dismissal reason of the Vulnerability */
export type VulnerabilityDismissalReason =
  /** The vulnerability is known, and has not been remediated or mitigated, but is considered to be an acceptable business risk. */
  | 'ACCEPTABLE_RISK'
  /** An error in reporting in which a test result incorrectly indicates the presence of a vulnerability in a system when the vulnerability is not present. */
  | 'FALSE_POSITIVE'
  /** A management, operational, or technical control (that is, safeguard or countermeasure) employed by an organization that provides equivalent or comparable protection for an information system. */
  | 'MITIGATING_CONTROL'
  /** The vulnerability is known, and has not been remediated or mitigated, but is considered to be in a part of the application that will not be updated. */
  | 'NOT_APPLICABLE'
  /** The finding is not a vulnerability because it is part of a test or is test data. */
  | 'USED_IN_TESTS';

/** An edge in a connection. */
export type VulnerabilityEdge = {
  __typename?: 'VulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Evidence */
export type VulnerabilityEvidence = {
  __typename?: 'VulnerabilityEvidence';
  /** HTTP request of the Vulnerability Evidence. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the Vulnerability Evidence. */
  response?: Maybe<VulnerabilityResponse>;
  /** Source of the Vulnerability Evidence. */
  source?: Maybe<VulnerabilityEvidenceSource>;
  /** Summary of the Vulnerability Evidence. */
  summary?: Maybe<Scalars['String']['output']>;
  /** Supporting messages of the Vulnerability Evidence. */
  supportingMessages?: Maybe<Array<VulnerabilityEvidenceSupportingMessage>>;
};

/** Represents a vulnerability evidence */
export type VulnerabilityEvidenceSource = {
  __typename?: 'VulnerabilityEvidenceSource';
  /** ID of the Vulnerability Evidence Source. */
  identifier: Scalars['String']['output'];
  /** Name of the Vulnerability Evidence Source. */
  name: Scalars['String']['output'];
  /** URL of the Vulnerability Evidence Source. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Represents a vulnerability evidence supporting message */
export type VulnerabilityEvidenceSupportingMessage = {
  __typename?: 'VulnerabilityEvidenceSupportingMessage';
  /** Name of the vulnerability supporting message. */
  name: Scalars['String']['output'];
  /** HTTP request of the vulnerability evidence supporting message. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the vulnerability evidence supporting message. */
  response?: Maybe<VulnerabilityResponse>;
};

/** Represents an external issue link of a vulnerability */
export type VulnerabilityExternalIssueLink = {
  __typename?: 'VulnerabilityExternalIssueLink';
  /** The external issue attached to the issue link. */
  externalIssue?: Maybe<ExternalIssue>;
  /** GraphQL ID of the external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID']['output'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
};

/** The connection type for VulnerabilityExternalIssueLink. */
export type VulnerabilityExternalIssueLinkConnection = {
  __typename?: 'VulnerabilityExternalIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityExternalIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityExternalIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkCreate */
export type VulnerabilityExternalIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** External tracker type of the external issue link. */
  externalTracker: VulnerabilityExternalIssueLinkExternalTracker;
  /** ID of the vulnerability. */
  id: Scalars['VulnerabilityID']['input'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkCreate. */
export type VulnerabilityExternalIssueLinkCreatePayload = {
  __typename?: 'VulnerabilityExternalIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created external issue link. */
  externalIssueLink?: Maybe<VulnerabilityExternalIssueLink>;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkDestroy */
export type VulnerabilityExternalIssueLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the vulnerability external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID']['input'];
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkDestroy. */
export type VulnerabilityExternalIssueLinkDestroyPayload = {
  __typename?: 'VulnerabilityExternalIssueLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type VulnerabilityExternalIssueLinkEdge = {
  __typename?: 'VulnerabilityExternalIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityExternalIssueLink>;
};

/** The external tracker of the external issue link related to a vulnerability */
export type VulnerabilityExternalIssueLinkExternalTracker =
  /** Jira external tracker */
  | 'JIRA';

/** The type of the external issue link related to a vulnerability */
export type VulnerabilityExternalIssueLinkType =
  /** Created link type. */
  | 'CREATED';

/** Status of vulnerability flag false positive detection */
export type VulnerabilityFalsePositiveDetectionStatus =
  /** Detection is detected as fp */
  | 'DETECTED_AS_FP'
  /** Detection is detected as not fp */
  | 'DETECTED_AS_NOT_FP'
  /** Detection is failed */
  | 'FAILED'
  /** Detection is in progress */
  | 'IN_PROGRESS'
  /** Detection is not started */
  | 'NOT_STARTED';

/** Represents the status of a secret token found in a vulnerability */
export type VulnerabilityFindingTokenStatus = {
  __typename?: 'VulnerabilityFindingTokenStatus';
  /** When the token status was created. */
  createdAt: Scalars['Time']['output'];
  /** ID of the finding token status. */
  id: Scalars['ID']['output'];
  /** When the token was last verified with the issuing service. */
  lastVerifiedAt?: Maybe<Scalars['Time']['output']>;
  /** Status of the token (unknown, active, inactive). */
  status: VulnerabilityFindingTokenStatusState;
  /** When the token status was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** Status of a secret token found in a vulnerability */
export type VulnerabilityFindingTokenStatusState =
  /** Token is active and can be exploited. */
  | 'ACTIVE'
  /** Token is inactive and cannot be exploited. */
  | 'INACTIVE'
  /** Token status is unknown. */
  | 'UNKNOWN';

/** Represents a flag result for a vulnerability */
export type VulnerabilityFlag = {
  __typename?: 'VulnerabilityFlag';
  /**
   * Confidence score of the detection (0.0 to 1.0). Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  confidenceScore?: Maybe<Scalars['Float']['output']>;
  /** Timestamp when the detection was created. */
  createdAt: Scalars['Time']['output'];
  /** Reasoning for the raising of the flag on the vulnerability. */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the false positive detection. */
  id: Scalars['ID']['output'];
  /** Origin of service that raising the flag on the vulnerability. */
  origin?: Maybe<Scalars['String']['output']>;
  /**
   * Status of the false positive detection. Introduced in GitLab 18.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.5.
   */
  status?: Maybe<VulnerabilityFalsePositiveDetectionStatus>;
  /** Timestamp when the detection was last updated. */
  updatedAt: Scalars['Time']['output'];
};

/** The connection type for VulnerabilityFlag. */
export type VulnerabilityFlagConnection = {
  __typename?: 'VulnerabilityFlagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityFlagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityFlag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityFlagEdge = {
  __typename?: 'VulnerabilityFlagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityFlag>;
};

/** The grade of the vulnerable project */
export type VulnerabilityGrade =
  /** A grade */
  | 'A'
  /** B grade */
  | 'B'
  /** C grade */
  | 'C'
  /** D grade */
  | 'D'
  /** F grade */
  | 'F';

/** Represents a vulnerability identifier */
export type VulnerabilityIdentifier = {
  __typename?: 'VulnerabilityIdentifier';
  /** External ID of the vulnerability identifier. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** External type of the vulnerability identifier. */
  externalType?: Maybe<Scalars['String']['output']>;
  /** Name of the vulnerability identifier. */
  name?: Maybe<Scalars['String']['output']>;
  /** URL of the vulnerability identifier. */
  url?: Maybe<Scalars['String']['output']>;
};

export type VulnerabilityIdentifierInput = {
  /** External ID of the vulnerability identifier. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** External type of the vulnerability identifier. */
  externalType?: InputMaybe<Scalars['String']['input']>;
  /** Name of the vulnerability identifier. */
  name: Scalars['String']['input'];
  /** URL of the vulnerability identifier. */
  url: Scalars['String']['input'];
};

/** Represents an issue link of a vulnerability */
export type VulnerabilityIssueLink = {
  __typename?: 'VulnerabilityIssueLink';
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID']['output'];
  /** Issue attached to issue link. */
  issue?: Maybe<Issue>;
  /** Type of the issue link. */
  linkType: VulnerabilityIssueLinkType;
};

/** The connection type for VulnerabilityIssueLink. */
export type VulnerabilityIssueLinkConnection = {
  __typename?: 'VulnerabilityIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of VulnerabilityIssueLinkCreate */
export type VulnerabilityIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to link to. */
  issueId: Scalars['IssueID']['input'];
  /** IDs of vulnerabilities to link to the given issue.  Up to 100 can be provided. */
  vulnerabilityIds: Array<Scalars['VulnerabilityID']['input']>;
};

/** Autogenerated return type of VulnerabilityIssueLinkCreate. */
export type VulnerabilityIssueLinkCreatePayload = {
  __typename?: 'VulnerabilityIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created issue links. */
  issueLinks?: Maybe<Array<VulnerabilityIssueLink>>;
};

/** An edge in a connection. */
export type VulnerabilityIssueLinkEdge = {
  __typename?: 'VulnerabilityIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityIssueLink>;
};

/** The type of the issue link related to a vulnerability */
export type VulnerabilityIssueLinkType =
  /** Issue is created for the vulnerability */
  | 'CREATED'
  /** Has a related issue */
  | 'RELATED';

/** Represents a link related to a vulnerability */
export type VulnerabilityLink = {
  __typename?: 'VulnerabilityLink';
  /** Name of the link. */
  name?: Maybe<Scalars['String']['output']>;
  /** URL of the link. */
  url: Scalars['String']['output'];
};

/** Autogenerated input type of VulnerabilityLinkMergeRequest */
export type VulnerabilityLinkMergeRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the merge request. */
  mergeRequestId: Scalars['MergeRequestID']['input'];
  /** Confidence rating representing the estimated accuracy of the fix in the AI generated merge request. Decimal value between 0 and 1, with 1 being the highest. */
  readinessScore?: InputMaybe<Scalars['Float']['input']>;
  /** ID of the vulnerability. */
  vulnerabilityId: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityLinkMergeRequest. */
export type VulnerabilityLinkMergeRequestPayload = {
  __typename?: 'VulnerabilityLinkMergeRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated vulnerability. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability location. The fields with data will depend on the vulnerability report type */
export type VulnerabilityLocation = VulnerabilityLocationClusterImageScanning | VulnerabilityLocationContainerScanning | VulnerabilityLocationCoverageFuzzing | VulnerabilityLocationDast | VulnerabilityLocationDependencyScanning | VulnerabilityLocationGeneric | VulnerabilityLocationSast | VulnerabilityLocationSecretDetection;

/** Represents the location of a vulnerability found by a cluster image scan */
export type VulnerabilityLocationClusterImageScanning = {
  __typename?: 'VulnerabilityLocationClusterImageScanning';
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']['output']>;
  /** Kubernetes resource which uses the vulnerable container image. */
  kubernetesResource?: Maybe<VulnerableKubernetesResource>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a container security scan */
export type VulnerabilityLocationContainerScanning = {
  __typename?: 'VulnerabilityLocationContainerScanning';
  /** URL of scanned image. */
  containerRepositoryUrl?: Maybe<Scalars['String']['output']>;
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']['output']>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a Coverage Fuzzing scan */
export type VulnerabilityLocationCoverageFuzzing = {
  __typename?: 'VulnerabilityLocationCoverageFuzzing';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']['output']>;
  /** Relative address in memory were the crash occurred. */
  crashAddress?: Maybe<Scalars['String']['output']>;
  /** Type of the crash. */
  crashType?: Maybe<Scalars['String']['output']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']['output']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']['output']>;
  /** Stack trace recorded during fuzzing resulting the crash. */
  stacktraceSnippet?: Maybe<Scalars['String']['output']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']['output']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']['output']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a DAST scan */
export type VulnerabilityLocationDast = {
  __typename?: 'VulnerabilityLocationDast';
  /** Domain name of the vulnerable request. */
  hostname?: Maybe<Scalars['String']['output']>;
  /** Query parameter for the URL on which the vulnerability occurred. */
  param?: Maybe<Scalars['String']['output']>;
  /** URL path and query string of the vulnerable request. */
  path?: Maybe<Scalars['String']['output']>;
  /** HTTP method of the vulnerable request. */
  requestMethod?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a dependency security scan */
export type VulnerabilityLocationDependencyScanning = {
  __typename?: 'VulnerabilityLocationDependencyScanning';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']['output']>;
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a generic scanner. */
export type VulnerabilityLocationGeneric = {
  __typename?: 'VulnerabilityLocationGeneric';
  /** Free-form description of where the vulnerability is located. */
  description?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a SAST scan */
export type VulnerabilityLocationSast = {
  __typename?: 'VulnerabilityLocationSast';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']['output']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']['output']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']['output']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']['output']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']['output']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']['output']>;
};

/** Represents the location of a vulnerability found by a secret detection scan */
export type VulnerabilityLocationSecretDetection = {
  __typename?: 'VulnerabilityLocationSecretDetection';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']['output']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']['output']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']['output']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']['output']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']['output']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']['output']>;
};

/** Represents the vulnerability management policy */
export type VulnerabilityManagementPolicy = OrchestrationPolicy & {
  __typename?: 'VulnerabilityManagementPolicy';
  /**
   * Indicates whether the policy comes from a centralized security policy group. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  csp: Scalars['Boolean']['output'];
  /** Description of the policy. */
  description: Scalars['String']['output'];
  /** URL of policy edit page. */
  editPath: Scalars['String']['output'];
  /** Indicates whether the policy is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** Name of the policy. */
  name: Scalars['String']['output'];
  /** Scope of the policy. */
  policyScope?: Maybe<PolicyScope>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** YAML definition of the policy. */
  yaml: Scalars['String']['output'];
};

/** Represents policy fields related to the vulnerability management policy. */
export type VulnerabilityManagementPolicyAttributesType = {
  __typename?: 'VulnerabilityManagementPolicyAttributesType';
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
};

/** The connection type for VulnerabilityManagementPolicy. */
export type VulnerabilityManagementPolicyConnection = {
  __typename?: 'VulnerabilityManagementPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityManagementPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityManagementPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityManagementPolicyEdge = {
  __typename?: 'VulnerabilityManagementPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityManagementPolicy>;
};

/** Counts for each vulnerability severity in the group and its subgroups. */
export type VulnerabilityNamespaceStatisticType = VulnerabilityStatisticInterface & {
  __typename?: 'VulnerabilityNamespaceStatisticType';
  /** Number of vulnerabilities of CRITICAL severity. */
  critical: Scalars['Int']['output'];
  /** Number of vulnerabilities of HIGH severity. */
  high: Scalars['Int']['output'];
  /** Number of vulnerabilities of INFO severity. */
  info: Scalars['Int']['output'];
  /** Number of vulnerabilities of LOW severity. */
  low: Scalars['Int']['output'];
  /** Number of vulnerabilities of MEDIUM severity. */
  medium: Scalars['Int']['output'];
  /** Namespace ID. */
  namespaceId: Scalars['Int']['output'];
  /** Total of all vulnerabilities. */
  total: Scalars['Int']['output'];
  /** Number of vulnerabilities of UNKNOWN severity. */
  unknown: Scalars['Int']['output'];
  /** Date that data was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** `OwaspTop10` vulnerability categories for OWASP 2021 */
export type VulnerabilityOwasp2021Top10 =
  /** A01:2021-Broken Access Control, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A01_2021'
  /** A02:2021-Cryptographic Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A02_2021'
  /** A03:2021-Injection, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A03_2021'
  /** A04:2021-Insecure Design, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A04_2021'
  /** A05:2021-Security Misconfiguration, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A05_2021'
  /** A06:2021-Vulnerable and Outdated Components, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A06_2021'
  /** A07:2021-Identification and Authentication Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A07_2021'
  /** A08:2021-Software and Data Integrity Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A08_2021'
  /** A09:2021-Security Logging and Monitoring Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A09_2021'
  /** A1:2021-Broken Access Control, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A1_2021'
  /** A2:2021-Cryptographic Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A2_2021'
  /** A3:2021-Injection, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A3_2021'
  /** A4:2021-Insecure Design, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A4_2021'
  /** A5:2021-Security Misconfiguration, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A5_2021'
  /** A6:2021-Vulnerable and Outdated Components, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A6_2021'
  /** A7:2021-Identification and Authentication Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A7_2021'
  /** A8:2021-Software and Data Integrity Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A8_2021'
  /** A9:2021-Security Logging and Monitoring Failures, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A9_2021'
  /** A10:2021-Server-Side Request Forgery, OWASP top 10 category. Introduced in GitLab 18.1: **Status**: Experiment. */
  | 'A10_2021'
  /** No OWASP top 10 category. */
  | 'NONE';

/** OwaspTop10 category of the vulnerability */
export type VulnerabilityOwaspTop10 =
  /** A1:2017-Injection, OWASP top 10 2017 category. */
  | 'A1_2017'
  /** A2:2017-Broken Authentication, OWASP top 10 2017 category. */
  | 'A2_2017'
  /** A3:2017-Sensitive Data Exposure, OWASP top 10 2017 category. */
  | 'A3_2017'
  /** A4:2017-XML External Entities (XXE), OWASP top 10 2017 category. */
  | 'A4_2017'
  /** A5:2017-Broken Access Control, OWASP top 10 2017 category. */
  | 'A5_2017'
  /** A6:2017-Security Misconfiguration, OWASP top 10 2017 category. */
  | 'A6_2017'
  /** A7:2017-Cross-Site Scripting (XSS), OWASP top 10 2017 category. */
  | 'A7_2017'
  /** A8:2017-Insecure Deserialization, OWASP top 10 2017 category. */
  | 'A8_2017'
  /** A9:2017-Using Components with Known Vulnerabilities, OWASP top 10 2017 category. */
  | 'A9_2017'
  /** A10:2017-Insufficient Logging & Monitoring, OWASP top 10 2017 category. */
  | 'A10_2017'
  /** No OWASP top 10 2017 category. */
  | 'NONE';

/** Check permissions for the current user on a vulnerability */
export type VulnerabilityPermissions = {
  __typename?: 'VulnerabilityPermissions';
  /** If `true`, the user can perform `admin_vulnerability` on this resource */
  adminVulnerability: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_vulnerability_external_issue_link` on this resource */
  adminVulnerabilityExternalIssueLink: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_vulnerability_issue_link` on this resource */
  adminVulnerabilityIssueLink: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_vulnerability_export` on this resource */
  createVulnerabilityExport: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_vulnerability_feedback` on this resource */
  createVulnerabilityFeedback: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `destroy_vulnerability_feedback` on this resource */
  destroyVulnerabilityFeedback: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_vulnerability` on this resource */
  readVulnerability: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_vulnerability_feedback` on this resource */
  readVulnerabilityFeedback: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_vulnerability_feedback` on this resource */
  updateVulnerabilityFeedback: Scalars['Boolean']['output'];
};

/** Represents a vulnerability remediation type. */
export type VulnerabilityRemediationType = {
  __typename?: 'VulnerabilityRemediationType';
  /** Diff of the remediation. */
  diff?: Maybe<Scalars['String']['output']>;
  /** Summary of the remediation. */
  summary?: Maybe<Scalars['String']['output']>;
};

/** The type of the security scan that found the vulnerability */
export type VulnerabilityReportType =
  /** API fuzzing report */
  | 'API_FUZZING'
  /** Cluster image scanning report */
  | 'CLUSTER_IMAGE_SCANNING'
  /** Container scanning report */
  | 'CONTAINER_SCANNING'
  /** Container scanning for registry report */
  | 'CONTAINER_SCANNING_FOR_REGISTRY'
  /** Coverage fuzzing report */
  | 'COVERAGE_FUZZING'
  /** DAST report */
  | 'DAST'
  /** Dependency scanning report */
  | 'DEPENDENCY_SCANNING'
  /** Generic report */
  | 'GENERIC'
  /** SAST report */
  | 'SAST'
  /** Secret detection report */
  | 'SECRET_DETECTION';

/** Represents a count of vulnerabilities for a specific report type */
export type VulnerabilityReportTypeCount = {
  __typename?: 'VulnerabilityReportTypeCount';
  /** Number of vulnerabilities. */
  count: Scalars['Int']['output'];
  /** Report type. */
  reportType: VulnerabilityReportType;
};

/** Represents vulnerability information */
export type VulnerabilityRepresentationInformation = {
  __typename?: 'VulnerabilityRepresentationInformation';
  /** SHA of the commit where the vulnerability was resolved. */
  resolvedInCommitSha?: Maybe<Scalars['String']['output']>;
};

/** Represents a Vulnerability Request */
export type VulnerabilityRequest = {
  __typename?: 'VulnerabilityRequest';
  /** Body of the Vulnerability Request. */
  body?: Maybe<Scalars['String']['output']>;
  /** HTTP headers of the Vulnerability Request. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Method of the Vulnerability Request. */
  method?: Maybe<Scalars['String']['output']>;
  /** URL of the Vulnerability Request. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Represents a Vulnerability Request/Response Header */
export type VulnerabilityRequestResponseHeader = {
  __typename?: 'VulnerabilityRequestResponseHeader';
  /** Name of the Vulnerability Request/Response Header. */
  name?: Maybe<Scalars['String']['output']>;
  /** Value of the Vulnerability Request/Response Header. */
  value?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of VulnerabilityResolve */
export type VulnerabilityResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability was resolved (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** ID of the vulnerability to be resolved. */
  id: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityResolve. */
export type VulnerabilityResolvePayload = {
  __typename?: 'VulnerabilityResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Response */
export type VulnerabilityResponse = {
  __typename?: 'VulnerabilityResponse';
  /** Body of the Vulnerability Response. */
  body?: Maybe<Scalars['String']['output']>;
  /** HTTP headers of the Vulnerability Response. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Reason Phrase of the Vulnerability Response. */
  reasonPhrase?: Maybe<Scalars['String']['output']>;
  /** Status Code of the Vulnerability Response. */
  statusCode?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of VulnerabilityRevertToDetected */
export type VulnerabilityRevertToDetectedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability was reverted to detected (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** ID of the vulnerability to be reverted to detected. */
  id: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityRevertToDetected. */
export type VulnerabilityRevertToDetectedPayload = {
  __typename?: 'VulnerabilityRevertToDetectedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability scanner */
export type VulnerabilityScanner = {
  __typename?: 'VulnerabilityScanner';
  /** External ID of the vulnerability scanner. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** ID of the scanner. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Name of the vulnerability scanner. */
  name?: Maybe<Scalars['String']['output']>;
  /** Type of the vulnerability report. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Humanized type of the vulnerability report. */
  reportTypeHumanized?: Maybe<Scalars['String']['output']>;
  /** Vendor of the vulnerability scanner. */
  vendor?: Maybe<Scalars['String']['output']>;
};

/** The connection type for VulnerabilityScanner. */
export type VulnerabilityScannerConnection = {
  __typename?: 'VulnerabilityScannerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityScannerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityScanner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityScannerEdge = {
  __typename?: 'VulnerabilityScannerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityScanner>;
};

export type VulnerabilityScannerInput = {
  /** Unique ID that identifies the scanner. */
  id: Scalars['String']['input'];
  /** Human readable value that identifies the analyzer, not required to be unique. */
  name: Scalars['String']['input'];
  /** Link to more information about the analyzer. */
  url: Scalars['String']['input'];
  /** Information about vendor/maintainer of the scanner. */
  vendor?: InputMaybe<VulnerabilityScannerVendorInput>;
  /** Version of the scanner. */
  version: Scalars['String']['input'];
};

export type VulnerabilityScannerVendorInput = {
  /** Name of the vendor/maintainer. */
  name: Scalars['String']['input'];
};

/** Represents vulnerability counts by severity */
export type VulnerabilitySeveritiesCount = {
  __typename?: 'VulnerabilitySeveritiesCount';
  /** Number of vulnerabilities of CRITICAL severity of the project */
  critical?: Maybe<Scalars['Int']['output']>;
  /** Number of vulnerabilities of HIGH severity of the project */
  high?: Maybe<Scalars['Int']['output']>;
  /** Number of vulnerabilities of INFO severity of the project */
  info?: Maybe<Scalars['Int']['output']>;
  /** Number of vulnerabilities of LOW severity of the project */
  low?: Maybe<Scalars['Int']['output']>;
  /** Number of vulnerabilities of MEDIUM severity of the project */
  medium?: Maybe<Scalars['Int']['output']>;
  /** Number of vulnerabilities of UNKNOWN severity of the project */
  unknown?: Maybe<Scalars['Int']['output']>;
};

/** The severity of the vulnerability */
export type VulnerabilitySeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** Represents a count of vulnerabilities for a specific severity level */
export type VulnerabilitySeverityCount = {
  __typename?: 'VulnerabilitySeverityCount';
  /** Number of vulnerabilities. */
  count: Scalars['Int']['output'];
  /** Average age in days of vulnerabilities since detection. */
  meanAge?: Maybe<Scalars['Float']['output']>;
  /** Median age in days of vulnerabilities since detection. */
  medianAge?: Maybe<Scalars['Float']['output']>;
  /** Severity level. */
  severity: VulnerabilitySeverity;
};

/** Vulnerability sort values */
export type VulnerabilitySort =
  /** Detection timestamp in ascending order. */
  | 'detected_asc'
  /** Detection timestamp in descending order. */
  | 'detected_desc'
  /** Severity in ascending order. */
  | 'severity_asc'
  /** Severity in descending order. */
  | 'severity_desc';

/** The state of the vulnerability */
export type VulnerabilityState =
  /** For details, see [vulnerability status values](https://docs.gitlab.com/user/application_security/vulnerabilities/#vulnerability-status-values). */
  | 'CONFIRMED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/user/application_security/vulnerabilities/#vulnerability-status-values). */
  | 'DETECTED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/user/application_security/vulnerabilities/#vulnerability-status-values). */
  | 'DISMISSED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/user/application_security/vulnerabilities/#vulnerability-status-values). */
  | 'RESOLVED';

/** Represents a state transition of a vulnerability */
export type VulnerabilityStateTransitionType = {
  __typename?: 'VulnerabilityStateTransitionType';
  /** User who changed the state of the vulnerability. */
  author?: Maybe<UserCore>;
  /** Comment for the state change. */
  comment?: Maybe<Scalars['String']['output']>;
  /** Time of the state change of the vulnerability. */
  createdAt: Scalars['Time']['output'];
  /** Reason for the dismissal. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** State of the vulnerability before transition. */
  fromState: VulnerabilityState;
  /** ID of the state transition. */
  id: Scalars['VulnerabilitiesStateTransitionID']['output'];
  /** State of the vulnerability after transition. */
  toState: VulnerabilityState;
};

/** The connection type for VulnerabilityStateTransitionType. */
export type VulnerabilityStateTransitionTypeConnection = {
  __typename?: 'VulnerabilityStateTransitionTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityStateTransitionTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityStateTransitionType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityStateTransitionTypeEdge = {
  __typename?: 'VulnerabilityStateTransitionTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityStateTransitionType>;
};

export type VulnerabilityStatisticInterface = {
  /** Number of vulnerabilities of CRITICAL severity. */
  critical: Scalars['Int']['output'];
  /** Number of vulnerabilities of HIGH severity. */
  high: Scalars['Int']['output'];
  /** Number of vulnerabilities of INFO severity. */
  info: Scalars['Int']['output'];
  /** Number of vulnerabilities of LOW severity. */
  low: Scalars['Int']['output'];
  /** Number of vulnerabilities of MEDIUM severity. */
  medium: Scalars['Int']['output'];
  /** Total of all vulnerabilities. */
  total: Scalars['Int']['output'];
  /** Number of vulnerabilities of UNKNOWN severity. */
  unknown: Scalars['Int']['output'];
  /** Date that data was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** Counts for each vulnerability severity in the project. */
export type VulnerabilityStatisticType = VulnerabilityStatisticInterface & {
  __typename?: 'VulnerabilityStatisticType';
  /** Number of vulnerabilities of CRITICAL severity. */
  critical: Scalars['Int']['output'];
  /** Number of vulnerabilities of HIGH severity. */
  high: Scalars['Int']['output'];
  /** Number of vulnerabilities of INFO severity. */
  info: Scalars['Int']['output'];
  /** Number of vulnerabilities of LOW severity. */
  low: Scalars['Int']['output'];
  /** Number of vulnerabilities of MEDIUM severity. */
  medium: Scalars['Int']['output'];
  /** Project ID. */
  projectId: Scalars['Int']['output'];
  /** Total of all vulnerabilities. */
  total: Scalars['Int']['output'];
  /** Number of vulnerabilities of UNKNOWN severity. */
  unknown: Scalars['Int']['output'];
  /** Date that data was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** Represents a triggered workflow for a vulnerability */
export type VulnerabilityTriggeredWorkflow = {
  __typename?: 'VulnerabilityTriggeredWorkflow';
  /** Associated workflow details. */
  workflow: DuoWorkflow;
  /** Name of the workflow. */
  workflowName: VulnerabilityWorkflowName;
};

/** The connection type for VulnerabilityTriggeredWorkflow. */
export type VulnerabilityTriggeredWorkflowConnection = {
  __typename?: 'VulnerabilityTriggeredWorkflowConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityTriggeredWorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityTriggeredWorkflow>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityTriggeredWorkflowEdge = {
  __typename?: 'VulnerabilityTriggeredWorkflowEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityTriggeredWorkflow>;
};

/** Autogenerated input type of VulnerabilityUnlinkMergeRequest */
export type VulnerabilityUnlinkMergeRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the merge request. */
  mergeRequestId: Scalars['MergeRequestID']['input'];
  /** ID of the vulnerability. */
  vulnerabilityId: Scalars['VulnerabilityID']['input'];
};

/** Autogenerated return type of VulnerabilityUnlinkMergeRequest. */
export type VulnerabilityUnlinkMergeRequestPayload = {
  __typename?: 'VulnerabilityUnlinkMergeRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated vulnerability. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Workflow name for vulnerability triggered workflows */
export type VulnerabilityWorkflowName =
  /** Workflow name is resolve sast vulnerability */
  | 'RESOLVE_SAST_VULNERABILITY'
  /** Workflow name is sast fp detection */
  | 'SAST_FP_DETECTION';

/** Represents a vulnerable dependency. Used in vulnerability location data */
export type VulnerableDependency = {
  __typename?: 'VulnerableDependency';
  /** Package associated with the vulnerable dependency. */
  package?: Maybe<VulnerablePackage>;
  /** Version of the vulnerable dependency. */
  version?: Maybe<Scalars['String']['output']>;
};

/** Represents a vulnerable Kubernetes resource. Used in vulnerability location data */
export type VulnerableKubernetesResource = {
  __typename?: 'VulnerableKubernetesResource';
  /** Kubernetes agent that performed the scan. */
  agent?: Maybe<ClusterAgent>;
  /** ID of the cluster integration used to perform the scan. */
  clusterId?: Maybe<Scalars['ClustersClusterID']['output']>;
  /** Name of the container that had its image scanned. */
  containerName: Scalars['String']['output'];
  /** Kind of the Kubernetes resource. */
  kind: Scalars['String']['output'];
  /** Name of the Kubernetes resource. */
  name: Scalars['String']['output'];
  /** Kubernetes namespace where the resource resides. */
  namespace: Scalars['String']['output'];
};

/** Represents a vulnerable package. Used in vulnerability dependency data */
export type VulnerablePackage = {
  __typename?: 'VulnerablePackage';
  /** Name of the vulnerable package. */
  name?: Maybe<Scalars['String']['output']>;
  /** Path of the vulnerable package. */
  path?: Maybe<Scalars['String']['output']>;
};

/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGrade = {
  __typename?: 'VulnerableProjectsByGrade';
  /** Number of projects within the grade. */
  count: Scalars['Int']['output'];
  /** Grade based on the highest severity vulnerability present. */
  grade: VulnerabilityGrade;
  /** Projects within the grade. */
  projects: ProjectConnection;
};


/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGradeProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Webhook auto-disabling alert status */
export type WebhookAlertStatus =
  /** Webhook has been permanently disabled and will not be automatically re-enabled. */
  | 'DISABLED'
  /** Webhook is executable. */
  | 'EXECUTABLE'
  /** Webhook has been temporarily disabled and will be automatically re-enabled. */
  | 'TEMPORARILY_DISABLED';

/** Strategy for filtering push events by branch name */
export type WebhookBranchFilterStrategy =
  /** Receive push events from all branches. */
  | 'ALL_BRANCHES'
  /** Receive push events from branches that match a regular expression (regex). */
  | 'REGEX'
  /** Receive push events from branches that match a wildcard pattern. */
  | 'WILDCARD';

export type WebhookCustomHeader = {
  __typename?: 'WebhookCustomHeader';
  /** Custom header name. */
  key: Scalars['String']['output'];
};

export type WebhookEvent = {
  __typename?: 'WebhookEvent';
  /** Webhook request time. */
  createdAt: Scalars['Time']['output'];
  /** Webhook execution duration in seconds. */
  executionDuration?: Maybe<Scalars['Float']['output']>;
  /** Global ID of the webhook event. */
  id: Scalars['WebHookLogID']['output'];
  /** Internal error message that occurred while executing the webhook. */
  internalErrorMessage?: Maybe<Scalars['String']['output']>;
  /** Whether request data was too large to be executed. */
  oversize: Scalars['Boolean']['output'];
  /** Data sent in the webhook request. */
  requestData?: Maybe<Scalars['String']['output']>;
  /** HTTP Headers used in the webhook request. */
  requestHeaders?: Maybe<Array<WebhookEventHeaderType>>;
  /** Body of the webhook response. */
  responseBody?: Maybe<Scalars['String']['output']>;
  /** HTTP Headers from the webhook response. */
  responseHeaders?: Maybe<Array<WebhookEventHeaderType>>;
  /** HTTP status of the webhook response. */
  responseStatus?: Maybe<Scalars['String']['output']>;
  /** Trigger that caused webhook execution. */
  trigger?: Maybe<Scalars['String']['output']>;
  /** URL used in webhook request. */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for WebhookEvent. */
export type WebhookEventConnection = {
  __typename?: 'WebhookEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WebhookEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WebhookEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WebhookEventEdge = {
  __typename?: 'WebhookEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WebhookEvent>;
};

export type WebhookEventHeaderType = {
  __typename?: 'WebhookEventHeaderType';
  /** HTTP response header name. */
  name: Scalars['String']['output'];
  /** HTTP response header value. */
  value: Scalars['String']['output'];
};

export type WebhookUrlVariable = {
  __typename?: 'WebhookUrlVariable';
  /** URL variable mask that will appear in a masked webhook url in place of its sensitive portion. */
  key: Scalars['String']['output'];
};

/** Weight ID wildcard values */
export type WeightWildcardId =
  /** Weight is assigned. */
  | 'ANY'
  /** No weight is assigned. */
  | 'NONE';

/** A wiki page */
export type WikiPage = NoteableInterface & Todoable & {
  __typename?: 'WikiPage';
  /** All commenters on the noteable. */
  commenters: UserCoreConnection;
  /** All discussions on the noteable. */
  discussions: DiscussionConnection;
  /** Global ID of the wiki page metadata record. */
  id: Scalars['WikiPageMetaID']['output'];
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Whether the current user is subscribed to notifications on the wiki page. */
  subscribed: Scalars['Boolean']['output'];
  /** Wiki page title. */
  title: Scalars['String']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: WikiPagePermissions;
  /** URL of the object. */
  webUrl?: Maybe<Scalars['String']['output']>;
};


/** A wiki page */
export type WikiPageCommentersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wiki page */
export type WikiPageDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wiki page */
export type WikiPageNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WikiPagePermissions = {
  __typename?: 'WikiPagePermissions';
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `mark_note_as_internal` on this resource */
  markNoteAsInternal: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_wiki_page` on this resource */
  readWikiPage: Scalars['Boolean']['output'];
};

/** Autogenerated input type of WikiPageSubscribe */
export type WikiPageSubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the wiki page meta record. */
  id: Scalars['WikiPageMetaID']['input'];
  /** Desired state of the subscription. */
  subscribed: Scalars['Boolean']['input'];
};

/** Autogenerated return type of WikiPageSubscribe. */
export type WikiPageSubscribePayload = {
  __typename?: 'WikiPageSubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Wiki page after mutation. */
  wikiPage?: Maybe<WikiPage>;
};

export type WorkItem = Todoable & {
  __typename?: 'WorkItem';
  /**
   * Whether the work item belongs to an archived project or group. Introduced in GitLab 16.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.5.
   */
  archived: Scalars['Boolean']['output'];
  /**
   * User that created the work item. Introduced in GitLab 15.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.9.
   */
  author?: Maybe<UserCore>;
  /** Timestamp of when the work item was closed. */
  closedAt?: Maybe<Scalars['Time']['output']>;
  /** Paths of the comment templates. */
  commentTemplatesPaths: Array<CommentTemplatePathType>;
  /** Indicates the work item is confidential. */
  confidential: Scalars['Boolean']['output'];
  /** User specific email address for the work item. */
  createNoteEmail?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the work item was created. */
  createdAt: Scalars['Time']['output'];
  /** Description of the work item. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** URL of the work item that the work item is marked as a duplicate of. */
  duplicatedToWorkItemUrl?: Maybe<Scalars['String']['output']>;
  /** Indicates the work item is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']['output']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['output'];
  /** Internal ID of the work item. */
  iid: Scalars['String']['output'];
  /** Indicates whether the work item was imported. */
  imported: Scalars['Boolean']['output'];
  /** Lock version of the work item. Incremented each time the work item is updated. */
  lockVersion: Scalars['Int']['output'];
  /** URL of the work item that the work item was moved to. */
  movedToWorkItemUrl?: Maybe<Scalars['String']['output']>;
  /** Name or title of the object. */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Namespace the work item belongs to. Introduced in GitLab 15.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.10.
   */
  namespace?: Maybe<Namespace>;
  /**
   * Project the work item belongs to. Introduced in GitLab 15.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.3.
   */
  project?: Maybe<Project>;
  /** URL of the epic that the work item has been promoted to. */
  promotedToEpicUrl?: Maybe<Scalars['String']['output']>;
  /** Internal reference of the work item. Returned in shortened format by default. */
  reference: Scalars['String']['output'];
  /**
   * Whether to show the promotional message for the work item. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  showPlanUpgradePromotion: Scalars['Boolean']['output'];
  /** State of the work item. */
  state: WorkItemState;
  /** Title of the work item. */
  title: Scalars['String']['output'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the work item was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Number of user discussions in the work item. */
  userDiscussionsCount: Scalars['Int']['output'];
  /** Permissions for the current user on the resource */
  userPermissions: WorkItemPermissions;
  /** Web path of the object. */
  webPath?: Maybe<Scalars['String']['output']>;
  /** URL of the object. */
  webUrl?: Maybe<Scalars['String']['output']>;
  /** Collection of widgets that belong to the work item. */
  widgets?: Maybe<Array<WorkItemWidget>>;
  /** Type assigned to the work item. */
  workItemType: WorkItemType;
};


export type WorkItemReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']['input']>;
};


export type WorkItemWidgetsArgs = {
  exceptTypes?: InputMaybe<Array<WorkItemWidgetType>>;
  onlyTypes?: InputMaybe<Array<WorkItemWidgetType>>;
};

/** Autogenerated input type of WorkItemAddClosingMergeRequest */
export type WorkItemAddClosingMergeRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the context namespace (project or group). Only project full paths are used to find a merge request using a short reference syntax like `!1`. Ignored for full references and URLs. Defaults to the namespace of the work item if not provided. */
  contextNamespacePath?: InputMaybe<Scalars['ID']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Merge request reference (short, full or URL). Example: `!1`, `project_full_path!1` or `https://gitlab.com/gitlab-org/gitlab/-/merge_requests/1`. */
  mergeRequestReference: Scalars['String']['input'];
};

/** Autogenerated return type of WorkItemAddClosingMergeRequest. */
export type WorkItemAddClosingMergeRequestPayload = {
  __typename?: 'WorkItemAddClosingMergeRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Closing merge request added to the work item. */
  closingMergeRequest?: Maybe<WorkItemClosingMergeRequest>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Work item with new closing merge requests. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemAddLinkedItems */
export type WorkItemAddLinkedItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Type of link. Defaults to `RELATED`. */
  linkType?: InputMaybe<WorkItemRelatedLinkType>;
  /** Global IDs of the items to link. Maximum number of IDs you can provide: 10. */
  workItemsIds: Array<Scalars['WorkItemID']['input']>;
};

/** Autogenerated return type of WorkItemAddLinkedItems. */
export type WorkItemAddLinkedItemsPayload = {
  __typename?: 'WorkItemAddLinkedItemsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Linked items update result message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Values for work item award emoji update enum */
export type WorkItemAwardEmojiUpdateAction =
  /** Adds the emoji. */
  | 'ADD'
  /** Removes the emoji. */
  | 'REMOVE'
  /** Toggles the status of the emoji. */
  | 'TOGGLE';

/** Autogenerated input type of WorkItemBulkMove */
export type WorkItemBulkMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID array of the work items that will be moved. IDs that the user can't move will be ignored. A max of 100 can be provided. */
  ids: Array<Scalars['WorkItemID']['input']>;
  /** Full path of the source namespace. For example, `gitlab-org/gitlab-foss`. */
  sourceFullPath: Scalars['String']['input'];
  /** Full path of the target namespace. For example, `gitlab-org/gitlab-foss`. User paths are not supported. */
  targetFullPath: Scalars['String']['input'];
};

/** Autogenerated return type of WorkItemBulkMove. */
export type WorkItemBulkMovePayload = {
  __typename?: 'WorkItemBulkMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Number of work items that were successfully moved. */
  movedWorkItemCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of WorkItemBulkUpdate */
export type WorkItemBulkUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project or group (Premium and Ultimate only) containing the work items that will be updated. User paths are not supported. */
  fullPath: Scalars['ID']['input'];
  /** Global ID array of the work items that will be updated. IDs that the user can't update will be ignored. A max of 100 can be provided. */
  ids: Array<Scalars['WorkItemID']['input']>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
};

/** Autogenerated return type of WorkItemBulkUpdate. */
export type WorkItemBulkUpdatePayload = {
  __typename?: 'WorkItemBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Number of work items that were successfully updated. */
  updatedWorkItemCount?: Maybe<Scalars['Int']['output']>;
};

export type WorkItemClosingMergeRequest = {
  __typename?: 'WorkItemClosingMergeRequest';
  /** Whether this merge request link was created by referencing the work item on the merge request description, using the closing pattern. */
  fromMrDescription: Scalars['Boolean']['output'];
  /** Global ID of the closing merge request association. */
  id: Scalars['MergeRequestsClosingIssuesID']['output'];
  /** Related merge request. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** The connection type for WorkItemClosingMergeRequest. */
export type WorkItemClosingMergeRequestConnection = {
  __typename?: 'WorkItemClosingMergeRequestConnection';
  /** Number of merge requests that close the work item on merge. */
  count?: Maybe<Scalars['Int']['output']>;
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemClosingMergeRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemClosingMergeRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemClosingMergeRequestEdge = {
  __typename?: 'WorkItemClosingMergeRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemClosingMergeRequest>;
};

/** The connection type for WorkItem. */
export type WorkItemConnection = {
  __typename?: 'WorkItemConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for WorkItem. */
export type WorkItemConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of WorkItemConvert */
export type WorkItemConvertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Global ID of the new work item type. */
  workItemTypeId: Scalars['WorkItemsTypeID']['input'];
};

/** Autogenerated return type of WorkItemConvert. */
export type WorkItemConvertPayload = {
  __typename?: 'WorkItemConvertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemConvertTaskInput = {
  /** Last line in the Markdown source that defines the list item task. */
  lineNumberEnd: Scalars['Int']['input'];
  /** First line in the Markdown source that defines the list item task. */
  lineNumberStart: Scalars['Int']['input'];
  /** Current lock version of the work item containing the task in the description. */
  lockVersion: Scalars['Int']['input'];
  /** Full string of the task to be replaced. New title for the created work item. */
  title: Scalars['String']['input'];
  /** Global ID of the work item type used to create the new work item. */
  workItemTypeId: Scalars['WorkItemsTypeID']['input'];
};

/** Autogenerated input type of WorkItemCreateFromTask */
export type WorkItemCreateFromTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Arguments necessary to convert a task into a work item. */
  workItemData: WorkItemConvertTaskInput;
};

/** Autogenerated return type of WorkItemCreateFromTask. */
export type WorkItemCreateFromTaskPayload = {
  __typename?: 'WorkItemCreateFromTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** New work item created from task. */
  newWorkItem?: Maybe<WorkItem>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemCreate */
export type WorkItemCreateInput = {
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Input for color widget. */
  colorWidget?: InputMaybe<WorkItemWidgetColorInput>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Source which triggered the creation of the work item. Used only for tracking purposes. */
  createSource?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the work item was created. Available only for admins and project owners. */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Input for CRM contacts widget. */
  crmContactsWidget?: InputMaybe<WorkItemWidgetCrmContactsCreateInput>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Information required to resolve discussions in a noteable, when the work item is created. */
  discussionsToResolve?: InputMaybe<WorkItemResolveDiscussionsInput>;
  /** Input for health status widget. */
  healthStatusWidget?: InputMaybe<WorkItemWidgetHealthStatusInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyCreateInput>;
  /** Iteration widget of the work item. */
  iterationWidget?: InputMaybe<WorkItemWidgetIterationInput>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsCreateInput>;
  /** Input for linked items widget. */
  linkedItemsWidget?: InputMaybe<WorkItemWidgetLinkedItemsCreateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Full path of the namespace(project or group) the work item is created in. */
  namespacePath?: InputMaybe<Scalars['ID']['input']>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Title of the work item. */
  title: Scalars['String']['input'];
  /** Input for weight widget. */
  weightWidget?: InputMaybe<WorkItemWidgetWeightInput>;
  /** Global ID of a work item type. */
  workItemTypeId: Scalars['WorkItemsTypeID']['input'];
};

/** Autogenerated return type of WorkItemCreate. */
export type WorkItemCreatePayload = {
  __typename?: 'WorkItemCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemCustomFieldValue = {
  /** Custom field associated with the custom field value. */
  customField: CustomField;
};

export type WorkItemDateFieldValue = WorkItemCustomFieldValue & {
  __typename?: 'WorkItemDateFieldValue';
  /** Custom field associated with the custom field value. */
  customField: CustomField;
  /** Date value of the custom field. */
  value?: Maybe<Scalars['Date']['output']>;
};

/** Autogenerated input type of WorkItemDelete */
export type WorkItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
};

/** Autogenerated return type of WorkItemDelete. */
export type WorkItemDeletePayload = {
  __typename?: 'WorkItemDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Namespace the deleted work item belonged to. */
  namespace?: Maybe<Namespace>;
  /**
   * Project the deleted work item belonged to. Deprecated in GitLab 16.9: Use `namespace`.
   * @deprecated Use `namespace`. Deprecated in GitLab 16.9.
   */
  project?: Maybe<Project>;
};

export type WorkItemDescriptionTemplate = {
  __typename?: 'WorkItemDescriptionTemplate';
  /** Category of description template. */
  category?: Maybe<Scalars['String']['output']>;
  /** Content of Description Template. */
  content?: Maybe<Scalars['String']['output']>;
  /** Name of Description Template. */
  name?: Maybe<Scalars['String']['output']>;
  /** ID of the description template project. */
  projectId?: Maybe<Scalars['Int']['output']>;
};

/** The connection type for WorkItemDescriptionTemplate. */
export type WorkItemDescriptionTemplateConnection = {
  __typename?: 'WorkItemDescriptionTemplateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemDescriptionTemplateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemDescriptionTemplate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type WorkItemDescriptionTemplateContentInput = {
  /** Full path of the group or project using the template. */
  fromNamespace?: InputMaybe<Scalars['String']['input']>;
  /** Name of the description template. */
  name: Scalars['String']['input'];
  /** ID of the project the template belongs to. */
  projectId: Scalars['Int']['input'];
};

/** An edge in a connection. */
export type WorkItemDescriptionTemplateEdge = {
  __typename?: 'WorkItemDescriptionTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemDescriptionTemplate>;
};

/** Values for sorting work item discussions */
export type WorkItemDiscussionsSort =
  /** Created at in ascending order. */
  | 'CREATED_ASC'
  /** Created at in descending order. */
  | 'CREATED_DESC';

/** An edge in a connection. */
export type WorkItemEdge = {
  __typename?: 'WorkItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemExport */
export type WorkItemExportInput = {
  /** Usernames of users assigned to the work item (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by assignee wildcard. Incompatible with `assigneeUsernames`. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter work items by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Work items closed after the date. */
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items closed before the date. */
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Work items created after the timestamp. */
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items created before the timestamp. */
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter by ID of CRM contact. */
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  /** Filter by ID of CRM contact organization. */
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  /** Work items due after the timestamp. */
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items due before the timestamp. */
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter by global IDs of work items (maximum is 100 IDs). */
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** List of IIDs of work items. For example, `["1", "2"]` (maximum is 100 IIDs). */
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Specify the fields to perform the search in.
   * Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
   *
   */
  in?: InputMaybe<Array<IssuableSearchableField>>;
  /** Labels applied to the work item (maximum is 100 labels). */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Milestone applied to the work item (maximum is 100 milestones). */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by milestone ID wildcard. Incompatible with `milestoneTitle`. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Negated work item arguments. */
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  /** List of arguments with inclusive `OR`. */
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  /** Filter work items by global IDs of their parent items (maximum is 100 IDs). */
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** Full project path. */
  projectPath: Scalars['ID']['input'];
  /** Release tag associated with the work item's milestone (maximum is 100 tags). Ignored when parent is a group. */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by release tag wildcard. */
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  /** Search query for title or description. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** List of selected fields to be exported. Omit to export all available fields. */
  selectedFields?: InputMaybe<Array<AvailableExportFields>>;
  /** Current state of the work item. */
  state?: InputMaybe<IssuableState>;
  /** Work items the current user is subscribed to. */
  subscribed?: InputMaybe<SubscriptionStatus>;
  /** Filter work items by the given work item types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Work items updated after the timestamp. */
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items updated before the timestamp. */
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};

/** Autogenerated return type of WorkItemExport. */
export type WorkItemExportPayload = {
  __typename?: 'WorkItemExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Export request result message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of WorkItemHierarchyAddChildrenItems */
export type WorkItemHierarchyAddChildrenItemsInput = {
  /** Global IDs of children work items. */
  childrenIds: Array<Scalars['WorkItemID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
};

/** Autogenerated return type of WorkItemHierarchyAddChildrenItems. */
export type WorkItemHierarchyAddChildrenItemsPayload = {
  __typename?: 'WorkItemHierarchyAddChildrenItemsPayload';
  /** Work items that were added as children. */
  addedChildren: Array<WorkItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Represents a lifecycle for work items */
export type WorkItemLifecycle = {
  __typename?: 'WorkItemLifecycle';
  /**
   * Default closed status of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  defaultClosedStatus?: Maybe<WorkItemStatus>;
  /**
   * Default duplicate status of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  defaultDuplicateStatus?: Maybe<WorkItemStatus>;
  /**
   * Default open status of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  defaultOpenStatus?: Maybe<WorkItemStatus>;
  /**
   * ID of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  id?: Maybe<Scalars['GlobalID']['output']>;
  /**
   * Name of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Work item counts by status for the lifecycle. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  statusCounts?: Maybe<Array<WorkItemStatusCount>>;
  /**
   * All available statuses of the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  statuses?: Maybe<Array<WorkItemStatus>>;
  /**
   * Work item types associated to the lifecycle. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  workItemTypes?: Maybe<Array<WorkItemType>>;
};

/** The connection type for WorkItemLifecycle. */
export type WorkItemLifecycleConnection = {
  __typename?: 'WorkItemLifecycleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemLifecycleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemLifecycle>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemLifecycleEdge = {
  __typename?: 'WorkItemLifecycleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemLifecycle>;
};

export type WorkItemLinkedResource = {
  __typename?: 'WorkItemLinkedResource';
  /** URL of resource. */
  url: Scalars['String']['output'];
};

/** The connection type for WorkItemLinkedResource. */
export type WorkItemLinkedResourceConnection = {
  __typename?: 'WorkItemLinkedResourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemLinkedResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemLinkedResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemLinkedResourceEdge = {
  __typename?: 'WorkItemLinkedResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemLinkedResource>;
};

export type WorkItemNumberFieldValue = WorkItemCustomFieldValue & {
  __typename?: 'WorkItemNumberFieldValue';
  /** Custom field associated with the custom field value. */
  customField: CustomField;
  /** Number value of the custom field. */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Parent ID wildcard values */
export type WorkItemParentWildcardId =
  /** Any parent is assigned. */
  | 'ANY'
  /** No parent is assigned. */
  | 'NONE';

/** Check permissions for the current user on a work item */
export type WorkItemPermissions = {
  __typename?: 'WorkItemPermissions';
  /** If `true`, the user can perform `admin_parent_link` on this resource */
  adminParentLink: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_work_item` on this resource */
  adminWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `admin_work_item_link` on this resource */
  adminWorkItemLink: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `blocked_work_items` on the work item. */
  blockedWorkItems?: Maybe<Scalars['Boolean']['output']>;
  /** If `true`, the user can perform `clone_work_item` on this resource */
  cloneWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `delete_work_item` on this resource */
  deleteWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `mark_note_as_internal` on this resource */
  markNoteAsInternal: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `move_work_item` on this resource */
  moveWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `read_work_item` on this resource */
  readWorkItem: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `report_spam` on this resource */
  reportSpam: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `set_work_item_metadata` on this resource */
  setWorkItemMetadata: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `summarize_comments` on this resource */
  summarizeComments: Scalars['Boolean']['output'];
  /** If `true`, the user can perform `update_work_item` on this resource */
  updateWorkItem: Scalars['Boolean']['output'];
};

export type WorkItemRelatedBranch = {
  __typename?: 'WorkItemRelatedBranch';
  /** Path to comparison of branch to default branch. */
  comparePath?: Maybe<Scalars['String']['output']>;
  /** Name of the branch. */
  name: Scalars['String']['output'];
  /** Status of pipeline for the branch. */
  pipelineStatus?: Maybe<DetailedStatus>;
};

/** The connection type for WorkItemRelatedBranch. */
export type WorkItemRelatedBranchConnection = {
  __typename?: 'WorkItemRelatedBranchConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemRelatedBranchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemRelatedBranch>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemRelatedBranchEdge = {
  __typename?: 'WorkItemRelatedBranchEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemRelatedBranch>;
};

/** Values for work item link types */
export type WorkItemRelatedLinkType =
  /** Blocked by type. */
  | 'BLOCKED_BY'
  /** Blocks type. */
  | 'BLOCKS'
  /** Related type. */
  | 'RELATED';

/** Autogenerated input type of WorkItemRemoveLinkedItems */
export type WorkItemRemoveLinkedItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Global IDs of the items to unlink. Maximum number of IDs you can provide: 10. */
  workItemsIds: Array<Scalars['WorkItemID']['input']>;
};

/** Autogenerated return type of WorkItemRemoveLinkedItems. */
export type WorkItemRemoveLinkedItemsPayload = {
  __typename?: 'WorkItemRemoveLinkedItemsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Linked items update result message. */
  message?: Maybe<Scalars['String']['output']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemResolveDiscussionsInput = {
  /** ID of a discussion to resolve. */
  discussionId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the noteable where discussions will be resolved when the work item is created. Only `MergeRequestID` is supported at the moment. */
  noteableId: Scalars['NoteableID']['input'];
};

/** Autogenerated input type of WorkItemSavedViewCreate */
export type WorkItemSavedViewCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the saved view. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Display settings associated with the saved view. */
  displaySettings: Scalars['JSON']['input'];
  /** Filters associated with the saved view. */
  filters: WorkItemSavedViewFilterInput;
  /** Name of the saved view. */
  name: Scalars['String']['input'];
  /** Full path of the namespace to create the saved view in. */
  namespacePath: Scalars['ID']['input'];
  /** Whether the saved view is private. Default is true. */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /** Sort option associated with the saved view. */
  sort: WorkItemSort;
};

/** Autogenerated return type of WorkItemSavedViewCreate. */
export type WorkItemSavedViewCreatePayload = {
  __typename?: 'WorkItemSavedViewCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

/** Autogenerated input type of WorkItemSavedViewDelete */
export type WorkItemSavedViewDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the saved view. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['input'];
};

/** Autogenerated return type of WorkItemSavedViewDelete. */
export type WorkItemSavedViewDeletePayload = {
  __typename?: 'WorkItemSavedViewDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Deleted saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

export type WorkItemSavedViewFilterInput = {
  /** Filter values for assignee usernames filter(maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter values for assignee wildcard id filter. Incompatible with `assigneeUsernames`. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter value for author username filter. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for closed after filter. */
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for closed before filter. */
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for confidential filter. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter value for created after filter. */
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for created before filter. */
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for crm contact id filter. */
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for crm organization id filter. */
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for custom field filter. (maximum is 100 fields). */
  customField?: InputMaybe<Array<WorkItemWidgetCustomFieldFilterInputType>>;
  /** Filter value for due after filter. */
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for due before filter. */
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for exclude group work items filter. */
  excludeGroupWorkItems?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter value for exclude projects filter. */
  excludeProjects?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter value for full path filter. */
  fullPath?: InputMaybe<Scalars['ID']['input']>;
  /** Filter value for health status filter. */
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  /** Filter value for hierarchy filter. */
  hierarchyFilters?: InputMaybe<HierarchyFilterInput>;
  /** Filter value for IID filter. */
  iid?: InputMaybe<Scalars['String']['input']>;
  /** "Filter value for in filter. */
  in?: InputMaybe<Array<IssuableSearchableField>>;
  /** Filter value for include descendant work items filter. */
  includeDescendantWorkItems?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter value for include descendants filter. */
  includeDescendants?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter value for iteration cadence id filter. (maximum is 100 IDs). */
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']['input']>>;
  /** Filter value for iteration id filter. */
  iterationId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter value for iteration wildcard id filter. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Filter value for label name filter. (maximum is 100 labels). */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for milestone title filter. (maximum is 100 milestones). */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for milestone wildcard id filter. Incompatible with `milestoneTitle`. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter value for my reaction emoji filter. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for not filter. */
  not?: InputMaybe<WorkItemSavedViewNegatedFilterInput>;
  /** Filter values for or filter. */
  or?: InputMaybe<WorkItemSavedViewUnionedFilterInput>;
  /** Filter value for release tag filter (maximum is 100 tags). */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for release tag wildcard id filter. */
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  /** Filter value for search filter. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for state filter. */
  state?: InputMaybe<IssuableState>;
  /** Filter value for status filter. */
  status?: InputMaybe<WorkItemWidgetStatusFilterInput>;
  /** Filter value for subscribed filter. */
  subscribed?: InputMaybe<SubscriptionStatus>;
  /** Filter value for types filter. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter value for updated after filter. */
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for updated before filter. */
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter value for weight filter. */
  weight?: InputMaybe<Scalars['String']['input']>;
  /** Filter value for weight wildcard id filter. */
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};

export type WorkItemSavedViewFilterWarningType = {
  __typename?: 'WorkItemSavedViewFilterWarningType';
  /** Name of the field associated with the warning. */
  field: Scalars['String']['output'];
  /** Message associated with the warning. */
  message: Scalars['String']['output'];
};

export type WorkItemSavedViewNegatedFilterInput = {
  /** Filter value for not assignee username filter. (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for not author username filter. (maximum is 100 usernames). */
  authorUsername?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for not custom field filter. */
  customField?: InputMaybe<Array<WorkItemWidgetCustomFieldFilterInputType>>;
  /** Filter values for not health status filter. */
  healthStatusFilter?: InputMaybe<Array<HealthStatus>>;
  /** Filter values for not iteration id filter. (maximum is 100 IDs). */
  iterationId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter value for not iteration wildcard id filter. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Filter value for not label name filter. (maximum is 100 labels). */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for not milestone title filter.(maximum is 100 milestones). */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for not milestone wildcard id filter. */
  milestoneWildcardId?: InputMaybe<NegatedMilestoneWildcardId>;
  /** Filter value for not my reaction emoji filter. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Filter work items by global IDs who don't belong to parent items (maximum is 100 IDs). */
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** File value for not release tag filter. (maximum is 100 tags). */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for not types filter. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter values for not weight filter. */
  weight?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of WorkItemSavedViewReorder */
export type WorkItemSavedViewReorderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the saved view to be reordered. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['input'];
  /** Global ID of a saved view that should be placed after the saved view. */
  moveAfterId?: InputMaybe<Scalars['WorkItemsSavedViewsSavedViewID']['input']>;
  /** Global ID of a saved view that should be placed before the saved view. */
  moveBeforeId?: InputMaybe<Scalars['WorkItemsSavedViewsSavedViewID']['input']>;
};

/** Autogenerated return type of WorkItemSavedViewReorder. */
export type WorkItemSavedViewReorderPayload = {
  __typename?: 'WorkItemSavedViewReorderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Reordered saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

/** Autogenerated input type of WorkItemSavedViewSubscribe */
export type WorkItemSavedViewSubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the saved view to subscribe to. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['input'];
};

/** Autogenerated return type of WorkItemSavedViewSubscribe. */
export type WorkItemSavedViewSubscribePayload = {
  __typename?: 'WorkItemSavedViewSubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Subscribed saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

export type WorkItemSavedViewType = {
  __typename?: 'WorkItemSavedViewType';
  /** Description of the saved view. */
  description?: Maybe<Scalars['String']['output']>;
  /** Display settings associated with the saved view. */
  displaySettings?: Maybe<Scalars['JSON']['output']>;
  /** Warnings associated with the filter values. */
  filterWarnings?: Maybe<Array<WorkItemSavedViewFilterWarningType>>;
  /** Filters associated with the saved view. */
  filters?: Maybe<Scalars['JSON']['output']>;
  /** ID of the saved view. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['output'];
  /** Name of the saved view. */
  name: Scalars['String']['output'];
  /** ID of the namespace of the saved view. */
  namespaceId: Scalars['TypesNamespaceID']['output'];
  /** Whether the saved view is private. */
  private: Scalars['Boolean']['output'];
  /** URL to auto subscribe users to the view. */
  shareUrl: Scalars['String']['output'];
  /** Sort option associated with the saved view. */
  sort?: Maybe<WorkItemSort>;
  /**
   * Work items associated with the saved view. Introduced in GitLab 18.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.7.
   */
  workItems?: Maybe<WorkItemConnection>;
};


export type WorkItemSavedViewTypeWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for WorkItemSavedViewType. */
export type WorkItemSavedViewTypeConnection = {
  __typename?: 'WorkItemSavedViewTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemSavedViewTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemSavedViewType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemSavedViewTypeEdge = {
  __typename?: 'WorkItemSavedViewTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemSavedViewType>;
};

export type WorkItemSavedViewUnionedFilterInput = {
  /** Filter value for unioned assignee usernames filter. (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for unioned author usernames filter. (maximum is 100 usernames). */
  authorUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter value for unioned custom field filter. */
  customField?: InputMaybe<Array<WorkItemWidgetCustomFieldFilterInputType>>;
  /** Filter value for unioned label names filter.(maximum is 100 labels). */
  labelNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated input type of WorkItemSavedViewUnsubscribe */
export type WorkItemSavedViewUnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the saved view to unsubscribe to. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['input'];
};

/** Autogenerated return type of WorkItemSavedViewUnsubscribe. */
export type WorkItemSavedViewUnsubscribePayload = {
  __typename?: 'WorkItemSavedViewUnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Unsubscribed saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

/** Autogenerated input type of WorkItemSavedViewUpdate */
export type WorkItemSavedViewUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the saved view. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Display settings associated with the saved view. */
  displaySettings?: InputMaybe<Scalars['JSON']['input']>;
  /** Filters associated with the saved view. */
  filters?: InputMaybe<WorkItemSavedViewFilterInput>;
  /** Global ID of the saved view. */
  id: Scalars['WorkItemsSavedViewsSavedViewID']['input'];
  /** Name of the saved view. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Whether the saved view is private. */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /** Sorting option associated with the saved view. */
  sort?: InputMaybe<WorkItemSort>;
};

/** Autogenerated return type of WorkItemSavedViewUpdate. */
export type WorkItemSavedViewUpdatePayload = {
  __typename?: 'WorkItemSavedViewUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated saved view. */
  savedView?: Maybe<WorkItemSavedViewType>;
};

export type WorkItemSelectFieldValue = WorkItemCustomFieldValue & {
  __typename?: 'WorkItemSelectFieldValue';
  /** Custom field associated with the custom field value. */
  customField: CustomField;
  /** Selected options of the custom field. */
  selectedOptions?: Maybe<Array<CustomFieldSelectOption>>;
};

/** Values for sorting work items */
export type WorkItemSort =
  /** Blocking items count by ascending order. */
  | 'BLOCKING_ISSUES_ASC'
  /** Blocking items count by descending order. */
  | 'BLOCKING_ISSUES_DESC'
  /** Closed time by ascending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'CLOSED_AT_ASC'
  /** Closed time by descending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'CLOSED_AT_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Due date by ascending order. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'DUE_DATE_ASC'
  /** Due date by descending order. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'DUE_DATE_DESC'
  /** Status from triggered to resolved. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'ESCALATION_STATUS_ASC'
  /** Status from resolved to triggered. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'ESCALATION_STATUS_DESC'
  /** Health status by ascending order. Introduced in GitLab 17.11: **Status**: Experiment. */
  | 'HEALTH_STATUS_ASC'
  /** Health status by descending order. Introduced in GitLab 17.11: **Status**: Experiment. */
  | 'HEALTH_STATUS_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** Number of upvotes (awarded "thumbs up" emoji) by ascending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'POPULARITY_ASC'
  /** Number of upvotes (awarded "thumbs up" emoji) by descending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'POPULARITY_DESC'
  /** Priority by ascending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'PRIORITY_DESC'
  /** Relative position by ascending order. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'RELATIVE_POSITION_ASC'
  /** Severity from less critical to more critical. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'SEVERITY_ASC'
  /** Severity from more critical to less critical. Introduced in GitLab 17.10: **Status**: Experiment. */
  | 'SEVERITY_DESC'
  /** Start date by ascending order. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'START_DATE_ASC'
  /** Start date by descending order. Introduced in GitLab 17.9: **Status**: Experiment. */
  | 'START_DATE_DESC'
  /** Status by ascending order. Introduced in GitLab 18.3: **Status**: Experiment. */
  | 'STATUS_ASC'
  /** Status by descending order. Introduced in GitLab 18.3: **Status**: Experiment. */
  | 'STATUS_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Weight by ascending order. Introduced in GitLab 17.11: **Status**: Experiment. */
  | 'WEIGHT_ASC'
  /** Weight by descending order. Introduced in GitLab 17.11: **Status**: Experiment. */
  | 'WEIGHT_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** State of a GitLab work item */
export type WorkItemState =
  /** In closed state. */
  | 'CLOSED'
  /** In open state. */
  | 'OPEN';

/** Represents total number of work items for the represented states */
export type WorkItemStateCountsType = {
  __typename?: 'WorkItemStateCountsType';
  /** Number of work items for the project or group. */
  all?: Maybe<Scalars['Int']['output']>;
  /** Number of work items with state CLOSED for the project or group. */
  closed?: Maybe<Scalars['Int']['output']>;
  /** Number of work items with state OPENED for the project or group. */
  opened?: Maybe<Scalars['Int']['output']>;
};

/** Values for work item state events */
export type WorkItemStateEvent =
  /** Closes the work item. */
  | 'CLOSE'
  /** Reopens the work item. */
  | 'REOPEN';

/** Represents status */
export type WorkItemStatus = {
  __typename?: 'WorkItemStatus';
  /**
   * Category of the status. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  category?: Maybe<WorkItemStatusCategoryEnum>;
  /**
   * Color of the status. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  color?: Maybe<Scalars['String']['output']>;
  /**
   * Description of the status. Introduced in GitLab 18.1: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.1.
   */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Icon name of the status. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  iconName?: Maybe<Scalars['String']['output']>;
  /**
   * ID of the status. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  id?: Maybe<Scalars['GlobalID']['output']>;
  /**
   * Name of the status. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Position of the status within its category. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  position?: Maybe<Scalars['Int']['output']>;
};

/** Category of the work item status */
export type WorkItemStatusCategoryEnum =
  /** Canceled status category */
  | 'CANCELED'
  /** Done status category */
  | 'DONE'
  /** In progress status category */
  | 'IN_PROGRESS'
  /** To do status category */
  | 'TO_DO'
  /** Triage status category */
  | 'TRIAGE';

/** The connection type for WorkItemStatus. */
export type WorkItemStatusConnection = {
  __typename?: 'WorkItemStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a status with its work item count */
export type WorkItemStatusCount = {
  __typename?: 'WorkItemStatusCount';
  /**
   * Work item count for the status. Shows "999+" when count exceeds 999. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  count?: Maybe<Scalars['String']['output']>;
  /**
   * Status of the work items. Introduced in GitLab 18.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.4.
   */
  status: WorkItemStatus;
};

/** An edge in a connection. */
export type WorkItemStatusEdge = {
  __typename?: 'WorkItemStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemStatus>;
};

export type WorkItemStatusInput = {
  /** Category of the status. */
  category?: InputMaybe<WorkItemStatusCategoryEnum>;
  /** Color of the status. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** Description of the status. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** ID of the status. If not provided, a new status will be created. */
  id?: InputMaybe<Scalars['GlobalID']['input']>;
  /** Name of the status. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of WorkItemSubscribe */
export type WorkItemSubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Desired state of the subscription. */
  subscribed: Scalars['Boolean']['input'];
};

/** Autogenerated return type of WorkItemSubscribe. */
export type WorkItemSubscribePayload = {
  __typename?: 'WorkItemSubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Work item after mutation. */
  workItem?: Maybe<WorkItem>;
};

/** Values for work item subscription events */
export type WorkItemSubscriptionEvent =
  /** Subscribe to a work item. */
  | 'SUBSCRIBE'
  /** Unsubscribe from a work item. */
  | 'UNSUBSCRIBE';

export type WorkItemTextFieldValue = WorkItemCustomFieldValue & {
  __typename?: 'WorkItemTextFieldValue';
  /** Custom field associated with the custom field value. */
  customField: CustomField;
  /** Text value of the custom field. */
  value?: Maybe<Scalars['String']['output']>;
};

export type WorkItemTimelog = {
  __typename?: 'WorkItemTimelog';
  /** Internal ID of the timelog. */
  id: Scalars['ID']['output'];
  /** Note where the quick action was executed to add the logged time. */
  note?: Maybe<Note>;
  /** Timestamp of when the time tracked was spent at. */
  spentAt?: Maybe<Scalars['Time']['output']>;
  /** Summary of how the time was spent. */
  summary?: Maybe<Scalars['String']['output']>;
  /** Time spent displayed in seconds. */
  timeSpent: Scalars['Int']['output'];
  /** User that logged the time. */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: TimelogPermissions;
};

/** The connection type for WorkItemTimelog. */
export type WorkItemTimelogConnection = {
  __typename?: 'WorkItemTimelogConnection';
  /** Total count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemTimelogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemTimelog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total time spent in seconds. */
  totalSpentTime: Scalars['BigInt']['output'];
};


/** The connection type for WorkItemTimelog. */
export type WorkItemTimelogConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type WorkItemTimelogEdge = {
  __typename?: 'WorkItemTimelogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemTimelog>;
};

/** Values for work item to-do update enum */
export type WorkItemTodoUpdateAction =
  /** Adds the to-do. */
  | 'ADD'
  /** Marks the to-do as done. */
  | 'MARK_AS_DONE';

export type WorkItemType = {
  __typename?: 'WorkItemType';
  /** Icon name of the work item type. */
  iconName?: Maybe<Scalars['String']['output']>;
  /** Global ID of the work item type. */
  id: Scalars['WorkItemsTypeID']['output'];
  /** Name of the work item type. */
  name: Scalars['String']['output'];
  /**
   * Supported conversion types for the work item type. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  supportedConversionTypes?: Maybe<Array<WorkItemType>>;
  /** Widgets that will be lost when converting from source work item type to target work item type. */
  unavailableWidgetsOnConversion?: Maybe<Array<WorkItemWidgetDefinition>>;
  /**
   * Available widgets for the work item type. Introduced in GitLab 16.7: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.7.
   */
  widgetDefinitions?: Maybe<Array<WorkItemWidgetDefinition>>;
};


export type WorkItemTypeUnavailableWidgetsOnConversionArgs = {
  target: Scalars['WorkItemsTypeID']['input'];
};

/** The connection type for WorkItemType. */
export type WorkItemTypeConnection = {
  __typename?: 'WorkItemTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents work item counts for the work item type */
export type WorkItemTypeCountsByState = {
  __typename?: 'WorkItemTypeCountsByState';
  /** Total number of work items for the represented states. */
  countsByState: WorkItemStateCountsType;
  /** Work item type. */
  workItemType: WorkItemType;
};

/** Represents Depth limit reached for the allowed work item type. */
export type WorkItemTypeDepthLimitReachedByType = {
  __typename?: 'WorkItemTypeDepthLimitReachedByType';
  /** Indicates if maximum allowed depth has been reached for the descendant type. */
  depthLimitReached: Scalars['Boolean']['output'];
  /** Work item type. */
  workItemType: WorkItemType;
};

/** An edge in a connection. */
export type WorkItemTypeEdge = {
  __typename?: 'WorkItemTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemType>;
};

export type WorkItemTypesUserPreference = {
  __typename?: 'WorkItemTypesUserPreference';
  /** Display settings for the work item lists. */
  displaySettings?: Maybe<Scalars['JSON']['output']>;
  /** Namespace for the user preference. */
  namespace: Namespace;
  /** Sort order for work item lists. */
  sort?: Maybe<WorkItemSort>;
  /** Type assigned to the work item. */
  workItemType?: Maybe<WorkItemType>;
};

/** Autogenerated input type of WorkItemUpdate */
export type WorkItemUpdateInput = {
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** Input for emoji reactions widget. */
  awardEmojiWidget?: InputMaybe<WorkItemWidgetAwardEmojiUpdateInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Input for color widget. */
  colorWidget?: InputMaybe<WorkItemWidgetColorInput>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Input for CRM contacts widget. */
  crmContactsWidget?: InputMaybe<WorkItemWidgetCrmContactsUpdateInput>;
  /** Input for to-dos widget. */
  currentUserTodosWidget?: InputMaybe<WorkItemWidgetCurrentUserTodosInput>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Input for health status widget. */
  healthStatusWidget?: InputMaybe<WorkItemWidgetHealthStatusInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyUpdateInput>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID']['input'];
  /** Input for iteration widget. */
  iterationWidget?: InputMaybe<WorkItemWidgetIterationInput>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Input for notes widget. */
  notesWidget?: InputMaybe<WorkItemWidgetNotesInput>;
  /** Input for notifications widget. */
  notificationsWidget?: InputMaybe<WorkItemWidgetNotificationsUpdateInput>;
  /** Input for progress widget. */
  progressWidget?: InputMaybe<WorkItemWidgetProgressInput>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Close or reopen a work item. */
  stateEvent?: InputMaybe<WorkItemStateEvent>;
  /** Input for time tracking widget. */
  timeTrackingWidget?: InputMaybe<WorkItemWidgetTimeTrackingInput>;
  /** Title of the work item. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Input for verification status widget. */
  verificationStatusWidget?: InputMaybe<VerificationStatusInput>;
  /** Input for weight widget. */
  weightWidget?: InputMaybe<WorkItemWidgetWeightInput>;
};

/** Autogenerated return type of WorkItemUpdate. */
export type WorkItemUpdatePayload = {
  __typename?: 'WorkItemUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemUserPreferenceUpdate */
export type WorkItemUserPreferenceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Display settings for the work item lists. */
  displaySettings?: InputMaybe<Scalars['JSON']['input']>;
  /** Full path of the namespace on which the preference is set. */
  namespacePath: Scalars['ID']['input'];
  /** Sort order for work item lists. */
  sort?: InputMaybe<WorkItemSort>;
  /** Global ID of a work item type. */
  workItemTypeId?: InputMaybe<Scalars['WorkItemsTypeID']['input']>;
};

/** Autogenerated return type of WorkItemUserPreferenceUpdate. */
export type WorkItemUserPreferenceUpdatePayload = {
  __typename?: 'WorkItemUserPreferenceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** User preferences. */
  userPreferences?: Maybe<WorkItemTypesUserPreference>;
};

export type WorkItemWidget = {
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents an assignees widget */
export type WorkItemWidgetAssignees = WorkItemWidget & {
  __typename?: 'WorkItemWidgetAssignees';
  /**
   * Indicates whether multiple assignees are allowed. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface.
   * @deprecated Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.allowsMultipleAssignees`. Deprecated in GitLab 16.7.
   */
  allowsMultipleAssignees?: Maybe<Scalars['Boolean']['output']>;
  /** Assignees of the work item. */
  assignees?: Maybe<UserCoreConnection>;
  /**
   * Indicates whether the current user can invite members to the work item's project. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface.
   * @deprecated Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.canInviteMembers`. Deprecated in GitLab 16.7.
   */
  canInviteMembers: Scalars['Boolean']['output'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents an assignees widget */
export type WorkItemWidgetAssigneesAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetAssigneesInput = {
  /** Global IDs of assignees. */
  assigneeIds: Array<Scalars['UserID']['input']>;
};

/** Represents the emoji reactions widget */
export type WorkItemWidgetAwardEmoji = WorkItemWidget & {
  __typename?: 'WorkItemWidgetAwardEmoji';
  /** Emoji reactions on the work item. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Number of downvotes the work item has received. */
  downvotes: Scalars['Int']['output'];
  /** Path to create a new custom emoji. */
  newCustomEmojiPath?: Maybe<Scalars['String']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Number of upvotes the work item has received. */
  upvotes: Scalars['Int']['output'];
};


/** Represents the emoji reactions widget */
export type WorkItemWidgetAwardEmojiAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetAwardEmojiUpdateInput = {
  /** Action for the update. */
  action: WorkItemAwardEmojiUpdateAction;
  /** Emoji name. */
  name: Scalars['String']['input'];
};

/** Represents a color widget */
export type WorkItemWidgetColor = WorkItemWidget & {
  __typename?: 'WorkItemWidgetColor';
  /** Color of the Work Item. */
  color?: Maybe<Scalars['String']['output']>;
  /** Text color generated for the Work Item. */
  textColor?: Maybe<Scalars['String']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetColorInput = {
  /** Color of the work item. */
  color: Scalars['Color']['input'];
};

/** Represents CRM contacts widget */
export type WorkItemWidgetCrmContacts = WorkItemWidget & {
  __typename?: 'WorkItemWidgetCrmContacts';
  /** Collection of CRM contacts associated with the work item. */
  contacts?: Maybe<CustomerRelationsContactConnection>;
  /** Indicates whether contacts are available to be associated with the work item. */
  contactsAvailable: Scalars['Boolean']['output'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents CRM contacts widget */
export type WorkItemWidgetCrmContactsContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetCrmContactsCreateInput = {
  /** CRM contact IDs to set. */
  contactIds: Array<Scalars['CustomerRelationsContactID']['input']>;
};

export type WorkItemWidgetCrmContactsUpdateInput = {
  /** CRM contact IDs to set. Replaces existing contacts by default. */
  contactIds: Array<Scalars['CustomerRelationsContactID']['input']>;
  /** Set the operation mode. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Represents a todos widget */
export type WorkItemWidgetCurrentUserTodos = CurrentUserTodos & WorkItemWidget & {
  __typename?: 'WorkItemWidgetCurrentUserTodos';
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a todos widget */
export type WorkItemWidgetCurrentUserTodosCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<TodoStateEnum>;
};

export type WorkItemWidgetCurrentUserTodosInput = {
  /** Action for the update. */
  action: WorkItemTodoUpdateAction;
  /** Global ID of the to-do. If not present, all to-dos of the work item will be updated. */
  todoId?: InputMaybe<Scalars['TodoID']['input']>;
};

export type WorkItemWidgetCustomFieldFilterInputType = {
  /** Global ID of the custom field. */
  customFieldId?: InputMaybe<Scalars['IssuablesCustomFieldID']['input']>;
  /** Name of the custom field. */
  customFieldName?: InputMaybe<Scalars['String']['input']>;
  /** Global IDs of the selected options for custom fields with select type (maximum is 100 IDs). */
  selectedOptionIds?: InputMaybe<Array<Scalars['IssuablesCustomFieldSelectOptionID']['input']>>;
  /** Values of the selected options for custom fields with select type (maximum is 100 values). */
  selectedOptionValues?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type WorkItemWidgetCustomFieldValueInputType = {
  /** Global ID of the custom field. */
  customFieldId: Scalars['IssuablesCustomFieldID']['input'];
  /** Value for custom fields with date type. */
  dateValue?: InputMaybe<Scalars['Date']['input']>;
  /** Value for custom fields with number type. */
  numberValue?: InputMaybe<Scalars['Float']['input']>;
  /** Global IDs of the selected options for custom fields with select type. */
  selectedOptionIds?: InputMaybe<Array<Scalars['IssuablesCustomFieldSelectOptionID']['input']>>;
  /** Value for custom fields with text type. */
  textValue?: InputMaybe<Scalars['String']['input']>;
};

/** Represents a custom fields widget */
export type WorkItemWidgetCustomFields = WorkItemWidget & {
  __typename?: 'WorkItemWidgetCustomFields';
  /**
   * Custom field values associated to the work item. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  customFieldValues?: Maybe<Array<WorkItemCustomFieldValue>>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a custom fields widget */
export type WorkItemWidgetCustomFieldsCustomFieldValuesArgs = {
  customFieldIds?: InputMaybe<Array<Scalars['IssuablesCustomFieldID']['input']>>;
};

export type WorkItemWidgetDefinition = {
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents an assignees widget definition */
export type WorkItemWidgetDefinitionAssignees = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionAssignees';
  /** Indicates whether multiple assignees are allowed. */
  allowsMultipleAssignees: Scalars['Boolean']['output'];
  /** Indicates whether the current user can invite members to the work item's parent. */
  canInviteMembers: Scalars['Boolean']['output'];
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a custom fields widget definition */
export type WorkItemWidgetDefinitionCustomFields = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionCustomFields';
  /**
   * Custom field values associated to the work item. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  customFieldValues?: Maybe<Array<WorkItemCustomFieldValue>>;
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a generic widget definition */
export type WorkItemWidgetDefinitionGeneric = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionGeneric';
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a hierarchy widget definition */
export type WorkItemWidgetDefinitionHierarchy = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionHierarchy';
  /** Allowed child types for the work item type. */
  allowedChildTypes?: Maybe<WorkItemTypeConnection>;
  /** Allowed parent types for the work item type. */
  allowedParentTypes?: Maybe<WorkItemTypeConnection>;
  /** Widget type. */
  type: WorkItemWidgetType;
};


/** Represents a hierarchy widget definition */
export type WorkItemWidgetDefinitionHierarchyAllowedChildTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a hierarchy widget definition */
export type WorkItemWidgetDefinitionHierarchyAllowedParentTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a labels widget definition */
export type WorkItemWidgetDefinitionLabels = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionLabels';
  /** Indicates whether scoped labels are available. */
  allowsScopedLabels: Scalars['Boolean']['output'];
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a Status widget definition */
export type WorkItemWidgetDefinitionStatus = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionStatus';
  /**
   * Allowed statuses for the work item type. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  allowedStatuses?: Maybe<Array<WorkItemStatus>>;
  /**
   * Default status for the `Closed` state for given work item type. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  defaultClosedStatus?: Maybe<WorkItemStatus>;
  /**
   * Default status for the `Open` state for given work item type. Introduced in GitLab 18.0: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 18.0.
   */
  defaultOpenStatus?: Maybe<WorkItemStatus>;
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a weight widget definition */
export type WorkItemWidgetDefinitionWeight = WorkItemWidgetDefinition & {
  __typename?: 'WorkItemWidgetDefinitionWeight';
  /** Indicates whether editable weight is available. */
  editable: Scalars['Boolean']['output'];
  /** Indicates whether rolled up weight is available. */
  rollUp: Scalars['Boolean']['output'];
  /** Widget type. */
  type: WorkItemWidgetType;
};

/** Represents a description widget */
export type WorkItemWidgetDescription = WorkItemWidget & {
  __typename?: 'WorkItemWidgetDescription';
  /** Description of the work item. */
  description?: Maybe<Scalars['String']['output']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']['output']>;
  /** Whether the description has been edited since the work item was created. */
  edited: Scalars['Boolean']['output'];
  /** Timestamp of when the work item's description was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']['output']>;
  /** User that made the last edit to the work item's description. */
  lastEditedBy?: Maybe<UserCore>;
  /** Task completion status of the work item. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetDescriptionInput = {
  /** Description of the work item. */
  description: Scalars['String']['input'];
};

/** Represents designs widget */
export type WorkItemWidgetDesigns = WorkItemWidget & {
  __typename?: 'WorkItemWidgetDesigns';
  /** Collection of design images associated with the issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents a development widget */
export type WorkItemWidgetDevelopment = WorkItemWidget & {
  __typename?: 'WorkItemWidgetDevelopment';
  /** Merge requests that will close the work item when merged. */
  closingMergeRequests?: Maybe<WorkItemClosingMergeRequestConnection>;
  /** Feature flags associated with the work item. */
  featureFlags?: Maybe<FeatureFlagConnection>;
  /** Branches that have referred to the work item, but do not have an associated merge request. */
  relatedBranches?: Maybe<WorkItemRelatedBranchConnection>;
  /**
   * Merge requests where the work item has been mentioned. This field can only be resolved for one work item in any single request. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  relatedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Whether the work item will automatically be closed when a closing merge request is merged. */
  willAutoCloseByMergeRequest: Scalars['Boolean']['output'];
};


/** Represents a development widget */
export type WorkItemWidgetDevelopmentClosingMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a development widget */
export type WorkItemWidgetDevelopmentFeatureFlagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a development widget */
export type WorkItemWidgetDevelopmentRelatedBranchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a development widget */
export type WorkItemWidgetDevelopmentRelatedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents email participants widget */
export type WorkItemWidgetEmailParticipants = WorkItemWidget & {
  __typename?: 'WorkItemWidgetEmailParticipants';
  /** Collection of email participants associated with the work item. */
  emailParticipants?: Maybe<EmailParticipantTypeConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents email participants widget */
export type WorkItemWidgetEmailParticipantsEmailParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the error tracking widget */
export type WorkItemWidgetErrorTracking = WorkItemWidget & {
  __typename?: 'WorkItemWidgetErrorTracking';
  /** Error tracking issue id.This field can only be resolved for one work item in any single request. */
  identifier?: Maybe<Scalars['BigInt']['output']>;
  /** Stack trace details of the error.This field can only be resolved for one work item in any single request. */
  stackTrace?: Maybe<ErrorTrackingStackTraceConnection>;
  /** Response status of error service.This field can only be resolved for one work item in any single request. */
  status?: Maybe<ErrorTrackingStatus>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the error tracking widget */
export type WorkItemWidgetErrorTrackingStackTraceArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents details about a line of code of the stack trace */
export type WorkItemWidgetErrorTrackingStackTraceContext = {
  __typename?: 'WorkItemWidgetErrorTrackingStackTraceContext';
  /** Line of code. */
  line?: Maybe<Scalars['String']['output']>;
  /** Line number of code. */
  lineNumber?: Maybe<Scalars['Int']['output']>;
};

/** Represents a health status widget */
export type WorkItemWidgetHealthStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetHealthStatus';
  /** Health status of the work item. */
  healthStatus?: Maybe<HealthStatus>;
  /**
   * Rolled up health status of the work item. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  rolledUpHealthStatus?: Maybe<Array<WorkItemWidgetHealthStatusCount>>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents work item counts for the health status */
export type WorkItemWidgetHealthStatusCount = {
  __typename?: 'WorkItemWidgetHealthStatusCount';
  /** Number of work items with the health status. */
  count: Scalars['Int']['output'];
  /** Health status of the work items. */
  healthStatus: HealthStatus;
};

export type WorkItemWidgetHealthStatusInput = {
  /** Health status to be assigned to the work item. */
  healthStatus?: InputMaybe<HealthStatus>;
};

/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchy = WorkItemWidget & {
  __typename?: 'WorkItemWidgetHierarchy';
  /** Ancestors (parents) of the work item. */
  ancestors?: Maybe<WorkItemConnection>;
  /** Child work items. */
  children?: Maybe<WorkItemConnection>;
  /**
   * Depth limit reached by allowed work item type. Introduced in GitLab 17.4: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.4.
   */
  depthLimitReachedByType: Array<WorkItemTypeDepthLimitReachedByType>;
  /** Indicates if the work item has children. */
  hasChildren: Scalars['Boolean']['output'];
  /** Indicates if the work item has a parent. */
  hasParent: Scalars['Boolean']['output'];
  /** Parent work item. */
  parent?: Maybe<WorkItem>;
  /**
   * Counts of descendant work items by work item type and state. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  rolledUpCountsByType: Array<WorkItemTypeCountsByState>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchyAncestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchyChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<WorkItemState>;
};

export type WorkItemWidgetHierarchyCreateInput = {
  /** Global ID of the parent work item. */
  parentId?: InputMaybe<Scalars['WorkItemID']['input']>;
};

export type WorkItemWidgetHierarchyUpdateInput = {
  /** ID of the work item to be switched with. */
  adjacentWorkItemId?: InputMaybe<Scalars['WorkItemID']['input']>;
  /** Global IDs of children work items. */
  childrenIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** Global ID of the parent work item. Use `null` to remove the association. */
  parentId?: InputMaybe<Scalars['WorkItemID']['input']>;
  /** Type of switch. Valid values are `BEFORE` or `AFTER`. */
  relativePosition?: InputMaybe<RelativePositionType>;
};

/** Represents an iteration widget */
export type WorkItemWidgetIteration = WorkItemWidget & {
  __typename?: 'WorkItemWidgetIteration';
  /** Iteration of the work item. */
  iteration?: Maybe<Iteration>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetIterationInput = {
  /** Iteration to assign to the work item. */
  iterationId?: InputMaybe<Scalars['IterationID']['input']>;
};

/** Represents the labels widget */
export type WorkItemWidgetLabels = WorkItemWidget & {
  __typename?: 'WorkItemWidgetLabels';
  /**
   * Indicates whether a scoped label is allowed. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface.
   * @deprecated Field moved to workItemType widget definition interface. Please use `WorkItemWidgetDefinitionLabels.allowsScopedLabels`. Deprecated in GitLab 16.7.
   */
  allowsScopedLabels?: Maybe<Scalars['Boolean']['output']>;
  /** Labels assigned to the work item. */
  labels?: Maybe<LabelConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the labels widget */
export type WorkItemWidgetLabelsLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetLabelsCreateInput = {
  /** IDs of labels to be added to the work item. */
  labelIds: Array<Scalars['LabelID']['input']>;
};

export type WorkItemWidgetLabelsUpdateInput = {
  /** Global IDs of labels to be added to the work item. */
  addLabelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
  /** Global IDs of labels to be removed from the work item. */
  removeLabelIds?: InputMaybe<Array<Scalars['LabelID']['input']>>;
};

/** Represents the linked items widget */
export type WorkItemWidgetLinkedItems = WorkItemWidget & {
  __typename?: 'WorkItemWidgetLinkedItems';
  /** Indicates the work item is blocked. */
  blocked?: Maybe<Scalars['Boolean']['output']>;
  /** Count of items blocking the work item. */
  blockedByCount?: Maybe<Scalars['Int']['output']>;
  /** Count of items the work item is blocking. */
  blockingCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Linked items for the work item. Introduced in GitLab 16.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 16.3.
   */
  linkedItems?: Maybe<LinkedWorkItemTypeConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the linked items widget */
export type WorkItemWidgetLinkedItemsLinkedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<WorkItemRelatedLinkType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetLinkedItemsCreateInput = {
  /** Type of link. Defaults to `RELATED`. */
  linkType?: InputMaybe<WorkItemRelatedLinkType>;
  /** Global IDs of the items to link. Maximum number of IDs you can provide: 10. */
  workItemsIds: Array<Scalars['WorkItemID']['input']>;
};

/** Represents the linked resources widget */
export type WorkItemWidgetLinkedResources = WorkItemWidget & {
  __typename?: 'WorkItemWidgetLinkedResources';
  /** Resources for the work item. */
  linkedResources?: Maybe<WorkItemLinkedResourceConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the linked resources widget */
export type WorkItemWidgetLinkedResourcesLinkedResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a milestone widget */
export type WorkItemWidgetMilestone = WorkItemWidget & {
  __typename?: 'WorkItemWidgetMilestone';
  /** Milestone of the work item. */
  milestone?: Maybe<Milestone>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetMilestoneInput = {
  /** Milestone to assign to the work item. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']['input']>;
};

/** Represents a notes widget */
export type WorkItemWidgetNotes = WorkItemWidget & {
  __typename?: 'WorkItemWidgetNotes';
  /** Discussion lock attribute of the work item. */
  discussionLocked?: Maybe<Scalars['Boolean']['output']>;
  /** Discussions on this work item. */
  discussions?: Maybe<DiscussionConnection>;
  /** Notes on this work item. */
  notes: NoteConnection;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a notes widget */
export type WorkItemWidgetNotesDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<WorkItemDiscussionsSort>;
};


/** Represents a notes widget */
export type WorkItemWidgetNotesNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkItemWidgetNotesInput = {
  /** Discussion lock attribute for notes widget of the work item. */
  discussionLocked: Scalars['Boolean']['input'];
};

/** Represents the notifications widget */
export type WorkItemWidgetNotifications = WorkItemWidget & {
  __typename?: 'WorkItemWidgetNotifications';
  /** Whether the current user is subscribed to notifications on the work item. */
  subscribed: Scalars['Boolean']['output'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetNotificationsUpdateInput = {
  /** Desired state of the subscription. */
  subscribed: Scalars['Boolean']['input'];
};

/** Represents a participants widget */
export type WorkItemWidgetParticipants = WorkItemWidget & {
  __typename?: 'WorkItemWidgetParticipants';
  /** Participants in the work item. */
  participants?: Maybe<UserCoreConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a participants widget */
export type WorkItemWidgetParticipantsParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a progress widget */
export type WorkItemWidgetProgress = WorkItemWidget & {
  __typename?: 'WorkItemWidgetProgress';
  /** Current value of the work item. */
  currentValue?: Maybe<Scalars['Int']['output']>;
  /** End value of the work item. */
  endValue?: Maybe<Scalars['Int']['output']>;
  /** Progress of the work item. */
  progress?: Maybe<Scalars['Int']['output']>;
  /** Start value of the work item. */
  startValue?: Maybe<Scalars['Int']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Timestamp of last progress update. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

export type WorkItemWidgetProgressInput = {
  /** Current progress value of the work item. */
  currentValue: Scalars['Int']['input'];
  /** End value of the work item. */
  endValue?: InputMaybe<Scalars['Int']['input']>;
  /** Start value of the work item. */
  startValue?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a legacy requirement widget */
export type WorkItemWidgetRequirementLegacy = WorkItemWidget & {
  __typename?: 'WorkItemWidgetRequirementLegacy';
  /**
   * Legacy requirement IID associated with the work item. Deprecated in GitLab 15.9: Use Work Item IID instead.
   * @deprecated Use Work Item IID instead. Deprecated in GitLab 15.9.
   */
  legacyIid?: Maybe<Scalars['Int']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents a start and due date widget */
export type WorkItemWidgetStartAndDueDate = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStartAndDueDate';
  /** Due date of the work item. */
  dueDate?: Maybe<Scalars['Date']['output']>;
  /** Indicates which milestone sources the rolled up due date. */
  dueDateSourcingMilestone?: Maybe<Milestone>;
  /** Indicates which work_item sources the rolled up due date. */
  dueDateSourcingWorkItem?: Maybe<WorkItem>;
  /** Indicates if the work item is using fixed dates. */
  isFixed: Scalars['Boolean']['output'];
  /** Indicates if the work item can use rolled up dates. */
  rollUp: Scalars['Boolean']['output'];
  /** Start date of the work item. */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Indicates which milestone sources the rolled up start date. */
  startDateSourcingMilestone?: Maybe<Milestone>;
  /** Indicates which work_item sources the rolled up start date. */
  startDateSourcingWorkItem?: Maybe<WorkItem>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetStartAndDueDateUpdateInput = {
  /** Due date for the work item. */
  dueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Indicates if the work item is using fixed dates. */
  isFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Start date for the work item. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Represents status widget */
export type WorkItemWidgetStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStatus';
  /**
   * Status assigned to work item. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  status?: Maybe<WorkItemStatus>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetStatusFilterInput = {
  /** Global ID of the status. */
  id?: InputMaybe<Scalars['WorkItemsStatusesStatusID']['input']>;
  /** Name of the status. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type WorkItemWidgetStatusInput = {
  /** Global ID of the status. */
  status?: InputMaybe<Scalars['WorkItemsStatusesStatusID']['input']>;
};

/** Represents a test reports widget */
export type WorkItemWidgetTestReports = WorkItemWidget & {
  __typename?: 'WorkItemWidgetTestReports';
  /** Test reports of the work item. */
  testReports?: Maybe<TestReportConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a test reports widget */
export type WorkItemWidgetTestReportsTestReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the time tracking widget on the work item */
export type WorkItemWidgetTimeTracking = WorkItemWidget & {
  __typename?: 'WorkItemWidgetTimeTracking';
  /** Human-readable attributes of the work item. */
  humanReadableAttributes?: Maybe<WorkItemWidgetTimeTrackingHumanReadableAttributes>;
  /** Time estimate of the work item. */
  timeEstimate?: Maybe<Scalars['Int']['output']>;
  /** Timelogs on the work item. */
  timelogs?: Maybe<WorkItemTimelogConnection>;
  /** Total time (in seconds) reported as spent on the work item. */
  totalTimeSpent?: Maybe<Scalars['Int']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the time tracking widget on the work item */
export type WorkItemWidgetTimeTrackingTimelogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a time tracking human readable attributes */
export type WorkItemWidgetTimeTrackingHumanReadableAttributes = {
  __typename?: 'WorkItemWidgetTimeTrackingHumanReadableAttributes';
  /** Human-readable time estimate of the work item. */
  timeEstimate?: Maybe<Scalars['String']['output']>;
  /** Human-readable total time reported as spent on the work item. */
  totalTimeSpent?: Maybe<Scalars['String']['output']>;
};

export type WorkItemWidgetTimeTrackingInput = {
  /** Time estimate for the work item in human readable format. For example: 1h 30m. */
  timeEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Timelog data for time spent on the work item. */
  timelog?: InputMaybe<WorkItemWidgetTimeTrackingTimelogInput>;
};

export type WorkItemWidgetTimeTrackingTimelogInput = {
  /** Timestamp of when the time tracked was spent at, if not provided would be set to current timestamp. */
  spentAt?: InputMaybe<Scalars['Time']['input']>;
  /** Summary of how the time was spent. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Amount of time spent in human readable format. For example: 1h 30m. */
  timeSpent: Scalars['String']['input'];
};

/** Type of a work item widget */
export type WorkItemWidgetType =
  /** Assignees widget. */
  | 'ASSIGNEES'
  /** Award Emoji widget. */
  | 'AWARD_EMOJI'
  /** Color widget. */
  | 'COLOR'
  /** Crm Contacts widget. */
  | 'CRM_CONTACTS'
  /** Current User Todos widget. */
  | 'CURRENT_USER_TODOS'
  /** Custom Fields widget. */
  | 'CUSTOM_FIELDS'
  /** Description widget. */
  | 'DESCRIPTION'
  /** Designs widget. */
  | 'DESIGNS'
  /** Development widget. */
  | 'DEVELOPMENT'
  /** Email Participants widget. */
  | 'EMAIL_PARTICIPANTS'
  /** Error Tracking widget. */
  | 'ERROR_TRACKING'
  /** Health Status widget. */
  | 'HEALTH_STATUS'
  /** Hierarchy widget. */
  | 'HIERARCHY'
  /** Iteration widget. */
  | 'ITERATION'
  /** Labels widget. */
  | 'LABELS'
  /** Linked Items widget. */
  | 'LINKED_ITEMS'
  /** Linked Resources widget. */
  | 'LINKED_RESOURCES'
  /** Milestone widget. */
  | 'MILESTONE'
  /** Notes widget. */
  | 'NOTES'
  /** Notifications widget. */
  | 'NOTIFICATIONS'
  /** Participants widget. */
  | 'PARTICIPANTS'
  /** Progress widget. */
  | 'PROGRESS'
  /** Requirement Legacy widget. */
  | 'REQUIREMENT_LEGACY'
  /** Start And Due Date widget. */
  | 'START_AND_DUE_DATE'
  /** Status widget. */
  | 'STATUS'
  /** Test Reports widget. */
  | 'TEST_REPORTS'
  /** Time Tracking widget. */
  | 'TIME_TRACKING'
  /** Verification Status widget. */
  | 'VERIFICATION_STATUS'
  /** Vulnerabilities widget. */
  | 'VULNERABILITIES'
  /** Weight widget. */
  | 'WEIGHT';

/** Represents a verification status widget */
export type WorkItemWidgetVerificationStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetVerificationStatus';
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /**
   * Verification status of the work item. Introduced in GitLab 15.5: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 15.5.
   */
  verificationStatus?: Maybe<Scalars['String']['output']>;
};

/** Represents a vulnerabilities widget */
export type WorkItemWidgetVulnerabilities = WorkItemWidget & {
  __typename?: 'WorkItemWidgetVulnerabilities';
  /**
   * Related vulnerabilities of the work item. Introduced in GitLab 17.10: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.10.
   */
  relatedVulnerabilities?: Maybe<CountableVulnerabilityConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a vulnerabilities widget */
export type WorkItemWidgetVulnerabilitiesRelatedVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a weight widget */
export type WorkItemWidgetWeight = WorkItemWidget & {
  __typename?: 'WorkItemWidgetWeight';
  /**
   * Rolled up weight from closed descendant work items. Introduced in GitLab 17.3: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.3.
   */
  rolledUpCompletedWeight?: Maybe<Scalars['Int']['output']>;
  /**
   * Rolled up weight from descendant work items. Introduced in GitLab 17.2: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.2.
   */
  rolledUpWeight?: Maybe<Scalars['Int']['output']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Weight of the work item. */
  weight?: Maybe<Scalars['Int']['output']>;
  /** Weight widget definition. */
  widgetDefinition?: Maybe<WorkItemWidgetDefinitionWeight>;
};

export type WorkItemWidgetWeightInput = {
  /** Weight of the work item. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of WorkItemsCsvExport */
export type WorkItemsCsvExportInput = {
  /** Usernames of users assigned to the work item (maximum is 100 usernames). */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by assignee wildcard. Incompatible with `assigneeUsernames`. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter work items by author username. */
  authorUsername?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Work items closed after the date. */
  closedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items closed before the date. */
  closedBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items. */
  confidential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Work items created after the timestamp. */
  createdAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items created before the timestamp. */
  createdBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter by ID of CRM contact. */
  crmContactId?: InputMaybe<Scalars['String']['input']>;
  /** Filter by ID of CRM contact organization. */
  crmOrganizationId?: InputMaybe<Scalars['String']['input']>;
  /** Work items due after the timestamp. */
  dueAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items due before the timestamp. */
  dueBefore?: InputMaybe<Scalars['Time']['input']>;
  /** Filter by global IDs of work items (maximum is 100 IDs). */
  ids?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** List of IIDs of work items. For example, `["1", "2"]` (maximum is 100 IIDs). */
  iids?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * Specify the fields to perform the search in.
   * Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
   *
   */
  in?: InputMaybe<Array<IssuableSearchableField>>;
  /** Labels applied to the work item (maximum is 100 labels). */
  labelName?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Milestone applied to the work item (maximum is 100 milestones). */
  milestoneTitle?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by milestone ID wildcard. Incompatible with `milestoneTitle`. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']['input']>;
  /** Negated work item arguments. */
  not?: InputMaybe<NegatedWorkItemFilterInput>;
  /** List of arguments with inclusive `OR`. */
  or?: InputMaybe<UnionedWorkItemFilterInput>;
  /** Filter work items by global IDs of their parent items (maximum is 100 IDs). */
  parentIds?: InputMaybe<Array<Scalars['WorkItemID']['input']>>;
  /** Full project path. */
  projectPath: Scalars['ID']['input'];
  /** Release tag associated with the work item's milestone (maximum is 100 tags). Ignored when parent is a group. */
  releaseTag?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filter by release tag wildcard. */
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  /** Search query for title or description. */
  search?: InputMaybe<Scalars['String']['input']>;
  /** List of selected fields to be exported. Omit to export all available fields. */
  selectedFields?: InputMaybe<Array<AvailableExportFields>>;
  /** Current state of the work item. */
  state?: InputMaybe<IssuableState>;
  /** Work items the current user is subscribed to. */
  subscribed?: InputMaybe<SubscriptionStatus>;
  /** Filter work items by the given work item types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Work items updated after the timestamp. */
  updatedAfter?: InputMaybe<Scalars['Time']['input']>;
  /** Work items updated before the timestamp. */
  updatedBefore?: InputMaybe<Scalars['Time']['input']>;
};

/** Autogenerated return type of WorkItemsCsvExport. */
export type WorkItemsCsvExportPayload = {
  __typename?: 'WorkItemsCsvExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Export request result message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of WorkItemsCsvImport */
export type WorkItemsCsvImportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** CSV file to import work items from. */
  file: Scalars['Upload']['input'];
  /** Full project path. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of WorkItemsCsvImport. */
export type WorkItemsCsvImportPayload = {
  __typename?: 'WorkItemsCsvImportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Import request result message. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Values for sorting saved views */
export type WorkItemsSavedViewsSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Ordered by id. */
  | 'ID'
  /** Relative position by ascending order. If user is logged out, or explicitly subscribed is not passed, falls back to id sort. */
  | 'RELATIVE_POSITION'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_asc'
  /** Created at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'created_desc'
  /** Updated at ascending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_asc'
  /** Updated at descending order. Deprecated in GitLab 13.5: This was renamed. */
  | 'updated_desc';

/** The environment of a workflow. */
export type WorkflowEnvironment =
  /** Ambient environment */
  | 'AMBIENT'
  /** Chat environment */
  | 'CHAT'
  /** Chat Partial environment */
  | 'CHAT_PARTIAL'
  /** Ide environment Deprecated in GitLab 18.6: This was renamed. */
  | 'IDE'
  /** Web environment Deprecated in GitLab 18.6: This was renamed. */
  | 'WEB';

/** Represents a remote development workspace */
export type Workspace = {
  __typename?: 'Workspace';
  /** Actual state of the workspace. */
  actualState: Scalars['String']['output'];
  /**
   * Timestamp of the last update to the actual state. Introduced in GitLab 17.11: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.11.
   */
  actualStateUpdatedAt: Scalars['Time']['output'];
  /** Kubernetes agent associated with the workspace. */
  clusterAgent: ClusterAgent;
  /** Timestamp of when the workspace was created. */
  createdAt: Scalars['Time']['output'];
  /** Version of the deployment resource for the workspace. */
  deploymentResourceVersion?: Maybe<Scalars['Int']['output']>;
  /** Desired state of the workspace. */
  desiredState: Scalars['String']['output'];
  /** Timestamp of the last update to the desired state. */
  desiredStateUpdatedAt: Scalars['Time']['output'];
  /** Source YAML of the devfile used to configure the workspace. */
  devfile: Scalars['String']['output'];
  /** Path to the devfile used to configure the workspace. */
  devfilePath?: Maybe<Scalars['String']['output']>;
  /**
   * Git reference that contains the devfile used to configure the workspace. Deprecated in GitLab 17.8: Field is renamed to project_ref.
   * @deprecated Field is renamed to project_ref. Deprecated in GitLab 17.8.
   */
  devfileRef: Scalars['String']['output'];
  /**
   * Web URL of the devfile used to configure the workspace. Deprecated in GitLab 17.8: Field is not used.
   * @deprecated Field is not used. Deprecated in GitLab 17.8.
   */
  devfileWebUrl?: Maybe<Scalars['String']['output']>;
  /**
   * Editor used to configure the workspace. Must match a configured template. Deprecated in GitLab 17.5: Field is not used.
   * @deprecated Field is not used. Deprecated in GitLab 17.5.
   */
  editor: Scalars['String']['output'];
  /**
   * Forces all resources to be included for the workspaceduring the next reconciliation with the agent. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  forceIncludeAllResources: Scalars['Boolean']['output'];
  /** Global ID of the workspace. */
  id: Scalars['RemoteDevelopmentWorkspaceID']['output'];
  /**
   * Number of hours until the workspace automatically terminates. Deprecated in GitLab 17.9: Field is not used.
   * @deprecated Field is not used. Deprecated in GitLab 17.9.
   */
  maxHoursBeforeTermination: Scalars['Int']['output'];
  /** Name of the workspace in Kubernetes. */
  name: Scalars['String']['output'];
  /** Namespace of the workspace in Kubernetes. */
  namespace: Scalars['String']['output'];
  /** Processed YAML of the devfile used to configure the workspace. */
  processedDevfile: Scalars['String']['output'];
  /** ID of the project that contains the devfile for the workspace. */
  projectId: Scalars['ID']['output'];
  /** Git reference that contains the devfile used to configure the workspace, and that will be cloned into the workspace */
  projectRef: Scalars['String']['output'];
  /** Timestamp of the last response sent to the GitLab agent for Kubernetes for the workspace. */
  respondedToAgentAt?: Maybe<Scalars['Time']['output']>;
  /** Timestamp of the last update to any mutable workspace property. */
  updatedAt: Scalars['Time']['output'];
  /** URL of the workspace. */
  url: Scalars['String']['output'];
  /** Owner of the workspace. */
  user: UserCore;
  /**
   * User defined variables associated with the workspace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  workspaceVariables?: Maybe<WorkspaceVariableConnection>;
  /**
   * Version of the associated WorkspacesAgentConfig for the workspace. Introduced in GitLab 17.6: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.6.
   */
  workspacesAgentConfigVersion: Scalars['Int']['output'];
};


/** Represents a remote development workspace */
export type WorkspaceWorkspaceVariablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Workspace. */
export type WorkspaceConnection = {
  __typename?: 'WorkspaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkspaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Workspace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of WorkspaceCreate */
export type WorkspaceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** GlobalID of the cluster agent the created workspace will be associated with. */
  clusterAgentId: Scalars['ClustersAgentID']['input'];
  /** Desired state of the created workspace. */
  desiredState: Scalars['String']['input'];
  /** Project path containing the devfile used to configure the workspace. If not provided, the GitLab default devfile is used. */
  devfilePath?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project that will provide the Devfile for the created workspace. */
  projectId: Scalars['ProjectID']['input'];
  /** Project repo git ref. */
  projectRef?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of WorkspaceCreate. */
export type WorkspaceCreatePayload = {
  __typename?: 'WorkspaceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created workspace. */
  workspace?: Maybe<Workspace>;
};

/** An edge in a connection. */
export type WorkspaceEdge = {
  __typename?: 'WorkspaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Workspace>;
};

/** Resource specifications of the workspace container. */
export type WorkspaceResources = {
  __typename?: 'WorkspaceResources';
  /** Limits for the requested container resources of a workspace. */
  limits?: Maybe<ResourceQuotas>;
  /** Requested resources for the container of a workspace. */
  requests?: Maybe<ResourceQuotas>;
};

/** Autogenerated input type of WorkspaceUpdate */
export type WorkspaceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Desired state of the created workspace. */
  desiredState: Scalars['String']['input'];
  /** Global ID of the workspace. */
  id: Scalars['RemoteDevelopmentWorkspaceID']['input'];
};

/** Autogenerated return type of WorkspaceUpdate. */
export type WorkspaceUpdatePayload = {
  __typename?: 'WorkspaceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created workspace. */
  workspace?: Maybe<Workspace>;
};

/** Represents a remote development workspace variable */
export type WorkspaceVariable = {
  __typename?: 'WorkspaceVariable';
  /** Timestamp of when the workspace variable was created. */
  createdAt: Scalars['Time']['output'];
  /** Global ID of the workspace variable. */
  id: Scalars['RemoteDevelopmentWorkspaceVariableID']['output'];
  /** Name of the workspace variable. */
  key?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the workspace variable was updated. */
  updatedAt: Scalars['Time']['output'];
  /** Value of the workspace variable. */
  value?: Maybe<Scalars['String']['output']>;
  /** Type of the workspace variable. */
  variableType?: Maybe<WorkspaceVariableType>;
};

/** The connection type for WorkspaceVariable. */
export type WorkspaceVariableConnection = {
  __typename?: 'WorkspaceVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkspaceVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkspaceVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkspaceVariableEdge = {
  __typename?: 'WorkspaceVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkspaceVariable>;
};

/** Attributes for defining a variable to be injected in a workspace. */
export type WorkspaceVariableInput = {
  /** Name of the workspace variable. */
  key: Scalars['String']['input'];
  /** Value of the variable. */
  value: Scalars['String']['input'];
  /** Type of the variable to be injected in a workspace. */
  variableType?: InputMaybe<WorkspaceVariableType>;
};

/** Enum for the type of the variable to be injected in a workspace. */
export type WorkspaceVariableInputType =
  /** Name type. */
  | 'ENVIRONMENT';

/** Enum for the type of the variable injected in a workspace. */
export type WorkspaceVariableType =
  /** Environment type. */
  | 'ENVIRONMENT';

/** Represents a workspaces agent config */
export type WorkspacesAgentConfig = {
  __typename?: 'WorkspacesAgentConfig';
  /** Allow privilege escalation. */
  allowPrivilegeEscalation: Scalars['Boolean']['output'];
  /** Annotations to apply to Kubernetes objects. */
  annotations: Array<KubernetesAnnotation>;
  /** Cluster agent that the workspaces agent config belongs to. */
  clusterAgent: ClusterAgent;
  /** Timestamp of when the workspaces agent config was created. */
  createdAt: Scalars['Time']['output'];
  /**
   * Default cpu and memory resources of the workspace container. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  defaultResourcesPerWorkspaceContainer: WorkspaceResources;
  /** Default Kubernetes RuntimeClass. */
  defaultRuntimeClass: Scalars['String']['output'];
  /** DNS zone where workspaces are available. */
  dnsZone: Scalars['String']['output'];
  /** Indicates whether remote development is enabled for the GitLab agent. */
  enabled: Scalars['Boolean']['output'];
  /** Namespace where gitlab-workspaces-proxy is installed. */
  gitlabWorkspacesProxyNamespace: Scalars['String']['output'];
  /** Global ID of the workspaces agent config. */
  id: Scalars['RemoteDevelopmentWorkspacesAgentConfigID']['output'];
  /**
   * Kubernetes secrets to pull private images for a workspace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  imagePullSecrets: Array<ImagePullSecrets>;
  /** Labels to apply to Kubernetes objects. */
  labels: Array<KubernetesLabel>;
  /**
   * Maximum cpu and memory resources of the workspace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  maxResourcesPerWorkspace: WorkspaceResources;
  /**
   * IP CIDR range specifications for egress destinations from a workspace. Introduced in GitLab 17.9: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.9.
   */
  networkPolicyEgress: Array<NetworkPolicyEgress>;
  /** Whether the network policy of the workspaces agent config is enabled. */
  networkPolicyEnabled: Scalars['Boolean']['output'];
  /** ID of the project that the workspaces agent config belongs to. */
  projectId?: Maybe<Scalars['ID']['output']>;
  /** Timestamp of the last update to any mutable workspaces agent config property. */
  updatedAt: Scalars['Time']['output'];
  /** Indicates whether to use user namespaces in Kubernetes. */
  useKubernetesUserNamespaces: Scalars['Boolean']['output'];
  /** Maximum number of workspaces per user. */
  workspacesPerUserQuota: Scalars['Int']['output'];
  /** Maximum number of workspaces for the GitLab agent. */
  workspacesQuota: Scalars['Int']['output'];
};

/** Represents an X.509 certificate. */
export type X509Certificate = {
  __typename?: 'X509Certificate';
  /** Indicates if the certificate is good or revoked. */
  certificateStatus: Scalars['String']['output'];
  /** Timestamp of when the certificate was saved. */
  createdAt: Scalars['Time']['output'];
  /** Email associated with the cerificate. */
  email: Scalars['String']['output'];
  /** ID of the certificate. */
  id: Scalars['ID']['output'];
  /** Serial number of the certificate. */
  serialNumber: Scalars['String']['output'];
  /** Subject of the certificate. */
  subject: Scalars['String']['output'];
  /** Subject key identifier of the certificate. */
  subjectKeyIdentifier: Scalars['String']['output'];
  /** Timestamp of when the certificate was last updated. */
  updatedAt: Scalars['Time']['output'];
  /** Issuer of the certificate. */
  x509Issuer: X509Issuer;
};

/** Issuer of an X.509 certificate. */
export type X509Issuer = {
  __typename?: 'X509Issuer';
  /** Timestamp of when the issuer was created. */
  createdAt?: Maybe<Scalars['Time']['output']>;
  /** Certificate revokation list of the issuer. */
  crlUrl?: Maybe<Scalars['String']['output']>;
  /** ID of the issuer. */
  id?: Maybe<Scalars['ID']['output']>;
  /** Subject of the issuer. */
  subject?: Maybe<Scalars['String']['output']>;
  /** Subject key identifier of the issuer. */
  subjectKeyIdentifier?: Maybe<Scalars['String']['output']>;
  /** Timestamp of when the issuer was last updated. */
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** X.509 signature for a signed commit */
export type X509Signature = CommitSignature & {
  __typename?: 'X509Signature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']['output']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
  /** Certificate used for the signature. */
  x509Certificate?: Maybe<X509Certificate>;
};

/** Requires ClickHouse. Premium and Ultimate only. */
export type AgentPlatformMetrics = {
  __typename?: 'agentPlatformMetrics';
  /** Total count of `agent_platform_session_created` event. */
  createdSessionEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_dropped` event. */
  droppedSessionEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_finished` event. */
  finishedSessionEventCount?: Maybe<Scalars['Int']['output']>;
  /** Aggregated flow metrics for Duo Agent Platform. */
  flowMetrics?: Maybe<Array<AgentPlatformFlowMetric>>;
  /** Total count of `agent_platform_session_resumed` event. */
  resumedSessionEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_started` event. */
  startedSessionEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_stopped` event. */
  stoppedSessionEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Agent Platform user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type AgentPlatformUserMetrics = {
  __typename?: 'agentPlatformUserMetrics';
  /** Total count of `agent_platform_session_created` event. */
  agentPlatformSessionCreatedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_dropped` event. */
  agentPlatformSessionDroppedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_finished` event. */
  agentPlatformSessionFinishedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_resumed` event. */
  agentPlatformSessionResumedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_started` event. */
  agentPlatformSessionStartedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `agent_platform_session_stopped` event. */
  agentPlatformSessionStoppedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of all Agent Platform events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of approvalProjectRuleDelete */
export type ApprovalProjectRuleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the approval project rule to delete. */
  id: Scalars['ApprovalProjectRuleID']['input'];
};

/** Autogenerated return type of approvalProjectRuleDelete. */
export type ApprovalProjectRuleDeletePayload = {
  __typename?: 'approvalProjectRuleDeletePayload';
  /** Deleted approval rule. */
  approvalRule?: Maybe<ApprovalProjectRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of approvalProjectRuleUpdate */
export type ApprovalProjectRuleUpdateInput = {
  /** How many approvals are required to satify rule. */
  approvalsRequired: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** List of IDs of Groups that can approval rule. */
  groupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Global ID of the approval rule to destroy. */
  id: Scalars['ApprovalProjectRuleID']['input'];
  /** Name of the approval rule. */
  name: Scalars['String']['input'];
  /** List of IDs of Users that can approval rule. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of approvalProjectRuleUpdate. */
export type ApprovalProjectRuleUpdatePayload = {
  __typename?: 'approvalProjectRuleUpdatePayload';
  /** Approval rule after mutation. */
  approvalRule?: Maybe<ApprovalProjectRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of branchRuleApprovalProjectRuleCreate */
export type BranchRuleApprovalProjectRuleCreateInput = {
  /** How many approvals are required to satify rule. */
  approvalsRequired: Scalars['Int']['input'];
  /** Global ID of the branch rule to destroy. */
  branchRuleId: Scalars['ProjectsBranchRuleID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** List of IDs of Groups that can approval rule. */
  groupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Name of the approval rule. */
  name: Scalars['String']['input'];
  /** List of IDs of Users that can approval rule. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of branchRuleApprovalProjectRuleCreate. */
export type BranchRuleApprovalProjectRuleCreatePayload = {
  __typename?: 'branchRuleApprovalProjectRuleCreatePayload';
  /** Approval rule after mutation. */
  approvalRule?: Maybe<ApprovalProjectRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Chat user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type ChatUserMetrics = {
  __typename?: 'chatUserMetrics';
  /** Total count of `request_duo_chat_response` event. */
  requestDuoChatResponseEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of all Chat events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Requires ClickHouse. Premium and Ultimate only. */
export type CodeReviewMetrics = {
  __typename?: 'codeReviewMetrics';
  /** Total count of `encounter_duo_code_review_error_during_review` event. */
  encounterDuoCodeReviewErrorDuringReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `excluded_files_from_duo_code_review` event. */
  excludedFilesFromDuoCodeReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `find_no_issues_duo_code_review_after_review` event. */
  findNoIssuesDuoCodeReviewAfterReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `find_nothing_to_review_duo_code_review_on_mr` event. */
  findNothingToReviewDuoCodeReviewOnMrEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `post_comment_duo_code_review_on_diff` event. */
  postCommentDuoCodeReviewOnDiffEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `react_thumbs_down_on_duo_code_review_comment` event. */
  reactThumbsDownOnDuoCodeReviewCommentEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `react_thumbs_up_on_duo_code_review_comment` event. */
  reactThumbsUpOnDuoCodeReviewCommentEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `request_review_duo_code_review_on_mr_by_author` event. */
  requestReviewDuoCodeReviewOnMrByAuthorEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `request_review_duo_code_review_on_mr_by_non_author` event. */
  requestReviewDuoCodeReviewOnMrByNonAuthorEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Code Review user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type CodeReviewUserMetrics = {
  __typename?: 'codeReviewUserMetrics';
  /** Total count of `encounter_duo_code_review_error_during_review` event. */
  encounterDuoCodeReviewErrorDuringReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `excluded_files_from_duo_code_review` event. */
  excludedFilesFromDuoCodeReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `find_no_issues_duo_code_review_after_review` event. */
  findNoIssuesDuoCodeReviewAfterReviewEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `find_nothing_to_review_duo_code_review_on_mr` event. */
  findNothingToReviewDuoCodeReviewOnMrEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `post_comment_duo_code_review_on_diff` event. */
  postCommentDuoCodeReviewOnDiffEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `react_thumbs_down_on_duo_code_review_comment` event. */
  reactThumbsDownOnDuoCodeReviewCommentEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `react_thumbs_up_on_duo_code_review_comment` event. */
  reactThumbsUpOnDuoCodeReviewCommentEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `request_review_duo_code_review_on_mr_by_author` event. */
  requestReviewDuoCodeReviewOnMrByAuthorEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `request_review_duo_code_review_on_mr_by_non_author` event. */
  requestReviewDuoCodeReviewOnMrByNonAuthorEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of all Code Review events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Requires ClickHouse. Premium and Ultimate only. */
export type CodeSuggestionMetrics = {
  __typename?: 'codeSuggestionMetrics';
  /** Total count of code suggestions accepted. */
  acceptedCount?: Maybe<Scalars['Int']['output']>;
  /** Sum of lines of code from code suggestions accepted. */
  acceptedLinesOfCode?: Maybe<Scalars['Int']['output']>;
  /** Number of code contributors who used GitLab Duo Code Suggestions features. */
  contributorsCount?: Maybe<Scalars['Int']['output']>;
  /** List of IDE names with at least one suggestion shown or accepted. */
  ideNames?: Maybe<Array<Scalars['String']['output']>>;
  /** List of languages with at least one suggestion shown or accepted. */
  languages?: Maybe<Array<Scalars['String']['output']>>;
  /** Total count of code suggestions shown. */
  shownCount?: Maybe<Scalars['Int']['output']>;
  /** Sum of lines of code from code suggestions shown. */
  shownLinesOfCode?: Maybe<Scalars['Int']['output']>;
};

/**
 * AI-related metrics with three months of data retention.
 * Premium and Ultimate only.
 *
 */
export type CodeSuggestionMetricsBasic = {
  __typename?: 'codeSuggestionMetricsBasic';
  /** Total count of code suggestions accepted. */
  acceptedCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of code suggestions shown. */
  shownCount?: Maybe<Scalars['Int']['output']>;
};

/** Code Suggestions user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type CodeSuggestionsUserMetrics = {
  __typename?: 'codeSuggestionsUserMetrics';
  /** Total count of `code_suggestion_accepted_in_ide` event. */
  codeSuggestionAcceptedInIdeEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `code_suggestion_direct_access_token_refresh` event. */
  codeSuggestionDirectAccessTokenRefreshEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `code_suggestion_rejected_in_ide` event. */
  codeSuggestionRejectedInIdeEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `code_suggestion_shown_in_ide` event. */
  codeSuggestionShownInIdeEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `code_suggestions_requested` event. */
  codeSuggestionsRequestedEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of all Code Suggestions events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of createContainerProtectionTagRule */
export type CreateContainerProtectionTagRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can delete tags.  */
  minimumAccessLevelForDelete?: InputMaybe<ContainerProtectionTagRuleAccessLevel>;
  /** Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. Introduced in GitLab 17.8: **Status**: Experiment. If the value is `nil`, no access level can push tags.  */
  minimumAccessLevelForPush?: InputMaybe<ContainerProtectionTagRuleAccessLevel>;
  /** Full path of the project containing the container image tags. */
  projectPath: Scalars['ID']['input'];
  /** The pattern that matches container image tags to protect. For example, `v1.*`. Wildcard character `*` allowed. Introduced in GitLab 17.8: **Status**: Experiment. */
  tagNamePattern: Scalars['String']['input'];
};

/** Autogenerated return type of createContainerProtectionTagRule. */
export type CreateContainerProtectionTagRulePayload = {
  __typename?: 'createContainerProtectionTagRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Protection rule for container image tags after creation. Introduced in GitLab 17.8: **Status**: Experiment.
   * @deprecated **Status**: Experiment. Introduced in GitLab 17.8.
   */
  containerProtectionTagRule?: Maybe<ContainerProtectionTagRule>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of iterationCreate */
export type IterationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']['input']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']['input']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']['input']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']['input']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of iterationCreate. */
export type IterationCreatePayload = {
  __typename?: 'iterationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

/** Mcp user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type McpUserMetrics = {
  __typename?: 'mcpUserMetrics';
  /** Total count of `finish_mcp_tool_call` event. */
  finishMcpToolCallEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `start_mcp_tool_call` event. */
  startMcpToolCallEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of all Mcp events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of projectBlobsRemove */
export type ProjectBlobsRemoveInput = {
  /** List of blob oids. */
  blobOids: Array<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to replace. */
  projectPath: Scalars['ID']['input'];
};

/** Autogenerated return type of projectBlobsRemove. */
export type ProjectBlobsRemovePayload = {
  __typename?: 'projectBlobsRemovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of projectTextReplace */
export type ProjectTextReplaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Full path of the project to replace. */
  projectPath: Scalars['ID']['input'];
  /** List of text patterns to replace project-wide. */
  replacements: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of projectTextReplace. */
export type ProjectTextReplacePayload = {
  __typename?: 'projectTextReplacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
};

/** Troubleshoot Job user metrics for a user. Requires ClickHouse. Premium and Ultimate with GitLab Duo Enterprise only. */
export type TroubleshootJobUserMetrics = {
  __typename?: 'troubleshootJobUserMetrics';
  /** Total count of all Troubleshoot Job events for the user. */
  totalEventCount?: Maybe<Scalars['Int']['output']>;
  /** Total count of `troubleshoot_job` event. */
  troubleshootJobEventCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of vulnerabilitiesSeverityOverride */
export type VulnerabilitiesSeverityOverrideInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Comment why vulnerability severity was changed (maximum 50,000 characters). */
  comment: Scalars['String']['input'];
  /** New severity value for the severities. */
  severity: VulnerabilitySeverity;
  /** IDs of the vulnerabilities for which severity needs to be changed (maximum 100 entries). */
  vulnerabilityIds: Array<Scalars['VulnerabilityID']['input']>;
};

/** Autogenerated return type of vulnerabilitiesSeverityOverride. */
export type VulnerabilitiesSeverityOverridePayload = {
  __typename?: 'vulnerabilitiesSeverityOverridePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Vulnerabilities after severity change. */
  vulnerabilities: Array<Vulnerability>;
};

/** Autogenerated input type of workItemsHierarchyReorder */
export type WorkItemsHierarchyReorderInput = {
  /** ID of the work item to move next to. For example, the item above or below. */
  adjacentWorkItemId?: InputMaybe<Scalars['WorkItemID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item to be reordered. */
  id: Scalars['WorkItemID']['input'];
  /** Global ID of the new parent work item. */
  parentId?: InputMaybe<Scalars['WorkItemID']['input']>;
  /** Position relative to the adjacent work item. Valid values are `BEFORE` or `AFTER`. */
  relativePosition?: InputMaybe<RelativePositionType>;
};

/** Autogenerated return type of workItemsHierarchyReorder. */
export type WorkItemsHierarchyReorderPayload = {
  __typename?: 'workItemsHierarchyReorderPayload';
  /** Adjacent work item after mutation. */
  adjacentWorkItem?: Maybe<WorkItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Work item's parent after mutation. */
  parentWorkItem?: Maybe<WorkItem>;
  /** Work item after mutation. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of workItemsReorder */
export type WorkItemsReorderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Global ID of the work item to be reordered. */
  id: Scalars['WorkItemID']['input'];
  /** Global ID of a work item that should be placed after the work item. */
  moveAfterId?: InputMaybe<Scalars['WorkItemID']['input']>;
  /** Global ID of a work item that should be placed before the work item. */
  moveBeforeId?: InputMaybe<Scalars['WorkItemID']['input']>;
};

/** Autogenerated return type of workItemsReorder. */
export type WorkItemsReorderPayload = {
  __typename?: 'workItemsReorderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Errors encountered during the mutation. */
  errors: Array<Scalars['String']['output']>;
  /** Work item after mutation. */
  workItem?: Maybe<WorkItem>;
};

export type GetIssueByIdQueryVariables = Exact<{
  id: Scalars['IssueID']['input'];
}>;


export type GetIssueByIdQuery = { __typename?: 'Query', issue?: { __typename?: 'Issue', id: string, title: string } | null };

export type GetProjectIssueByIidQueryVariables = Exact<{
  fullPath: Scalars['ID']['input'];
  iid: Scalars['String']['input'];
}>;


export type GetProjectIssueByIidQuery = { __typename?: 'Query', project?: { __typename?: 'Project', id: string, issue?: { __typename?: 'Issue', id: string, title: string } | null } | null };

export type GetProjectQueryVariables = Exact<{
  fullPath: Scalars['ID']['input'];
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProjectQuery = { __typename?: 'Query', project?: { __typename?: 'Project', id: string, issues?: { __typename?: 'IssueConnection', nodes?: Array<{ __typename?: 'Issue', id: string, iid: string, name?: string | null, webUrl: string } | null> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null } | null };


export const GetIssueByIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetIssueById"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IssueID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"issue"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}}]}}]}}]} as unknown as DocumentNode<GetIssueByIdQuery, GetIssueByIdQueryVariables>;
export const GetProjectIssueByIidDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetProjectIssueByIid"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"fullPath"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"iid"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"project"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"fullPath"},"value":{"kind":"Variable","name":{"kind":"Name","value":"fullPath"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"issue"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"iid"},"value":{"kind":"Variable","name":{"kind":"Name","value":"iid"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}}]}}]}}]}}]} as unknown as DocumentNode<GetProjectIssueByIidQuery, GetProjectIssueByIidQueryVariables>;
export const GetProjectDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetProject"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"fullPath"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"first"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"after"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"project"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"fullPath"},"value":{"kind":"Variable","name":{"kind":"Name","value":"fullPath"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"issues"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"sort"},"value":{"kind":"EnumValue","value":"MILESTONE_DUE_DESC"}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"Variable","name":{"kind":"Name","value":"first"}}},{"kind":"Argument","name":{"kind":"Name","value":"after"},"value":{"kind":"Variable","name":{"kind":"Name","value":"after"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"iid"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"webUrl"}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetProjectQuery, GetProjectQueryVariables>;